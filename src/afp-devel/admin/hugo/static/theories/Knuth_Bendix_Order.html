<div id="Order_Pair">
<div class="head"><h1>Theory Order_Pair</h1>
<span class="command">theory</span> <span class="name">Order_Pair</span><br/>
<span class="keyword">imports</span> <a href="../Abstract-Rewriting/Relative_Rewriting.html"><span class="name">Relative_Rewriting</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Order Pairs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  An order pair consists of two relations @{term S} and @{term NS}, where @{term S}
  is a strict order and @{term NS} a compatible non-strict order,
  such that the combination of @{term S} and @{term NS} always results in strict decrease.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Order_Pair</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstract-Rewriting.Relative_Rewriting"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>order_simps</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>O_assoc</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pre_order_pair</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>refl_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl NS"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans NS"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_NS_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, s) ∈ NS"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>refl_NS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>refl_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_O_NS</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O NS = NS"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O NS O T = NS O T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O NS = NS"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>trans_refl_imp_O_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_NS</span><span> </span><span>refl_NS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O NS O T = NS O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trancl_NS</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>+</sup> = NS"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_NS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtrancl_NS</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>*</sup> = NS"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans_refl_imp_rtrancl_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_NS</span><span> </span><span>refl_NS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trancl_S</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S<span class="hidden">⇧</span><sup>+</sup> = S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_O_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S O S ⊆ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O S O T ⊆ S O T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O S ⊆ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>trans_O_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O S O T ⊆ S O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_S_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. (x, y) ∈ S ⟹ (y, z) ∈ S ⟹ (x, z) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_NS_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. (x, y) ∈ NS ⟹ (y, z) ∈ NS ⟹ (x, z) ∈ NS"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_NS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>compat_pair</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat_NS_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O S ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat_S_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS ⊆ S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compat_NS_S_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. (x, y) ∈ NS ⟹ (y, z) ∈ S ⟹ (x, z) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_NS_S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compat_S_NS_point</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. (x, y) ∈ S ⟹ (y, z) ∈ NS ⟹ (x, z) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_S_NS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_O_rtrancl_NS</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS<span class="hidden">⇧</span><sup>*</sup> = S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS<span class="hidden">⇧</span><sup>*</sup> O T = S O T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS<span class="hidden">⇧</span><sup>*</sup> = S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S O NS<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S O NS^^n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ S O NS^^n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, y) ∈ NS"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xz</span><span class="delimiter">]</span><span> </span><span>zy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S O NS"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat_S_NS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS<span class="hidden">⇧</span><sup>*</sup> O T = S O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtrancl_NS_O_S</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>*</sup> O S = S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>*</sup> O S O T = S O T"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>*</sup> O S = S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ NS<span class="hidden">⇧</span><sup>*</sup> O S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ NS^^n O S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ NS"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, y) ∈ NS^^n O S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>relpow_Suc</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xz</span><span> </span><span>IH.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>zy</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ NS O S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat_NS_S</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS<span class="hidden">⇧</span><sup>*</sup> O S O T = S O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>order_pair</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_order_pair</span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">+</span><span> </span><span>compat_pair</span><span> </span><span>S</span><span> </span><span>NS</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_O_NS</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS = S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S O NS O T = S O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>S_O_rtrancl_NS</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rtrancl_NS</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_O_S</span><span class="delimiter">[</span><span>order_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O S = S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS O S O T = S O T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>rtrancl_NS_O_S</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rtrancl_NS</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compat_rtrancl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b) ∈ S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b, c) ∈ (NS ∪ S)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, c) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bc</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ab</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>c</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_S_NS_point</span><span> </span><span>trans_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>SN_ars</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN S"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>SN_pair</span><span> </span><span class="delimiter">=</span><span> </span><span>compat_pair</span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">+</span><span> </span><span>SN_ars</span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>SN_order_pair</span><span> </span><span class="delimiter">=</span><span> </span><span>order_pair</span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">+</span><span> </span><span>SN_ars</span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>SN_order_pair</span><span> </span><span class="delimiter">⊆</span><span> </span><span>SN_pair</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lexicographic_Extension">
<div class="head"><h1>Theory Lexicographic_Extension</h1>
<span class="command">theory</span> <span class="name">Lexicographic_Extension</span><br/>
<span class="keyword">imports</span> <a href="Utility.html"><span class="name">Utility</span></a> <a href="Order_Pair.html"><span class="name">Order_Pair</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lexicographic Extension›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lexicographic_Extension</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Matrix.Utility</span><span>
</span><span>    </span><span>Order_Pair</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory we define the lexicographic extension of an order pair, so that it generalizes
  the existing notion @{const lex_prod} which is based on a single order only.

  Our main result is that this extension yields again an order pair.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lex_two</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel ⇒ 'b rel ⇒ ('a × 'b) rel"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lex_two s ns s2 = {((a1, b1), (a2, b2)) . (a1, a2) ∈ s ∨ (a1, a2) ∈ ns ∧ (b1, b2) ∈ s2}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns O s ⊆ s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SN_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN s"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SN_s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN s2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (lex_two s ns s2)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. (f i, f (Suc i)) ∈ ?r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. (f i, f (Suc i)) ∈ ?r"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ i. fst (f i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ i. snd (f i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>steps</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?a i, ?a (Suc i)) ∈ s ∨ (?a i, ?a (Suc i)) ∈ ns ∧ (?b i, ?b (Suc i)) ∈ s2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f i"</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Suc i)"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>steps</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ j. ∀ i ≥ j. (?a i, ?a (Suc i)) ∈ ns - s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>non_strict_ending</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>compat</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>steps</span><span> </span><span>SN_s</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>SN_on_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>steps</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i ≥ j ⟹ (?b i, ?b (Suc i)) ∈ s2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g = (λ i. ?b (j + i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>steps</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. (g i, g (Suc i)) ∈ s2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SN_s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_compat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O s1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O ns1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O s1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O ns1 ⊆ ns1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns2 O s2 ⊆ s2"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab1, ab2) ∈ lex_two s1 ns1 ns2"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab2, ab3) ∈ lex_two s1 ns1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab1, ab3) ∈ lex_two s1 ns1 s2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>b1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab1 = (a1, b1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a2</span><span> </span><span>b2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab2 = (a2, b2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a3</span><span> </span><span>b3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab3 = (a3, b3)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>id</span><span> </span><span class="delimiter">=</span><span> </span><span>ab1</span><span> </span><span>ab2</span><span> </span><span>ab3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a1, a2) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trans1</span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ ns1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat1'</span><span> </span><span>s1</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a1, a2) ∈ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b1, b2) ∈ ns2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat1</span><span> </span><span>ns</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b2, b3) ∈ s2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trans1'</span><span> </span><span>ns</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nss</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>compat2</span><span> </span><span>ns</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nss</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_compat'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O s1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O ns1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O s1 ⊆ s1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O ns1 ⊆ ns1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 O ns2 ⊆ s2"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab1, ab2) ∈ lex_two s1 ns1 s2"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab2, ab3) ∈ lex_two s1 ns1 ns2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ab1, ab3) ∈ lex_two s1 ns1 s2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>b1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab1 = (a1, b1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a2</span><span> </span><span>b2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab2 = (a2, b2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a3</span><span> </span><span>b3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ab3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab3 = (a3, b3)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>id</span><span> </span><span class="delimiter">=</span><span> </span><span>ab1</span><span> </span><span>ab2</span><span> </span><span>ab3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a1, a2) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trans1</span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ ns1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat1'</span><span> </span><span>s1</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a1, a2) ∈ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b1, b2) ∈ s2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ s1"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat1</span><span> </span><span>s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a2, a3) ∈ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b2, b3) ∈ ns2"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>trans1'</span><span> </span><span>s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nss</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>compat2'</span><span> </span><span>s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nss</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_compat2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O s1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O ns1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O s1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O ns1 ⊆ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns2 O s2 ⊆ s2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_two s1 ns1 ns2 O lex_two s1 ns1 s2 ⊆ lex_two s1 ns1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_two_compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subsetI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>relcompE</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_compat'2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O s1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O ns1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s1 O s1 ⊆ s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns1 O ns1 ⊆ ns1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 O ns2 ⊆ s2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_two s1 ns1 s2 O lex_two s1 ns1 ns2 ⊆ lex_two s1 ns1 s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_two_compat'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subsetI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>relcompE</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_refl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl ns1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl ns2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"refl (lex_two s1 ns1 ns2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>refl_onD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>r1</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>refl_onD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>r2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refl_onI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_order_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"order_pair s1 ns1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>o2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"order_pair s2 ns2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"order_pair (lex_two s1 ns1 s2) (lex_two s1 ns1 ns2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span> </span><span>order_pair</span><span> </span><span>s1</span><span> </span><span>ns1</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>o2</span><span class="delimiter">:</span><span> </span><span>order_pair</span><span> </span><span>s2</span><span> </span><span>ns2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o2</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>o1.trans_S</span><span> </span><span>o1.trans_NS</span><span> </span><span>o2.trans_S</span><span> </span><span>o2.trans_NS</span><span> 
</span><span>    </span><span>o1.compat_NS_S</span><span> </span><span>o2.compat_NS_S</span><span> </span><span>o1.compat_S_NS</span><span> </span><span>o2.compat_S_NS</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>trans_O_iff</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>o1.refl_NS</span><span> </span><span>o2.refl_NS</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>lex_two_refl</span><span class="delimiter">,</span><span> </span><span>fact</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>trans_O_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lex_two_compat2</span><span> </span><span>lex_two_compat'2</span><span class="delimiter">;</span><span>fact</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_two_SN_order_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN_order_pair s1 ns1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>o2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN_order_pair s2 ns2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN_order_pair (lex_two s1 ns1 s2) (lex_two s1 ns1 ns2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span> </span><span>SN_order_pair</span><span> </span><span>s1</span><span> </span><span>ns1</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>o2</span><span class="delimiter">:</span><span> </span><span>SN_order_pair</span><span> </span><span>s2</span><span> </span><span>ns2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o2</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>o1.trans_S</span><span> </span><span>o1.trans_NS</span><span> </span><span>o2.trans_S</span><span> </span><span>o2.trans_NS</span><span> </span><span>o1.SN</span><span> </span><span>o2.SN</span><span>
</span><span>    </span><span>o1.compat_NS_S</span><span> </span><span>o2.compat_NS_S</span><span> </span><span>o1.compat_S_NS</span><span> </span><span>o2.compat_S_NS</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>trans_O_iff</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>order_pair</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lex_two s1 ns1 s2)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lex_two s1 ns1 ns2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lex_two_order_pair</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>lex_two</span><span class="delimiter">;</span><span> </span><span>fact</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In the unbounded lexicographic extension, there is no restriction on the lengths
  of the lists. Therefore it is possible to compare lists of different lengths.
  This usually results a non-terminating relation, e.g., $[1] &gt; [0, 1] &gt; [0, 0, 1] &gt; \ldots$
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lex_ext_unbounded</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a ⇒ bool × bool) ⇒ 'a list ⇒ 'a list ⇒ bool × bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded f [] [] = (False, True)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded f (_ # _) [] = (True, True)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded f [] (_ # _) = (False, False)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded f (a # as) (b # bs) =
      (let (stri, nstri) = f a b in
      if stri then (True, True)
      else if nstri then lex_ext_unbounded f as bs
      else (False, False))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lex_ext_unbounded f xs ys) = (
  ((∃ i &lt; length xs. i &lt; length ys ∧ (∀ j &lt; i. snd (f (xs ! j) (ys ! j))) ∧ fst (f (xs ! i) (ys !i))) ∨ 
  (∀ i &lt; length ys. snd (f (xs ! i) (ys ! i))) ∧ length xs &gt; length ys),
  ((∃ i &lt; length xs. i &lt; length ys ∧ (∀ j &lt; i. snd (f (xs ! j) (ys ! j))) ∧ fst (f (xs ! i) (ys !i))) ∨ 
  (∀ i &lt; length ys. snd (f (xs ! i) (ys ! i))) ∧ length xs ≥ length ys))
  "</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lex xs ys = (?stri xs ys, ?nstri xs ys)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>oCons</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>oCons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pair</span><span> </span><span>stri</span><span> </span><span>nstri</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>stri</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Pair</span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>        
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>nstri</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ stri›</span></span></span><span> </span><span>Pair</span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>Pair</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b = (False, True)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_Suc_conv</span><span> </span><span>ex_Suc_conv</span><span> </span><span>Cons</span><span> </span><span>f</span><span> </span><span>oCons</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The lexicographic extension of an order pair takes a natural number as maximum bound.
  A decrease with lists of unequal lengths will never be successful if the length of the
  second list exceeds this bound. The bound is essential to preserve strong normalization.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lex_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a ⇒ bool × bool) ⇒ nat ⇒ 'a list ⇒ 'a list ⇒ bool × bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lex_ext f n ss ts =
      (let lts = length ts in 
      if (length ss = lts ∨ lts ≤ n) then lex_ext_unbounded f ss ts
      else (False, False))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lex_ext f m xs ys) = (
  (length xs = length ys ∨ length ys ≤ m) ∧ ((∃ i &lt; length xs. i &lt; length ys ∧ (∀ j &lt; i. snd (f (xs ! j) (ys ! j))) ∧ fst (f (xs ! i) (ys !i))) ∨ 
  (∀ i &lt; length ys. snd (f (xs ! i) (ys ! i))) ∧ length xs &gt; length ys),
  (length xs = length ys ∨ length ys ≤ m) ∧
  ((∃ i &lt; length xs. i &lt; length ys ∧ (∀ j &lt; i. snd (f (xs ! j) (ys ! j))) ∧ fst (f (xs ! i) (ys !i))) ∨ 
  (∀ i &lt; length ys. snd (f (xs ! i) (ys ! i))) ∧ length xs ≥ length ys))
  "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>Let_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_to_lex_ext_unbounded</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≤ n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ys ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext f n xs ys = lex_ext_unbounded f xs ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_stri_imp_nstri</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext f m xs ys)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext f m xs ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_stri_imp_nstri</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded f xs ys)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded f xs ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_nstri_imp_lex_nstri</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length ys. snd (f (xs ! i) (ys ! i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≥ length ys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys ∨ length ys ≤ m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext f m xs ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>m1</span><span> </span><span>m2</span><span> </span><span>xs1</span><span> </span><span>xs2</span><span> </span><span>ys1</span><span> </span><span>ys2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs1 = length ys1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m1 = m2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs2 = length ys2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. ⟦i &lt; length ys1; i &lt; length ys2⟧ ⟹ f (xs1 ! i) (xs2 ! i) = g (ys1 ! i) (ys2 ! i)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext f m1 xs1 xs2 = lex_ext g m2 ys1 ys2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs = bs'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length as' ⟹ i &lt; length bs' ⟹ f (as' ! i) (bs' ! i) = g (as' ! i) (bs' ! i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded f as bs = lex_ext_unbounded g as' bs'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility is the key property to ensure transitivity of the order.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We prove compatibility locally, i.e., it only has to hold for elements
  of the argument lists. Locality is essential for being applicable in recursively
  defined term orders such as KBO.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_compat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s t u. ⟦s ∈ set ss; t ∈ set ts; u ∈ set us⟧ ⟹
    (snd (f s t) ∧ fst (f t u) ⟶ fst (f s u)) ∧ 
    (fst (f s t) ∧ snd (f t u) ⟶ fst (f s u)) ∧ 
    (snd (f s t) ∧ snd (f t u) ⟶ snd (f s u)) ∧
    (fst (f s t) ∧ fst (f t u) ⟶ fst (f s u))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
    (snd (lex_ext f n ss ts) ∧ fst (lex_ext f n ts us) ⟶ fst (lex_ext f n ss us)) ∧ 
    (fst (lex_ext f n ss ts) ∧ snd (lex_ext f n ts us) ⟶ fst (lex_ext f n ss us)) ∧ 
    (snd (lex_ext f n ss ts) ∧ snd (lex_ext f n ts us) ⟶ snd (lex_ext f n ss us)) ∧
    (fst (lex_ext f n ss ts) ∧ fst (lex_ext f n ts us) ⟶ fst (lex_ext f n ss us))
    "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ls</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"length us"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?st</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext f n ss ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext f n ts us"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?su</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext f n ss us"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?fst</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ss ts i. fst (f (ss ! i) (ts ! i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?snd</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ss ts i. snd (f (ss ! i) (ts ! i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ss ts. ∃ i &lt; length ss. i &lt; length ts ∧ (∀ j &lt; i. ?snd ss ts j) ∧ ?fst ss ts i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?all</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ss ts. ∀ i &lt; length ts. ?snd ss ts i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?ls = ?lt ∨ ?lt ≤ n) ∧ (?lt = ?lu ∨ ?lu ≤ n) ⟶
    (?ls = ?lu ∨ ?lu ≤ n)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lst ∧ ?ltu ⟶ ?lsu"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?st"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?tu"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lengths</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lsu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lsu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts ∨ ?all ss ts ∧ ?lt ≤ ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us ∨ ?all ts us ∧ ?lu &lt; ?lt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?su"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?ls ∧ i1 &lt; ?lt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts i1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss ts j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"min i1 i2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?i &lt; ?ls ∧ ?i &lt; ?lt ∧ ?i &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! ?i ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! ?i ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! ?i ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?i. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; i2"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>fst1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; i1"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ i1 &lt; i2›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span> </span><span>lsu</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?i</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst</span><span> </span><span>snd</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu &lt; ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?lu"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i1 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i1 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i1 ∈ set ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>True</span><span> </span><span>i1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu &lt; ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>i1</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ss ts ∧ ?lt ≤ ?ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?ls ∧ i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i2 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i2 ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i2 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst2</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i2</span><span> </span><span>snd2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>i2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu &lt; ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu &lt; ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?st"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?tu"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lengths</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lsu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lsu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts ∨ ?all ss ts ∧ ?lt &lt; ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us ∨ ?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?su"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?ls ∧ i1 &lt; ?lt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts i1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss ts j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"min i1 i2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?i &lt; ?ls ∧ ?i &lt; ?lt ∧ ?i &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! ?i ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! ?i ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! ?i ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?i. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; i2"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>fst1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; i1"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ i1 &lt; i2›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span> </span><span>lsu</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?i</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst</span><span> </span><span>snd</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?lu"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i1 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i1 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i1 ∈ set ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>True</span><span> </span><span>i1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu &lt; ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>i1</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ss ts ∧ ?lt &lt; ?ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?ls ∧ i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i2 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i2 ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i2 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst2</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i2</span><span> </span><span>snd2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>i2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu &lt; ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?st"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?tu"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lengths</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lsu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lsu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts ∨ ?all ss ts ∧ ?lt ≤ ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us ∨ ?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?su"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ss ts"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?ls ∧ i1 &lt; ?lt"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts i1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss ts j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"min i1 i2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?i &lt; ?ls ∧ ?i &lt; ?lt ∧ ?i &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! ?i ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! ?i ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! ?i ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?i. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; i2"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>fst1</span><span> </span><span>snd2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; i1"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?i = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ i1 &lt; i2›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 = i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>fst2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss ts ?i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us ?i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span> </span><span>lsu</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?i</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst</span><span> </span><span>snd</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i1 &lt; ?lu"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i1 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i1 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i1 ∈ set ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst1</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i1. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span>True</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>True</span><span> </span><span>i1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu ≤ ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>i1</span><span> </span><span>snd1</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ss ts ∧ ?lt ≤ ?ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ex ts us"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fst2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ts us i2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ts us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span>i2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i2 &lt; ?ls ∧ i2 &lt; ?lt ∧ i2 &lt; ?lu"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! i2 ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! i2 ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! i2 ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst2</span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssi</span><span> </span><span>tsi</span><span> </span><span>usi</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst ss us i2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; i2. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; i2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i2</span><span> </span><span>snd2</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fst</span><span> </span><span>lsu</span><span> </span><span>i2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?all ts us ∧ ?lu ≤ ?lt"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lu ≤ ?ls"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ j &lt; ?lu. ?snd ss us j"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; ?lu"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss ts j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snd2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ts us j"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>ssj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ! j ∈ set ss"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tsj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts ! j ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>usj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ! j ∈ set us"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssj</span><span> </span><span>tsj</span><span> </span><span>usj</span><span class="delimiter">]</span><span> </span><span>snd1</span><span> </span><span>snd2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?snd ss us j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lus</span><span> </span><span>lsu</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_ext_stri_imp_nstri</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ fst (r (ss ! i) (ts ! i)) ⟹ fst (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ snd (r (ss ! i) (ts ! i)) ⟹ snd (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst (lex_ext_unbounded r ss ts) ⟶ fst (lex_ext_unbounded r (map f ss) (map f ts))) ∧
    (snd (lex_ext_unbounded r ss ts) ⟶ snd (lex_ext_unbounded r (map f ss) (map f ts)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_map_S</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ fst (r (ss ! i) (ts ! i)) ⟹ fst (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ snd (r (ss ! i) (ts ! i)) ⟹ snd (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded r ss ts)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded r (map f ss) (map f ts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_ext_unbounded_map</span><span class="delimiter">[</span><span>of</span><span> </span><span>ss</span><span> </span><span>ts</span><span> </span><span>r</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>S</span><span> </span><span>NS</span><span class="delimiter">]</span><span> </span><span>stri</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_map_NS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ fst (r (ss ! i) (ts ! i)) ⟹ fst (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ss ⟹ i &lt; length ts ⟹ snd (r (ss ! i) (ts ! i)) ⟹ snd (r (map f ss ! i) (map f ts ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nstri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded r ss ts)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded r (map f ss) (map f ts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_ext_unbounded_map</span><span class="delimiter">[</span><span>of</span><span> </span><span>ss</span><span> </span><span>ts</span><span> </span><span>r</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>S</span><span> </span><span>NS</span><span class="delimiter">]</span><span> </span><span>nstri</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strong normalization with local SN assumption›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_SN</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. ⟦snd (g x y); fst (g y z)⟧ ⟹ fst (g x z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN { (ys, xs). (∀ y ∈ set ys. SN_on { (s, t). fst (g s t) } {y}) ∧ fst (lex_ext g m ys xs) }"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN { (ys, xs). ?cond ys xs }"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n :: nat. ?cond (f n) (f (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m_imp_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. length (f n) ≤ m ⟹ length (f (Suc n)) ≤ m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) ≤ m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f (Suc n)) ≤ m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lm_imp_m_or_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. length (f n) &gt; m ⟹ length (f (Suc n)) ≤ m ∨ length (f n) = length (f (Suc n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) &gt; m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ length (f n) ≤ m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f (Suc n)) ≤ m ∨ length (f n) = length (f (Suc n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?l0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"max (length (f 0)) m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. length (f n) ≤ ?l0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) ≤ ?l0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) ≤ m"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>m_imp_m</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) &gt; m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lm_imp_m_or_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (f n) = length (f (Suc n)) ∨ length (f (Suc n)) ≤ m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. length (f n) ≤ m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lexgr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ys xs. fst (lex_ext g m ys xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lexge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ys xs. snd (lex_ext g m ys xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t s. fst (g t s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t s. snd (g t s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ (y, x). fst (g y x) }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?NS</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ (y, x). snd (g y x) }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?baseSN</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ys. ∀ y ∈ set ys. SN_on ?S {y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?con</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ ys xs m'. ?baseSN ys ∧ length ys ≤ m' ∧ ?lexgr ys xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?confn</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ m' f n . ?con (f n) (f (Suc n)) m'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>compat</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>compat2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?NS O ?S ⊆ ?S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ f. ∀ n. ?confn m' f n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>m'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?confn 0 f 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>	
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lexgr [] (f (Suc 0))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>confn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. ?confn (Suc m') f n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. f n ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f n ≠ []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f n"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>confn</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?hf</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ n. hd (f n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. ?ge (?hf n) (?hf (Suc n)) ∨ ?gr (?hf n) (?hf (Suc n))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f n = a # as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f n"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Suc n) = b # bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Suc n)"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ge a b ∨ ?gr a b"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?gr a b"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ge a b"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?gr a b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?ge a b"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g a b = (False, False)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"g a b"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>confn</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext g m (f n) (f (Suc n)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?fst</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fst = False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>sn</span><span> </span><span>lex_ext_def</span><span> </span><span>g</span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?fst›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ge a b ∨ ?gr a b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span> </span><span>sn</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ge (?hf n) (?hf (Suc n)) ∨ ?gr (?hf n) (?hf (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>GE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n. (?hf n, ?hf (Suc n)) ∈ ?NS ∪ ?S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>confn</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>ne</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SN_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN_on ?S {?hf 0}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f 0"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>non_strict_ending</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?hf</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>GE</span><span> </span><span>compat2</span><span> </span><span>SN_0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i ≥ j. (?hf i, ?hf (Suc i)) ∈ ?NS - ?S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?h</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ n. tl (f (j + n))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h = ?h"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n. ?confn m' h n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?nj</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?nj</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ge_not_gr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?hf ?nj, ?hf (Suc ?nj)) ∈ ?NS - ?S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>confn</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?nj</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>old</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?confn (Suc m') f ?nj"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?nj</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ?nj = a # as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ?nj"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ne</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc ?nj"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Suc ?nj) = b # bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (Suc ?nj)"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>old</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ y ∈ set (h n). SN_on ?S {y}"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>old</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (h n) ≤ m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>j</span><span> </span><span>n</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ge_not_gr</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ge_not_gr2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g a b = (False, True)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>sn</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"g a b"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>old</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext g m (f (j+ n)) (f (Suc (j+n))))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?fst</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = length bs ∨ length bs ≤ m"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?len</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_def</span><span> </span><span>n</span><span> </span><span>sn</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="var">?len</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?fst›</span></span></span><span class="delimiter">[</span><span>simplified</span><span> </span><span>n</span><span> </span><span>sn</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded g as bs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?fst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_def</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = length bs ∨ Suc (length bs) ≤ m"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ge_not_gr2</span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded g as bs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?fst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>three</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lexgr (h n) (h (Suc n))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_def</span><span> </span><span>h</span><span> </span><span>n</span><span> </span><span>sn</span><span> </span><span>ge_not_gr2</span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?len›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?fst›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>one</span><span> </span><span>two</span><span> </span><span>three</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?confn m' h n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strong normalization with global SN assumption is immediate consequence.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_SN_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ x y z. ⟦snd (g x y); fst (g y z)⟧ ⟹ fst (g x z)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SN</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"SN {(s, t). fst (g s t)}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN { (ys, xs). fst (lex_ext g m ys xs) }"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex_ext_SN</span><span class="delimiter">[</span><span>OF</span><span> </span><span>compat</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN { (ys, xs). (∀ y ∈ set ys. SN_on { (s, t). fst (g s t) } {y}) ∧ fst (lex_ext g m ys xs) }"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The empty list is the least element in the lexicographic extension.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_least_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext f m xs [])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_least_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ fst (lex_ext f m [] ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of totality on lists of same length.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_total</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(s, t)∈set (zip ss ts). s = t ∨ fst (f s t) ∨ fst (f t s)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t. snd (f t t)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss = length ts"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ts ∨ fst (lex_ext_unbounded f ss ts) ∨ fst (lex_ext_unbounded f ts ss)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t ∨ (fst (f s t) ∨ fst (f t s))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span>refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f t t"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_total</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(s, t)∈set (zip ss ts). s = t ∨ fst (f s t) ∨ fst (f t s)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t. snd (f t t)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss = length ts"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ts ∨ fst (lex_ext f n ss ts) ∨ fst (lex_ext f n ts ss)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lex_ext_unbounded_total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity of the lexicographic extension.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lex_ext_unbounded_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦i &lt; length xs; i &lt; length ys; fst (P (xs ! i) (ys ! i))⟧ ⟹ fst (P' (xs ! i) (ys ! i))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦i &lt; length xs; i &lt; length ys; snd (P (xs ! i) (ys ! i))⟧ ⟹ snd (P' (xs ! i) (ys ! i))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(fst (lex_ext_unbounded P xs ys) ⟶ fst (lex_ext_unbounded P' xs ys)) ∧
     (snd (lex_ext_unbounded P xs ys) ⟶ snd (lex_ext_unbounded P' xs ys))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?l1 xs ys ⟶ ?r1 xs ys) ∧ (?l2 xs ys ⟶ ?r2 xs ys)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">≡</span><span>P</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>lex_ext_unbounded.simps</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>TT</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y = (True, True)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>TF</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y = (True, False)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>FT</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y = (False, True)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>FF</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y = (False, False)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>TT</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = (True, True)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>TF</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (P' x y)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TF</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = (True, False)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TF</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = (True, True)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span class="delimiter">)</span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>surj_pair</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>FF</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>FT</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (P' x y)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FT</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = (True, True)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l1 (x#xs) (y#ys) ⟶ ?r1 (x#xs) (y#ys)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FT</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l2 (x#xs) (y#ys) ⟶ ?r2 (x#xs) (y#ys)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FT</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = (False, True)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span> </span><span>FT</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FT</span><span> </span><span>*</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_less_eq</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded.simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Subterm_and_Context">
<div class="head"><h1>Theory Subterm_and_Context</h1>
<span class="command">theory</span> <span class="name">Subterm_and_Context</span><br/>
<span class="keyword">imports</span> <a href="../First_Order_Terms/Term.html"><span class="name">Term</span></a> <a href="../Abstract-Rewriting/Abstract_Rewriting.html"><span class="name">Abstract_Rewriting</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterms and Contexts›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We define the (proper) sub- and superterm relations on first order terms,
  as well as contexts (you can think of contexts as terms with exactly one hole,
  where we can plug-in another term).
  Moreover, we establish several connections between these concepts as well as
  to other concepts such as substitutions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Subterm_and_Context</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>First_Order_Terms.Term</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Abstract-Rewriting.Abstract_Rewriting"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ∗‹superterm› relation.›</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>supteq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('f, 'v) term × ('f, 'v) term) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, t) ∈ supteq"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>subt</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ set ss ⟹ (u, t) ∈ supteq ⟹ (Fun f ss, t) ∈ supteq"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ∗‹proper superterm› relation.›</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>supt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('f, 'v) term × ('f, 'v) term) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>arg</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss ⟹ (Fun f ss, s) ∈ supt"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>subt</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss ⟹ (s, t) ∈ supt ⟹ (Fun f ss, t) ∈ supt"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>suptp</span><span> </span><span>supteqp</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span>
</span><span>  </span><span>suptp.arg</span><span> </span><span>suptp.cases</span><span> </span><span>suptp.induct</span><span> </span><span>suptp.intros</span><span> </span><span>suptp.subt</span><span> </span><span>suptp_supt_eq</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span>
</span><span>  </span><span>supteqp.cases</span><span> </span><span>supteqp.induct</span><span> </span><span>supteqp.intros</span><span> </span><span>supteqp.refl</span><span> </span><span>supteqp.subt</span><span> </span><span>supteqp_supteq_eq</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>supt.arg</span><span> </span><span>supt.subt</span><span> </span><span>supteq.refl</span><span> </span><span>supteq.subt</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntactic Sugar›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infix syntax.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"supt_pred s t ≡ (s, t) ∈ supt"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"supteq_pred s t ≡ (s, t) ∈ supteq"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"subt_pred s t ≡ supt_pred t s"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"subteq_pred s t ≡ supteq_pred t s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span>  </span><span>supt</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{⊳}"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>supt_pred</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ⊳ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>56</span><span class="delimiter">,</span><span> </span><span>56</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subt_pred</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>supteq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{⊵}"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>supteq_pred</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ⊵ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>56</span><span class="delimiter">,</span><span> </span><span>56</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subteq_pred</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊴"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>subt</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{⊲}"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{⊲} ≡ {⊳}¯"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>subteq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{⊴}"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{⊴} ≡ {⊵}¯"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Quantifier syntax.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_All_supteq"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∀_⊵_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Ex_supteq"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃_⊵_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_All_supt"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∀_⊳_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Ex_supt"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃_⊳_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">"_All_subteq"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∀_⊴_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="string"><span class="delete"><span class="delete">"_Ex_subteq"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃_⊴_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="string"><span class="delete"><span class="delete">"_All_subt"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∀_⊲_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="string"><span class="delete"><span class="delete">"_Ex_subt"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[idt, 'a, bool] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃_⊲_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* for parsing *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x⊵y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊵ y ⟶ P"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x⊵y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x ⊵ y ∧ P"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x⊳y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊳ y ⟶ P"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x⊳y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x ⊳ y ∧ P"</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">"∀x⊴y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊴ y ⟶ P"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"∃x⊴y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x ⊴ y ∧ P"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"∀x⊲y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ⊲ y ⟶ P"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"∃x⊲y. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x ⊲ y ∧ P"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* for printing *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">print_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
let
  val All_binder = Mixfix.binder_name @{const_syntax All};
  val Ex_binder = Mixfix.binder_name @{const_syntax Ex};
  val impl = @{const_syntax "implies"};
  val conj = @{const_syntax "conj"};
  val supt = @{const_syntax "supt_pred"};
  val supteq = @{const_syntax "supteq_pred"};

  val trans =
   [((All_binder, impl, supt), ("_All_supt", "_All_subt")),
    ((All_binder, impl, supteq), ("_All_supteq", "_All_subteq")),
    ((Ex_binder, conj, supt), ("_Ex_supt", "_Ex_subt")),
    ((Ex_binder, conj, supteq), ("_Ex_supteq", "_Ex_subteq"))];

  fun matches_bound v t =
     case t of (Const ("_bound", _) $ Free (v', _)) =&gt; (v = v')
              | _ =&gt; false
  fun contains_var v = Term.exists_subterm (fn Free (x, _) =&gt; x = v | _ =&gt; false)
  fun mk x c n P = Syntax.const c $ Syntax_Trans.mark_bound_body x $ n $ P

  fun tr' q = (q,
    K (fn [Const ("_bound", _) $ Free (v, T), Const (c, _) $ (Const (d, _) $ t $ u) $ P] =&gt;
      (case AList.lookup (=) trans (q, c, d) of
        NONE =&gt; raise Match
      | SOME (l, g) =&gt;
          if matches_bound v t andalso not (contains_var v u) then mk (v, T) l u P
          else if matches_bound v u andalso not (contains_var v t) then mk (v, T) g t P
          else raise Match)
     | _ =&gt; raise Match));
in [tr' All_binder, tr' Ex_binder] end
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitivity Reasoning for Subterms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ t ⊳ u ⟹ s ⊳ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supt.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_supt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans {⊳}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trans_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>supt_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_trans</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ⟹ t ⊵ u ⟹ s ⊵ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supteq.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary lemmas about term size.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp5</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss ⟹ s ⊳ t ⟹ size t &lt; size s ⟹ size t &lt; Suc (size_list size ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp6</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss ⟹ s ⊵ t ⟹ size t ≤ size s ⟹ size t ≤ Suc (size_list size ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ss</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ∈ set ts ⟹ size t &lt; Suc (size_list size ts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ∈ set ts ⟹ size t &lt; Suc (Suc (size s + size_list size ts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ set (zip xs ys)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size x &lt; Suc (size_list size xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_zip_leftD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>  </span><span>size_simp1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_simp4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ set (zip xs ys)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size y &lt; Suc (size_list size ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_zip_rightD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_simp1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>size_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>size_simp1</span><span> </span><span>size_simp2</span><span> </span><span>size_simp3</span><span> </span><span>size_simp4</span><span> </span><span>size_simp5</span><span> </span><span>size_simp6</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>size_simps</span><span> </span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_size</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ size s &gt; size t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supt.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_size</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ⟹ size s ≥ size t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supteq.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reflexivity and Asymmetry.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflcl_supteq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"supteq<span class="hidden">⇧</span><sup>=</sup> = supteq"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trancl_supteq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"supteq<span class="hidden">⇧</span><sup>+</sup> = supteq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trancl_id</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trans_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>supteq_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtrancl_supteq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"supteq<span class="hidden">⇧</span><sup>*</sup> = supteq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trancl_reflcl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_supteq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t ⟹ s ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_neqD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ s ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supt_size</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_Var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ vars_term t ⟹ t ⊵ Var x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>vars_term_supteq</span><span> </span><span class="delimiter">=</span><span> </span><span>supteq_Var</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_not_arg</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ∉ set ss"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?t ∉ set ss"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?t ∈ set ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?t ⊳ ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?t ≠ ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>supt_neqD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_Fun</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ Fun f ss"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ ?t"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ set ss›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?t ⊳ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size ?t &gt; size s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt_size</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ⊳ ?t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size s &gt; size ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt_size</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹size ?t &gt; size s›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_supteq_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t = (s ⊵ t ∧ s ≠ t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ∧ s ≠ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supt.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subt</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ s"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ set ss›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⊵ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ⊵ t ∧ s ≠ t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Fun f ss ⊵ s›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>first</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supteq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ set ss›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ⊳ t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>second</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>supt_neqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>first</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>second</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⊵ t ∧ Fun f ss ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>size_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ∧ s ≠ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_not_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ ¬ (t ⊳ s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊳ s"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supt_supteq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_irrefl</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ t ⊳ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supt_not_sym</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>irrefl_subt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl {⊲}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>irrefl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_imp_supteq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ s ⊵ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supt_supteq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_supteq_not_supteq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t = (s ⊵ t ∧ ¬ (t ⊵ s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supt_not_sym</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supt_supteq_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_supt_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ⊵ t) = (s ⊳ t ∨ s = t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supt_supteq_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_antisym</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supteq_supt_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supt_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The subterm relation is an order on terms.›</span></span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>subterm</span><span class="delimiter">:</span><span> </span><span>order</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊴)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊲)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt_supteq_not_supteq</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>supteq_trans</span><span> </span><span>supteq_antisym</span><span> </span><span>supt_supteq_not_supteq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹More transitivity rules.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_supteq_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ t ⊵ u ⟹ s ⊳ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subterm.le_less_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_supt_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ⟹ t ⊳ u ⟹ s ⊳ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subterm.less_le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>subterm.le_less_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>subterm.less_le_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suptE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t ⟹ (s ⊵ t ⟹ P) ⟹ (s ≠ t ⟹ P) ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supt_supteq_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>suptI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>subterm.dual_order.not_eq_order_implies_strict</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_supteq_set_conv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{⊳} = {⊵} - Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>supt_supteq_conv</span><span> </span><span class="delimiter">[</span><span>to_set</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_supt_set_conv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{⊵} = {⊳}<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supt_supteq_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_imp_vars_term_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t ⟹ vars_term t ⊆ vars_term s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supteq.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_supteq_into_supt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ts ⊳ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ⊵ s›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = s ∨ t ⊳ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ set ts›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊳ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>supt.subt</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t ∈ set ts›</span></span></span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The superterm relation is strongly normalizing.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_supt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"SN {⊳}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_iff_wf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>supt_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_not_refl</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊳ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>False</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_not_supt</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (s ⊳ t)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_not_supt_conv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{⊵} - {⊳} = Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋅ σ ⊵ t ⋅ σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supteq.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subt</span><span> </span><span>u</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ set ss›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋅ σ ∈ set (map (λt. t ⋅ σ) ss)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋅ σ ⊵ u ⋅ σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⋅ σ ⊵ u ⋅ σ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_apply_term.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ⋅ σ ⊵ t ⋅ σ›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supteq_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋅ σ ⊳ t ⋅ σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>supt.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>arg</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋅ σ ∈ set (map (λt. t ⋅ σ) ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_apply_term.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt.arg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subt</span><span> </span><span>u</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ set ss›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋅ σ ∈ set (map (λt. t ⋅ σ) ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss ⋅ σ ⊳ u ⋅ σ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_apply_term.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>supt.arg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ⋅ σ ⊳ t ⋅ σ›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>supt_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subterm_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. ∀s⊲t. P s ⟹ P t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>subterm</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_measure</span><span class="delimiter">[</span><span>of</span><span> </span><span>size</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>P</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>supt_size</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Contexts›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ∗‹context› is a term containing exactly one ∗‹hole›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span>funs_ctxt</span><span class="delimiter">:</span><span> </span><span class="tfree">'f</span><span class="delimiter">,</span><span> </span><span>vars_ctxt</span><span class="delimiter">:</span><span> </span><span class="tfree">'v</span><span class="delimiter">)</span><span> </span><span>ctxt</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Hole</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"□"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>More</span><span> </span><span class="tfree">'f</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We also say that we apply a context~@{term C} to a term~@{term t} when we
  replace the hole in a @{term C} by @{term t}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ctxt_apply_term</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt ⇒ ('f, 'v) term ⇒ ('f, 'v) term"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_⟨_⟩"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"□⟨s⟩ = s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(More f ss1 C ss2)⟨s⟩ = Fun f (ss1 @ C⟨s⟩ # ss2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(C⟨s⟩ = C⟨t⟩) = (s = t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ctxt_compose</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt ⇒ ('f, 'v) ctxt ⇒ ('f, 'v) ctxt"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∘<span class="hidden">⇩</span><sub>c</sub>"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"□ ∘<span class="hidden">⇩</span><sub>c</sub> D = D"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(More f ss1 C ss2) ∘<span class="hidden">⇩</span><sub>c</sub> D = More f ss1 (C ∘<span class="hidden">⇩</span><sub>c</sub> D) ss2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>ctxt_monoid_mult</span><span class="delimiter">:</span><span> </span><span>monoid_mult</span><span> </span><span class="string"><span class="delete"><span class="delete">"□"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∘<span class="hidden">⇩</span><sub>c</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span>D</span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∘<span class="hidden">⇩</span><sub>c</sub> D ∘<span class="hidden">⇩</span><sub>c</sub> E = C ∘<span class="hidden">⇩</span><sub>c</sub> (D ∘<span class="hidden">⇩</span><sub>c</sub> E)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"□ ∘<span class="hidden">⇩</span><sub>c</sub> C = C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∘<span class="hidden">⇩</span><sub>c</sub> □ = C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>ctxt</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span> </span><span>type</span><span class="delimiter">)</span><span> </span><span>monoid_mult</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = □"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(*) = (∘<span class="hidden">⇩</span><sub>c</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_ctxt_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ∘<span class="hidden">⇩</span><sub>c</sub> D)⟨t⟩ = C⟨D⟨t⟩⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ctxt_ctxt</span><span> </span><span class="delimiter">=</span><span> </span><span>ctxt_ctxt_compose</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Applying substitutions to contexts.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subst_apply_ctxt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt ⇒ ('f, 'v, 'w) gsubst ⇒ ('f, 'w) ctxt"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅<span class="hidden">⇩</span><sub>c</sub>"</span></span></span><span> </span><span>67</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"□ ⋅<span class="hidden">⇩</span><sub>c</sub> σ = □"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(More f ss1 D ss2) ⋅<span class="hidden">⇩</span><sub>c</sub> σ = More f (map (λt. t ⋅ σ) ss1) (D ⋅<span class="hidden">⇩</span><sub>c</sub> σ) (map (λt. t ⋅ σ) ss2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_apply_term_ctxt_apply_distrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"C⟨t⟩ ⋅ μ = (C ⋅<span class="hidden">⇩</span><sub>c</sub> μ)⟨t ⋅ μ⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_compose_ctxt_compose_distrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(C ∘<span class="hidden">⇩</span><sub>c</sub> D) ⋅<span class="hidden">⇩</span><sub>c</sub> σ = (C ⋅<span class="hidden">⇩</span><sub>c</sub> σ) ∘<span class="hidden">⇩</span><sub>c</sub> (D ⋅<span class="hidden">⇩</span><sub>c</sub> σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_compose_subst_compose_distrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"C ⋅<span class="hidden">⇩</span><sub>c</sub> (σ ∘<span class="hidden">⇩</span><sub>s</sub> τ) = (C ⋅<span class="hidden">⇩</span><sub>c</sub> σ) ⋅<span class="hidden">⇩</span><sub>c</sub> τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Connection between Contexts and the Superterm Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_imp_supteq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C⟨t⟩ ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_ctxtE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>refl</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = □⟨s⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>refl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subt</span><span> </span><span>u</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = C⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u ∈ set ss›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ss1 @ u # ss2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss = (More f ss1 C ss2)⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u = C⟨t⟩›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>subt</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>best</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_supteq</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Hole</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>More</span><span> </span><span>f</span><span> </span><span>ss1</span><span> </span><span>D</span><span> </span><span>ss2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Fun f (ss1 @ D⟨t⟩ # ss2)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = Fun _ ?ss"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D⟨t⟩ ∈ set ?ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D⟨t⟩ ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_ctxt_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ⊵ t) = (∃C. s = C⟨t⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_ctxtE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>arg</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ set ss›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ss1 @ s # ss2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"More f ss1 □ ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C ≠ □"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss = ?C⟨s⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>best</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subt</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ set ss›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ss1 @ s # ss2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"More f ss1 C ss2 ≠ □"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss = (More f ss1 C ss2)⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = C⟨t⟩›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subt</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>best</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_supt</span><span class="delimiter">[</span><span>intro</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Hole</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>More</span><span> </span><span>f</span><span> </span><span>ss1</span><span> </span><span>D</span><span> </span><span>ss2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Fun f (ss1 @ D⟨t⟩ # ss2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D⟨t⟩ ∈ set (ss1 @ D⟨t⟩ # ss2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ D⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D⟨t⟩ ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_ctxt_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ⊳ t) = (∃C. C ≠ □ ∧ s = C⟨t⟩)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ⊵ t›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≠ t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = C⟨t⟩›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nectxt_imp_supt_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □ ⟹ C⟨t⟩ ⊳ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (Var x ⊳ u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x ⊳ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x = C⟨u⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (Fun f [] ⊳ u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f [] ⊳ u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f [] = C⟨u⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_var_imp_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Var x ⊵ t) = (t = Var x)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = (_ = ?x)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Var x"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x ⊵ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?x ⊵ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?x = C⟨t⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>best</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = ?x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Var_supt</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x ⊳ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>P</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>supt_var</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fun_supt</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ts ⊳ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⊵ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supt_supteq_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_ctxt_apply_term</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj (ctxt_apply_term C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_subst_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ vars_ctxt C ⟹ σ x = τ x) ⟹ C ⋅<span class="hidden">⇩</span><sub>c</sub> σ = C ⋅<span class="hidden">⇩</span><sub>c</sub> τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>More</span><span> </span><span>f</span><span> </span><span>bef</span><span> </span><span>C</span><span> </span><span>aft</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ∈ set bef"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋅ σ = t ⋅ τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>More</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_subst_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ∈ set aft"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋅ σ = t ⋅ τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>More</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_subst_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⋅<span class="hidden">⇩</span><sub>c</sub> σ = C ⋅<span class="hidden">⇩</span><sub>c</sub> τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>More</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Term_Aux">
<div class="head"><h1>Theory Term_Aux</h1>
<span class="command">theory</span> <span class="name">Term_Aux</span><br/>
<span class="keyword">imports</span> <a href="Subterm_and_Context.html"><span class="name">Subterm_and_Context</span></a> <a href="../../HOL/HOL-Library/Multiset.html"><span class="name">Multiset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Term_Aux</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Subterm_and_Context</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory contains material about terms that is required for KBO, 
  but does not belong to @{theory Knuth_Bendix_Order.Subterm_and_Context}.

  We plan to merge this material into the theory @{theory First_Order_Terms.Term}
  at some point.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The variables of a term as multiset.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>vars_term_ms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term ⇒ 'v multiset"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (Var x) = {#x#}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (Fun f ts) = ⋃# (mset (map vars_term_ms ts))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_term_ms_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (t ⋅ σ) =
    ⋃# (image_mset (λ x. vars_term_ms (σ x)) (vars_term_ms t))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?V t"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ t. vars_term_ms (t ⋅ σ)) ts = map (λ t. ?V t) ts"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span> </span><span>Fun</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>IH</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>ts</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_term_ms_subst_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms s ⊆# vars_term_ms t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (s ⋅ σ) ⊆# vars_term_ms (t ⋅ σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mset_subset_eq_exists_conv</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms t = vars_term_ms s + u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_term_ms_subst</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_mset_vars_term_ms</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_mset (vars_term_ms t) = vars_term t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A term is called ∗‹ground› if it does not contain any variables.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ground</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ground (Var x) ⟷ False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ground (Fun f ts) ⟷ (∀t ∈ set ts. ground t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_vars_term_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground t ⟷ vars_term t = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground (t ⋅ σ) ⟷ (∀x ∈ vars_term t. ground (σ x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_subst_apply</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋅ σ = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = t ⋅ Var"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = t ⋅ σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>term_subst_eq</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ground_vars_term_empty</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A ∗‹signature› is a set of function symbol/arity pairs, where the arity of a function symbol,
  denotes the number of arguments it expects.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'f</span><span> </span><span>sig</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f × nat) set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The set of all function symbol/ arity pairs occurring in a term.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>funas_term</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term ⇒ 'f sig"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"funas_term (Var _) = {}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"funas_term (Fun f ts) = {(f, length ts)} ∪ ⋃(set (map funas_term ts))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supt_imp_funas_term_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"funas_term t ⊆ funas_term s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supteq_imp_funas_term_subset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"funas_term t ⊆ funas_term s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The set of all function symbol/arity pairs occurring in a context.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>funas_ctxt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) ctxt ⇒ 'f sig"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"funas_ctxt Hole = {}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"funas_ctxt (More f ss1 D ss2) = {(f, Suc (length (ss1 @ ss2)))}
     ∪ funas_ctxt D ∪ ⋃(set (map funas_term (ss1 @ ss2)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funas_term_ctxt_apply</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"funas_term (C⟨t⟩) = funas_ctxt C ∪ funas_term t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funas_term_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"funas_term (t ⋅ σ) = funas_term t ∪ ⋃(funas_term ` σ ` vars_term t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funas_ctxt_compose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"funas_ctxt (C ∘<span class="hidden">⇩</span><sub>c</sub> D) = funas_ctxt C ∪ funas_ctxt D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funas_ctxt_subst</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"funas_ctxt (C ⋅<span class="hidden">⇩</span><sub>c</sub> σ) = funas_ctxt C ∪ ⋃(funas_term ` σ ` vars_ctxt C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>funas_term_subst</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="KBO">
<div class="head"><h1>Theory KBO</h1>
<span class="command">theory</span> <span class="name">KBO</span><br/>
<span class="keyword">imports</span> <a href="Lexicographic_Extension.html"><span class="name">Lexicographic_Extension</span></a> <a href="Term_Aux.html"><span class="name">Term_Aux</span></a> <a href="Missing_List.html"><span class="name">Missing_List</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KBO›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Below, we formalize a variant of KBO that includes subterm coefficient functions.

  A more standard definition is obtained by setting all subterm coefficients to 1.
  For this special case it would be possible to define more efficient code-equations that
  do not have to evaluate subterm coefficients at all.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KBO</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Lexicographic_Extension</span><span>
</span><span>    </span><span>Term_Aux</span><span>
</span><span>    </span><span>Polynomial_Factorization.Missing_List</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subterm Coefficient Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Given a function @{term scf}, associating positions with subterm coefficients, and
  a list @{term xs}, the function @{term scf_list} yields an expanded list where  each
  element of @{term xs} is replicated a number of times according to its subterm coefficient.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>scf_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ nat) ⇒ 'a list ⇒ 'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"scf_list scf xs = concat (map (λ(x, i). replicate (scf i) x) (zip xs [0 ..&lt; length xs]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_scf_list</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length xs. scf i &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (scf_list scf xs) = set xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span> </span><span>set_zip</span><span> </span><span>set_conv_nth</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scf_list_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (scf_list scf xs) ⊆ set xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span> </span><span>set_zip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scf_list_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scf_list scf [] = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scf_list_bef_i_aft</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scf_list scf (bef @ i # aft) =
    scf_list scf bef @ replicate (scf (length bef)) i @
    scf_list (λ i. scf (Suc (length bef + i))) aft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scf_list_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>aft</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List.rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>a</span><span> </span><span>aft</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bia</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bia = bef @ i # aft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bia</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bef @ i # aft @ [a] = bia @ [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bia_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"zip (bia @ [a]) [0..&lt;length (bia @ [a])]
   = zip bia [0..&lt;length bia] @ [(a, length bia)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>concat</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"concat (map (λ(x, i). replicate (scf i) x) (zip bia [0..&lt;length bia] @ [(a, length bia)])) =
      concat (map (λ(x, i). replicate (scf i) x) (zip bia [0..&lt;length bia])) @
      replicate (scf (length bia)) a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bia</span><span> </span><span>zip</span><span> </span><span>concat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bia_def</span><span> </span><span>snoc</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scf_list_map</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scf_list scf (map f xs) = map f (scf_list scf xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List.rev_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The function @{term scf_term} replicates each argument a number of times according to its
  subterm coefficient function.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>scf_term</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f × nat ⇒ nat ⇒ nat) ⇒ ('f, 'v) term ⇒ ('f, 'v) term"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"scf_term scf (Var x) = (Var x)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"scf_term scf (Fun f ts) = Fun f (scf_list (scf (f, length ts)) (map (scf_term scf) ts))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_term_scf_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_term (scf_term scf s) ⊆ vars_term s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term (scf_term scf (Fun f ss)) =
    (⋃x∈set (scf_list (scf (f, length ss)) ss). vars_term (scf_term scf x))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ (⋃x∈set ss. vars_term (scf_term scf x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scf_list_subset</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ss</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ (⋃x∈set ss. vars_term x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scf_term_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scf_term scf (t ⋅ σ) = scf_term scf t ⋅ (λ x. scf_term scf (σ x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set (scf_list (scf (f, length ts)) ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>scf_list_subset</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ts</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ set ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scf_term scf (t ⋅ σ) = scf_term scf t ⋅ (λx. scf_term scf (σ x))"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Fun</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weight Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>weight_fun</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f × nat ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w0</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>scf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f × nat ⇒ nat ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The ∗‹weight› of a term is computed recursively, where variables have weight @{term w0}
  and the weight of a compound term is computed by adding the weight of its root symbol
  @{term "w (f, n)"} to the weighted sum where weights of arguments are multiplied
  according to their subterm coefficients.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"weight (Var x) = w0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"weight (Fun f ts) =
    (let n = length ts; scff = scf (f, n) in
    w (f, n) + sum_list (map (λ (ti, i). weight ti * scff i) (zip ts [0 ..&lt; n])))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Alternatively, we can replicate arguments via @{const scf_list}.
  The advantage is that then both @{const weight} and @{const scf_term} are defined
  via @{const scf_list}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weight (Fun f ts) = w (f, length ts) + sum_list (map weight (scf_list (scf (f, length ts)) ts))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>scff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"scff = (scf (f, length ts) :: nat ⇒ nat)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(ti, i) ← zip ts [0..&lt;length ts]. weight ti * scff i) =
   sum_list (map weight (scf_list scff ts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List.rev_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>t</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (replicate n (weight t)) = n * weight t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>scff_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>weight.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SCF ≡ scf_term scf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_scf_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. i &lt; length ts ⟹ f i &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight ts) ≤ sum_list (map weight (scf_list f ts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scf_list_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List.rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>t</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight ts) ≤
    sum_list (map weight (concat (map (λ(x, i). replicate (f i) x) (zip ts [0..&lt;length ts]))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>snoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ts"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (length ts) = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of KBO›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The precedence is given by three parameters:

  ▪ a predicate @{term pr_strict} for strict decrease between two function symbols,
  ▪ a predicate @{term pr_weak} for weak decrease between two function symbols, and
  ▪ a function indicating whether a symbol is least in the precedence.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kbo</span><span> </span><span class="delimiter">=</span><span> </span><span>weight_fun</span><span> </span><span>w</span><span> </span><span>w0</span><span> </span><span>scf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span> </span><span>w0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>scf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f × nat ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>least</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_strict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f × nat ⇒ 'f × nat ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_weak</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f × nat ⇒ 'f × nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The result of @{term kbo} is a pair of Booleans encoding strict/weak decrease.

  Interestingly, the bound on the lengths of the lists in the lexicographic extension is not 
  required for KBO.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>kbo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term ⇒ ('f, 'v) term ⇒ bool × bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"kbo s t = (if (vars_term_ms (SCF t) ⊆# vars_term_ms (SCF s) ∧ weight t ≤ weight s)
      then if (weight t &lt; weight s)
        then (True, True)
        else (case s of
          Var y ⇒ (False, (case t of Var x ⇒ x = y | Fun g ts ⇒ ts = [] ∧ least g))
        | Fun f ss ⇒ (case t of
            Var x ⇒ (True, True)
          | Fun g ts ⇒ if pr_strict (f, length ss) (g, length ts)
            then (True, True)
            else if pr_weak (f, length ss) (g, length ts)
            then lex_ext_unbounded kbo ss ts
            else (False, False)))
      else (False, False))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abbreviations for strict (S) and nonstrict (NS) KBO.›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ λ s t. fst (kbo s t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS ≡ λ s t. snd (kbo s t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  For code-generation we do not compute the weights of @{term s} and @{term t} repeatedly.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kbo_code</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kbo s t = (let wt = weight t; ws = weight s in
    if (vars_term_ms (SCF t) ⊆# vars_term_ms (SCF s) ∧ wt ≤ ws)
    then if wt &lt; ws
      then (True, True)
      else (case s of
        Var y ⇒ (False, (case t of Var x ⇒ True | Fun g ts ⇒ ts = [] ∧ least g))
      | Fun f ss ⇒ (case t of
          Var x ⇒ (True, True)
        | Fun g ts ⇒ let ff = (f, length ss); gg = (g, length ts) in
          if pr_strict ff gg
          then (True, True)
          else if pr_weak ff gg
            then lex_ext_unbounded kbo ss ts
            else (False, False)))
    else (False, False))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>term.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>kbo.kbo_code</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>weight_fun.weight.simps</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_replicate_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m1 ⊆# m2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃# (mset (replicate n m1)) ⊆# ⋃# (mset (replicate n m2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃# (mset (replicate (Suc n) m1)) =
    ⋃# (mset (replicate n m1)) + m1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆# ⋃# (mset (replicate n m1)) + m2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m1 ⊆# m2›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆# ⋃# (mset (replicate n m2)) + m2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  While the locale @{locale kbo} only fixes its parameters, we now demand that these
  parameters are sensible, e.g., encoding a well-founded precedence, etc.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>admissible_kbo</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>kbo</span><span> </span><span>w</span><span> </span><span>w0</span><span> </span><span>scf</span><span> </span><span>least</span><span> </span><span>pr_strict</span><span> </span><span>pr_weak</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span> </span><span>w0</span><span> </span><span>pr_strict</span><span> </span><span>pr_weak</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>least</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>scf</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>w0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (f, 0) ≥ w0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (f, 1) = 0 ⟹ pr_weak (f, 1) (g, n)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least f = (w (f, 0) = w0 ∧ (∀ g. w (g, 0) = w0 ⟶ pr_weak (g, 0) (f, 0)))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>scf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n ⟹ scf (f, n) i &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_weak_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak fn fn"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak fn gm ⟹ pr_weak gm hk ⟹ pr_weak fn hk"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict fn gm ⟷ pr_weak fn gm ∧ ¬ pr_weak gm fn"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_SN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN {(fn, gm). pr_strict fn gm}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_w0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t ≥ w0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 ≤ w (f, length ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>scf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>scf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; scf (f, length ts) i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>scf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"scf (f, length ts) i = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>id_take_nth_drop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bef</span><span> </span><span>aft</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = bef @ ts ! i # aft"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ii</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length bef = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>tsi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tsi = ts ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ts</span><span> </span><span class="delimiter">=</span><span> </span><span>ts</span><span class="delimiter">[</span><span>folded</span><span> </span><span>tsi_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tsi ∈ set ts"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tsi_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 ≤ weight tsi"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scf</span><span> </span><span>ii</span><span> </span><span>w0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_w0</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_0</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t = 0 ⟷ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_gt_0</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_S_Var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S (Var x) t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t ⟹ NS s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>kbo.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF s) ∧ weight t ≤ weight s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>S</span><span> </span><span>w</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t &lt; weight s"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>S</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_S_Var</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Fun f ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>Var</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Fun</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, length ss)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded kbo ss ts"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>s</span><span> </span><span>Fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict ?f ?g ∨ pr_weak ?f ?g ∧ fst ?lex"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict ?f ?g"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span> </span><span>s</span><span> </span><span>Fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>disj</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ?lex"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span> </span><span>fg</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext kbo (length ss + length ts) ss ts)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex_ext_stri_imp_nstri</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ?lex"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span>fg</span><span> </span><span>S</span><span> </span><span>s</span><span> </span><span>Fun</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reflexivity and Irreflexivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext kbo (length ss) ss ss)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_nstri_imp_lex_nstri</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>Fun</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>set_conv_nth</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo ss ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pr_strict_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict fn fn"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S t t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>not_S_Var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_strict_irrefl</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict (f, length ts) (f, length ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo ts ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S (ts ! i) (ts ! i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Fun</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity (a.k.a. Closure under Contexts)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_mono_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S (Fun f (ss1 @ s # ss2)) (Fun f (ss1 @ t # ss2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 @ s # ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 @ t # ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ?ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ?ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t ≤ weight s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF s)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_replicate_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t ≤ weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_list_replicate_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo ?ss ?ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>fst_conv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss1"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>S</span><span> </span><span>NS_refl</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v'</span><span> </span><span>w'</span><span> </span><span>lex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t ⟹ S (C⟨s⟩) (C⟨t⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>S_mono_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_mono_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Fun f (ss1 @ s # ss2)) (Fun f (ss1 @ t # ss2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 @ s # ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss1 @ t # ss2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ?ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ?ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t ≤ weight s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_replicate_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t ≤ weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_list_replicate_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo ?ss ?ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>snd_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>disjI2</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (ss1 @ t # ss2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (?ss ! i) (?ts ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NS</span><span> </span><span>NS_refl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = length ss1"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v'</span><span> </span><span>w'</span><span> </span><span>lex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t ⟹ NS (C⟨s⟩) (C⟨t⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>NS_mono_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Subterm Property›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Var_imp_eq_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Var x) t ⟹ t = Var x ∨ (∃ f. t = Fun f [] ∧ least f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kbo_supt_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s (t :: ('f, 'v) term) ⟹ S (Fun f (bef @ s # aft)) t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>f</span><span> </span><span>s</span><span> </span><span>bef</span><span> </span><span>aft</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>NS</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bef @ s # aft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length bef &lt; length ?ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>scf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>scf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"scf (f, length ?ss) (length bef) = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF (Fun f ?ss)) = vars_term_ms (SCF s) + X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>scf</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF s) ⊆# vars_term_ms (SCF (Fun f ?ss))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vt</span><span> </span><span>vs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF (Fun f ?ss))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_mset.order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ?ss"</span></span></span><span class="delimiter">]</span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span> </span><span>f</span><span> </span><span>s</span><span> </span><span>bef</span><span> </span><span>aft</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun g ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bef @ s # aft"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>NS</span><span> </span><span class="delimiter">=</span><span> </span><span>Fun</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>Fun</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length bef &lt; length ?ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>scf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>scff</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"scf (f, length ?ss) (length bef) = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>scff</span><span> </span><span class="delimiter">=</span><span> </span><span>scff</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF (Fun f ?ss)) = vars_term_ms (SCF s) + X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>scff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF s) ⊆# vars_term_ms (SCF (Fun f ?ss))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight s ≤ sum_list (map weight (scf_list (scf (f, length ?ss)) ?ss))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>scff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t ≤ weight s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>vt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ws</span><span> </span><span>wt</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t ≤ sum_list (map weight (scf_list (scf (f, length ?ss)) ?ss))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vt</span><span> </span><span>vs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF (Fun f ?ss))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vars_term_ms (SCF ?t) ⊆# vars_term_ms (SCF (Fun f ?ss))) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t = weight (Fun f ?ss)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>True</span><span class="delimiter">]</span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (f, length ?ss) = 0"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (scf_list (scf (f, length ?ss)) bef)) = 0"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (scf_list (λ i. (scf (f, length ?ss) (Suc (length bef) + i))) aft)) = 0"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight bef) ≤ sum_list (map weight (scf_list (scf (f, length ?ss)) bef))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_scf_list</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>scf</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lsum</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight bef) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bef = []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd bef"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bef</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight aft) ≤ sum_list (map weight (scf_list (λ i. (scf (f, length ?ss) (Suc (length bef) + i))) aft))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_scf_list</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>scf</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lsum</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight aft) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aft</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"aft = []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd aft"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>aft</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>scff</span><span> </span><span class="delimiter">=</span><span> </span><span>scff</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bef</span><span> </span><span>aft</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bef</span><span> </span><span>aft</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ba</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bef @ s # aft = [s]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (f, 1) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight s = weight ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ba</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, 1)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict ?f ?g"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ba</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>admf</span><span> </span><span class="delimiter">=</span><span> </span><span>adm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>admf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pg</span><span> </span><span>False</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>pr_strict</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?g ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>admf</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ h k. pr_weak ?g (h, k)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo [s] ts)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Nil</span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pg</span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ba</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t</span><span> </span><span>tts</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Var x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS_Var_imp_eq_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NS</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>s</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = Fun h ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span>wst</span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss"</span></span></span><span class="delimiter">]</span><span> </span><span>pr_strict</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(h, length ss)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo ss ts)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s0</span><span> </span><span>sss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = s0 # sss"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>snd_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ss</span><span> </span><span>Cons</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S s0 t ∨ NS s0 t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"kbo s0 t"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_ext_unbounded.simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span>s0</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s0 t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>h</span><span> </span><span>Nil</span><span> </span><span>sss</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo [s] ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>fst_conv</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo [s] ts) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>all</span><span> </span><span class="delimiter">=</span><span> </span><span>lex</span><span> </span><span>wst</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span>pg</span><span> </span><span>scff</span><span> </span><span>v'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>all</span><span> </span><span class="delimiter">=</span><span> </span><span>all</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ba</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>Cons</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (Fun f [t]) = weight (t :: ('f, 'v) term)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span> </span><span>scff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ba</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span>ss</span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f [Fun h (s0 # sss)]"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_supt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>supt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊳ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>supt</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = C⟨t⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ □"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>More</span><span> </span><span>f</span><span> </span><span>bef</span><span> </span><span>C</span><span> </span><span>aft</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"C = □"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>kbo_supt_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NS_refl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>bef</span><span> </span><span>t</span><span> </span><span>aft</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>kbo_supt_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>More</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>bef</span><span> </span><span>t</span><span> </span><span>aft</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_supteq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⊵ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_supt</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>NS_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>subterm.le_less</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Least Elements›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_all_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS t (Fun f [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span>l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s (Fun f [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>kbo_supt_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>g</span><span> </span><span>Nil</span><span> </span><span>ss</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun g []"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (Fun g []) ≥ weight (Fun f [])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex_ext_least_1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext kbo 0 [] [])"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo [] [])"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fun</span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>empty_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_S_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S (Fun f []) t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fun</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S (Fun f []) (Fun g ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Fun</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) + sum_list (map weight (scf_list (scf (g, length ts)) ts)) ≤ weight (Fun f [])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) ≤ weight (Fun f [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (Fun f []) ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) = w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>w0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span>Nil</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) = w (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak (f, 0) (g, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak (g, 0) (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>p2</span><span> </span><span>gf</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo [] ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = [] @ s # ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>scf</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ts"</span></span></span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>scff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"scf (g, length ts) 0 = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (
          scf_list (λi. scf (g, Suc (length ss)) (Suc i)) ss
          ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 + sum_list (map weight (replicate n s)) ≤ weight s + sum_list (map weight (replicate n s))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = sum_list (map weight (replicate (scf (g, length ts) 0) s))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) + … + ?e ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ts</span><span> </span><span>scf_list_bef_i_aft</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 + sum_list (map weight (replicate n s)) + w (g, length ts) + ?e ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>null</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?e = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (replicate n s)) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>null</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight ss) ≤ ?e"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_scf_list</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>scf</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>null</span><span class="delimiter">]</span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd ss"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = [s]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>scff</span><span> </span><span class="delimiter">=</span><span> </span><span>scff</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ts</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wg</span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 1) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wg</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak (g, 1) (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Fun</span><span> </span><span>ts</span><span class="delimiter">]</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>scff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo [] [s])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_least_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least f"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Fun f []) t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ g. t = Fun g [] ∧ least g"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Fun</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) + sum_list (map weight (scf_list (scf (g, length ts)) ts)) ≤ weight (Fun f [])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) ≤ weight (Fun f [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (Fun f []) ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) = w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>w0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span>Nil</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 0) = w (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak (f, 0) (g, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>least</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (h, 0) = w0 ⟶ pr_weak (h, 0) (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pr_weak_trans</span><span> </span><span>p</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (h, 0) = w0 ⟶ pr_weak (h, 0) (g, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>Fun</span><span> </span><span>Nil</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>least</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>s</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = [] @ s # ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>scf</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ts"</span></span></span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>scff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"scf (g, length ts) 0 = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>lessE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (
        scf_list (λi. scf (g, Suc (length ss)) (Suc i)) ss
      ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 + sum_list (map weight (replicate n s)) ≤ weight s + sum_list (map weight (replicate n s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = sum_list (map weight (replicate (scf (g, length ts) 0) s))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) + … + ?e ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ts</span><span> </span><span>scf_list_bef_i_aft</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w0 + sum_list (map weight (replicate n s)) + w (g, length ts) + ?e ≤ w0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, length ts) = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>null</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?e = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight (replicate n s)) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>null</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map weight ss) ≤ ?e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_scf_list</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>scf</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>null</span><span class="delimiter">]</span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd ss"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ts = [s]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>scff</span><span> </span><span class="delimiter">=</span><span> </span><span>scff</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ts</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wg</span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w (g, 1) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wg</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak (g, 1) (f, 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Fun</span><span> </span><span>ts</span><span class="delimiter">]</span><span> </span><span>l</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>scff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo [] [s])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf_list_def</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_unbounded_iff</span><span> </span><span>snd_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stability (a.k.a. Closure under Substitutions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (t ⋅ σ) =
  weight t + sum_mset (image_mset (λ x. weight (σ x) - w0) (vars_term_ms (SCF t)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"scf_list (scf (f, length ts)) ts"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>sts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sts = ?ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ t. weight (t ⋅ σ)) ?ts = map (λ t. weight t + sum_mset (image_mset (λ x. weight (σ x) - w0) (vars_term_ms (scf_term scf t)))) ?ts"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span> </span><span>Fun</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>scf_list_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ts</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>sts_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>sts</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_stable_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight s ≤ weight t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF s) ⊆# vars_term_ms (SCF t)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (s ⋅ σ) ≤ weight (t ⋅ σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vs</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mset_subset_eq_exists_conv</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>vt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) = vars_term_ms (SCF s) + u"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>weight_subst</span><span> </span><span>vt</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_stable_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ws</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight s &lt; weight t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF s) ⊆# vars_term_ms (SCF t)"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (s ⋅ σ) &lt; weight (t ⋅ σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vs</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mset_subset_eq_exists_conv</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>vt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) = vars_term_ms (SCF s) + u"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>weight_subst</span><span> </span><span>vt</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KBO is stable, i.e., closed under substitutions.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kbo_stable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) subst"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(S s t ⟶ S (s ⋅ σ) (t ⋅ σ)) ∧ NS (s ⋅ σ) (t ⋅ σ)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P s t"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>y</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S (Var y) t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_S_Var</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS_Var_imp_eq_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Var</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Var y ∨ (∃ f. t = Fun f [] ∧ least f)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Var y ∨ t = Fun f [] ∧ least f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Var y ⋅ σ) (t ⋅ σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Var y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NS_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋅ σ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Fun f [] ∧ least f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS_all_least</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var y ⋅ σ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>not</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>NS</span><span> </span><span class="delimiter">=</span><span> </span><span>Fun</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>Fun</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = ?s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ s. s ⋅ σ) ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t ≤ weight ?s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>weight_stable_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wσ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (t ⋅ σ) ≤ weight (?s ⋅ σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vars_term_ms_subst_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. SCF (σ x)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vσ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF (t ⋅ σ)) ⊆# vars_term_ms (SCF (?s ⋅ σ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scf_term_subst</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (t ⋅ σ) &lt; weight (?s ⋅ σ)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>vσ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>weight_stable_lt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t = weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>s_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ vars_term (SCF s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ vars_term s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vars_term_scf_subset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ vars_term s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>supteq_Var</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?s ⊳ Var y"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s_def</span><span> </span><span>Fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S_supt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supt_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S (?s ⋅ σ) (t ⋅ σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Var</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, length ss)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ s. s ⋅ σ) ts"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict ?f ?g"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S (?s ⋅ σ) (t ⋅ σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wσ</span><span> </span><span>vσ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S</span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>prec</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?g"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>prec</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ NS ?s t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>vars_term_ms.simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF ?s) ∧ weight t ≤ weight ?s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ weight t &lt; weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ts"</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S (ss ! i) (ts ! i)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S (map (λs. s ⋅ σ) ss ! i) (map (λs. s ⋅ σ) ts ! i)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH_S</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ts"</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (ss ! i) (ts ! i)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (map (λs. s ⋅ σ) ss ! i) (map (λs. s ⋅ σ) ts ! i)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>NS</span><span class="delimiter">]</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>kbo.simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH_NS</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s t"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prec</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo ss ts)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s_def</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (lex_ext_unbounded kbo ?ss ?ts)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lex_ext_unbounded_map_S</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>lex</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>IH_NS</span><span> </span><span>IH_S</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>vσ</span><span> </span><span>wσ</span><span> </span><span>prec</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S (?s ⋅ σ) (t ⋅ σ)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span>prec</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo ss ts)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (lex_ext_unbounded kbo ?ss ?ts)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lex_ext_unbounded_map_NS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>lex</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>IH_S</span><span> </span><span>IH_NS</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>vσ</span><span> </span><span>wσ</span><span> </span><span>prec</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (?s ⋅ σ) (t ⋅ σ)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"S s t ⟹ S (s ⋅ (σ :: ('f, 'v) subst)) (t ⋅ σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_stable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_imp_NS</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t ⟹ NS (s ⋅ (σ :: ('f, 'v) subst)) (t ⋅ σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_stable</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transitivity and Compatibility›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kbo_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S s t ⟶ NS t u ⟶ S s u) ∧
  (NS s t ⟶ S t u ⟶ S s u) ∧
  (NS s t ⟶ NS t u ⟶ NS s u)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P s t u"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_S_Var</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S (Var x) t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Var x) t"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>nS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS_Var_imp_eq_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"t = Var x ∨ t = Fun f [] ∧ least f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Var x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Fun f [] ∧ least f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Fun f []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_S_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nS'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S t u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS t u"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS_least_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = Fun h []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS_all_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS (Var x) u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>nS</span><span> </span><span>nS'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS ?s t"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t ≤ weight ?s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS t u"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tu</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vtu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF u) ⊆# vars_term_ms (SCF t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wtu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight u ≤ weight t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vst</span><span> </span><span>vtu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF u) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wst</span><span> </span><span>wtu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight u ≤ weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight u &lt; weight ?s"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wst</span><span> </span><span>wtu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight t = weight ?s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wtu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight u = weight t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight u = weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>h</span><span> </span><span>us</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>u</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>g</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, length ss)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?h</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(h, length us)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span>t</span><span> </span><span>wst</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>wtu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?g ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pr_strict</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fg</span><span> </span><span>gh</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_strict ?f ?h"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span>u</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded kbo"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?h ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hf</span><span> </span><span>fg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?h ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gh2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict ?g ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gh</span><span> </span><span>hf</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?g ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>gf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fg2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict ?f ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span>t</span><span> </span><span>wst</span><span> </span><span>fg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lex ss ts)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>wtu</span><span> </span><span>gh2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lex ts us)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ set ss"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(NS s t ∧ S t u ⟶ S s u) ∧
                  (S s t ∧ NS t u ⟶ S s u) ∧
                  (NS s t ∧ NS t u ⟶ NS s u) ∧
                  (S s t ∧ S t u ⟶ S s u)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss + length ts + length us"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lex</span><span> </span><span class="delimiter">=</span><span> </span><span>lex_ext_compat</span><span class="delimiter">[</span><span>of</span><span> </span><span>ss</span><span> </span><span>ts</span><span> </span><span>us</span><span> </span><span>kbo</span><span> </span><span class="var">?b</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>IH</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lexb</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext kbo ?b"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conv</span><span> </span><span class="delimiter">=</span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lexb ss ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lexb ts us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lexb ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (?lex ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span>u</span><span> </span><span>su</span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS ?s u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s t"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t</span><span> </span><span>wst</span><span> </span><span>fg</span><span> </span><span>fg2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lex ss ts)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexb ss ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexb ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lex ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span>u</span><span> </span><span>su</span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S_left</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S t u"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>wtu</span><span> </span><span>gh2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lex ts us)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexb ts us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex</span><span> </span><span>st</span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexb ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lex ss us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>w</span><span> </span><span>v</span><span> </span><span>u</span><span> </span><span>su</span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S_right</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS</span><span> </span><span>S_left</span><span> </span><span>S_right</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span>weight_w0</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least h"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = Fun h []"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NS_all_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS ?s u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_S_Var</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nS'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ S t u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s t"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>nS'</span><span> </span><span>NS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term_ms (SCF t) ⊆# vars_term_ms (SCF ?s)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>set_mset_vars_term_ms</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ vars_term (SCF ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ vars_term ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vars_term_scf_subset</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>sss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = s # sss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ss</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>kbo_supt_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NS_all_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>Nil</span><span> </span><span>sss</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?s u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss</span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t ⟹ S t u ⟹ S s u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_imp_NS</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>kbo_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t ⟹ NS t u ⟹ NS s u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_S_compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NS s t ⟹ S t u ⟹ S s u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_NS_compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S s t ⟹ NS t u ⟹ S s u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strong Normalization (a.k.a. Well-Foundedness)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kbo_strongly_normalizing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN_on {(s, t). S s t} {s}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SN</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t :: ('f, 'v) term. SN_on {(s, t). S s t} {t}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ (f, ss). weight (Fun f ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ (f, ss). (f, length ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?rel'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_two {(fss, gts). ?m1 fss &gt; ?m1 gts} {(fss, gts). ?m1 fss ≥ ?m1 gts} {(fss, gts). pr_strict (?m2 fss) (?m2 gts)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?rel</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_image ?rel' (λ x. (x, x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SN_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ?rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_inv_image</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>lex_two</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>SN_inv_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pr_SN</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?m2</span><span class="delimiter">]</span><span>  </span><span>SN_inv_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SN_nat_gt</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?m1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_image_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conv</span><span> </span><span class="delimiter">=</span><span> </span><span>SN_on_all_reducts_SN_on_conv</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SN s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_S_Var</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ss ⊆ {s. ?SN s}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ (f, ss). set ss ⊆ {s. ?SN s} ⟶ ?SN (Fun f ss)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>fss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P fss"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>fss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SN_rel</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>fss</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>fss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fss = (f, ss)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>ts</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m1 (f, ss) &gt; ?m1 (g, ts) ∨ ?m1 (f, ss) ≥ ?m1 (g, ts) ∧ pr_strict (?m2 (f, ss)) (?m2 (g, ts))"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set ts ⊆ {s. ?SN s}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SN (Fun g ts)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, ts)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>fss</span><span> </span><span>split</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fss</span><span> </span><span>split</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>SN_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ss ⊆ {s. ?SN s}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, length ss)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SNt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ g ts. ?SN (Fun g ts)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?sym</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ g ts. (g, length ts)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext kbo (weight ?s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lexu</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lex_ext_unbounded kbo"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lex_SN</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(ys, xs). (∀ y ∈ set ys. ?SN y) ∧ fst (?lex ys xs)}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex_ext_SN</span><span class="delimiter">[</span><span>of</span><span> </span><span>kbo</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?s"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>NS_S_compat</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ?lex_SN"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term list"</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f (?sym g ts) ∧ weight (Fun g ts) ≤ weight ?s ∧ set ts ⊆ {s. ?SN s}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SNt g ts"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>g</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SN</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>ts</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inner_IH</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun g ts"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?g"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t ≤ weight ?s"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ts ⊆ {s. ?SN s}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SNt g ts"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?t</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?t, u) ∈ {(s, t). S s t}"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?t u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SN u"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_S_Var</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>h</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?h</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(h, length us)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?u</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun h us"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tu</span><span> </span><span class="delimiter">=</span><span> </span><span>Fun</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ set us"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?u ⊳ u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tu</span><span> </span><span>S_supt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?t u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Fun</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SN u"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SNu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set us ⊆ {s . ?SN s}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?u ≤ weight ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?m1 (f, ss) &gt; ?m1 (h, us) ∨ ?m1 (f, ss) ≥ ?m1 (h, us) ∧ pr_strict (?m2 (f, ss)) (?m2 (h, us))"</span></span></span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wut</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?t = weight ?u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight ?s = weight ?u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>False</span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span> </span><span>wut</span><span class="delimiter">]</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tu</span><span> </span><span class="delimiter">=</span><span> </span><span>tu</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?t</span><span class="delimiter">]</span><span> </span><span>wut</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Fun</span><span> </span><span>term.simps</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?g ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fg</span><span> </span><span>gh</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span>wut</span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict ?f ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fh</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?h ?f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_weak_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hf</span><span> </span><span>fg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?h ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gh2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pr_strict ?g ?h"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pr_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tu</span><span> </span><span>gh2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexu ts us)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fh</span><span> </span><span>wut</span><span> </span><span>SNu</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak ?f ?h ∧ weight ?u ≤ weight ?s ∧ set us ⊆ {s. ?SN s}"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inner_IH</span><span> </span><span class="delimiter">=</span><span> </span><span>inner_IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inner_IH</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>split</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lexu ts us)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lex</span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length us ≤ weight ?s"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length us ≤ sum_list (map weight us)"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>                          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>u</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>                          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (u # us) ≤ Suc (sum_list (map weight us))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ sum_list (map weight (u # us))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_gt_0</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>                            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ sum_list (map weight (scf_list (scf (h, length us)) us))"</span></span></span><span>
</span><span>                          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_scf_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>scf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ weight ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wut</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (?lex ts us)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_ext_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>SN</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">]</span><span> </span><span>SN_s</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SN ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, ss)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_SN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN {(x, y). S x y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kbo_strongly_normalizing</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SN_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ground Totality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_SCF</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground (SCF t) = ground t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length xs. scf (f, length xs) i &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'f</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term list"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>scf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_scf_list</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_vars_term_ms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t ⟹ vars_term_ms t = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f × nat) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pr_weak</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr_weak = pr_strict<span class="hidden">⇧</span><sup>=</sup><span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr_gtotal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f g. f ∈ F ⟹ g ∈ F ⟹ f = g ∨ pr_strict f g ∨ pr_strict g f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>S_ground_total</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"funas_term s ⊆ F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"funas_term t ⊆ F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t ∨ S s t ∨ S t s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ground_vars_term_ms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun f ss"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(vars_term_ms (SCF t) ⊆# vars_term_ms (SCF ?s)) = True"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(vars_term_ms (SCF ?s) ⊆# vars_term_ms (SCF t)) = True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ground ?s›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ground t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>scf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Fun g ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun g ts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f, length ss)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g, length ts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?f ∈ F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?g ∈ F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?case"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>contra</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?s</span><span class="delimiter">]</span><span> </span><span>kbo.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>*</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>t</span><span> </span><span>term.simps</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pr_gtotal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span>contra</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?f = ?g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(s, t)∈set (zip ss ts). s = t ∨ S s t ∨ S t s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_set_zipE</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ss = length ts"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lex_ext_unbounded_total</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH</span><span> </span><span>NS_refl</span><span> </span><span>len</span><span class="delimiter">]</span><span> </span><span>contra</span><span> </span><span>fg</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Summary›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  At this point we have shown well-foundedness @{thm [source] S_SN},
  transitivity and compatibility @{thm [source] S_trans NS_trans NS_S_compat S_NS_compat},
  closure under substitutions @{thm [source] S_subst NS_subst},
  closure under contexts @{thm [source] S_ctxt NS_ctxt},
  the subterm property @{thm [source] S_supt NS_supteq},
  reflexivity of the weak @{thm [source] NS_refl} and irreflexivity of the strict
  part @{thm [source] S_irrefl},
  and ground-totality @{thm [source] S_ground_total}.

  In particular, this allows us to show that KBO is an instance of
  strongly normalizing order pairs (@{locale SN_order_pair}).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>SN_order_pair</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(x, y). S x y}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(x, y). NS x y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>NS_refl</span><span> </span><span>NS_trans</span><span> </span><span>S_trans</span><span> </span><span>S_SN</span><span> </span><span>NS_S_compat</span><span> </span><span>S_NS_compat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refl_on_def</span><span> </span><span>trans_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>