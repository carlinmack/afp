<div id="OpenFlow_Helpers">
<div class="head">
<h1>Theory OpenFlow_Helpers</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Misc›</span></span>
<span class="keyword1"><span class="command">theory</span></span> OpenFlow_Helpers
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hrule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">S</span> <span class="main">=</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Single valuedness on lists›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> foldr_True_set<span class="main">:</span> <span class="quoted"><span class="quoted">"foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(∧)</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> True <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">l</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">single_valued_code</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">single_valued_code</span> <span class="main">[]</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">single_valued_code</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(∧)</span> <span class="main">(</span>fst <span class="bound">x</span> <span class="main">≠</span> fst <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">∨</span> snd <span class="bound">x</span> <span class="main">=</span> snd <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> True <span class="main">∧</span> <span class="free">single_valued_code</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> single_valued_code_lam<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>set <span class="free">r</span><span class="main">)</span> <span class="main">=</span> single_valued_code <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">es</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span> fwd bwd<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> bwd
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.IH conjunct2<span class="main">[</span><span class="operator">OF</span> bwd<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> single_valued_code.simps<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="skolem">es</span><span class="main">.</span> fst <span class="bound">x</span> <span class="main">≠</span> fst <span class="skolem">e</span> <span class="main">∨</span> snd <span class="bound">x</span> <span class="main">=</span> snd <span class="skolem">e</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> conjunct1<span class="main">[</span><span class="operator">OF</span> bwd<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> single_valued_code.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">unfolded</span> foldr_True_set<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> single_valued_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> fwd
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fwd <span class="keyword1"><span class="command">unfolding</span></span> single_valued_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> Cons.IH<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"single_valued_code <span class="skolem">es</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="skolem">es</span><span class="main">.</span> fst <span class="bound">x</span> <span class="main">≠</span> fst <span class="skolem">e</span> <span class="main">∨</span> snd <span class="bound">x</span> <span class="main">=</span> snd <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fwd <span class="keyword1"><span class="command">unfolding</span></span> single_valued_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">from</span></span> conjI<span class="main">[</span><span class="operator">OF</span> this calculation<span class="main">,</span> <span class="operator">unfolded</span> foldr_True_set<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> single_valued_code.simps <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">as</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">e</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∨</span> <span class="free">e</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹List fun›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_const<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> list_all_map<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all <span class="free">f</span> <span class="main">(</span>map <span class="free">g</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> list_all <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_length<span class="main">)</span> <span class="comment1">(* by(induction l) simp_all *)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_2lcomprI<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">as</span> <span class="main">⟹</span> distinct <span class="free">bs</span> <span class="main">⟹</span>
	<span class="main">(</span><span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">e</span> <span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">e</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">=</span> <span class="bound">i</span><span class="main">)</span> <span class="main">⟹</span>
	distinct <span class="main">[</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> a <span class="main">←</span> <span class="free">as</span><span class="main">,</span> b <span class="main">←</span> <span class="free">bs</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> distinct.simps simp_thms list.map concat.simps map_append distinct_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">subst</span> distinct_map<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_3lcomprI<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">as</span> <span class="main">⟹</span> distinct <span class="free">bs</span> <span class="main">⟹</span> distinct <span class="free">cs</span> <span class="main">⟹</span>
	<span class="main">(</span><span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">e</span> <span class="bound">i</span> <span class="bound">g</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span> <span class="bound">i</span> <span class="bound">g</span> <span class="main">⟹</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">e</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">=</span> <span class="bound">i</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">g</span><span class="main">)</span> <span class="main">⟹</span>
	distinct <span class="main">[</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> a <span class="main">←</span> <span class="free">as</span><span class="main">,</span> b <span class="main">←</span> <span class="free">bs</span><span class="main">,</span> c <span class="main">←</span> <span class="free">cs</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> distinct.simps simp_thms list.map concat.simps map_append distinct_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> distinct_2lcomprI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">a</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_zipI1 zip_map_fst_snd<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> distinct_snd<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map snd <span class="free">a</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_zipI2 zip_map_fst_snd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> inter_empty_fst2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">S</span> <span class="main">∩</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">T</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">∩</span> <span class="free">T</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Cardinality and Existence of Distinct Members›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> card1_eI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> card <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">y</span> <span class="bound">S'</span><span class="main">.</span> <span class="free">S</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">}</span> <span class="main">∪</span> <span class="bound">S'</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∉</span> <span class="bound">S'</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def card.infinite card_le_Suc_iff insert_is_Un leD zero_less_Suc<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> card2_eI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">≤</span> card <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1<span class="main">)</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> card <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">note</span></span> card1_eI<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> <span class="skolem">S'</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">S'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> card <span class="skolem">S'</span>"</span></span> 
		<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> 1 Suc_1 card.infinite card_insert_if finite_Un insert_is_Un le0 not_less_eq_eq<span class="main">)</span> 
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">S'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">lemma</span></span> card3_eI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="numeral">3</span> <span class="main">≤</span> card <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">≤</span> card <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">note</span></span> card2_eI<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span> <span class="main">∪</span> <span class="skolem">S'</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">S'</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">S'</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> 
	  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Set.set_insert Un_insert_left insert_eq_iff insert_is_Un<span class="main">)</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> card <span class="skolem">S'</span>"</span></span>
	  <span class="keyword1"><span class="command">using</span></span> 1  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_leI Un_insert_left card_gt_0_iff insert_absorb numeral_3_eq_3 singleton_insert_inj_eq card.infinite card_insert_if finite_Un insert_is_Un le0 not_less_eq_eq<span class="main">)</span> <span class="comment1">(* uuuh *)</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">S'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> card1_eE<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> <span class="main">1</span> <span class="main">≤</span> card <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_0_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">lemma</span></span> card2_eE<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> <span class="numeral">2</span> <span class="main">≤</span> card <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> card1_eE card_Suc_eq card_insert_if <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">lemma</span></span> card3_eE<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> <span class="numeral">3</span> <span class="main">≤</span> card <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> card2_eE card_Suc_eq card_insert_if <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> f_Img_ex_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">f</span> <span class="bound">x</span><span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">f</span> <span class="main">`</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> set_maps<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>List.maps <span class="free">f</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">a</span><span class="main">∈</span>set <span class="free">a</span><span class="main">.</span> set <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">unfolding</span></span> List.maps_def set_concat set_map UN_simps<span class="main">(</span>10<span class="main">)</span> <span class="keyword1"><span class="command">..</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Sort_Descending">
<div class="head">
<h1>Theory Sort_Descending</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Sort_Descending
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹sorting descending›</span></span>
  <span class="keyword1"><span class="command">context</span></span> linorder
  <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">sorted_descending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">sorted_descending</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">sorted_descending</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≥</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">sorted_descending</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">sort_descending_key</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">sort_descending_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> rev <span class="main">(</span>sort_key <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> sorted_descending <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_tail<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">⟷</span> sorted_descending <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_append<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> 
    <span class="main">(</span>sorted_descending <span class="free">xs</span> <span class="main">∧</span> sorted_descending <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">ys</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≥</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> sorted <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_descending_tail<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="free">xs</span> <span class="main">⟷</span> sorted <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sorted_descending<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"rev <span class="free">xs</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> rev_rev_ident <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> sort_descending<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>sort_descending_key <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_descending_key_def sorted_descending<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> sort_descending_key_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span> <span class="main">⟹</span> distinct <span class="main">(</span>sort_descending_key <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_descending_key_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_sort_descending_key<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>sort_descending_key <span class="free">f</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_descending_key_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> sorted_descending <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rev_map sorted_sort_key<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> sorted_descending_split<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="free">f</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> 
  	<span class="main">∃</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="free">l</span> <span class="main">=</span> <span class="bound">m</span> <span class="main">@</span> <span class="bound">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> set <span class="bound">m</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>hd <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> set <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="main">(</span>hd <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  	<span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
  	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
  	<span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> IHm<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="free">f</span> <span class="skolem">as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  	<span class="keyword1"><span class="command">note</span></span> mIH <span class="main">=</span> Cons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  	<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span><span class="main">)</span>
  	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">as</span></span><span class="main">)</span>
  		<span class="keyword3"><span class="command">case</span></span> Nil
  		<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Nil <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  	<span class="keyword1"><span class="command">next</span></span>
  		<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">aa</span> <span class="skolem">ass</span><span class="main">)</span>
  		<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span>
  		<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">aa</span>"</span></span><span class="main">)</span>
  			<span class="keyword3"><span class="command">case</span></span> True
  			<span class="keyword1"><span class="command">from</span></span> mIH <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> mn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">=</span> <span class="skolem">m</span> <span class="main">@</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">m</span><span class="main">.</span> <span class="free">f</span> <span class="skolem">a</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
  				<span class="keyword1"><span class="command">using</span></span> True local.Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  			<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">m</span> <span class="main">@</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> mn<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  			<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">m</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>hd <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> list.sel<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> True mn<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  			<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">m</span> <span class="bound">n</span><span class="main">.</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span> <span class="main">=</span> <span class="bound">m</span> <span class="main">@</span> <span class="bound">n</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="bound">m</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>hd <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">∧</span> 
  				<span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="main">(</span>hd <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> mn<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  		<span class="keyword1"><span class="command">next</span></span>
  			<span class="keyword3"><span class="command">case</span></span> False
  			<span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="main">(</span>map <span class="free">f</span> <span class="skolem">as</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">a</span>"</span></span>
  				<span class="keyword1"><span class="command">unfolding</span></span> list.map<span class="main">(</span>2<span class="main">)</span> 
  				<span class="keyword1"><span class="command">unfolding</span></span> sorted_descending_Cons
  				<span class="keyword1"><span class="command">unfolding</span></span> set_map
  				<span class="keyword1"><span class="command">unfolding</span></span> local.Cons
  				<span class="keyword1"><span class="command">using</span></span> False 
  				<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  			<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">as</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  			<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">as</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>hd <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  			<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  		<span class="keyword1"><span class="command">qed</span></span>
  	<span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> sort_descending_set_inv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>sort_descending_key <span class="free">k</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> set <span class="free">t</span>"</span></span>
  	<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_descending_key_def<span class="main">)</span>
  	
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="List_Group">
<div class="head">
<h1>Theory List_Group</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> List_Group
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Sort_Descending.html">Sort_Descending</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹List Group›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">list_group_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_group_eq</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">list_group_eq</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> takeWhile <span class="main">(</span><span class="main">(=)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">]</span> <span class="main">@</span> <span class="free">list_group_eq</span> <span class="main">(</span>dropWhile <span class="main">(</span><span class="main">(=)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">list_group_eq</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="bound">N</span><span class="main">.</span> length <span class="bound">N</span> <span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_imp_less_Suc length_dropWhile_le<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"list_group_eq <span class="main">[</span><span class="main">1</span><span class="main">::</span>int<span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">5</span><span class="main">]</span>"</span></span>


<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">list_group_eq_key</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_group_eq_key</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">list_group_eq_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> takeWhile <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">]</span> <span class="main">@</span> <span class="free">list_group_eq_key</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>dropWhile <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">list_group_eq_key</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span><span class="main">.</span> length <span class="bound">N</span> <span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_imp_less_Suc length_dropWhile_le<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"list_group_eq_key fst <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>int<span class="main">,</span> <span class="inner_quoted">''''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="inner_quoted">''b''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="inner_quoted">''c''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="inner_quoted">''c''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span><span class="inner_quoted">''''</span><span class="main">)</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"list_group_eq_key id <span class="free">xs</span> <span class="main">=</span> list_group_eq <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_group_eq.induct<span class="main">)</span>
 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> id_def<span class="main">)</span>

<span class="comment1">(*
lemma "sorted (map f (x#xs)) ⟹ list_group_eq_key f (x#xs) = [x # filter (λy. f x = f y) xs] @ list_group_eq_key f (filter (λy. f x ≠ f y) xs)"
  apply(simp)
  oops
lemma "sorted (x#xs) ⟹ distinct (list_group_eq_key f (x#xs)) ⟹ distinct (list_group_eq_key f xs)"
  apply(induction xs)
   apply(simp)
oops
*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OpenFlow_Matches">
<div class="head">
<h1>Theory OpenFlow_Matches</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> OpenFlow_Matches
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../IP_Addresses/Prefix_Match.html">IP_Addresses.Prefix_Match</a>
        <a href="../Simple_Firewall/Simple_Packet.html">Simple_Firewall.Simple_Packet</a>
        <span class="quoted">"<a href="../../HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
        <span class="comment1">(*"../Iptables_Semantics/Primitive_Matchers/Simple_Packet" (* I just want those TCP,UDP,… defs *)*)</span>
        <span class="quoted">"<a href="../../HOL/HOL-Library/List_Lexorder.html">HOL-Library.List_Lexorder</a>"</span>
        <span class="quoted">"<a href="../../HOL/HOL-Library/Char_ord.html">HOL-Library.Char_ord</a>"</span> <span class="comment1">(* For a linorder on strings. See below. *)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* From OpenFlow 1.1, Table 3: *)</span>
<span class="keyword1"><span class="command">datatype</span></span> of_match_field <span class="main">=</span> 
	  IngressPort <span class="quoted">string</span>
	<span class="main">|</span> EtherSrc <span class="quoted"><span class="quoted">"<span class="numeral">48</span> word"</span></span>
	<span class="main">|</span> EtherDst <span class="quoted"><span class="quoted">"<span class="numeral">48</span> word"</span></span>
	<span class="main">|</span> EtherType <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
	<span class="main">|</span> VlanId <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
	<span class="main">|</span> VlanPriority <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
<span class="comment1">(*	| MplsLabel
	| MplsClass *)</span>
	<span class="main">|</span> IPv4Src <span class="quoted"><span class="quoted">"<span class="numeral">32</span> prefix_match"</span></span> <span class="comment1">(* could also be arbitrary bitmask - see page 80 of 1.5.1 *)</span>
	<span class="main">|</span> IPv4Dst <span class="quoted"><span class="quoted">"<span class="numeral">32</span> prefix_match"</span></span> <span class="comment1">(* ditto *)</span>
	<span class="main">|</span> IPv4Proto <span class="quoted"><span class="quoted">"<span class="numeral">8</span> word"</span></span>
<span class="comment1">(*	| IPv4ToS "16 word" *)</span>
	<span class="main">|</span> L4Src <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span> <span class="comment1">(* openvswitch 1.6 supports bitmasks - does not seem to be in of 1.5.1, but I need it. *)</span>
	<span class="main">|</span> L4Dst <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>

<span class="comment1">(* I just do not want this proof in the documentation theory *)</span>
<span class="keyword1"><span class="command">schematic_goal</span></span> of_match_field_typeset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">field_match</span> <span class="main">::</span> of_match_field<span class="main">)</span> <span class="main">∈</span> <span class="main">{</span>
  IngressPort <span class="main">(</span><span class="var">?s</span><span class="main">::</span>string<span class="main">)</span><span class="main">,</span>
  EtherSrc <span class="main">(</span><span class="var">?as</span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span><span class="main">,</span> EtherDst <span class="main">(</span><span class="var">?ad</span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span><span class="main">,</span>
	EtherType <span class="main">(</span><span class="var">?t</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	VlanId <span class="main">(</span><span class="var">?i</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span> VlanPriority <span class="main">(</span><span class="var">?p</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	IPv4Src <span class="main">(</span><span class="var">?pms</span><span class="main">::</span><span class="numeral">32</span> prefix_match<span class="main">)</span><span class="main">,</span> 
	IPv4Dst <span class="main">(</span><span class="var">?pmd</span><span class="main">::</span><span class="numeral">32</span> prefix_match<span class="main">)</span><span class="main">,</span>
	IPv4Proto <span class="main">(</span><span class="var">?ipp</span> <span class="main">::</span> <span class="numeral">8</span> word<span class="main">)</span><span class="main">,</span>
	L4Src <span class="main">(</span><span class="var">?ps</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">(</span><span class="var">?ms</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	L4Dst <span class="main">(</span><span class="var">?pd</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">(</span><span class="var">?md</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">field_match</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">clarsimp</span><span class="main">)</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IngressPort <span class="skolem">s</span><span class="main">)</span>  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> IngressPort <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> IngressPort of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EtherSrc <span class="skolem">s</span><span class="main">)</span>     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> EtherSrc <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>     <span class="keyword1"><span class="command">unfolding</span></span> EtherSrc of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EtherDst <span class="skolem">s</span><span class="main">)</span>     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> EtherDst <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>     <span class="keyword1"><span class="command">unfolding</span></span> EtherDst of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>EtherType <span class="skolem">s</span><span class="main">)</span>    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> EtherType <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>    <span class="keyword1"><span class="command">unfolding</span></span> EtherType of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>VlanId <span class="skolem">s</span><span class="main">)</span>       <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> VlanId <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>       <span class="keyword1"><span class="command">unfolding</span></span> VlanId of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>VlanPriority <span class="skolem">s</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> VlanPriority <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> VlanPriority of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IPv4Src <span class="skolem">s</span><span class="main">)</span>      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> IPv4Src <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>      <span class="keyword1"><span class="command">unfolding</span></span> IPv4Src of_match_field.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IPv4Dst <span class="skolem">s</span><span class="main">)</span>      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> IPv4Dst <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IPv4Proto <span class="skolem">s</span><span class="main">)</span>    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> IPv4Proto <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">)</span>"</span></span>    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>L4Src <span class="skolem">p</span> <span class="skolem">l</span><span class="main">)</span>      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> L4Src <span class="bound">p</span> <span class="bound">m</span> <span class="main">⇒</span> <span class="bound">p</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> L4Src <span class="bound">p</span> <span class="bound">m</span> <span class="main">⇒</span> <span class="bound">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>L4Dst <span class="skolem">p</span> <span class="skolem">l</span><span class="main">)</span>      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> L4Dst <span class="bound">p</span> <span class="bound">m</span> <span class="main">⇒</span> <span class="bound">p</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">field_match</span> <span class="keyword1">of</span> L4Dst <span class="bound">p</span> <span class="bound">m</span> <span class="main">⇒</span> <span class="bound">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*

The semantics of an openflow match is by no means trivial. See Specification 7.2.3.6, v1.5.1
For example:
▪ An OXM TLV for oxm_type=OXM OF IPV4 SRC is allowed only if it is preceded by another en-
try with oxm_type=OXM_OF_ETH_TYPE, oxm_hasmask=0, and oxm_value=0x0800. That is, match-
ing on the IPv4 source address is allowed only if the Ethernet type is explicitly set to IPv4.
…
Even if OpenFlow 1.0 does not require this behavior, some switches may still silently drop matches without prerequsites.

*)</span>

<span class="comment1">(* subtable of table in 7.2.3.8 of spec1.5 (also present in 1.3, and less cluttered) for the matches we implement *)</span> 
<span class="keyword1"><span class="command">function</span></span> <span class="entity">prerequisites</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field <span class="main">⇒</span> of_match_field set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>IngressPort <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_ETH_DST None *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>EtherDst <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_ETH_SRC None *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>EtherSrc <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_ETH_TYPE None *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>EtherType <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_VLAN_VID None *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>VlanId <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_VLAN_PCP VLAN_VID!=NONE *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>VlanPriority <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">id</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> VlanId <span class="bound">id</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="free">prerequisites</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_IPV4_PROTO ETH_TYPE=0x0800 or ETH_TYPE=0x86dd *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>IPv4Proto <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="free">prerequisites</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="comment1">(* IPv6 nah *)</span> <span class="main">|</span>
<span class="comment1">(* OF_IPV4_SRC ETH_TYPE=0x0800 *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>IPv4Src <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="free">prerequisites</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="comment1">(* OF_IPV4_DST ETH_TYPE=0x0800 *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>IPv4Dst <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="free">prerequisites</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="comment1">(* Now here goes a bit of fuzz: OF specifies differen OXM_OF_(TCP,UDP,L4_Protocol.SCTP,…)_(SRC,DST). I only have L4Src. So gotta make do with that. *)</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>L4Src <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">proto</span> <span class="main">∈</span> <span class="main">{</span>TCP<span class="main">,</span>UDP<span class="main">,</span>L4_Protocol.SCTP<span class="main">}</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> IPv4Proto <span class="bound">proto</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∧</span> <span class="free">prerequisites</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">prerequisites</span> <span class="main">(</span>L4Dst <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free">prerequisites</span> <span class="main">(</span>L4Src undefined undefined<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="comment1">(* Ignoredd PACKET_TYPE=foo *)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">match_sorter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>IngressPort <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>VlanId <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>VlanPriority <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">3</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>EtherType <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>EtherSrc <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">5</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>EtherDst <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">6</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>IPv4Proto <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">7</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>IPv4Src <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">8</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>IPv4Dst <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">9</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>L4Src <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">10</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_sorter</span> <span class="main">(</span>L4Dst <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">11</span>"</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">prerequisites</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>match_sorter <span class="main">∘</span> fst<span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">less_eq_of_match_field1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field <span class="main">⇒</span> of_match_field <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_of_match_field1</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
		<span class="main">(</span>IngressPort <span class="bound">a</span><span class="main">,</span> IngressPort <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>VlanId <span class="bound">a</span><span class="main">,</span> VlanId <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>EtherDst <span class="bound">a</span><span class="main">,</span> EtherDst <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>EtherSrc <span class="bound">a</span><span class="main">,</span> EtherSrc <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>EtherType <span class="bound">a</span><span class="main">,</span> EtherType <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>VlanPriority <span class="bound">a</span><span class="main">,</span> VlanPriority <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>IPv4Proto <span class="bound">a</span><span class="main">,</span> IPv4Proto <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>IPv4Src <span class="bound">a</span><span class="main">,</span> IPv4Src <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>IPv4Dst <span class="bound">a</span><span class="main">,</span> IPv4Dst <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">|</span>
		<span class="main">(</span>L4Src <span class="bound">a1</span> <span class="bound">a2</span><span class="main">,</span> L4Src <span class="bound">b1</span> <span class="bound">b2</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">a2</span> <span class="main">=</span> <span class="bound">b2</span> <span class="keyword1">then</span> <span class="bound">a1</span> <span class="main">≤</span> <span class="bound">b1</span> <span class="keyword1">else</span> <span class="bound">a2</span> <span class="main">≤</span> <span class="bound">b2</span> <span class="main">|</span>
		<span class="main">(</span>L4Dst <span class="bound">a1</span> <span class="bound">a2</span><span class="main">,</span> L4Dst <span class="bound">b1</span> <span class="bound">b2</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">a2</span> <span class="main">=</span> <span class="bound">b2</span> <span class="keyword1">then</span> <span class="bound">a1</span> <span class="main">≤</span> <span class="bound">b1</span> <span class="keyword1">else</span> <span class="bound">a2</span> <span class="main">≤</span> <span class="bound">b2</span> <span class="main">|</span>
		<span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> match_sorter <span class="bound">a</span> <span class="main">&lt;</span> match_sorter <span class="bound">b</span><span class="main">)</span>"</span></span>

<span class="comment1">(* feel free to move this to OpenFlowSerialize if it gets in the way. *)</span>
<span class="keyword1"><span class="command">instantiation</span></span> of_match_field <span class="main">::</span> <span class="quoted">linorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_eq_of_match_field</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">⟷</span> less_eq_of_match_field1 <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>	

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">less_of_match_field</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">::</span>of_match_field<span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">∧</span> less_eq_of_match_field1 <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_of_match_field_def less_of_match_field_def less_eq_of_match_field1_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits of_match_field.splits if_splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">match_no_prereq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field <span class="main">⇒</span> <span class="main">(</span><span class="numeral">32</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>IngressPort <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_iiface <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>EtherDst <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_l2src <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>EtherSrc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_l2dst <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>EtherType <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_l2type <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>VlanId <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_vlanid <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span> <span class="comment1">(* hack, otherwise it would be iso/osi *)</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>VlanPriority <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_vlanprio <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>IPv4Proto <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_proto <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>IPv4Src <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>prefix_match_semantics <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span>p_src <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>IPv4Dst <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>prefix_match_semantics <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span>p_dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>L4Src <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_sport <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&amp;&amp;</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">match_no_prereq</span> <span class="main">(</span>L4Dst <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>p_dport <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&amp;&amp;</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">match_prereq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field <span class="main">⇒</span> of_match_field set <span class="main">⇒</span> <span class="main">(</span><span class="numeral">32</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme <span class="main">⇒</span> bool option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">match_prereq</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> prerequisites <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span>match_no_prereq <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">set_seq</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> None<span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span>the <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_true</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">.</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">map_option</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">OF_match_fields</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field set <span class="main">⇒</span> <span class="main">(</span><span class="numeral">32</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme <span class="main">⇒</span> bool option"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">OF_match_fields</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> map_option all_true <span class="main">(</span>set_seq <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> match_prereq <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">OF_match_fields_unsafe</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"of_match_field set <span class="main">⇒</span> <span class="main">(</span><span class="numeral">32</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">OF_match_fields_unsafe</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">.</span> match_no_prereq <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">OF_match_fields_safe</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> the <span class="main">∘</span> OF_match_fields <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_prerequisites</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">.</span> prerequisites <span class="bound">f</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="comment1">(* as stated in paper *)</span>
	<span class="quoted"><span class="quoted">"all_prerequisites <span class="free">p</span> <span class="main">⟹</span>
	 L4Src <span class="free">x</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">⟹</span>
	 IPv4Proto <span class="main">`</span> <span class="main">{</span>TCP<span class="main">,</span> UDP<span class="main">,</span> L4_Protocol.SCTP<span class="main">}</span> <span class="main">∩</span> <span class="free">p</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> all_prerequisites_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> of_safe_unsafe_match_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"all_prerequisites <span class="free">m</span> <span class="main">⟹</span> OF_match_fields <span class="free">m</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span>OF_match_fields_unsafe <span class="free">m</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_match_fields_def OF_match_fields_unsafe_def comp_def set_seq_def match_prereq_def all_prerequisites_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
	<span class="keyword3"><span class="command">case</span></span> 1
	<span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="keyword1">if</span> prerequisites <span class="bound">f</span> <span class="free">m</span> <span class="keyword1">then</span> Some <span class="main">(</span>match_no_prereq <span class="bound">f</span> <span class="free">p</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span> <span class="main">`</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> Some <span class="main">(</span>match_no_prereq <span class="bound">f</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">m</span>"</span></span>
		<span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
	<span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> Some <span class="main">(</span>match_no_prereq <span class="bound">f</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">m</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
		<span class="keyword1"><span class="command">unfolding</span></span> 2 <span class="keyword1"><span class="command">unfolding</span></span> eqTrueI<span class="main">[</span><span class="operator">OF</span> 3<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> if_True <span class="keyword1"><span class="command">unfolding</span></span> image_comp comp_def <span class="keyword1"><span class="command">unfolding</span></span> option.sel <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_true_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> of_match_fields_safe_eq<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"all_prerequisites <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_match_fields_safe <span class="free">m</span> <span class="main">=</span> OF_match_fields_unsafe <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_match_fields_safe_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> fun_eq_iff comp_def <span class="keyword1"><span class="command">unfolding</span></span> of_safe_unsafe_match_eq<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> option.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarify</span> 

<span class="keyword1"><span class="command">lemma</span></span> OF_match_fields_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_fields <span class="free">m</span> <span class="free">p</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∃</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">m</span><span class="main">.</span> <span class="main">¬</span>prerequisites <span class="bound">f</span> <span class="free">m</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> 
    <span class="keyword1">if</span> <span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">m</span><span class="main">.</span> match_no_prereq <span class="bound">f</span> <span class="free">p</span> <span class="keyword1">then</span> Some True <span class="keyword1">else</span> Some False<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> OF_match_fields_def all_true_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> set_seq_def match_prereq_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ball_Un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> of_match_fields_safe_eq2<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"all_prerequisites <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_match_fields_safe <span class="free">m</span> <span class="free">p</span> <span class="main">⟷</span> OF_match_fields <span class="free">m</span> <span class="free">p</span> <span class="main">=</span> Some True"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_match_fields_safe_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> fun_eq_iff comp_def <span class="keyword1"><span class="command">unfolding</span></span> of_safe_unsafe_match_eq<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> option.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OpenFlow_Action">
<div class="head">
<h1>Theory OpenFlow_Action</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> OpenFlow_Action
<span class="keyword2"><span class="keyword">imports</span></span>
	<a href="OpenFlow_Matches.html">OpenFlow_Matches</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Beware the differences between Actions and Instructions. OF1.0 doesn't support the former and they're thus not modelled here. *)</span>

<span class="comment1">(* OF1.0 says actions are a list and executed in-order, OF1.5 has two things: an action set with fixed order in 5.6 and an action list.
So… list. *)</span>

<span class="comment1">(* Just those which we need(ed). *)</span>
<span class="keyword1"><span class="command">datatype</span></span> of_action <span class="main">=</span> Forward <span class="main">(</span><span class="free"><span class="entity">oiface_sel</span></span><span class="main">:</span> <span class="quoted">string</span><span class="main">)</span> <span class="main">|</span> ModifyField_l2dst <span class="quoted"><span class="quoted">"<span class="numeral">48</span> word"</span></span>
<span class="comment1">(* Note that the 1.0 is not entirely clear that there's no drop action. 1.5 clarifies that this is represented by and empty instruction/action set. *)</span>

<span class="comment1">(* So each flow entry has a list of these. Semantics… The actions are executed in order, but the order of the side-effects is not defined. *)</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">of_action_semantics</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">of_action_semantics</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">of_action_semantics</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span>
	Forward <span class="bound">i</span> <span class="main">⇒</span> insert <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">of_action_semantics</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">|</span>
	ModifyField_l2dst <span class="bound">a</span> <span class="main">⇒</span> <span class="free">of_action_semantics</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">a</span><span class="main">⦈</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"of_action_semantics <span class="free">p</span> <span class="main">[]</span>"</span></span> <span class="comment1">(* Drop *)</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"of_action_semantics <span class="free">p</span> <span class="main">[</span>ModifyField_l2dst <span class="numeral">66</span><span class="main">,</span> Forward <span class="inner_quoted">''oif''</span><span class="main">]</span>"</span></span> <span class="comment1">(* set mac and send *)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Semantics_OpenFlow">
<div class="head">
<h1>Theory Semantics_OpenFlow</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Semantics_OpenFlow
<span class="keyword2"><span class="keyword">imports</span></span> <a href="List_Group.html">List_Group</a> <a href="Sort_Descending.html">Sort_Descending</a>
  <a href="../IP_Addresses/IPv4.html">IP_Addresses.IPv4</a>
  <a href="OpenFlow_Helpers.html">OpenFlow_Helpers</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> flowtable_behavior <span class="main">=</span> Action <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> NoAction <span class="main">|</span> Undefined

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">option_to_ftb</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">of</span> Some <span class="bound">a</span> <span class="main">⇒</span> Action <span class="bound">a</span> <span class="main">|</span> None <span class="main">⇒</span> NoAction"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ftb_to_option</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">of</span> Action <span class="bound">a</span> <span class="main">⇒</span> Some <span class="bound">a</span> <span class="main">|</span> NoAction <span class="main">⇒</span> None"</span></span>

<span class="comment1">(*section‹OpenFlow›*)</span>

<span class="comment1">(*https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-switch-v1.5.0.pdf*)</span>

<span class="comment1">(*"OpenFlow packets are received on an ingress port [...]. The packet ingress port is a property of the packet
throughout the OpenFlow pipeline and represents the OpenFlow port on which the packet was received
into the OpenFlow switch."
*)</span>

<span class="comment1">(* "Packet forwarded to non-existent ports are just dropped"*)</span>

<span class="comment1">(*we do not support egress tables (those are optional in the standard).
  we only support flow table 0 (ingress table).
  Essentially, this means, we only support one flow table and no pipelining.
  This corresponds to OpenFlow 1.0.0
*)</span>

<span class="comment1">(*priority × Match Fields × instructions
 not modeled: counters, timeouts, cookie ("Not used when processing packets"), flags,
     instructions (only an output list of egress ports will be modeled)
*)</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flow_entry_match <span class="main">=</span> OFEntry <span class="main">(</span><span class="free"><span class="entity">ofe_prio</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">ofe_fields</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> set"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">ofe_action</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span>

<span class="comment1">(* why is there curry *)</span>
<span class="keyword1"><span class="command">find_consts</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>
<span class="comment1">(* but no "uncurry" *)</span>
<span class="keyword1"><span class="command">find_consts</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>
<span class="comment1">(* Anyway, we want this to easily construct OFEntrys from tuples *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">split3</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span>"</span></span>
<span class="keyword1"><span class="command">find_consts</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'d</span>"</span></span>

<span class="comment1">(*
"If there are multiple matching flow entries with the same highest priority, the selected flow entry is explicitly undefined."
OFP 1.0.0 also stated that non-wildcarded matches implicitly have the highest priority (which is gone in 1.5).
*)</span>
<span class="comment1">(*Defined None ⟷ No match
  Defined (Some a) ⟷ Match and instruction is a
  Undefined ⟷ Undefined*)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flowtable <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flow_entry_match<span class="main">)</span> list"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'p</span><span class="main">)</span> field_matcher <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> set <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">OF_same_priority_match2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'p</span><span class="main">)</span> field_matcher <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flowtable <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'a</span> flowtable_behavior"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">OF_same_priority_match2</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> 
  	<span class="main">{</span>ofe_action <span class="bound">f</span><span class="main">|</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span> <span class="main">∧</span> 
  	  <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">&gt;</span> ofe_prio <span class="bound">f</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span><span class="main">)</span><span class="main">}</span> <span class="keyword1">in</span>
  	<span class="keyword1">case</span> card <span class="bound">s</span> <span class="keyword1">of</span> <span class="main">0</span>       <span class="main">⇒</span> NoAction
                 <span class="main">|</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">⇒</span> Action <span class="main">(</span>the_elem <span class="bound">s</span><span class="main">)</span> 
                 <span class="main">|</span> <span class="main"><span class="bound">_</span></span>       <span class="main">⇒</span> Undefined"</span></span>

<span class="comment1">(* are there any overlaping rules? *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">check_no_overlap</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">ft</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ft</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ft</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span> <span class="main">∈</span> UNIV<span class="main">.</span> <span class="main">(</span>ofe_prio <span class="bound">a</span> <span class="main">=</span> ofe_prio <span class="bound">b</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">a</span><span class="main">)</span> <span class="bound">p</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">check_no_overlap2</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">ft</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ft</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ft</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span> <span class="main">∧</span> ofe_prio <span class="bound">a</span> <span class="main">=</span> ofe_prio <span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span> <span class="main">∈</span> UNIV<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">a</span><span class="main">)</span> <span class="bound">p</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> check_no_overlap_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">ft</span> <span class="main">=</span> check_no_overlap2 <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap2_def check_no_overlap_def
	<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* If there are no overlapping rules, our match should check out. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> no_overlap_not_unefined<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">ft</span> <span class="main">⟹</span> OF_same_priority_match2 <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> goal1<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"OF_same_priority_match2 <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> Undefined"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?as</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free">ft</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span>
	<span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="var">?as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">note</span></span> goal1<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> OF_same_priority_match2_def<span class="main">]</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">≤</span> card <span class="main">(</span>ofe_action <span class="main">`</span> <span class="var">?as</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f_Img_ex_set
		<span class="keyword1"><span class="command">unfolding</span></span> Let_def
		<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>ofe_action <span class="main">`</span> <span class="var">?as</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">rename_tac</span> nat1<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">nat1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_Collect<span class="main"><span class="keyword3">,</span></span> <span class="operator">presburger</span><span class="main">)</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">≤</span> card <span class="var">?as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_image_le<span class="main">[</span><span class="operator">OF</span> fin<span class="main">,</span> <span class="operator">of</span> <span class="quoted">ofe_action</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="var">?as</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?as</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card2_eI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> ab2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">a</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">a</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
	               <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">b</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">b</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ofe_prio <span class="skolem">a</span> <span class="main">=</span> ofe_prio <span class="skolem">b</span>"</span></span>
		<span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
	<span class="keyword1"><span class="command">note</span></span> goal1<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> check_no_overlap_def<span class="main">]</span> ab2<span class="main">(</span>1<span class="main">)</span> ab2<span class="main">(</span>4<span class="main">)</span> this ab2<span class="main">(</span>2<span class="main">)</span> ab<span class="main">(</span>1<span class="main">)</span> ab2<span class="main">(</span>5<span class="main">)</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">OF_match_linear</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'p</span><span class="main">)</span> field_matcher <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flowtable <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'a</span> flowtable_behavior"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">OF_match_linear</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> NoAction"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">OF_match_linear</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">then</span> Action <span class="main">(</span>ofe_action <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">OF_match_linear</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> OF_match_linear_ne_Undefined<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ft</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> OF_match_linear_append<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="main">(</span><span class="free">a</span> <span class="main">@</span> <span class="free">b</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> OF_match_linear <span class="free">γ</span> <span class="free">a</span> <span class="free">p</span> <span class="keyword1">of</span> NoAction <span class="main">⇒</span> OF_match_linear <span class="free">γ</span> <span class="free">b</span> <span class="free">p</span> <span class="main">|</span> <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">lemma</span></span> OF_match_linear_match_allsameaction<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">gr</span> <span class="main">∈</span> set <span class="free">oms</span><span class="main">;</span> <span class="free">γ</span> <span class="free">gr</span> <span class="free">p</span> <span class="main">=</span> True<span class="main">⟧</span>
       <span class="main">⟹</span> OF_match_linear <span class="free">γ</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> split3 OFEntry <span class="main">(</span><span class="free">pri</span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="free">act</span><span class="main">)</span><span class="main">)</span> <span class="free">oms</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">act</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">oms</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split3_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> OF_lm_noa_none_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> NoAction <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">e</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ft</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_eq_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">a</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">b</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subsetI subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unmatching_insert_agnostic<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">a</span><span class="main">)</span> <span class="free">p</span> <span class="main">⟹</span> OF_same_priority_match2 <span class="free">γ</span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> OF_same_priority_match2 <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?as</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free">ft</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?aas</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span> <span class="main">|</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span>
	<span class="keyword3"><span class="command">assume</span></span> nm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">a</span><span class="main">)</span> <span class="free">p</span>"</span></span> 
	<span class="keyword1"><span class="command">have</span></span> aa<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?aas</span> <span class="main">=</span> <span class="var">?as</span>"</span></span>
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_eq_rule<span class="main">)</span>
	  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
		<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">f</span> <span class="main">|</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span>
		<span class="keyword1"><span class="command">hence</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">x</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">with</span></span> nm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
		<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> as <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">f</span></span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> as <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
	<span class="keyword1"><span class="command">next</span></span>
	  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
		<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">f</span></span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span>
		<span class="keyword1"><span class="command">hence</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">x</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
		<span class="keyword1"><span class="command">from</span></span> as<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> as<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">f</span> <span class="main">|</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> as<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">qed</span></span>
	<span class="keyword1"><span class="command">note</span></span> uf <span class="main">=</span> arg_cong<span class="main">[</span><span class="operator">OF</span> aa<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> ofe_action"</span></span><span class="main">,</span> <span class="operator">unfolded</span> image_Collect<span class="main">]</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> OF_same_priority_match2_def <span class="keyword1"><span class="command">using</span></span> uf <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> OF_match_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map ofe_prio <span class="free">ft</span><span class="main">)</span> <span class="main">⟹</span> check_no_overlap <span class="free">γ</span> <span class="free">ft</span> <span class="main">⟹</span> 
	OF_same_priority_match2 <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> OF_match_linear <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"<span class="free">ft</span>"</span></span><span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">ft</span><span class="main">)</span>
	<span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map ofe_prio <span class="skolem">ft</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="skolem">ft</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_def <span class="keyword1"><span class="command">using</span></span> set_subset_Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
	<span class="keyword1"><span class="command">note</span></span> mIH <span class="main">=</span> Cons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> 1 2<span class="main">]</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span><span class="main">)</span>
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">a</span><span class="main">)</span> <span class="free">p</span>"</span></span><span class="main">)</span>
		<span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span>
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> OF_match_linear.simps if_False mIH<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> unmatching_insert_agnostic<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">γ</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> False<span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword1"><span class="command">note</span></span> sorted_descending_split<span class="main">[</span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
		<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> mn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">ft</span> <span class="main">=</span> <span class="skolem">m</span> <span class="main">@</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">m</span><span class="main">.</span> ofe_prio <span class="skolem">a</span> <span class="main">=</span> ofe_prio <span class="bound">e</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">n</span><span class="main">.</span> ofe_prio <span class="bound">e</span> <span class="main">&lt;</span> ofe_prio <span class="skolem">a</span>"</span></span>
			<span class="keyword1"><span class="command">unfolding</span></span> list.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
		<span class="keyword1"><span class="command">hence</span></span> aem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="skolem">m</span>"</span></span>
			<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnE less_imp_neq list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> set_append<span class="main">)</span>
		<span class="keyword1"><span class="command">have</span></span> mover<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_def
			<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff mn<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> set_append<span class="main">)</span>
		<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?fc</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> 
			<span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="bound">s</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> 
			<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
		<span class="keyword3"><span class="command">case</span></span> True
		<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fc</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">@</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="var">?fc</span> <span class="skolem">m</span> <span class="main">∪</span> <span class="var">?fc</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
		<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fc</span> <span class="skolem">n</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
		<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_eq_rule<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
			<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
			<span class="keyword1"><span class="command">hence</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">x</span><span class="main">)</span> <span class="free">p</span>"</span></span> 
				<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="skolem">m</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
				<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="skolem">n</span><span class="main">.</span> ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
				<span class="keyword1"><span class="command">unfolding</span></span> mn<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
			<span class="keyword1"><span class="command">from</span></span> g1<span class="main">(</span>1<span class="main">)</span> mn<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> le<span class="main">:</span> <span class="quoted"><span class="quoted">"ofe_prio <span class="skolem">x</span> <span class="main">&lt;</span> ofe_prio <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
			<span class="keyword1"><span class="command">note</span></span> le g1<span class="main">(</span>3<span class="main">)</span> aem True
			<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
		<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> cc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?fc</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">@</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="var">?fc</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
		<span class="keyword1"><span class="command">have</span></span> cm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?fc</span> <span class="skolem">m</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span>"</span></span> <span class="comment1">(* using Cons(3) *)</span>
		<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
			<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> set <span class="skolem">m</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
				<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnE less_asym mn set_append<span class="main">)</span>
			<span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?fc</span> <span class="skolem">m</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">f</span></span> <span class="main">∈</span> set <span class="skolem">m</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
			<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">f</span></span> <span class="main">∈</span> set <span class="skolem">m</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">ft</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">f</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fo</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> "</span></span> <span class="keyword1"><span class="command">unfolding</span></span> 1
			<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> set_eq_rule<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span> fwd bwd<span class="main">)</span>
				<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>bwd <span class="skolem">x</span><span class="main">)</span>
				<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">f</span></span> <span class="main">∈</span> set <span class="skolem">m</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True aem <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
				<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> bwd <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
			<span class="keyword1"><span class="command">next</span></span>
				<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>fwd <span class="skolem">x</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
					<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
					<span class="keyword1"><span class="command">from</span></span> fwd <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">x</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
					<span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"ofe_prio <span class="skolem">x</span> <span class="main">=</span> ofe_prio <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>1<span class="main">)</span> mn<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
					<span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> 1 ne mover aem True 2 <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
				<span class="keyword1"><span class="command">qed</span></span>
			<span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?kees</span></span></span>
			<span class="keyword1"><span class="command">unfolding</span></span> mn<span class="main">(</span>1<span class="main">)</span>
			<span class="keyword1"><span class="command">unfolding</span></span> OF_same_priority_match2_def
			<span class="keyword1"><span class="command">unfolding</span></span> f_Img_ex_set
			<span class="keyword1"><span class="command">unfolding</span></span> cc<span class="main">[</span><span class="operator">unfolded</span> mn<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
			<span class="keyword1"><span class="command">unfolding</span></span> cm<span class="main">[</span><span class="operator">unfolded</span> mn<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
			<span class="keyword1"><span class="command">unfolding</span></span> Let_def
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mn<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> OF_match_linear.simps True if_True<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
		<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OF_same_priority_match2_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> overlap_sort_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="main">(</span>sort_descending_key <span class="free">k</span> <span class="free">ft</span><span class="main">)</span> <span class="main">=</span> check_no_overlap <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_def
	<span class="keyword1"><span class="command">unfolding</span></span> sort_descending_set_inv
	<span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> OF_match_eq2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">ft</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_same_priority_match2 <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> OF_match_linear <span class="free">γ</span> <span class="main">(</span>sort_descending_key ofe_prio <span class="free">ft</span><span class="main">)</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map ofe_prio <span class="main">(</span>sort_descending_key ofe_prio <span class="free">ft</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_descending_sort_descending_key<span class="main">)</span>
	<span class="keyword1"><span class="command">note</span></span> ceq <span class="main">=</span> OF_match_eq<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">unfolded</span> overlap_sort_invar<span class="main">,</span> <span class="operator">OF</span> <span class="quoted"><span class="quoted">‹check_no_overlap <span class="free">γ</span> <span class="free">ft</span>›</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
		<span class="keyword1"><span class="command">unfolding</span></span> ceq
		<span class="keyword1"><span class="command">unfolding</span></span> OF_same_priority_match2_def
		<span class="keyword1"><span class="command">unfolding</span></span> sort_descending_set_inv
		<span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* Just me, thinking about some alternate ways of writing this down. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> prio_match_matcher_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free">flow_entries</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">packet</span> <span class="main">∧</span> 
  	  <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="free">flow_entries</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">&gt;</span> ofe_prio <span class="bound">f</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fo</span><span class="main">)</span> <span class="free">packet</span><span class="main">)</span><span class="main">}</span>
  	  <span class="main">=</span> <span class="main">(</span>
  	  <span class="keyword1">let</span> <span class="bound">matching</span> <span class="main">=</span> <span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free">flow_entries</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">packet</span><span class="main">}</span> 
  	  <span class="keyword1">in</span> <span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> <span class="bound">matching</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> <span class="bound">matching</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span><span class="main">}</span>
  	  <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> prio_match_matcher_alt2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>
  	  <span class="keyword1">let</span> <span class="bound">matching</span> <span class="main">=</span> <span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> set <span class="free">flow_entries</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">packet</span><span class="main">}</span> 
  	  <span class="keyword1">in</span> <span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> <span class="bound">matching</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> <span class="bound">matching</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span><span class="main">}</span>
  	  <span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>
  	  <span class="keyword1">let</span> <span class="bound">matching</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">packet</span><span class="main">)</span> <span class="free">flow_entries</span>
  	  <span class="keyword1">in</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="bound">matching</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span> <span class="bound">matching</span>
  	  <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">OF_priority_match</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">OF_priority_match</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">let</span> <span class="bound">m</span>  <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span><span class="main">;</span>
  	  <span class="bound">m'</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="bound">m</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">in</span>
  	<span class="keyword1">case</span> <span class="bound">m'</span> <span class="keyword1">of</span> <span class="main">[]</span>  <span class="main">⇒</span> NoAction
             <span class="main">|</span> <span class="main">[</span><span class="bound">s</span><span class="main">]</span> <span class="main">⇒</span> Action <span class="main">(</span>ofe_action <span class="bound">s</span><span class="main">)</span>
             <span class="main">|</span>  <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> Undefined"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">OF_priority_match_ana</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">OF_priority_match_ana</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">let</span> <span class="bound">m</span>  <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">packet</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">flow_entries</span></span></span><span class="main">;</span>
  	  <span class="bound">m'</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="bound">m</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">in</span>
  	<span class="keyword1">case</span> <span class="bound">m'</span> <span class="keyword1">of</span> <span class="main">[]</span>  <span class="main">⇒</span> NoAction
             <span class="main">|</span> <span class="main">[</span><span class="bound">s</span><span class="main">]</span> <span class="main">⇒</span> Action <span class="bound">s</span>
             <span class="main">|</span>  <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> Undefined"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="bound">x</span><span class="main">←</span><span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">∈</span> set <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> filter_eq_Cons_iff in_set_conv_decomp<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> OF_spm3_get_fe<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">a</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">fe</span><span class="main">.</span> ofe_action <span class="bound">fe</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∧</span> <span class="bound">fe</span> <span class="main">∈</span> set <span class="free">ft</span> <span class="main">∧</span> OF_priority_match_ana <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="bound">fe</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> OF_priority_match_def OF_priority_match_ana_def
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> flowtable_behavior.splits list.splits<span class="main">)</span> <span class="main">(</span><span class="operator">drule</span> filter_singleton<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">no_overlaps</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">no_overlaps</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">no_overlaps</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">no_overlaps</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="main">∧</span> <span class="main">(</span>
	<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">.</span> ofe_prio <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> ofe_prio <span class="bound">b</span> <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span> <span class="main">∈</span> UNIV<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="bound">p</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlap_ConsI<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap2 <span class="free">γ</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> check_no_overlap2 <span class="free">γ</span> <span class="free">xs</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlapsI<span class="main">:</span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">t</span> <span class="main">⟹</span> distinct <span class="free">t</span> <span class="main">⟹</span> no_overlaps <span class="free">γ</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_alt
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">t</span><span class="main">)</span>
	<span class="keyword1"><span class="command">from</span></span> no_overlap_ConsI<span class="main">[</span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> Cons<span class="main">(</span>3<span class="main">,</span>1<span class="main">)</span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> check_no_overlap2_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> check_no_overlapI<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">t</span> <span class="main">⟹</span> check_no_overlap <span class="free">γ</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_alt
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">t</span><span class="main">)</span>
	<span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> conjunct1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> no_overlaps.simps<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
		<span class="keyword1"><span class="command">using</span></span> conjunct2<span class="main">[</span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> no_overlaps.simps<span class="main"><span class="main">]</span></span><span class="main">]</span>
		<span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap2_def
		<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> check_no_overlap2_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">e</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> set <span class="free">t</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">e</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span> <span class="main">⟹</span> no_overlaps <span class="free">γ</span> <span class="free">t</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_append<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="main">(</span><span class="free">x</span> <span class="main">@</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> no_overlaps <span class="free">γ</span> <span class="free">y</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_ne1<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="main">(</span><span class="free">x</span> <span class="main">@</span> <span class="free">a</span> <span class="main">#</span> <span class="free">y</span> <span class="main">@</span> <span class="free">b</span> <span class="main">#</span> <span class="free">z</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">a</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≠</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> notI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span> contr<span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> contr
	<span class="keyword1"><span class="command">from</span></span> contr<span class="main">(</span>1<span class="main">)</span> no_overlaps_append <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">y</span> <span class="main">@</span> <span class="free">b</span> <span class="main">#</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">unfolded</span> no_overlaps.simps<span class="main">]</span>
	<span class="keyword1"><span class="command">with</span></span> contr<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">a</span><span class="main">)</span> <span class="bound">p</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">with</span></span> contr<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> contr<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_defeq<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">fe</span> <span class="main">⟹</span> OF_same_priority_match2 <span class="free">γ</span> <span class="free">fe</span> <span class="free">p</span> <span class="main">=</span> OF_priority_match <span class="free">γ</span> <span class="free">fe</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> OF_same_priority_match2_def OF_priority_match_def 
	<span class="keyword1"><span class="command">unfolding</span></span> f_Img_ex_set
	<span class="keyword1"><span class="command">unfolding</span></span> prio_match_matcher_alt
	<span class="keyword1"><span class="command">unfolding</span></span> prio_match_matcher_alt2
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">goal_cases</span> uf<span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> uf
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">[</span><span class="bound">f</span><span class="main">←</span><span class="free">fe</span> <span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">p</span><span class="main">]</span> <span class="keyword1">in</span> <span class="main">[</span><span class="bound">f</span><span class="main">←</span><span class="bound">m</span> <span class="main">.</span> <span class="main">∀</span><span class="bound">fo</span><span class="main">∈</span>set <span class="bound">m</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">]</span>"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ofe_action <span class="main">`</span> set <span class="var">?m'</span>"</span></span>
	<span class="keyword1"><span class="command">from</span></span> uf <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?m'</span></span></span><span class="main">)</span>
		<span class="keyword3"><span class="command">case</span></span> Nil
		<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">then</span></span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?s</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
		<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
		<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
		<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
			<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
			<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="skolem"><span class="skolem">bs</span></span> <span class="keyword2"><span class="keyword">where</span></span> bbs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">=</span> <span class="skolem">b</span> <span class="main">#</span> <span class="skolem">bs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> neq_Nil_conv<span class="main">)</span>
			 <span class="keyword1"><span class="command">note</span></span> no <span class="main">=</span> Cons<span class="main">[</span><span class="operator">unfolded</span> Let_def filter_filter<span class="main">]</span>
			<span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="var">?m'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> set <span class="var">?m'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bbs local.Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
			<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ofe_prio <span class="skolem">a</span> <span class="main">=</span> ofe_prio <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antisym<span class="main">)</span> 
			<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> ms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">a</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">b</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> bbs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Cons_eq_filterD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
			<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> abis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="free">fe</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> set <span class="free">fe</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
			<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">fe</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="bound">y</span> <span class="main">@</span> <span class="skolem">b</span> <span class="main">#</span> <span class="bound">z</span>"</span></span><span class="main">)</span>
				<span class="keyword3"><span class="command">case</span></span> True
				<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> xyz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fe</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">y</span> <span class="main">@</span> <span class="skolem">b</span> <span class="main">#</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
				<span class="keyword1"><span class="command">from</span></span> no_overlaps_ne1 ms<span class="main">(</span>1<span class="main">)</span> uf<span class="main">[</span><span class="operator">unfolded</span> xyz<span class="main">]</span>
				<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
			<span class="keyword1"><span class="command">next</span></span>
				<span class="keyword3"><span class="command">case</span></span> False
				<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> xyz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fe</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">@</span> <span class="skolem">b</span> <span class="main">#</span> <span class="skolem">y</span> <span class="main">@</span> <span class="skolem">a</span> <span class="main">#</span> <span class="skolem">z</span>"</span></span>
					<span class="keyword1"><span class="command">using</span></span> no <span class="keyword1"><span class="command">unfolding</span></span> bbs
					<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Cons_eq_filterD<span class="main">)</span>
				<span class="keyword1"><span class="command">from</span></span> no_overlaps_ne1 ms<span class="main">(</span>1<span class="main">)</span> uf<span class="main">[</span><span class="operator">unfolded</span> xyz<span class="main">]</span>
				<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
			<span class="keyword1"><span class="command">qed</span></span>
			<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> check_no_overlapI<span class="main">[</span><span class="operator">OF</span> uf<span class="main">,</span> <span class="operator">unfolded</span> check_no_overlap_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
		<span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> oe<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">[</span><span class="operator">unfolded</span> oe<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
	<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(* the above lemma used to be this, but it's slightly weaker than I wanted. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">fe</span> <span class="main">⟹</span> check_no_overlap <span class="free">γ</span> <span class="free">fe</span> <span class="main">⟹</span> OF_same_priority_match2 <span class="free">γ</span> <span class="free">fe</span> <span class="free">p</span> <span class="main">=</span> OF_priority_match <span class="free">γ</span> <span class="free">fe</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> no_overlaps_defeq<span class="main">)</span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> no_overlapsI<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> OF_eq<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">f</span>"</span></span>
	    <span class="keyword2"><span class="keyword">and</span></span> so<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map ofe_prio <span class="free">f</span><span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="free">f</span> <span class="free">p</span> <span class="main">=</span> OF_priority_match <span class="free">γ</span> <span class="free">f</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> no_overlaps_defeq<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span><span class="operator">OF</span> no<span class="main">]</span> OF_match_eq<span class="main">[</span><span class="operator">OF</span> so check_no_overlapI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> no<span class="main"><span class="main">]</span></span><span class="main">]</span>
	<span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">corollary</span></span> OF_eq_sort<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">f</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">f</span> <span class="free">p</span> <span class="main">=</span> OF_match_linear <span class="free">γ</span> <span class="main">(</span>sort_descending_key ofe_prio <span class="free">f</span><span class="main">)</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command">using</span></span> OF_match_eq2 check_no_overlapI no no_overlaps_defeq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> OF_lm_noa_none<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> NoAction <span class="main">⟹</span> <span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">e</span><span class="main">)</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ft</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	
<span class="comment1">(* this should be provable without the overlaps assumption, but that's quite a bit harder. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> OF_spm3_noa_none<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> NoAction <span class="main">⟹</span> <span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">e</span><span class="main">)</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_eq_sort<span class="main">[</span><span class="operator">OF</span> no<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> OF_lm_noa_none<span class="main">)</span> <span class="operator">simp</span>

<span class="comment1">(* repetition of the lemma for definition 2 for definition 3 *)</span>
<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_not_unefined<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span> <span class="main">⟹</span> OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span>
	<span class="keyword1"><span class="command">using</span></span> check_no_overlapI no_overlap_not_unefined no_overlaps_defeq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OpenFlow_Serialize">
<div class="head">
<h1>Theory OpenFlow_Serialize</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> OpenFlow_Serialize
<span class="keyword2"><span class="keyword">imports</span></span> <a href="OpenFlow_Matches.html">OpenFlow_Matches</a>
        <a href="OpenFlow_Action.html">OpenFlow_Action</a>
        <a href="Semantics_OpenFlow.html">Semantics_OpenFlow</a>
        <a href="../Simple_Firewall/Primitives_toString.html">Simple_Firewall.Primitives_toString</a>
        <a href="../IP_Addresses/Lib_Word_toString.html">IP_Addresses.Lib_Word_toString</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">serialization_test_entry</span> <span class="main">≡</span> OFEntry <span class="numeral">7</span> <span class="main">{</span>EtherDst <span class="numeral">0x1</span><span class="main">,</span> IPv4Dst <span class="main">(</span>PrefixMatch <span class="numeral">0xA000201</span> <span class="numeral">32</span><span class="main">)</span><span class="main">,</span> IngressPort <span class="inner_quoted">''s1-lan''</span><span class="main">,</span> L4Dst <span class="numeral">0x50</span> <span class="main">0</span><span class="main">,</span> L4Src <span class="numeral">0x400</span> <span class="numeral">0x3FF</span><span class="main">,</span> IPv4Proto <span class="numeral">6</span><span class="main">,</span> EtherType <span class="numeral">0x800</span><span class="main">}</span> <span class="main">[</span>ModifyField_l2dst <span class="numeral">0xA641F185E862</span><span class="main">,</span> Forward <span class="inner_quoted">''s1-wan''</span><span class="main">]</span>"</span></span>



<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map <span class="main">(</span><span class="main">(&lt;&lt;)</span> <span class="main">(</span><span class="main">1</span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span> <span class="main">∘</span> <span class="main">(*)</span> <span class="numeral">8</span><span class="main">)</span> <span class="main">∘</span> rev<span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="numeral">6</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">serialize_mac</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span> <span class="main">≡</span> <span class="main">(</span>intersperse <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">'':''</span><span class="main">)</span> <span class="main">∘</span> map <span class="main">(</span>hex_string_of_word <span class="main">1</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">&gt;&gt;</span> <span class="bound">h</span> <span class="main">*</span> <span class="numeral">8</span><span class="main">)</span> <span class="main">&amp;&amp;</span> <span class="numeral">0xff</span><span class="main">)</span><span class="main">)</span> <span class="main">∘</span> rev<span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="numeral">6</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_mac <span class="numeral">0xdeadbeefcafe</span> <span class="main">=</span> <span class="inner_quoted">''de:ad:be:ef:ca:fe''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">serialize_action</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span>
	Forward <span class="bound">oif</span> <span class="main">⇒</span> <span class="inner_quoted">''output:''</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="bound">oif</span> <span class="main">|</span>
	ModifyField_l2dst <span class="bound">na</span> <span class="main">⇒</span> <span class="inner_quoted">''mod_dl_dst:''</span> <span class="main">@</span> serialize_mac <span class="bound">na</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">serialize_actions</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> length <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="inner_quoted">''drop''</span> <span class="keyword1">else</span> <span class="main">(</span>intersperse <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">'',''</span><span class="main">)</span> <span class="main">∘</span> map <span class="main">(</span>serialize_action <span class="free"><span class="bound"><span class="entity">pids</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_actions <span class="main">(</span><span class="main">λ</span><span class="bound">oif</span><span class="main">.</span> <span class="inner_quoted">''42''</span><span class="main">)</span> <span class="main">(</span>ofe_action serialization_test_entry<span class="main">)</span> <span class="main">=</span>
  <span class="inner_quoted">''mod_dl_dst:a6:41:f1:85:e8:62,output:42''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_actions <span class="free">anything</span> <span class="main">[]</span> <span class="main">=</span> <span class="inner_quoted">''drop''</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> serialize_actions_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prefix_to_string</span> <span class="free"><span class="bound"><span class="entity">pfx</span></span></span> <span class="main">≡</span> ipv4_cidr_toString <span class="main">(</span>pfxm_prefix <span class="free"><span class="bound"><span class="entity">pfx</span></span></span><span class="main">,</span> pfxm_length <span class="free"><span class="bound"><span class="entity">pfx</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">serialize_of_match</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="main">(</span>IngressPort <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''in_port=''</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>VlanId <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''dl_vlan=''</span> <span class="main">@</span> dec_string_of_word0 <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>VlanPriority <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> undefined"</span></span> <span class="main">|</span> <span class="comment1">(* uh, äh… We don't use that anyway… *)</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>EtherType <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''dl_type=0x''</span> <span class="main">@</span> hex_string_of_word0 <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>EtherSrc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''dl_src=''</span> <span class="main">@</span> serialize_mac <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>EtherDst <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''dl_dst=''</span> <span class="main">@</span> serialize_mac <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>IPv4Proto <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''nw_proto=''</span> <span class="main">@</span> dec_string_of_word0 <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>IPv4Src <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''nw_src=''</span> <span class="main">@</span> prefix_to_string <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>IPv4Dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''nw_dst=''</span> <span class="main">@</span> prefix_to_string <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>L4Src <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''tp_src=''</span> <span class="main">@</span> dec_string_of_word0 <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> max_word <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="inner_quoted">''/0x''</span> <span class="main">@</span> hex_string_of_word <span class="numeral">3</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">serialize_of_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>L4Dst <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">''tp_dst=''</span> <span class="main">@</span> dec_string_of_word0 <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> max_word <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="inner_quoted">''/0x''</span> <span class="main">@</span> hex_string_of_word <span class="numeral">3</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">serialize_of_matches</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>string <span class="main">⇒</span> string<span class="main">)</span> <span class="main">⇒</span> of_match_field set <span class="main">⇒</span> string"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">serialize_of_matches</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="main">≡</span> <span class="main">(@)</span> <span class="inner_quoted">''hard_timeout=0,idle_timeout=0,''</span> <span class="main">∘</span> intersperse <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">'',''</span><span class="main">)</span> <span class="main">∘</span> map <span class="main">(</span>serialize_of_match <span class="free"><span class="bound"><span class="entity">pids</span></span></span><span class="main">)</span> <span class="main">∘</span> sorted_list_of_set"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_of_matches <span class="free">pids</span> <span class="free">of_matches</span><span class="main">=</span> 
<span class="main">(</span>List.append <span class="inner_quoted">''hard_timeout=0,idle_timeout=0,''</span><span class="main">)</span> 
  <span class="main">(</span>intersperse <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">'',''</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>serialize_of_match <span class="free">pids</span><span class="main">)</span> <span class="main">(</span>sorted_list_of_set <span class="free">of_matches</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> serialize_of_matches_def<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">serialize_of_matches</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML <span class="comment1">(*needs "HOL-Library.Code_Char"*)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_of_matches <span class="main">(</span><span class="main">λ</span><span class="bound">oif</span><span class="main">.</span> <span class="inner_quoted">''42''</span><span class="main">)</span> <span class="main">(</span>ofe_fields serialization_test_entry<span class="main">)</span> <span class="main">=</span>
  <span class="inner_quoted">''hard_timeout=0,idle_timeout=0,in_port=42,dl_type=0x800,dl_dst=00:00:00:00:00:01,nw_proto=6,nw_dst=10.0.2.1/32,tp_src=1024/0x03ff,tp_dst=80/0x0000''</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">serialize_of_entry</span> <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> <span class="main">(</span>OFEntry <span class="bound">p</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">⇒</span> <span class="inner_quoted">''priority=''</span> <span class="main">@</span> dec_string_of_word0 <span class="bound">p</span> <span class="main">@</span> <span class="inner_quoted">'',''</span> <span class="main">@</span> serialize_of_matches <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="bound">f</span> <span class="main">@</span> <span class="inner_quoted">'',''</span> <span class="main">@</span> <span class="inner_quoted">''action=''</span> <span class="main">@</span> serialize_actions <span class="free"><span class="bound"><span class="entity">pids</span></span></span> <span class="bound">a</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"serialize_of_entry <span class="main">(</span>the <span class="main">∘</span> map_of <span class="main">[</span><span class="main">(</span><span class="inner_quoted">''s1-lan''</span><span class="main">,</span><span class="inner_quoted">''42''</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="inner_quoted">''s1-wan''</span><span class="main">,</span><span class="inner_quoted">''1337''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> serialization_test_entry <span class="main">=</span>
  <span class="inner_quoted">''priority=7,hard_timeout=0,idle_timeout=0,in_port=42,dl_type=0x800,dl_dst=00:00:00:00:00:01,nw_proto=6,nw_dst=10.0.2.1/32,tp_src=1024/0x03ff,tp_dst=80/0x0000,action=mod_dl_dst:a6:41:f1:85:e8:62,output:1337''</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Featherweight_OpenFlow_Comparison">
<div class="head">
<h1>Theory Featherweight_OpenFlow_Comparison</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Featherweight_OpenFlow_Comparison
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Semantics_OpenFlow.html">Semantics_OpenFlow</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* compare to https://github.com/frenetic-lang/featherweight-openflow/blob/master/coq/OpenFlow/OpenFlowSemantics.v#L260 *)</span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">guha_table_semantics</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'p</span><span class="main">)</span> field_matcher <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> flowtable <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
guha_matched<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="free"><span class="bound"><span class="entity">fe</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> True <span class="main">⟹</span> 
 <span class="main">∀</span><span class="bound">fe'</span> <span class="main">∈</span> set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ft1</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">ft2</span></span></span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">fe'</span> <span class="main">&gt;</span> ofe_prio <span class="free"><span class="bound"><span class="entity">fe</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> False <span class="main">⟹</span> 
 <span class="free">guha_table_semantics</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ft1</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">fe</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ft2</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="free"><span class="bound"><span class="entity">fe</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
guha_unmatched<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">fe</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ft</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">(</span>ofe_fields <span class="bound">fe</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> False <span class="main">⟹</span>
 <span class="free">guha_table_semantics</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="free"><span class="bound"><span class="entity">ft</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> None"</span></span>

<span class="comment1">(* 
so... there's the possibility for a flow table with two matching entries.
I'm not so sure it is a good idea to model undefined behavior by nondeterministic but very defined behavior..
*)</span>
<span class="keyword1"><span class="command">lemma</span></span> guha_table_semantics_ex2res<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span> <span class="comment1">(* if there's only one action, the whole thing is moot. *)</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ff</span><span class="main">.</span> <span class="free">γ</span> <span class="bound">ff</span> <span class="free">p</span>"</span></span> <span class="comment1">(* if our matcher rejects the packet for any match condition, it is borked. *)</span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ft</span> <span class="main">(</span><span class="bound">a1</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">(</span><span class="bound">a2</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="bound">a1</span> <span class="main">≠</span> <span class="bound">a2</span> <span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="bound">a1</span><span class="main">)</span> <span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="bound">a2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">from</span></span> ms	<span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ff</span></span>  <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="skolem">ff</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
	<span class="keyword1"><span class="command">from</span></span> ta <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a1</span></span> <span class="skolem"><span class="skolem">a2</span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a1</span> <span class="main">≠</span> <span class="skolem">a2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card2_eI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?fe1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"OFEntry <span class="main">0</span> <span class="skolem">ff</span> <span class="skolem">a1</span>"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?fe2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"OFEntry <span class="main">0</span> <span class="skolem">ff</span> <span class="skolem">a2</span>"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ft</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?fe1</span><span class="main">,</span> <span class="var">?fe2</span><span class="main">]</span>"</span></span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="var">?ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="skolem">a1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="var">?ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="skolem">a2</span><span class="main">)</span>"</span></span> 
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> guha_table_semantics.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">γ</span></span> <span class="var"><span class="quoted"><span class="var">?fe1</span></span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?fe2</span><span class="main">]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> append_Nil flow_entry_match.sel<span class="main"><span class="main">]</span></span> <span class="main"><span class="keyword3">|</span></span> 
	   <span class="operator">rule</span> guha_table_semantics.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">γ</span></span> <span class="var"><span class="quoted"><span class="var">?fe2</span></span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?fe1</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> append_Nil2 flow_entry_match.sel append.simps<span class="main"><span class="main">]</span></span> <span class="main"><span class="keyword3">|</span></span>
	   <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
	<span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> as <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_umstaendlich<span class="main">:</span> <span class="comment1">(* or maybe it's Coq where the original formulation is more beneficial *)</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ae<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> ofe_action <span class="free">fe</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ele<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fe</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> rest<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">fe</span><span class="main">)</span> <span class="free">p</span>"</span></span> 
	              <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">fe'</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">fe'</span> <span class="main">&gt;</span> ofe_prio <span class="free">fe</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span>"</span></span>
 	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">from</span></span> ele <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ft1</span></span> <span class="skolem"><span class="skolem">ft2</span></span> <span class="keyword2"><span class="keyword">where</span></span> ftspl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ft</span> <span class="main">=</span> <span class="skolem">ft1</span> <span class="main">@</span> <span class="free">fe</span> <span class="main">#</span> <span class="skolem">ft2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> split_list <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ae ftspl
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> guha_table_semantics.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
		<span class="keyword1"><span class="command">using</span></span> rest<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
		<span class="keyword1"><span class="command">using</span></span> rest<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> ftspl<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_matched_rule_inversion<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">a</span><span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">fe</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="free">a</span> <span class="main">=</span> ofe_action <span class="bound">fe</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fe'</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">fe'</span> <span class="main">&gt;</span> ofe_prio <span class="bound">fe</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
	<span class="keyword1"><span class="command">{</span></span>
		<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
		<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="skolem">d</span>"</span></span>
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Some <span class="free">a</span> <span class="main">=</span> <span class="skolem">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">fe</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="free">a</span> <span class="main">=</span> ofe_action <span class="bound">fe</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe</span><span class="main">)</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fe'</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="bound">fe'</span> <span class="main">&gt;</span> ofe_prio <span class="bound">fe</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> guha_table_semantics.induct<span class="main">)</span> <span class="operator">simp_all</span> <span class="comment1">(* strange to show this by induction, but I don't see an exhaust or cases I could use. *)</span>
	<span class="keyword1"><span class="command">}</span></span>
	<span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">OF</span> assms refl<span class="main">]</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_equal_Action<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> spm<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">a</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">note</span></span> spm<span class="main">[</span><span class="operator">THEN</span> OF_spm3_get_fe<span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fe</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"ofe_action <span class="skolem">fe</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fein<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fe</span> <span class="main">∈</span> set <span class="free">ft</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> feana<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match_ana <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="skolem">fe</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> guha_umstaendlich<span class="main">)</span>
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> a<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fein<span class="main">)</span>
		<span class="keyword1"><span class="command">using</span></span> feana <span class="keyword1"><span class="command">unfolding</span></span> OF_priority_match_ana_def
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> filter_singleton <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.splits<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_equal_NoAction<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> spm<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> NoAction"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> None"</span></span>
<span class="keyword1"><span class="command">using</span></span> spm <span class="keyword1"><span class="command">unfolding</span></span> OF_priority_match_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_empty_conv OF_spm3_noa_none<span class="main"><span class="main">[</span></span><span class="operator">OF</span> no spm<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> guha_table_semantics.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> guha_equal_hlp<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>ftb_to_option <span class="main">(</span>OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">unfolding</span></span> ftb_to_option_def
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span><span class="main">)</span>"</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> guha_equal_Action<span class="main"><span class="main">[</span></span><span class="operator">OF</span> no<span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> guha_equal_NoAction<span class="main"><span class="main">[</span></span><span class="operator">OF</span> no<span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted">False</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no no_overlaps_not_unefined<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_deterministic1<span class="main">:</span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">x1</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> None"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> guha_table_semantics.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> guha_deterministic2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>no_overlaps <span class="free">γ</span> <span class="free">ft</span><span class="main">;</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">x1</span><span class="main">)</span><span class="main">;</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="free">a</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x1</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
	<span class="keyword3"><span class="command">case</span></span> 1
	<span class="keyword1"><span class="command">note</span></span> 1<span class="main">(</span>2-3<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> guha_matched_rule_inversion<span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fe1</span></span> <span class="skolem"><span class="skolem">fe2</span></span> <span class="keyword2"><span class="keyword">where</span></span> fes<span class="main">:</span>
	<span class="quoted"><span class="quoted">"<span class="skolem">fe1</span><span class="main">∈</span>set <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">=</span> ofe_action <span class="skolem">fe1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">fe1</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fe'</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">fe1</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fe'</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">fe2</span><span class="main">∈</span>set <span class="free">ft</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span>  <span class="main">=</span> ofe_action <span class="skolem">fe2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="skolem">fe2</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fe'</span><span class="main">∈</span>set <span class="free">ft</span><span class="main">.</span> ofe_prio <span class="skolem">fe2</span> <span class="main">&lt;</span> ofe_prio <span class="bound">fe'</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    	<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x1</span> <span class="main">≠</span> <span class="free">a</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> fene<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fe1</span> <span class="main">≠</span> <span class="skolem">fe2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fes<span class="main">(</span>2<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> pe<span class="main">:</span> <span class="quoted"><span class="quoted">"ofe_prio <span class="skolem">fe1</span> <span class="main">=</span> ofe_prio <span class="skolem">fe2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fes<span class="main">(</span>1<span class="main">,</span>3-4<span class="main">,</span>5<span class="main">,</span>7-8<span class="main">)</span> less_linear <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹no_overlaps <span class="free">γ</span> <span class="free">ft</span>›</span></span><span class="main">[</span><span class="operator">THEN</span> check_no_overlapI<span class="main">,</span> <span class="operator">unfolded</span> check_no_overlap_def<span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">unfolded</span> Ball_def<span class="main">,</span> <span class="operator">THEN</span> spec<span class="main">,</span> <span class="operator">THEN</span> mp<span class="main">,</span> <span class="operator">OF</span> fes<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">THEN</span> spec<span class="main">,</span> <span class="operator">THEN</span> mp<span class="main">,</span> <span class="operator">OF</span> fes<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">THEN</span> spec<span class="main">,</span> <span class="operator">THEN</span> mp<span class="main">,</span> <span class="operator">OF</span> UNIV_I<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> pe fene fes<span class="main">(</span>3<span class="main">,</span>7<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_equal<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> no<span class="main">:</span> <span class="quoted"><span class="quoted">"no_overlaps <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> option_to_ftb <span class="free">d</span> <span class="main">⟷</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="free">d</span>"</span></span>
	<span class="keyword1"><span class="command">using</span></span> guha_equal_hlp<span class="main">[</span><span class="operator">OF</span> no<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> ftb_to_option_def option_to_ftb_def
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
	<span class="keyword1"><span class="command">using</span></span> guha_deterministic1 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>
	<span class="keyword1"><span class="command">using</span></span> guha_deterministic2<span class="main">[</span><span class="operator">OF</span> no<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">using</span></span> guha_deterministic1 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>
	<span class="keyword1"><span class="command">using</span></span> no_overlaps_not_unefined<span class="main">[</span><span class="operator">OF</span> no<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
	<span class="keyword1"><span class="command">using</span></span> no_overlaps_not_unefined<span class="main">[</span><span class="operator">OF</span> no<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> guha_nondeterministicD<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>check_no_overlap <span class="free">γ</span> <span class="free">ft</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">fe1</span> <span class="bound">fe2</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">fe1</span> <span class="main">∈</span> set <span class="free">ft</span> <span class="main">∧</span> <span class="bound">fe2</span> <span class="main">∈</span> set <span class="free">ft</span>
		<span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="bound">p</span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="bound">fe1</span><span class="main">)</span><span class="main">)</span>
		<span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="bound">p</span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="bound">fe2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> check_no_overlap_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> fe1 fe2 p<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">fe1</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">fe2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> guha_table_semantics.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> disjI1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">fe1</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> split_list<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> ft1 ft2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">ft1</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">ft2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">oops</span></span> <span class="comment1">(* shadowed overlaps yay! *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The above lemma does indeed not hold, the reason for this are (possibly partially) shadowed overlaps.
This is exemplified below: If there are at least three different possible actions (necessary assumption)
and a match expression that matches all packets (convenience assumption), it is possible to construct a flow 
table that is admonished by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> check_no_overlap<span class="antiquote"><span class="antiquote">}</span></span></span></span> but still will never run into undefined behavior.
›</span></span>
<span class="comment1">(* This is not the terribly most important lemma. Feel free to delete it if the proof gives you trouble. *)</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'action</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">3</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="free">γ</span> <span class="free">x</span> <span class="bound">p</span>"</span></span> <span class="comment1">(* with a sane γ, x = {} *)</span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ft</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'action</span><span class="main">)</span> flow_entry_match list<span class="main">.</span> <span class="main">¬</span>check_no_overlap <span class="free">γ</span> <span class="bound">ft</span> <span class="main">∧</span>
	  <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">fe1</span> <span class="bound">fe2</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">fe1</span> <span class="main">∈</span> set <span class="bound">ft</span> <span class="main">∧</span> <span class="bound">fe2</span> <span class="main">∈</span> set <span class="bound">ft</span> <span class="main">∧</span> <span class="bound">fe1</span> <span class="main">≠</span> <span class="bound">fe2</span> <span class="main">∧</span> ofe_prio <span class="bound">fe1</span> <span class="main">=</span> ofe_prio <span class="bound">fe2</span>
		<span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="bound">p</span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="bound">fe1</span><span class="main">)</span><span class="main">)</span>
		<span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="bound">p</span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="bound">fe2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">adef</span></span> <span class="skolem"><span class="skolem">aa</span></span> <span class="skolem"><span class="skolem">ab</span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'action</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> anb<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">aa</span> <span class="main">≠</span> <span class="skolem">ab</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">adef</span> <span class="main">≠</span> <span class="skolem">aa</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">adef</span> <span class="main">≠</span> <span class="skolem">ab</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> card3_eI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cex</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>OFEntry <span class="main">1</span> <span class="free">x</span> <span class="skolem">adef</span><span class="main">,</span> OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">aa</span><span class="main">,</span> OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">ab</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> ol<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>check_no_overlap <span class="free">γ</span> <span class="var">?cex</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_def ball_simps
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">aa</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">ab</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> df<span class="main">:</span> <span class="quoted"><span class="quoted">"guha_table_semantics <span class="free">γ</span> <span class="var">?cex</span> <span class="skolem">p</span> <span class="skolem">oc</span> <span class="main">⟹</span> <span class="skolem">oc</span> <span class="main">=</span> Some <span class="skolem">adef</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">oc</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> guha_table_semantics.simps
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> fe ft1 ft2
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ft1</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ft2</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">ft1</span> <span class="main">=</span> <span class="main">[</span>OFEntry <span class="main">1</span> <span class="free">x</span> <span class="skolem">adef</span><span class="main">]</span> <span class="main">∧</span> <span class="skolem">fe</span> <span class="main">=</span> OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">aa</span> <span class="main">∧</span> <span class="skolem">ft2</span> <span class="main">=</span> <span class="main">[</span>OFEntry <span class="main">0</span> <span class="free">x</span> <span class="skolem">ab</span><span class="main">]</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.neq_Nil_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> ya ys yz<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.neq_Nil_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="var"><span class="quoted"><span class="var">?cex</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span> ol<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> set_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">elim</span> insertE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="main">(</span><span class="operator">drule</span> df<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">unfold</span> option.inject<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">elim</span> anb<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> notE<span class="main"><span class="main">]</span></span> <span class="main"><span class="keyword3">|</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="LinuxRouter_OpenFlow_Translation">
<div class="head">
<h1>Theory LinuxRouter_OpenFlow_Translation</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> LinuxRouter_OpenFlow_Translation
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../IP_Addresses/CIDR_Split.html">IP_Addresses.CIDR_Split</a>
  <a href="../Automatic_Refinement/Misc.html">Automatic_Refinement.Misc</a> <span class="comment1">(*TODO@Peter: rename and make available at better place :)*)</span>
	<a href="../Simple_Firewall/Generic_SimpleFw.html">Simple_Firewall.Generic_SimpleFw</a> 
	<a href="Semantics_OpenFlow.html">Semantics_OpenFlow</a>
	<a href="OpenFlow_Matches.html">OpenFlow_Matches</a>
	<a href="OpenFlow_Action.html">OpenFlow_Action</a>
	<a href="../Routing/Linux_Router.html">Routing.Linux_Router</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">hide_const</span></span> Misc.uncurry
<span class="keyword1"><span class="command">hide_fact</span></span> Misc.uncurry_def
  
<span class="comment1">(* For reference:
iiface :: "iface" --"in-interface"
oiface :: "iface" --"out-interface"
src :: "(ipv4addr × nat) " --"source IP address"
dst :: "(ipv4addr × nat) " --"destination"
proto :: "protocol"
sports :: "(16 word × 16 word)" --"source-port first:last"
dports :: "(16 word × 16 word)" --"destination-port first:last"

p_iiface :: string
p_oiface :: string
p_src :: ipv4addr
p_dst :: ipv4addr
p_proto :: primitive_protocol
p_sport :: "16 word"
p_dport :: "16 word"
p_tcp_flags :: "tcp_flag set"
p_payload :: string
*)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">route2match</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
	<span class="main">⦇</span>iiface <span class="main">=</span> ifaceAny<span class="main">,</span> oiface <span class="main">=</span> ifaceAny<span class="main">,</span> 
	src <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">,</span> dst<span class="main">=</span><span class="main">(</span>pfxm_prefix <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">,</span>pfxm_length <span class="main">(</span>routing_match <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
	proto<span class="main">=</span>ProtoAny<span class="main">,</span> sports<span class="main">=</span><span class="main">(</span><span class="main">0</span><span class="main">,</span>max_word<span class="main">)</span><span class="main">,</span> ports<span class="main">=</span><span class="main">(</span><span class="main">0</span><span class="main">,</span>max_word<span class="main">)</span><span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">toprefixmatch</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">toprefixmatch</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">pm</span> <span class="main">=</span> PrefixMatch <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">pm</span> <span class="main">=</span> PrefixMatch <span class="main">0</span> <span class="main">0</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="bound">pm</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> prefix_match_semantics_simple_match<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> some<span class="main">:</span> <span class="quoted"><span class="quoted">"toprefixmatch <span class="free">m</span> <span class="main">=</span> Some <span class="free">pm</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> vld<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefix <span class="free">pm</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="free">pm</span> <span class="main">=</span> simple_match_ip <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> some
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
	  <span class="main">(</span><span class="operator">clarsimp</span> 
	   <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> toprefixmatch_def ipset_from_cidr_def pfxm_mask_def fun_eq_iff
	            prefix_match_semantics_ipset_from_netmask<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vld<span class="main"><span class="main">]</span></span> NOT_mask_shifted_lenword<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
	   <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">simple_match_to_of_match_single</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">32</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> simple_match_scheme
     <span class="main">⇒</span> char list option <span class="main">⇒</span> protocol <span class="main">⇒</span> <span class="main">(</span><span class="numeral">16</span> word <span class="main">×</span> <span class="numeral">16</span> word<span class="main">)</span> option <span class="main">⇒</span> <span class="main">(</span><span class="numeral">16</span> word <span class="main">×</span> <span class="numeral">16</span> word<span class="main">)</span> option <span class="main">⇒</span> of_match_field set"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">simple_match_to_of_match_single</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">iif</span></span></span> <span class="free"><span class="bound"><span class="entity">prot</span></span></span> <span class="free"><span class="bound"><span class="entity">sport</span></span></span> <span class="free"><span class="bound"><span class="entity">dport</span></span></span> <span class="main">≡</span>
	   uncurry L4Src <span class="main">`</span> option2set <span class="free"><span class="bound"><span class="entity">sport</span></span></span> <span class="main">∪</span> uncurry L4Dst <span class="main">`</span> option2set <span class="free"><span class="bound"><span class="entity">dport</span></span></span>
	 <span class="main">∪</span> IPv4Proto <span class="main">`</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">prot</span></span></span> <span class="keyword1">of</span> ProtoAny <span class="main">⇒</span> <span class="main">{}</span> <span class="main">|</span> Proto <span class="bound">p</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">p</span><span class="main">}</span><span class="main">)</span> <span class="comment1">― ‹protocol is an 8 word option anyway...›</span>
	 <span class="main">∪</span> IngressPort <span class="main">`</span> option2set <span class="free"><span class="bound"><span class="entity">iif</span></span></span>
	 <span class="main">∪</span> IPv4Src <span class="main">`</span> option2set <span class="main">(</span>toprefixmatch <span class="main">(</span>src <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> IPv4Dst <span class="main">`</span> option2set <span class="main">(</span>toprefixmatch <span class="main">(</span>dst <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>
	 <span class="main">∪</span> <span class="main">{</span>EtherType <span class="numeral">0x0800</span><span class="main">}</span>"</span></span>
<span class="comment1">(* okay, we need to make sure that no packets are output on the interface they were input on. So for rules that don't have an input interface, we'd need to do a product over all interfaces, if we stay naive.
   The more smart way would be to insert a rule with the same match condition that additionally matches the input interface and drops. However, I'm afraid this is going to be very tricky to verify… *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">simple_match_to_of_match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">32</span> simple_match <span class="main">⇒</span> string list <span class="main">⇒</span> of_match_field set list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">simple_match_to_of_match</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">let</span>
	<span class="bound">npm</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> fst <span class="bound">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> snd <span class="bound">p</span> <span class="main">=</span> max_word<span class="main">)</span><span class="main">;</span>
	<span class="bound">sb</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">npm</span> <span class="bound">p</span> <span class="keyword1">then</span> <span class="main">[</span>None<span class="main">]</span> <span class="keyword1">else</span> <span class="keyword1">if</span> fst <span class="bound">p</span> <span class="main">≤</span> snd <span class="bound">p</span>
  <span class="keyword1">then</span> map <span class="main">(</span>Some <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">pfx</span><span class="main">.</span> <span class="main">(</span>pfxm_prefix <span class="bound">pfx</span><span class="main">,</span> <span class="keyword1">NOT</span> <span class="main">(</span>pfxm_mask <span class="bound">pfx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>
	<span class="keyword1">in</span> <span class="main">[</span>simple_match_to_of_match_single <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">iif</span> <span class="main">(</span>proto <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="bound">sport</span> <span class="bound">dport</span><span class="main">.</span>
		iif <span class="main">←</span> <span class="main">(</span><span class="keyword1">if</span> iiface <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> ifaceAny <span class="keyword1">then</span> <span class="main">[</span>None<span class="main">]</span> <span class="keyword1">else</span> <span class="main">[</span>Some <span class="bound">i</span><span class="main">.</span> i <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">,</span> match_iface <span class="main">(</span>iiface <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="bound">i</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
		sport <span class="main">←</span> <span class="bound">sb</span> <span class="main">(</span>sports <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">,</span>
		dport <span class="main">←</span> <span class="bound">sb</span> <span class="main">(</span>dports <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">]</span>
<span class="main">)</span>"</span></span>
<span class="comment1">(* I wonder… should I check whether list_all (match_iface (iiface m)) ifs instead of iiface m = ifaceAny? It would be pretty stupid if that wasn't the same, but you know… *)</span>

<span class="keyword1"><span class="command">lemma</span></span> smtoms_eq_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_to_of_match_single <span class="free">r</span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span> <span class="free">d</span> <span class="main">=</span> simple_match_to_of_match_single <span class="free">r</span> <span class="free">f</span> <span class="free">g</span> <span class="free">h</span> <span class="free">i</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">=</span> <span class="free">h</span> <span class="main">∧</span> <span class="free">d</span> <span class="main">=</span> <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="comment1">(* In case this proof breaks: there are two alternate proofs in the repo. They are of similar quality, though. Good luck. *)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> of_match_field<span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">=</span> Some <span class="bound">x</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">P</span> <span class="main">(</span>IngressPort <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits uncurry_splits protocol.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> of_match_field<span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">=</span> Proto <span class="bound">x</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">P</span> <span class="main">(</span>IPv4Proto <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main">)</span> 
        <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits uncurry_splits protocol.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> of_match_field<span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">=</span> Some <span class="bound">x</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">P</span> <span class="main">(</span>uncurry L4Src <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits uncurry_splits protocol.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">P</span> <span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> of_match_field<span class="main">.</span> <span class="bound">P</span> <span class="bound">x</span><span class="main">;</span> <span class="bound">z</span> <span class="main">=</span> Some <span class="bound">x</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">P</span> <span class="main">(</span>uncurry L4Dst <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits uncurry_splits protocol.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_to_of_match_generates_prereqs<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">m</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="free">m</span> <span class="free">ifs</span><span class="main">)</span> <span class="main">⟹</span> all_prerequisites <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> simple_match_to_of_match_def Let_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">xiface</span> <span class="skolem">xsrcp</span> <span class="skolem">xdstp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> o <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> simple_match_to_of_match_single_def all_prerequisites_def
    <span class="keyword1"><span class="command">unfolding</span></span> ball_Un
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">|</span></span> <span class="operator">-</span> <span class="main">)</span><span class="main">)</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1
    <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="main">(</span>sports <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> snd <span class="main">(</span>sports <span class="free">m</span><span class="main">)</span> <span class="main">=</span> max_word<span class="main">)</span> <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto TCP <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto UDP <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto L4_Protocol.SCTP"</span></span>
      <span class="keyword1"><span class="command">using</span></span> o<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> simple_match_valid_alt Let_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> o<span class="main">(</span>3<span class="main">)</span> e
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits prod.splits uncurry_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 2
    <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="main">(</span>dports <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> snd <span class="main">(</span>dports <span class="free">m</span><span class="main">)</span> <span class="main">=</span> max_word<span class="main">)</span> <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto TCP <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto UDP <span class="main">∨</span> proto <span class="free">m</span> <span class="main">=</span> Proto L4_Protocol.SCTP"</span></span>
      <span class="keyword1"><span class="command">using</span></span> o<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> simple_match_valid_alt Let_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> o<span class="main">(</span>4<span class="main">)</span> e
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits prod.splits uncurry_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> and_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">∧</span> <span class="free">b</span><span class="main">)</span> <span class="main">∧</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> custom_simpset <span class="main">=</span> Let_def set_concat set_map map_map comp_def concat_map_maps set_maps UN_iff fun_app_def Set.image_iff

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">simple_fw_prefix_to_wordinterval</span> <span class="main">≡</span> prefix_to_wordinterval <span class="main">∘</span> uncurry PrefixMatch"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_port_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_port <span class="free">m</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>uncurry WordInterval <span class="free">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> uncurry_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_src_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">r</span> <span class="main">⟹</span> 
	simple_match_ip <span class="main">(</span>src <span class="free">r</span><span class="main">)</span> <span class="free">p</span> <span class="main">⟷</span> prefix_match_semantics <span class="main">(</span>PrefixMatch <span class="main">(</span>fst <span class="main">(</span>src <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>src <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>src <span class="free">r</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_ipset_from_netmask2 prefix_to_wordset_ipset_from_cidr simple_match_valid_def valid_prefix_fw_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> simple_match_dst_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">r</span> <span class="main">⟹</span> 
	simple_match_ip <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span> <span class="free">p</span> <span class="main">⟷</span> prefix_match_semantics <span class="main">(</span>PrefixMatch <span class="main">(</span>fst <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>dst <span class="free">r</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_ipset_from_netmask2 prefix_to_wordset_ipset_from_cidr simple_match_valid_def valid_prefix_fw_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="free">w</span><span class="main">)</span> <span class="main">⟹</span> valid_prefix <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> wordinterval_CIDR_split_prefixmatch_all_valid_Ball<span class="main">[</span><span class="operator">THEN</span> bspec<span class="main">,</span> <span class="operator">THEN</span> conjunct1<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_to_of_matchI<span class="main">:</span> 
	<span class="keyword2"><span class="keyword">assumes</span></span> mv<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">r</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> mm<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_matches <span class="free">r</span> <span class="free">p</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ii<span class="main">:</span> <span class="quoted"><span class="quoted">"p_iiface <span class="free">p</span> <span class="main">∈</span> set <span class="free">ifs</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ippkt<span class="main">:</span> <span class="quoted"><span class="quoted">"p_l2type <span class="free">p</span> <span class="main">=</span> <span class="numeral">0x800</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">gr</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="free">r</span> <span class="free">ifs</span><span class="main">)</span><span class="main">.</span> OF_match_fields <span class="bound">gr</span> <span class="free">p</span> <span class="main">=</span> Some True"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?npm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">p</span><span class="main">.</span> fst <span class="bound">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> snd <span class="bound">p</span> <span class="main">=</span> max_word"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sb</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">p</span> <span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="var">?npm</span> <span class="bound">p</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="bound">r</span><span class="main">)</span>"</span></span>
	<span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">si</span></span> <span class="keyword2"><span class="keyword">where</span></span> si<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">si</span> <span class="keyword1">of</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> p_sport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ssi</span> <span class="main">|</span> None <span class="main">⇒</span> True"</span></span>
		<span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">si</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> <span class="bound">ssi</span> <span class="main">∈</span> set <span class="main">(</span>
		wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
		<span class="quoted"><span class="quoted">"<span class="skolem">si</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="var">?npm</span> <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?npm</span> <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
		<span class="keyword3"><span class="command">case</span></span> 1 <span class="comment1">(* True *)</span>
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> None <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> p_sport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ssi</span><span class="main">)</span> <span class="main">∧</span>
            <span class="main">(</span><span class="keyword1">case</span> None <span class="keyword1">of</span> None <span class="main">⇒</span> True
            <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> <span class="bound">ssi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">case</span></span> 2 <span class="comment1">(* False *)</span>
		<span class="keyword1"><span class="command">from</span></span> mm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"p_sport <span class="free">p</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> simple_matches.simps simple_match_port_alt<span class="main">)</span>
		<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ssi</span></span> <span class="keyword2"><span class="keyword">where</span></span> ssi<span class="main">:</span>
			<span class="quoted"><span class="quoted">"<span class="skolem">ssi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="quoted"><span class="quoted">"p_sport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">ssi</span>"</span></span> 
			<span class="keyword1"><span class="command">using</span></span> wordinterval_CIDR_split_existential <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> Some <span class="skolem">ssi</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> p_sport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ssi</span><span class="main">)</span> <span class="main">∧</span>
            <span class="main">(</span><span class="keyword1">case</span> Some <span class="skolem">ssi</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True
            <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> <span class="bound">ssi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>				
	<span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">di</span></span> <span class="keyword2"><span class="keyword">where</span></span> di<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">di</span> <span class="keyword1">of</span> Some <span class="bound">ddi</span> <span class="main">⇒</span> p_dport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ddi</span> <span class="main">|</span> None <span class="main">⇒</span> True"</span></span>
		<span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">di</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ddi</span> <span class="main">⇒</span> <span class="bound">ddi</span> <span class="main">∈</span> set <span class="main">(</span>
		wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
		<span class="quoted"><span class="quoted">"<span class="skolem">di</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="var">?npm</span> <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?npm</span> <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
		<span class="keyword3"><span class="command">case</span></span> 1
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> None <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> p_dport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ssi</span><span class="main">)</span> <span class="main">∧</span>
            <span class="main">(</span><span class="keyword1">case</span> None <span class="keyword1">of</span> None <span class="main">⇒</span> True
            <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> <span class="bound">ssi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">case</span></span> 2
		<span class="keyword1"><span class="command">from</span></span> mm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"p_dport <span class="free">p</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> simple_matches.simps simple_match_port_alt<span class="main">)</span>
		<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ddi</span></span> <span class="keyword2"><span class="keyword">where</span></span> ddi<span class="main">:</span>
			<span class="quoted"><span class="quoted">"<span class="skolem">ddi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
			<span class="quoted"><span class="quoted">"p_dport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">ddi</span>"</span></span> 
			<span class="keyword1"><span class="command">using</span></span> wordinterval_CIDR_split_existential <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
		<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> Some <span class="skolem">ddi</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> p_dport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="bound">ssi</span><span class="main">)</span> <span class="main">∧</span>
            <span class="main">(</span><span class="keyword1">case</span> Some <span class="skolem">ddi</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True
            <span class="main">|</span> Some <span class="bound">ssi</span> <span class="main">⇒</span> <span class="bound">ssi</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
	<span class="keyword1"><span class="command">proof</span></span>
		<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mf</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_option <span class="main">(</span>apsnd <span class="main">(</span>wordNOT <span class="main">∘</span> mask <span class="main">∘</span> <span class="main">(-)</span> <span class="numeral">16</span><span class="main">)</span> <span class="main">∘</span> prefix_match_dtor<span class="main">)</span>"</span></span>
		<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?gr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"simple_match_to_of_match_single <span class="free">r</span>
			<span class="main">(</span><span class="keyword1">if</span> iiface <span class="free">r</span> <span class="main">=</span> ifaceAny <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>p_iiface <span class="free">p</span><span class="main">)</span><span class="main">)</span> 
			<span class="main">(</span><span class="keyword1">if</span> proto <span class="free">r</span> <span class="main">=</span> ProtoAny <span class="keyword1">then</span> ProtoAny <span class="keyword1">else</span> Proto <span class="main">(</span>p_proto <span class="free">p</span><span class="main">)</span><span class="main">)</span>
			<span class="main">(</span><span class="var">?mf</span> <span class="skolem">si</span><span class="main">)</span> <span class="main">(</span><span class="var">?mf</span> <span class="skolem">di</span><span class="main">)</span>"</span></span>
		<span class="keyword1"><span class="command">note</span></span> mfu <span class="main">=</span> simple_match_port.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> surjective_pairing<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"sports <span class="free">r</span>"</span></span><span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
				   simple_match_port.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> surjective_pairing<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"dports <span class="free">r</span>"</span></span><span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
		<span class="keyword1"><span class="command">note</span></span> u <span class="main">=</span> mm<span class="main">[</span><span class="operator">unfolded</span> simple_matches.simps mfu ord_class.atLeastAtMost_iff simple_packet_unext_def simple_packet.simps<span class="main">]</span>
		<span class="keyword1"><span class="command">note</span></span> of_safe_unsafe_match_eq<span class="main">[</span><span class="operator">OF</span> simple_match_to_of_match_generates_prereqs<span class="main">]</span>
		<span class="keyword1"><span class="command">from</span></span> u <span class="keyword1"><span class="command">have</span></span> ple<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> snd <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> snd <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
		<span class="keyword3"><span class="command">show</span></span> eg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?gr</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="free">r</span> <span class="free">ifs</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">unfolding</span></span> simple_match_to_of_match_def
			<span class="keyword1"><span class="command">unfolding</span></span> custom_simpset
			<span class="keyword1"><span class="command">unfolding</span></span> smtoms_eq_hlp
			<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main">)</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
				<span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> ple<span class="main">(</span>2<span class="main">)</span> di
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pfxm_mask_def prefix_match_dtor_def Set.image_iff 
					           <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits prod.splits uncurry_splits<span class="main">)</span>
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> bexI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prefix_match.splits<span class="main">)</span>
				<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
			<span class="keyword1"><span class="command">next</span></span>
				<span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> ple<span class="main">(</span>1<span class="main">)</span> si
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pfxm_mask_def prefix_match_dtor_def Set.image_iff 
					           <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits prod.splits uncurry_splits<span class="main">)</span>
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> bexI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
					<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prefix_match.splits<span class="main">)</span>
				<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
			<span class="keyword1"><span class="command">next</span></span>
				<span class="keyword3"><span class="command">case</span></span> 4 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
				  <span class="keyword1"><span class="command">using</span></span> u ii <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_maps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
			<span class="keyword1"><span class="command">next</span></span>
				<span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> ii u <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span> <span class="main">(</span><span class="operator">metis</span> match_proto.elims<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>  
			<span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword1"><span class="command">have</span></span> dpm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">di</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> p_dport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x1</span> <span class="skolem">x2</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">di</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> prefix_match_semantics <span class="main">(</span>the <span class="skolem">di</span><span class="main">)</span> <span class="main">(</span>p_dport <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> p_dport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_def pfxm_mask_def word_bw_comms<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pfx</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="skolem">ra</span><span class="main">)</span> <span class="main">⟹</span> prefix_match_semantics <span class="skolem">pfx</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">pfx</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">pfx</span> <span class="skolem">ra</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> prefix_match_semantics_wordset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wordinterval_CIDR_split_prefixmatch_all_valid_Ball<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">THEN</span> bspec<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> conjunct1<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">di</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">;</span> p_dport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">;</span> PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⟧</span>
             <span class="main">⟹</span> p_dport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> di<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> * ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">di</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> p_dport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> di<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword1"><span class="command">have</span></span> spm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">si</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> p_sport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x1</span> <span class="skolem">x2</span>
    <span class="keyword1"><span class="command">using</span></span> si
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">si</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> prefix_match_semantics <span class="main">(</span>the <span class="skolem">si</span><span class="main">)</span> <span class="main">(</span>p_sport <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> p_sport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_def pfxm_mask_def word_bw_comms<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pfx</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="skolem">ra</span><span class="main">)</span> <span class="main">⟹</span> prefix_match_semantics <span class="skolem">pfx</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">pfx</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">pfx</span> <span class="skolem">ra</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> prefix_match_semantics_wordset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wordinterval_CIDR_split_prefixmatch_all_valid_Ball<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">THEN</span> bspec<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> conjunct1<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">si</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">;</span> p_sport <span class="free">p</span> <span class="main">∈</span> prefix_to_wordset <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">;</span> PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>uncurry WordInterval <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⟧</span>
             <span class="main">⟹</span> p_sport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> si<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> * ** <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">si</span> <span class="main">=</span> Some <span class="main">(</span>PrefixMatch <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">⟹</span> p_sport <span class="free">p</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>mask <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x1</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> si<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"OF_match_fields <span class="var">?gr</span> <span class="free">p</span> <span class="main">=</span> Some True"</span></span>
		<span class="keyword1"><span class="command">unfolding</span></span> of_safe_unsafe_match_eq<span class="main">[</span><span class="operator">OF</span> simple_match_to_of_match_generates_prereqs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv eg<span class="main"><span class="main">]</span></span><span class="main">]</span>
		  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">si</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">di</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">simp_all</span>
					<span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_match_to_of_match_single_def OF_match_fields_unsafe_def spm
					     option2set_def u ippkt prefix_match_dtor_def toprefixmatch_def dpm
					     simple_match_dst_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> simple_match_src_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
					<span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prefix_match.splits<span class="main">)</span>
	<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prefix_match_00<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_match_semantics <span class="main">(</span>PrefixMatch <span class="main">0</span> <span class="main">0</span><span class="main">)</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefix_def zero_prefix_match_all<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_to_of_matchD<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> eg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">gr</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="free">r</span> <span class="free">ifs</span><span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> mo<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_fields <span class="free">gr</span> <span class="free">p</span> <span class="main">=</span> Some True"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> me<span class="main">:</span> <span class="quoted"><span class="quoted">"match_iface <span class="main">(</span>oiface <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_oiface <span class="free">p</span><span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> mv<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">r</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simple_matches <span class="free">r</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">from</span></span> mv <span class="keyword1"><span class="command">have</span></span> validpfx<span class="main">:</span> 
		<span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>uncurry PrefixMatch <span class="main">(</span>src <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>uncurry PrefixMatch <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
		<span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">pm</span><span class="main">.</span> toprefixmatch <span class="main">(</span>src <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Some <span class="bound">pm</span> <span class="main">⟹</span> valid_prefix <span class="bound">pm</span>"</span></span>
		<span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">pm</span><span class="main">.</span> toprefixmatch <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Some <span class="bound">pm</span> <span class="main">⟹</span> valid_prefix <span class="bound">pm</span>"</span></span>
		<span class="keyword1"><span class="command">unfolding</span></span> simple_match_valid_def valid_prefix_fw_def toprefixmatch_def 
		  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> uncurry_splits if_splits<span class="main">)</span>
	<span class="keyword1"><span class="command">from</span></span> mo <span class="keyword1"><span class="command">have</span></span> mo<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_fields_unsafe <span class="free">gr</span> <span class="free">p</span>"</span></span> 
		<span class="keyword1"><span class="command">unfolding</span></span> of_safe_unsafe_match_eq<span class="main">[</span><span class="operator">OF</span> simple_match_to_of_match_generates_prereqs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv eg<span class="main"><span class="main">]</span></span><span class="main">]</span>
		<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">unfolded</span> OF_match_fields_unsafe_def<span class="main">]</span>
	<span class="keyword1"><span class="command">note</span></span> eg<span class="main">[</span><span class="operator">unfolded</span> simple_match_to_of_match_def simple_match_to_of_match_single_def  custom_simpset option2set_def<span class="main">]</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> x <span class="keyword1"><span class="command">..</span></span>	<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> xa <span class="keyword1"><span class="command">..</span></span>	<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> xb <span class="keyword1"><span class="command">..</span></span>
	<span class="keyword1"><span class="command">note</span></span> xx <span class="main">=</span> calculation<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> this

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">xc</span> <span class="skolem">xa</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">pp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word"</span></span>
	  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">pp</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">xc</span><span class="main">)</span> <span class="main">=</span> pfxm_prefix <span class="skolem">xc</span><span class="main">⟧</span>
              <span class="main">⟹</span> prefix_match_semantics <span class="skolem">xc</span> <span class="main">(</span><span class="skolem">pp</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xc</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prefix_match_semantics_def word_bw_comms<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pp</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>WordInterval <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">a</span> <span class="main">≤</span> <span class="skolem">pp</span> <span class="main">∧</span> <span class="skolem">pp</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xc</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">pp</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">xc</span>  <span class="main">⟹</span> <span class="skolem">pp</span> <span class="main">∈</span> wordinterval_to_set <span class="main">(</span>WordInterval <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> wordinterval_CIDR_split_prefixmatch<span class="main">)</span> <span class="operator">blast</span>
	  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">xc</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="skolem">xa</span> <span class="main">=</span> Some <span class="main">(</span>pfxm_prefix <span class="skolem">xc</span><span class="main">,</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">xc</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> prefix_match_semantics <span class="skolem">xc</span> <span class="main">(</span><span class="skolem">pp</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">pp</span> <span class="main">∈</span> prefix_to_wordset <span class="skolem">xc</span>"</span></span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> prefix_match_semantics_wordset<span class="main">)</span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> wordinterval_CIDR_split_prefixmatch_all_valid_Ball<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> bspec<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> conjunct1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
	  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
	  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">xc</span> <span class="main">∈</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="skolem">xa</span> <span class="main">=</span> Some <span class="main">(</span>pfxm_prefix <span class="skolem">xc</span><span class="main">,</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">xc</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
               <span class="skolem">pp</span> <span class="main">&amp;&amp;</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">xc</span><span class="main">)</span> <span class="main">=</span> pfxm_prefix <span class="skolem">xc</span><span class="main">⟧</span>
              <span class="main">⟹</span> <span class="skolem">a</span> <span class="main">≤</span> <span class="skolem">pp</span> <span class="main">∧</span> <span class="skolem">pp</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
	<span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> l4port_logic <span class="main">=</span> this

	<span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> simple_matches.simps
	<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold</span> and_assoc<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"match_iface <span class="main">(</span>iiface <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_iiface <span class="free">p</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"iiface <span class="free">r</span> <span class="main">=</span> ifaceAny"</span></span><span class="main">)</span>
			 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> match_ifaceAny<span class="main">)</span> 
			<span class="keyword1"><span class="command">using</span></span> xx<span class="main">(</span>1<span class="main">)</span> mo <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> if_False set_maps UN_iff<span class="main">)</span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> a<span class="main"><span class="keyword3">;</span></span> <span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"match_iface <span class="main">(</span>iiface <span class="free">r</span><span class="main">)</span> <span class="improper">a</span>"</span></span><span class="main">)</span>
			 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option2set_def<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
			<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
		<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"match_iface <span class="main">(</span>oiface <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_oiface <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> me <span class="keyword1"><span class="command">.</span></span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"simple_match_ip <span class="main">(</span>src <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_src <span class="free">p</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">using</span></span> mo <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def toprefixmatch_def
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span>
			  <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_packet_unext_def option2set_def validpfx simple_match_src_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv<span class="main"><span class="main">]</span></span> toprefixmatch_def 
			  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"simple_match_ip <span class="main">(</span>dst <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">using</span></span> mo <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def toprefixmatch_def
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span>
			  <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_packet_unext_def option2set_def validpfx simple_match_dst_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mv<span class="main"><span class="main">]</span></span> toprefixmatch_def 
			  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
 	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"match_proto <span class="main">(</span>proto <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_proto <span class="free">p</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">using</span></span> mo <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def
			<span class="keyword1"><span class="command">using</span></span> xx<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> 
				<span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> singleton_iff simple_packet_unext_def option2set_def prefix_match_semantics_simple_match ball_Un 
				<span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits protocol.splits<span class="main">)</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"simple_match_port <span class="main">(</span>sports <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_sport <span class="free">p</span><span class="main">)</span>"</span></span>
			<span class="keyword1"><span class="command">using</span></span> mo xx<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sports <span class="free">r</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l4port_logic simple_packet_unext_def option2set_def prefix_match_semantics_simple_match <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	<span class="keyword1"><span class="command">next</span></span>
		<span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"simple_match_port <span class="main">(</span>dports <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_dport <span class="free">p</span><span class="main">)</span>"</span></span> 
		  <span class="keyword1"><span class="command">using</span></span> mo xx<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> xx<span class="main">(</span>4<span class="main">)</span> OF_match_fields_unsafe_def
			<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"dports <span class="free">r</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l4port_logic simple_packet_unext_def option2set_def prefix_match_semantics_simple_match <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">annotate_rlen</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">annotate_rlen</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">annotate_rlen</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">annotate_rlen</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"annotate_rlen <span class="inner_quoted">''asdf''</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="keyword1">CHR</span> <span class="inner_quoted">''a''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="keyword1">CHR</span> <span class="inner_quoted">''s''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="keyword1">CHR</span> <span class="inner_quoted">''d''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="keyword1">CHR</span> <span class="inner_quoted">''f''</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> fst_annotate_rlen_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">a</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">&lt;</span> length <span class="free">l</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_fst_annotate_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">using</span></span> fst_annotate_rlen_le <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> distinct_annotate_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">using</span></span> distinct_fst_annotate_rlen <span class="keyword1"><span class="command">unfolding</span></span> distinct_map <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">lemma</span></span> in_annotate_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">l</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> map_snd_annotate_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"map snd <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map fst <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fst_annotate_rlen_le<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"annotate_rlen <span class="free">l</span> <span class="main">=</span> zip <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">l</span><span class="main">]</span><span class="main">)</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="comment1">(* It would probably have been better to just use the zip, but oh well… *)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">annotate_rlen_code</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">annotate_rlen_code</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">annotate_rlen_code</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">annotate_rlen_code</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">aas</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>Suc <span class="bound">r</span><span class="main">,</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="bound">aas</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> annotate_rlen_len<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>annotate_rlen_code <span class="free">r</span><span class="main">)</span> <span class="main">=</span> length <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">lemma</span></span> annotate_rlen_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"annotate_rlen <span class="free">s</span> <span class="main">=</span> snd <span class="main">(</span>annotate_rlen_code <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">s</span> <span class="skolem">ss</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> annotate_rlen_len<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ss</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> suc2plus_inj_on<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span> <span class="main">::</span> len<span class="main">)</span> word<span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>unat <span class="main">(</span>max_word <span class="main">::</span> <span class="tfree">'l</span> word<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span>
   <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mmw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>max_word <span class="main">::</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mstp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
   <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">nat</span>
   <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>unat <span class="var">?mmw</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>unat <span class="var">?mmw</span><span class="main">}</span>"</span></span>
   <span class="keyword1"><span class="command">hence</span></span> se<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> unat <span class="var">?mmw</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≤</span> unat <span class="var">?mmw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
   <span class="keyword3"><span class="command">assume</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?mstp</span> <span class="skolem">x</span> <span class="main">=</span> <span class="var">?mstp</span> <span class="skolem">y</span>"</span></span>
   <span class="keyword1"><span class="command">note</span></span> f <span class="main">=</span> le_unat_uoi<span class="main">[</span><span class="operator">OF</span> se<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> le_unat_uoi<span class="main">[</span><span class="operator">OF</span> se<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
   <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq le_unat_uoi se <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_of_nat_list<span class="main">:</span> <span class="comment1">(* TODO: Move to CaesarWordLemmaBucket *)</span>
	<span class="quoted"><span class="quoted">"distinct <span class="free">l</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> set <span class="free">l</span><span class="main">.</span> <span class="bound">e</span> <span class="main">≤</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">::</span>len<span class="main">)</span> word<span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map <span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="tfree">'l</span> word<span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mmw</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>max_word <span class="main">::</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mstp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
	<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">as</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="skolem">as</span><span class="main">.</span> <span class="bound">e</span> <span class="main">≤</span> unat <span class="var">?mmw</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span> 
	<span class="keyword1"><span class="command">note</span></span> mIH <span class="main">=</span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
	<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mstp</span> <span class="skolem">a</span> <span class="main">∉</span> <span class="var">?mstp</span> <span class="main">`</span> set <span class="skolem">as</span>"</span></span>
	<span class="keyword1"><span class="command">proof</span></span> 
		<span class="keyword1"><span class="command">have</span></span> representable_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">as</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>unat <span class="var">?mmw</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span><span class="main">)</span><span class="main">.</span> <span class="bound">e</span> <span class="main">≤</span> unat max_word›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
		<span class="keyword1"><span class="command">have</span></span> a_reprbl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span>unat <span class="var">?mmw</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span><span class="main">)</span><span class="main">.</span> <span class="bound">e</span> <span class="main">≤</span> unat max_word›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mstp</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="var">?mstp</span> <span class="main">`</span> set <span class="skolem">as</span>"</span></span>
		<span class="keyword1"><span class="command">with</span></span> inj_on_image_mem_iff<span class="main">[</span><span class="operator">OF</span> suc2plus_inj_on a_reprbl representable_set<span class="main">]</span>
		<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="skolem">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
		<span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">as</span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">qed</span></span>
	<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> annotate_first_le_hlp<span class="main">:</span>
	<span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">&lt;</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span> <span class="main">::</span> len<span class="main">)</span> word<span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="main">(</span>map fst <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">e</span> <span class="main">≤</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">meson</span> fst_annotate_rlen_le less_trans nat_less_le<span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> distinct_of_prio_hlp <span class="main">=</span> distinct_of_nat_list<span class="main">[</span><span class="operator">OF</span> distinct_fst_annotate_rlen annotate_first_le_hlp<span class="main">]</span>
<span class="comment1">(* don't need these right now, but maybe later? *)</span>
                                                  
<span class="keyword1"><span class="command">lemma</span></span> fst_annotate_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"map fst <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">l</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_word_upt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span><span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">won</span> <span class="main">≡</span> <span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span> <span class="main">::</span> len<span class="main">)</span> word<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">≤</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="free">won</span> <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main"><span class="keyword3">;</span></span><span class="operator">clarsimp</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> le_SucI le_unat_uoi of_nat_Suc order_refl word_le_nat_alt<span class="main">)</span>
    <span class="comment1">(* This proof is kind of ugly. In case it breaks unfixably, go back to rev a9c4927 and get word_upto.
       The lemmas on word_upto can be used to shows this trivially. *)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_annotated<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">l</span> <span class="main">≤</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span> <span class="main">::</span> len<span class="main">)</span> word<span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map fst <span class="main">(</span>map <span class="main">(</span>apfst <span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="tfree">'l</span> word<span class="main">)</span><span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?won</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>of_nat <span class="main">::</span> nat <span class="main">⇒</span> <span class="tfree">'l</span> word<span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="var">?won</span> <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> 
		<span class="keyword1"><span class="command">using</span></span> sorted_word_upt<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
	<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map <span class="var">?won</span> <span class="main">(</span>map fst <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fst_annotate_rlen<span class="main">)</span>
	<span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map fst <span class="main">(</span>map <span class="main">(</span>apfst <span class="var">?won</span><span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="free">l</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹l3 device to l2 forwarding›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lr_of_tran_s3</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="free"><span class="bound"><span class="entity">ard</span></span></span> <span class="main">=</span> <span class="main">(</span>
	<span class="main">[</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1">case</span> <span class="bound">a</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="bound">c</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span><span class="main">.</span>
		<span class="main">(</span>p<span class="main">,</span>r<span class="main">,</span><span class="main">(</span>c<span class="main">,</span>a<span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ard</span></span></span><span class="main">,</span> b <span class="main">←</span> simple_match_to_of_match <span class="bound">r</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">oif_ne_iif_p1</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> <span class="main">[</span><span class="main">(</span>simple_match_any<span class="main">⦇</span>oiface <span class="main">:=</span> Iface <span class="bound">oif</span><span class="main">,</span> iiface <span class="main">:=</span> Iface <span class="bound">iif</span><span class="main">⦈</span><span class="main">,</span> simple_action.Accept<span class="main">)</span><span class="main">.</span> oif <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">,</span> iif <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">,</span> <span class="bound">oif</span> <span class="main">≠</span> <span class="bound">iif</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">oif_ne_iif_p2</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span>simple_match_any<span class="main">⦇</span>oiface <span class="main">:=</span> Iface <span class="bound">i</span><span class="main">,</span> iiface <span class="main">:=</span> Iface <span class="bound">i</span><span class="main">⦈</span><span class="main">,</span> simple_action.Drop<span class="main">)</span><span class="main">.</span> i <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">oif_ne_iif</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">=</span> oif_ne_iif_p2 <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">@</span> oif_ne_iif_p1 <span class="free"><span class="bound"><span class="entity">ifs</span></span></span>"</span></span> <span class="comment1">(* order irrelephant *)</span>
<span class="comment1">(*value "oif_ne_iif [''a'', ''b'']"*)</span>
<span class="comment1">(* I first tried something like "oif_ne_iif ifs ≡ [(simple_match_any⦇oiface := Iface oi, iiface := Iface ii⦈, if oi = ii then simple_action.Drop else simple_action.Accept). oi ← ifs, ii ← ifs]", 
   but making the statement I wanted with that was really tricky. Much easier to have the second element constant and do it separately. *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lr_of_tran_s4</span> <span class="free"><span class="bound"><span class="entity">ard</span></span></span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> generalized_fw_join <span class="free"><span class="bound"><span class="entity">ard</span></span></span> <span class="main">(</span>oif_ne_iif <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lr_of_tran_s1</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span>route2match <span class="bound">r</span><span class="main">,</span> output_iface <span class="main">(</span>routing_action <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> r <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lr_of_tran_fbs</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
	<span class="bound">gfw</span> <span class="main">=</span> map simple_rule_dtor <span class="free"><span class="bound"><span class="entity">fw</span></span></span><span class="main">;</span> <span class="comment1">― ‹generalized simple fw, hopefully for FORWARD›</span>
	<span class="bound">frt</span> <span class="main">=</span> lr_of_tran_s1 <span class="free"><span class="bound"><span class="entity">rt</span></span></span><span class="main">;</span> <span class="comment1">― ‹rt as fw›</span>
	<span class="bound">prd</span> <span class="main">=</span> generalized_fw_join <span class="bound">frt</span> <span class="bound">gfw</span>
	<span class="keyword1">in</span> <span class="bound">prd</span>
"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pack_OF_entries</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="free"><span class="bound"><span class="entity">ard</span></span></span> <span class="main">≡</span> <span class="main">(</span>map <span class="main">(</span>split3 OFEntry<span class="main">)</span> <span class="main">(</span>lr_of_tran_s3 <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="free"><span class="bound"><span class="entity">ard</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_oif_match</span> <span class="main">≡</span> list_all <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>match_sel <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lr_of_tran</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">if</span> <span class="main">¬</span> <span class="main">(</span>no_oif_match <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="main">∧</span> has_default_policy <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="main">∧</span> simple_fw_valid <span class="free"><span class="bound"><span class="entity">fw</span></span></span>	<span class="main">∧</span> valid_prefixes <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">∧</span> has_default_route <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">∧</span> distinct <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">)</span>
    <span class="keyword1">then</span> Inl <span class="inner_quoted">''Error in creating OpenFlow table: prerequisites not satisifed''</span>
    <span class="keyword1">else</span> <span class="main">(</span>
  <span class="keyword1">let</span>	<span class="bound">nrd</span> <span class="main">=</span> lr_of_tran_fbs <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span><span class="main">;</span>
	<span class="bound">ard</span> <span class="main">=</span> map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="bound">nrd</span><span class="main">)</span> <span class="comment1">― ‹give them a priority›</span>
	<span class="keyword1">in</span>
	<span class="keyword1">if</span> length <span class="bound">nrd</span> <span class="main">&lt;</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>
	<span class="keyword1">then</span> Inr <span class="main">(</span>pack_OF_entries <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="bound">ard</span><span class="main">)</span>
	<span class="keyword1">else</span> Inl <span class="inner_quoted">''Error in creating OpenFlow table: priority number space exhausted''</span><span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_iface_name</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> <span class="main">¬</span>Iface.iface_name_is_wildcard <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_iface_list</span> <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">≡</span> distinct <span class="free"><span class="bound"><span class="entity">ifs</span></span></span> <span class="main">∧</span> list_all is_iface_name <span class="free"><span class="bound"><span class="entity">ifs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> max_16_word_max<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0xffff</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">0xFFFF</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> <span class="main">1</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
	<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> replicate_FT_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="numeral">16</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≤</span> <span class="numeral">16</span> <span class="main">⟹</span> replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="free">x</span> True <span class="main">=</span> replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="free">y</span> True <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ns</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">6</span><span class="main">,</span><span class="numeral">7</span><span class="main">,</span><span class="numeral">8</span><span class="main">,</span><span class="numeral">9</span><span class="main">,</span><span class="numeral">10</span><span class="main">,</span><span class="numeral">11</span><span class="main">,</span><span class="numeral">12</span><span class="main">,</span><span class="numeral">13</span><span class="main">,</span><span class="numeral">14</span><span class="main">,</span><span class="numeral">15</span><span class="main">,</span><span class="numeral">16</span><span class="main">}</span>"</span></span>
	<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="numeral">16</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≤</span> <span class="numeral">16</span>"</span></span>
	<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="var">?ns</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="var">?ns</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">presburger</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
	<span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="free">x</span> True <span class="main">=</span> replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="free">y</span> True"</span></span>
	<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numeral_eq_Suc<span class="main">)</span> <span class="comment1">(* that's only 289 subgoals after the elim *)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mask_inj_hlp1<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>mask <span class="main">::</span> nat <span class="main">⇒</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="numeral">16</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> inj_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> oe<span class="main">:</span> <span class="quoted"><span class="quoted">"of_bl <span class="main">(</span>replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="skolem">x</span> True<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>of_bl <span class="main">(</span>replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">y</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="skolem">y</span> True<span class="main">)</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>"</span></span>
         <span class="keyword1"><span class="command">unfolding</span></span> mask_bl of_bl_rep_False <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="numeral">16</span> <span class="main">⟹</span> length <span class="main">(</span>replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="bound">z</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="bound">z</span> True<span class="main">)</span> <span class="main">=</span> <span class="numeral">16</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> 1<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> ps<span class="main">:</span> <span class="quoted"><span class="quoted">"replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">x</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="skolem">x</span> True <span class="main">∈</span> <span class="main">{</span><span class="bound">bl</span><span class="main">.</span> length <span class="bound">bl</span> <span class="main">=</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="numeral">16</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">" replicate <span class="main">(</span><span class="numeral">16</span> <span class="main">-</span> <span class="skolem">y</span><span class="main">)</span> False <span class="main">@</span> replicate <span class="skolem">y</span> True <span class="main">∈</span> <span class="main">{</span><span class="bound">bl</span><span class="main">.</span> length <span class="bound">bl</span> <span class="main">=</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="numeral">16</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> inj_onD<span class="main">[</span><span class="operator">OF</span> word_bl.Abs_inj_on<span class="main">,</span> <span class="operator">OF</span> oe ps<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> replicate_FT_hlp<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_simple_match_to_of_match_portlist_hlp<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ps</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">16</span> word <span class="main">×</span> <span class="numeral">16</span> word<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ifs</span> <span class="main">⟹</span>
    distinct
     <span class="main">(</span><span class="keyword1">if</span> fst <span class="free">ps</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> snd <span class="free">ps</span> <span class="main">=</span> max_word <span class="keyword1">then</span> <span class="main">[</span>None<span class="main">]</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> fst <span class="free">ps</span> <span class="main">≤</span> snd <span class="free">ps</span>
           <span class="keyword1">then</span> map <span class="main">(</span>Some <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">pfx</span><span class="main">.</span> <span class="main">(</span>pfxm_prefix <span class="bound">pfx</span><span class="main">,</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="bound">pfx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="main">(</span>fst <span class="free">ps</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">ps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> di<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">ifs</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">wis</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">wis</span> <span class="main">=</span> set <span class="main">(</span>wordinterval_CIDR_split_prefixmatch <span class="main">(</span>WordInterval <span class="main">(</span>fst <span class="free">ps</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">ps</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> prefix_match"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xm</span></span> <span class="skolem"><span class="skolem">xn</span></span> <span class="skolem"><span class="skolem">ym</span></span> <span class="skolem"><span class="skolem">yn</span></span> <span class="keyword2"><span class="keyword">where</span></span> xyd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> PrefixMatch <span class="skolem">xm</span> <span class="skolem">xn</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> PrefixMatch <span class="skolem">ym</span> <span class="skolem">yn</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> iw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">wis</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">wis</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> et<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pfxm_prefix <span class="skolem">x</span><span class="main">,</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>pfxm_prefix <span class="skolem">y</span><span class="main">,</span> <span class="main">~~</span> <span class="main">(</span>pfxm_mask <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> le16<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xn</span> <span class="main">≤</span> <span class="numeral">16</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">yn</span> <span class="main">≤</span> <span class="numeral">16</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> wis_def <span class="keyword1"><span class="command">using</span></span> wordinterval_CIDR_split_prefixmatch_all_valid_Ball<span class="main">[</span><span class="operator">unfolded</span> Ball_def<span class="main">,</span> <span class="operator">THEN</span> spec<span class="main">,</span> <span class="operator">THEN</span> mp<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> et <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> <span class="main">-</span> <span class="skolem">xn</span> <span class="main">=</span> <span class="numeral">16</span> <span class="main">-</span> <span class="skolem">yn</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> pfxm_mask_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> mask_inj_hlp1<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> inj_onD<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> et le16 <span class="keyword1"><span class="command">using</span></span> diff_diff_cancel <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smtoms_eq_hlp distinct_map wordinterval_CIDR_split_distinct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> comp_inj_on_iff<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> inj_onI<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_simple_match_to_of_match<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">ifs</span> <span class="main">⟹</span> distinct <span class="main">(</span>simple_match_to_of_match <span class="free">m</span> <span class="free">ifs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> simple_match_to_of_match_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> distinct_3lcomprI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ifs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> distinct_simple_match_to_of_match_portlist_hlp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> distinct_simple_match_to_of_match_portlist_hlp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smtoms_eq_hlp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_inj_on<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="free">F</span> <span class="main">⟹</span> inj_on <span class="free">F</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subset_inj_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="comment1">(* TODO: include Word_Lib *)</span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_lroft_hlp2<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> distinct <span class="main">(</span><span class="free">fm</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
    distinct <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="free">fs</span> <span class="bound">a</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">fm</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="free">amr</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">amr</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> injI inj_onI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_map <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_lroft_s3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span><span class="main">;</span> distinct <span class="free">ifs</span><span class="main">⟧</span> <span class="main">⟹</span> distinct <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_s3_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> no_overlaps_lroft_hlp2<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_simple_match_to_of_match<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_lroft_hlp3<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span> <span class="main">⟹</span>
<span class="main">(</span><span class="free">aa</span><span class="main">,</span> <span class="free">ab</span><span class="main">,</span> <span class="free">ac</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">ba</span><span class="main">,</span> <span class="free">bb</span><span class="main">,</span> <span class="free">bc</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span> <span class="main">⟹</span>
<span class="free">ac</span> <span class="main">≠</span> <span class="free">bc</span> <span class="main">⟹</span> <span class="free">aa</span> <span class="main">≠</span> <span class="free">ba</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> lr_of_tran_s3_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> simple_action.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> map_of_eq_Some_iff old.prod.inject option.inject<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> map_of_eq_Some_iff old.prod.inject option.inject simple_action.distinct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_lroft_s3_hlp_hlp<span class="main">:</span> <span class="comment1">(* I hlps *)</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span><span class="main">;</span> OF_match_fields_unsafe <span class="free">ab</span> <span class="free">p</span><span class="main">;</span> <span class="free">ab</span> <span class="main">≠</span> <span class="free">ad</span> <span class="main">∨</span> <span class="free">ba</span> <span class="main">≠</span> <span class="free">bb</span><span class="main">;</span> OF_match_fields_unsafe <span class="free">ad</span> <span class="free">p</span><span class="main">;</span>
        <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="free">ab</span><span class="main">,</span> <span class="free">ba</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="free">ad</span><span class="main">,</span> <span class="free">bb</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span><span class="main">⟧</span>
       <span class="main">⟹</span> False"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">have</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span><span class="main">;</span>  <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="skolem">ab</span><span class="main">,</span> <span class="skolem">x1</span><span class="main">,</span> <span class="skolem">x2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">amr</span><span class="main">;</span> <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="skolem">bb</span><span class="main">,</span> <span class="skolem">x4</span><span class="main">,</span> <span class="skolem">x5</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">amr</span><span class="main">;</span> <span class="skolem">ab</span> <span class="main">≠</span> <span class="skolem">bb</span><span class="main">⟧</span>
       <span class="main">⟹</span> False"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">ab</span> <span class="skolem">x1</span> <span class="skolem">x2</span> <span class="skolem">bb</span> <span class="skolem">x4</span> <span class="skolem">x5</span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> distinct_map_fstD old.prod.inject<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> conjunctSomeProtoAnyD<span class="main">:</span> <span class="quoted"><span class="quoted">"Some ProtoAny <span class="main">=</span> simple_proto_conjunct <span class="skolem">a</span> <span class="main">(</span>Proto <span class="skolem">b</span><span class="main">)</span> <span class="main">⟹</span> False"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">using</span></span> conjunctProtoD <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">have</span></span> 5<span class="main">:</span>
       <span class="quoted"><span class="quoted">"<span class="main">⟦</span>OF_match_fields_unsafe <span class="skolem">am</span> <span class="free">p</span><span class="main">;</span> OF_match_fields_unsafe <span class="skolem">bm</span> <span class="free">p</span><span class="main">;</span> <span class="skolem">am</span> <span class="main">≠</span> <span class="skolem">bm</span><span class="main">;</span> 
        <span class="skolem">am</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="skolem">ab</span> <span class="free">ifs</span><span class="main">)</span><span class="main">;</span> <span class="skolem">bm</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="skolem">bb</span> <span class="free">ifs</span><span class="main">)</span><span class="main">;</span> <span class="main">¬</span> <span class="skolem">ab</span> <span class="main">≠</span> <span class="skolem">bb</span><span class="main">⟧</span>
       <span class="main">⟹</span> False"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">ab</span> <span class="skolem">bb</span> <span class="skolem">am</span> <span class="skolem">bm</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarify</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">unfold</span>
         simple_match_to_of_match_def smtoms_eq_hlp Let_def set_concat set_map de_Morgan_conj not_False_eq_True<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> conjunctSomeProtoAnyD cidrsplit_no_overlaps
	            <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OF_match_fields_unsafe_def simple_match_to_of_match_single_def option2set_def comp_def
	            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits
	            <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> smtoms_eq_hlp<span class="main">)</span> <span class="comment1">(*1min*)</span>
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> 4 5 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lr_of_tran_s3_def<span class="main">)</span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">metis</span> no_overlaps_lroft_hlp3<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> no_overlaps_lroft_s3_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">amr</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="free">ifs</span> <span class="main">⟹</span> 
no_overlaps OF_match_fields_unsafe <span class="main">(</span>map <span class="main">(</span>split3 OFEntry<span class="main">)</span> <span class="main">(</span>lr_of_tran_s3 <span class="free">ifs</span> <span class="free">amr</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> no_overlapsI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> distinct_map<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> distinct_lroft_s3<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> inj_inj_on<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> injI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> x y<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split3_def<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> check_no_overlap_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> set_map<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> split3_def prod.simps flow_entry_match.simps flow_entry_match.sel de_Morgan_conj<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> no_overlaps_lroft_s3_hlp_hlp<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_no_overlaps<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ifs</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inr <span class="free">t</span> <span class="main">=</span> <span class="main">(</span>lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="main">⟹</span> no_overlaps OF_match_fields_unsafe <span class="free">t</span>"</span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> lr_of_tran_def Let_def pack_OF_entries_def<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> distinct_of_prio_hlp<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> no_overlaps_lroft_s3_hlp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_lr_of_tran_s3_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">f</span><span class="main">.</span> fst <span class="bound">x</span> <span class="main">≤</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s3 <span class="free">s</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟹</span> fst <span class="free">b</span> <span class="main">≤</span> <span class="free">a</span>"</span></span> 
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lr_of_tran_s3_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_s3_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"lr_of_tran_s3 <span class="free">ifs</span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">ard</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
	<span class="main">[</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1">case</span> <span class="bound">a</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="bound">c</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span><span class="main">.</span>
		<span class="main">(</span>p<span class="main">,</span>r<span class="main">,</span><span class="main">(</span>c<span class="main">,</span>a<span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">,</span> b <span class="main">←</span> simple_match_to_of_match <span class="bound">r</span> <span class="free">ifs</span><span class="main">]</span><span class="main">)</span> <span class="main">@</span> lr_of_tran_s3 <span class="free">ifs</span> <span class="free">ard</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lr_of_tran_s3_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_lr_of_tran_s3<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted_descending <span class="main">(</span>map fst <span class="free">f</span><span class="main">)</span> <span class="main">⟹</span> sorted_descending <span class="main">(</span>map fst <span class="main">(</span>lr_of_tran_s3 <span class="free">s</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lr_of_tran_s3_def<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lr_of_tran_s3_Cons map_concat comp_def<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> sorted_descending_append<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_descending_alt rev_map sorted_lr_of_tran_s3_hlp sorted_const<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_lr_of_tran_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ofe_prio <span class="main">∘</span> split3 OFEntry<span class="main">)</span> <span class="main">=</span> fst"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff comp_def split3_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_sorted_descending<span class="main">:</span> <span class="quoted"><span class="quoted">"Inr <span class="free">r</span> <span class="main">=</span> lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">⟹</span> sorted_descending <span class="main">(</span>map ofe_prio <span class="free">r</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> lr_of_tran_def Let_def<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> sorted_lr_of_tran_hlp pack_OF_entries_def split3_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> fun_app_def map_map comp_def prod.case_distrib<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fst_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> sorted_lr_of_tran_s3<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> sorted_annotated<span class="main"><span class="main">[</span></span><span class="operator">OF</span> less_or_eq_imp_le<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> disjI1<span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_s1_split<span class="main">:</span> <span class="quoted"><span class="quoted">"lr_of_tran_s1 <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">rt</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>route2match <span class="free">a</span><span class="main">,</span> output_iface <span class="main">(</span>routing_action <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">#</span> lr_of_tran_s1 <span class="free">rt</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold</span> lr_of_tran_s1_def list.map<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> route2match_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>routing_match <span class="free">a</span><span class="main">)</span> <span class="main">⟹</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="free">a</span><span class="main">)</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> simple_matches <span class="main">(</span>route2match <span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> route2match_def simple_matches.simps match_ifaceAny match_iface_refl ipset_from_cidr_0 prefix_match_semantics_ipset_from_netmask2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> s1_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span> <span class="main">⟹</span> has_default_route <span class="main">(</span><span class="free">rt</span><span class="main">::</span><span class="main">(</span><span class="tfree">'i</span><span class="main">::</span>len<span class="main">)</span> prefix_routing<span class="main">)</span> <span class="main">⟹</span> 
  <span class="main">∃</span><span class="bound">rm</span> <span class="bound">ra</span><span class="main">.</span> generalized_sfw <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">rm</span><span class="main">,</span><span class="bound">ra</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">ra</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">rt</span></span><span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> valid_prefixes_split<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a rt
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> routing_m metric routing_action<span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">routing_m</span></span><span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefix_def pfxm_mask_def prefix_match_semantics_def generalized_sfw_def 
	       lr_of_tran_s1_def route2match_def simple_matches.simps match_ifaceAny match_iface_refl ipset_from_cidr_0
	       max_word_mask<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'i</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generalized_sfw_def lr_of_tran_s1_def route2match_correct<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> route2match_def simple_matches.simps prefix_match_semantics_ipset_from_netmask2 
                    lr_of_tran_s1_split generalized_sfw_simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">to_OF_action</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">d</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="bound">p</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_OF_action</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> <span class="main">(</span><span class="inner_quoted">''''</span><span class="main">,</span>simple_action.Drop<span class="main">)</span> <span class="main">|</span> <span class="main">[</span>Forward <span class="bound">p</span><span class="main">]</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> simple_action.Accept<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> OF_match_linear_not_noD<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="free">oms</span> <span class="free">p</span> <span class="main">≠</span> NoAction <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ome</span><span class="main">.</span> <span class="bound">ome</span> <span class="main">∈</span> set <span class="free">oms</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">ome</span><span class="main">)</span> <span class="free">p</span>"</span></span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">oms</span></span><span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
	<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
	 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> s3_noaction_hlp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>simple_match_valid <span class="free">ac</span><span class="main">;</span> <span class="main">¬</span>simple_matches <span class="free">ac</span> <span class="free">p</span><span class="main">;</span> match_iface <span class="main">(</span>oiface <span class="free">ac</span><span class="main">)</span> <span class="main">(</span>p_oiface <span class="free">p</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> 
OF_match_linear OF_match_fields_safe <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> split3 OFEntry <span class="main">(</span><span class="free">x1</span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="keyword1">case</span> <span class="free">ba</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="free">ad</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>simple_match_to_of_match <span class="free">ac</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> NoAction"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> OF_match_linear_not_noD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"all_prerequisites <span class="improper">x</span>"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> simple_match_to_of_matchD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split3_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> of_match_fields_safe_eq2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">using</span></span> simple_match_to_of_match_generates_prereqs <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="free">v</span> <span class="main">=</span> Some <span class="free">x</span> <span class="main">⟹</span> the <span class="free">v</span> <span class="main">=</span> <span class="free">x</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> s3_correct<span class="main">:</span>
	<span class="keyword2"><span class="keyword">assumes</span></span> vsfwm<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all simple_match_valid <span class="main">(</span>map <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="free">ard</span><span class="main">)</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> ippkt<span class="main">:</span> <span class="quoted"><span class="quoted">"p_l2type <span class="free">p</span> <span class="main">=</span> <span class="numeral">0x800</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> iiifs<span class="main">:</span> <span class="quoted"><span class="quoted">"p_iiface <span class="free">p</span> <span class="main">∈</span> set <span class="free">ifs</span>"</span></span>
	<span class="keyword2"><span class="keyword">assumes</span></span> oiifs<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="free">ard</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_match_linear OF_match_fields_safe <span class="main">(</span>pack_OF_entries <span class="free">ifs</span> <span class="free">ard</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">ao</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span> <span class="bound">af</span><span class="main">.</span> generalized_sfw <span class="main">(</span>map snd <span class="free">ard</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">af</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">if</span> snd <span class="bound">af</span> <span class="main">=</span> simple_action.Drop <span class="keyword1">then</span> <span class="free">ao</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="free">ao</span> <span class="main">=</span> <span class="main">[</span>Forward <span class="main">(</span>fst <span class="bound">af</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pack_OF_entries_def lr_of_tran_s3_def fun_app_def
<span class="keyword1"><span class="command">using</span></span> vsfwm oiifs
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ard</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generalized_sfw_simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generalized_sfw_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span> <span class="comment1">(* make two subgoals from one *)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ard x1 ac ad ba
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OF_match_linear_append <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> simple_match_to_of_matchI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> iiifs<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ippkt<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> 
       OF_match_linear_match_allsameaction<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span>
         γ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">OF_match_fields_safe</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> pri <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">x1</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span>
         oms <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"simple_match_to_of_match <span class="skolem">ac</span> <span class="free">ifs</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> 
         act <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">ba</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="skolem">ad</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> OF_match_fields_safe_def comp_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> aux<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> iffI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">ac</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">ad</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">ba</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split3_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> simple_action.splits flowtable_behavior.splits if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rename_tac</span> b<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ard x1 ac ad ba
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> OF_match_linear_append OF_match_fields_safe_def comp_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"OF_match_linear OF_match_fields_safe <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> split3 OFEntry <span class="main">(</span><span class="skolem">x1</span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="keyword1">case</span> <span class="skolem">ba</span> <span class="keyword1">of</span> simple_action.Accept <span class="main">⇒</span> <span class="main">[</span>Forward <span class="skolem">ad</span><span class="main">]</span> <span class="main">|</span> simple_action.Drop <span class="main">⇒</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>simple_match_to_of_match <span class="skolem">ac</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> NoAction"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> s3_noaction_hlp<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> match_ifaceAny<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_prefix_00<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_s1_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span> <span class="main">⟹</span> gsfw_valid <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_s1_def route2match_def gsfw_valid_def list_all_iff
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_match_valid_def valid_prefix_fw_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefixes_alt_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_valid_fbs_rlen<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>valid_prefixes <span class="free">rt</span><span class="main">;</span> simple_fw_valid <span class="free">fw</span><span class="main">;</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">aa</span><span class="main">,</span> <span class="free">ab</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> simple_match_valid <span class="free">aa</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">note</span></span> 1<span class="main">[</span><span class="operator">unfolded</span> lr_of_tran_fbs_def Let_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gsfw_validI 1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 lr_of_tran_s1_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>generalized_fw_join <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span> <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gsfw_join_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">aa</span><span class="main">,</span> <span class="free">ab</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">using</span></span> in_annotate_rlen <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_fbs_def Let_def gsfw_valid_def list_all_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_match_valid_fbs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>valid_prefixes <span class="free">rt</span><span class="main">;</span> simple_fw_valid <span class="free">fw</span><span class="main">⟧</span> <span class="main">⟹</span> list_all simple_match_valid <span class="main">(</span>map fst <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">note</span></span> 1<span class="main">[</span><span class="operator">unfolded</span> lr_of_tran_fbs_def Let_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gsfw_validI 1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 lr_of_tran_s1_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"gsfw_valid <span class="main">(</span>generalized_fw_join <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span> <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gsfw_join_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_fbs_def Let_def gsfw_valid_def list_all_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_prereqs<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span> <span class="main">⟹</span> simple_fw_valid <span class="free">fw</span> <span class="main">⟹</span> lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">=</span> Inr <span class="free">oft</span> <span class="main">⟹</span>
list_all <span class="main">(</span>all_prerequisites <span class="main">∘</span> ofe_fields<span class="main">)</span> <span class="free">oft</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_def pack_OF_entries_def lr_of_tran_s3_def Let_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_concat comp_def prod.case_distrib split3_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> simple_match_valid_fbs_rlen<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> simple_match_to_of_match_generates_prereqs<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* TODO: move. where? *)</span>
<span class="keyword1"><span class="command">lemma</span></span> OF_unsafe_safe_match3_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"
  list_all <span class="main">(</span>all_prerequisites <span class="main">∘</span> ofe_fields<span class="main">)</span> <span class="free">oft</span> <span class="main">⟹</span>
  OF_priority_match OF_match_fields_unsafe <span class="free">oft</span> <span class="main">=</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_priority_match_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">packet</span><span class="main">.</span> <span class="main">[</span><span class="bound">f</span><span class="main">←</span><span class="free">oft</span> <span class="main">.</span> OF_match_fields_unsafe <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="bound">packet</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="bound">f</span><span class="main">←</span><span class="free">oft</span> <span class="main">.</span> OF_match_fields_safe <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="bound">packet</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff of_match_fields_safe_eq<span class="main">)</span> 
  <span class="keyword1"><span class="command">using</span></span> of_match_fields_safe_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> filter_cong<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> OF_unsafe_safe_match_linear_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"
  list_all <span class="main">(</span>all_prerequisites <span class="main">∘</span> ofe_fields<span class="main">)</span> <span class="free">oft</span> <span class="main">⟹</span>
  OF_match_linear OF_match_fields_unsafe <span class="free">oft</span> <span class="main">=</span> OF_match_linear OF_match_fields_safe <span class="free">oft</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">oft</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff of_match_fields_safe_eq<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> simple_action_ne<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> simple_action.Accept <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> simple_action.Drop"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> simple_action.Drop <span class="main">⟷</span> <span class="free">b</span> <span class="main">=</span> simple_action.Accept"</span></span>
<span class="keyword1"><span class="command">using</span></span> simple_action.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_snd_apfst<span class="main">:</span> <span class="quoted"><span class="quoted">"map snd <span class="main">(</span>map <span class="main">(</span>apfst <span class="free">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> map snd <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_map comp_def snd_apfst <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> match_ifaceAny_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"oiface <span class="free">m</span> <span class="main">=</span> ifaceAny <span class="main">⟹</span> simple_matches <span class="free">m</span> <span class="free">p</span> <span class="main">=</span> simple_matches <span class="free">m</span> <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">any</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_matches.simps match_ifaceAny<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> no_oif_matchD<span class="main">:</span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span> <span class="main">⟹</span> simple_fw <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> simple_fw <span class="free">fw</span> <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">any</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">fw</span></span><span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_oif_match_def simple_fw_alt <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> match_ifaceAny_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_fbs_acceptD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="free">oif</span><span class="main">,</span> simple_action.Accept<span class="main">)</span> <span class="main">⟹</span>
  simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">oif</span><span class="main">⦈</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">note</span></span> 1<span class="main">[</span><span class="operator">unfolded</span> lr_of_tran_fbs_def Let_def<span class="main">,</span> <span class="operator">THEN</span> generalized_fw_joinD<span class="main">]</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> r1 <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> r2 <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> r12 <span class="main">=</span> this
  <span class="keyword1"><span class="command">note</span></span> s1_correct<span class="main">[</span><span class="operator">OF</span> s1<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> rm <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> ra <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> rmra <span class="main">=</span> this
  <span class="keyword1"><span class="command">from</span></span> r12 rmra <span class="keyword1"><span class="command">have</span></span> oifra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">oif</span> <span class="main">=</span> <span class="skolem">ra</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> r12 <span class="keyword1"><span class="command">have</span></span> sfw<span class="main">:</span> <span class="quoted"><span class="quoted">"simple_fw <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Decision FinalAllow"</span></span> <span class="keyword1"><span class="command">using</span></span> simple_fw_iff_generalized_fw_accept <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> ifupdateirrel <span class="main">=</span> no_oif_matchD<span class="main">[</span><span class="operator">OF</span> s2<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> any <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">" output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> p <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> simple_linux_router_nol12_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def ifupdateirrel sfw oifra rmra <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits option.splits<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_fbs_acceptI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_policy <span class="free">fw</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">oif</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">r</span><span class="main">.</span> generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="free">oif</span><span class="main">,</span> simple_action.Accept<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> s2 <span class="keyword1"><span class="command">have</span></span> nud<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> simple_fw <span class="free">fw</span> <span class="bound">p</span> <span class="main">≠</span> Undecided"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> has_default_policy state.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ifupdateirrel <span class="main">=</span> no_oif_matchD<span class="main">[</span><span class="operator">OF</span> s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple_fw <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Decision FinalAllow"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def nud ifupdateirrel <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits state.splits final_decision.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> simple_action.Accept<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> simple_fw_iff_generalized_fw_accept <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> oif_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">oif</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def nud ifupdateirrel <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits state.splits final_decision.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> s1_correct<span class="main">[</span><span class="operator">OF</span> s1<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> rm <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> ra <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> rmra <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_fbs_def Let_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> generalized_fw_joinI<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> oif_def <span class="keyword1"><span class="command">using</span></span> rmra <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> r<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_fbs_dropD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="free">oif</span><span class="main">,</span> simple_action.Drop<span class="main">)</span> <span class="main">⟹</span>
  simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ifupdateirrel <span class="main">=</span> no_oif_matchD<span class="main">[</span><span class="operator">OF</span> s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">from</span></span> 1<span class="main">[</span><span class="operator">unfolded</span> lr_of_tran_fbs_def Let_def<span class="main">,</span> <span class="operator">THEN</span> generalized_fw_joinD<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">rr</span></span> <span class="skolem"><span class="skolem">fr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">rr</span><span class="main">,</span> <span class="free">oif</span><span class="main">)</span> <span class="main">∧</span>
          generalized_sfw <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">fr</span><span class="main">,</span> simple_action.Drop<span class="main">)</span> <span class="main">∧</span> Some <span class="free">r</span> <span class="main">=</span> simple_match_and <span class="skolem">rr</span> <span class="skolem">fr</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">hence</span></span> fd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> simple_fw <span class="free">fw</span> <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="bound">u</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> Decision FinalDeny"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ifupdateirrel
  <span class="keyword1"><span class="command">using</span></span> simple_fw_iff_generalized_fw_drop <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def fd <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_fbs_dropI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_policy <span class="free">fw</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> None <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">r</span> <span class="bound">oif</span><span class="main">.</span> generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">oif</span><span class="main">,</span> simple_action.Drop<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> s2 <span class="keyword1"><span class="command">have</span></span> nud<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> simple_fw <span class="free">fw</span> <span class="bound">p</span> <span class="main">≠</span> Undecided"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> has_default_policy state.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ifupdateirrel <span class="main">=</span> no_oif_matchD<span class="main">[</span><span class="operator">OF</span> s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple_fw <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Decision FinalDeny"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def nud ifupdateirrel <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits state.splits final_decision.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>map simple_rule_dtor <span class="free">fw</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> simple_action.Drop<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> simple_fw_iff_generalized_fw_drop <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">note</span></span> s1_correct<span class="main">[</span><span class="operator">OF</span> s1<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> rm <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> ra <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> rmra <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_fbs_def Let_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">ra</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> generalized_fw_joinI<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> rmra <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> r<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> no_oif_match_fbs<span class="main">:</span>
 <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span> <span class="main">⟹</span> list_all <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">mr</span> <span class="bound">ar</span> <span class="bound">mf</span> <span class="bound">af</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">mr</span><span class="main">,</span> <span class="bound">ar</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>lr_of_tran_s1 <span class="free">rt</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="bound">mf</span><span class="main">,</span> <span class="bound">af</span><span class="main">)</span> <span class="main">∈</span> simple_rule_dtor <span class="main">`</span> set <span class="free">fw</span><span class="main">;</span> simple_match_and <span class="bound">mr</span> <span class="bound">mf</span> <span class="main">=</span> Some <span class="bound">a</span><span class="main">⟧</span> <span class="main">⟹</span> oiface <span class="bound">a</span> <span class="main">=</span> ifaceAny"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">mr</span> <span class="skolem">ar</span> <span class="skolem">mf</span> <span class="skolem">af</span> <span class="skolem">f</span> <span class="skolem">a</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"oiface <span class="skolem">mr</span> <span class="main">=</span> ifaceAny"</span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_s1_def route2match_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.image_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"oiface <span class="skolem">mf</span> <span class="main">=</span> ifaceAny"</span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹no_oif_match <span class="free">fw</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> no_oif_match_def simple_rule_dtor_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_all_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> simple_rule.splits<span class="main">)</span> <span class="operator">fastforce</span> 
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">mr</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">mf</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iface_conjunct_ifaceAny <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> la<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_fbs_def Let_def list_all_iff
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> generalized_sfw_join_set<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="main">∘</span> snd"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> comp_def <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> * list_all_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> map_snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">using</span></span> la <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> lr_of_tran_correct<span class="main">:</span>
	<span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">32</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> nerr<span class="main">:</span> <span class="quoted"><span class="quoted">"lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">=</span> Inr <span class="free">oft</span>"</span></span>
	 <span class="keyword2"><span class="keyword">and</span></span> ippkt<span class="main">:</span> <span class="quoted"><span class="quoted">"p_l2type <span class="free">p</span> <span class="main">=</span> <span class="numeral">0x800</span>"</span></span>
	 <span class="keyword2"><span class="keyword">and</span></span> ifvld<span class="main">:</span> <span class="quoted"><span class="quoted">"p_iiface <span class="free">p</span> <span class="main">∈</span> set <span class="free">ifs</span>"</span></span>
	<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[</span>Forward <span class="free">oif</span><span class="main">]</span> <span class="main">⟷</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">oif</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
	      <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[]</span> <span class="main">⟷</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> None"</span></span>
	      <span class="comment1">(* fun stuff: *)</span>
	      <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> NoAction"</span></span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span>
	      <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">ls</span> <span class="main">⟶</span> length <span class="free">ls</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
	      <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ls</span><span class="main">.</span> length <span class="bound">ls</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="bound">ls</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
	<span class="keyword1"><span class="command">have</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_prefixes <span class="free">rt</span>"</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span>"</span></span> 
   <span class="keyword2"><span class="keyword">and</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"has_default_policy <span class="free">fw</span>"</span></span> <span class="quoted"><span class="quoted">"simple_fw_valid <span class="free">fw</span>"</span></span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> difs<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">ifs</span>"</span></span>
	  <span class="keyword1"><span class="command">using</span></span> nerr <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free">fw</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nerr <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> s2 <span class="main">=</span> s2 this
  <span class="keyword1"><span class="command">have</span></span> unsafe_safe_eq<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_unsafe <span class="free">oft</span> <span class="main">=</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span>"</span></span>
    <span class="quoted"><span class="quoted">"OF_match_linear OF_match_fields_unsafe <span class="free">oft</span> <span class="main">=</span> OF_match_linear OF_match_fields_safe <span class="free">oft</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> OF_unsafe_safe_match3_eq<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> lr_of_tran_prereqs s1 s2 nerr refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> OF_unsafe_safe_match_linear_eq<span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> lr_of_tran_prereqs s1 s2 nerr refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> lin<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="main">=</span> OF_match_linear OF_match_fields_safe <span class="free">oft</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> OF_eq<span class="main">[</span><span class="operator">OF</span> lr_of_tran_no_overlaps lr_of_tran_sorted_descending<span class="main">,</span> <span class="operator">OF</span> difs nerr<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> nerr<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff unsafe_safe_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ard</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> oft_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">oft</span> <span class="main">=</span> pack_OF_entries <span class="free">ifs</span> <span class="var">?ard</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nerr <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_def Let_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> vld<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all simple_match_valid <span class="main">(</span>map <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="var">?ard</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_app_def map_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> snd_apfst map_snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">using</span></span> simple_match_valid_fbs<span class="main">[</span><span class="operator">OF</span> s1<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> s2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> oiface <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ifaceAny<span class="main">)</span> <span class="var">?ard</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> no_oif_match_fbs<span class="main">[</span><span class="operator">OF</span> s2<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> not_undec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> simple_fw <span class="free">fw</span> <span class="bound">p</span> <span class="main">≠</span> Undecided"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> has_default_policy s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> state.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> w1_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">oif</span><span class="main">.</span> OF_match_linear OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[</span>Forward <span class="bound">oif</span><span class="main">]</span> <span class="main">⟹</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="bound">oif</span><span class="main">⦈</span><span class="main">)</span> 
    <span class="main">∧</span> <span class="bound">oif</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">oif</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> s3_correct<span class="main">[</span><span class="operator">OF</span> vld ippkt ifvld<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main">,</span> <span class="operator">THEN</span> iffD1<span class="main">,</span> <span class="operator">unfolded</span> oft_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">OF</span> 1<span class="main">]</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">r</span><span class="main">.</span> generalized_sfw <span class="main">(</span>map snd <span class="main">(</span>map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="main">(</span><span class="skolem">oif</span><span class="main">,</span> simple_action.Accept<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="main">(</span><span class="skolem">oif</span><span class="main">,</span> simple_action.Accept<span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> map_map comp_def snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> lr_of_tran_fbs_acceptD<span class="main">[</span><span class="operator">OF</span> s1 s2<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oif</span> <span class="main">=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def not_undec <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits state.splits final_decision.splits<span class="main">)</span> 
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> w1_2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">oif</span><span class="main">.</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="bound">oif</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⟹</span> OF_match_linear OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[</span>Forward <span class="bound">oif</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">oif</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> lr_of_tran_fbs_acceptI<span class="main">[</span><span class="operator">OF</span> s1 s2<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">ifs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span> r <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">note</span></span> r <span class="main">=</span> this
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>map snd <span class="main">(</span>map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="main">(</span><span class="skolem">oif</span><span class="main">,</span> simple_action.Accept<span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> map_snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> s3_correct<span class="main">[</span><span class="operator">OF</span> vld ippkt ifvld<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main">,</span> <span class="operator">THEN</span> iffD2<span class="main">,</span> <span class="operator">unfolded</span> oft_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>Forward <span class="skolem">oif</span><span class="main">]</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> w1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">oif</span><span class="main">.</span> <span class="main">(</span>OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[</span>Forward <span class="bound">oif</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="bound">oif</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lin <span class="keyword1"><span class="command">using</span></span> w1_1 w1_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> w2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lin
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1
    <span class="keyword1"><span class="command">note</span></span> s3_correct<span class="main">[</span><span class="operator">OF</span> vld ippkt ifvld<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main">,</span> <span class="operator">THEN</span> iffD1<span class="main">,</span> <span class="operator">unfolded</span> oft_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">OF</span> 1<span class="main">]</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">oif</span></span> <span class="keyword2"><span class="keyword">where</span></span> roif<span class="main">:</span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">oif</span><span class="main">,</span> simple_action.Drop<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> map_snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> lr_of_tran_fbs_dropD<span class="main">[</span><span class="operator">OF</span> s1 s2<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> this<span class="main">]</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 2 
    <span class="keyword1"><span class="command">note</span></span> lr_of_tran_fbs_dropI<span class="main">[</span><span class="operator">OF</span> s1 s2<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> s2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">ifs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">then</span></span> 
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">oif</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">oif</span><span class="main">,</span> simple_action.Drop<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>map snd <span class="main">(</span>map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">(</span>annotate_rlen <span class="main">(</span>lr_of_tran_fbs <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">oif</span><span class="main">,</span> simple_action.Drop<span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> map_snd_apfst map_snd_annotate_rlen <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> s3_correct<span class="main">[</span><span class="operator">OF</span> vld ippkt ifvld<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> *<span class="main">,</span> <span class="operator">THEN</span> iffD2<span class="main">,</span> <span class="operator">unfolded</span> oft_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> lr_determ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> Some <span class="bound">a</span> <span class="main">⟹</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_linux_router_nol12_def Let_def not_undec <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits state.splits final_decision.splits<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> notno<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> NoAction"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> w2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> w1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> lr_determ<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> notub<span class="main">:</span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lin <span class="keyword1"><span class="command">using</span></span> OF_match_linear_ne_Undefined <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> notmult<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ls</span><span class="main">.</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="bound">ls</span> <span class="main">⟶</span> length <span class="bound">ls</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> w2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> w1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"output_iface <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> lr_determ<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ls</span><span class="main">.</span> length <span class="bound">ls</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="bound">ls</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> notmult <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">using</span></span> notno   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">using</span></span> notub   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OF_conv_test">
<div class="head">
<h1>Theory OF_conv_test</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> OF_conv_test
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Iptables_Semantics/Parser.html">Iptables_Semantics.Parser</a>
  <a href="../Simple_Firewall/SimpleFw_toString.html">Simple_Firewall.SimpleFw_toString</a>
  <a href="../Routing/IpRoute_Parser.html">Routing.IpRoute_Parser</a>
  <span class="quoted">"<a href="LinuxRouter_OpenFlow_Translation.html">../../LinuxRouter_OpenFlow_Translation</a>"</span>
  <span class="quoted">"<a href="OpenFlow_Serialize.html">../../OpenFlow_Serialize</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*section‹Example: Simple Test for Translation to OpenFlow›*)</span>


<span class="keyword1"><span class="command">parse_iptables_save</span></span> SQRL_fw<span class="main">=</span><span class="quoted">"iptables-save"</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">SQRL_fw</span>
<span class="keyword1"><span class="command">thm</span></span> SQRL_fw_def
<span class="keyword1"><span class="command">thm</span></span> SQRL_fw_FORWARD_default_policy_def

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">rs</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> map <span class="main">(</span>quote_rewrite <span class="main">∘</span> common_primitive_rule_toString<span class="main">)</span> <span class="bound">rs</span><span class="main">)</span><span class="main">)</span> SQRL_fw"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfolded</span> <span class="main">=</span> unfold_ruleset_FORWARD SQRL_fw_FORWARD_default_policy <span class="main">(</span>map_of_string_ipv4 SQRL_fw<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>quote_rewrite <span class="main">∘</span> common_primitive_rule_toString<span class="main">)</span> unfolded <span class="main">=</span>
  <span class="main">[</span><span class="inner_quoted">''-p icmp -j ACCEPT''</span><span class="main">,</span>
   <span class="inner_quoted">''-i s1-lan -p tcp -m tcp --spts [1024:65535] -m tcp --dpts [80] -j ACCEPT''</span><span class="main">,</span>
   <span class="inner_quoted">''-i s1-wan -p tcp -m tcp --spts [80] -m tcp --dpts [1024:65535] -j ACCEPT''</span><span class="main">,</span>
   <span class="inner_quoted">'' -j DROP''</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length unfolded <span class="main">=</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>


<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>quote_rewrite <span class="main">∘</span> common_primitive_rule_toString<span class="main">)</span> <span class="main">(</span>upper_closure unfolded<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>upper_closure unfolded<span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>


<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>lower_closure unfolded<span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"check_simple_fw_preconditions <span class="main">(</span>upper_closure unfolded<span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m</span> <span class="main">∈</span> get_match<span class="main">`</span>set <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">.</span> normalized_nnf_match <span class="bound">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m</span> <span class="main">∈</span> get_match<span class="main">`</span>set <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> normalized_nnf_match <span class="bound">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"check_simple_fw_preconditions <span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>to_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lower_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lower_closure unfolded"</span></span>
      <span class="quoted"><span class="quoted">"lower_closure unfolded <span class="main">=</span> upper_closure unfolded"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> upper_closure unfolded"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>getParts <span class="main">(</span>to_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_fw_simple</span> <span class="main">≡</span> remdups_rev <span class="main">(</span>to_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"SQRL_fw_simple"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"simple_fw_valid SQRL_fw_simple"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="comment1">(*section‹Example: SQRL RTBL›*)</span>

<span class="keyword1"><span class="command">parse_ip_route</span></span> SQRL_rtbl_main <span class="main">=</span> <span class="quoted">"ip-route"</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted">SQRL_rtbl_main</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"SQRL_rtbl_main <span class="main">=</span> <span class="main">[</span><span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xA000100</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''s1-lan''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xA000200</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''s1-wan''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="main">0</span> <span class="main">0</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''s1-wan''</span><span class="main">,</span> next_hop <span class="main">=</span> Some <span class="numeral">0xA000201</span><span class="main">⦈</span><span class="main">⦈</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"dotdecimal_of_ipv4addr <span class="numeral">0xA0D2500</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"SQRL_rtbl_main <span class="main">=</span> <span class="main">[</span>
	rr_ctor <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">24</span> <span class="inner_quoted">''s1-lan''</span> None <span class="main">0</span><span class="main">,</span>
	rr_ctor <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">24</span> <span class="inner_quoted">''s1-wan''</span> None <span class="main">0</span><span class="main">,</span>
	rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="inner_quoted">''s1-wan''</span> <span class="main">(</span>Some <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>
	<span class="main">]</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_rtbl_main_sorted</span> <span class="main">≡</span> rev <span class="main">(</span>sort_key <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> pfxm_length <span class="main">(</span>routing_match <span class="bound">r</span><span class="main">)</span><span class="main">)</span> SQRL_rtbl_main<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted">SQRL_rtbl_main_sorted</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_ifs</span> <span class="main">≡</span> <span class="main">[</span>
<span class="main">⦇</span>iface_name <span class="main">=</span> <span class="inner_quoted">''s1-lan''</span><span class="main">,</span> iface_mac <span class="main">=</span> <span class="numeral">0x10001</span><span class="main">⦈</span><span class="main">,</span>
<span class="main">⦇</span>iface_name <span class="main">=</span> <span class="inner_quoted">''s1-wan''</span><span class="main">,</span> iface_mac <span class="main">=</span> <span class="numeral">0x10002</span><span class="main">⦈</span>
<span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted">SQRL_ifs</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_macs</span> <span class="main">≡</span> <span class="main">[</span>
	<span class="comment1">⌦‹(''s1-lan'', (ipv4addr_of_dotdecimal (10,0,1,1), 0x3)),›</span>
	<span class="main">(</span><span class="inner_quoted">''s1-lan''</span><span class="main">,</span> <span class="main">(</span>ipv4addr_of_dotdecimal <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0x1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
	<span class="main">(</span><span class="inner_quoted">''s1-lan''</span><span class="main">,</span> <span class="main">(</span>ipv4addr_of_dotdecimal <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0x2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
	<span class="main">(</span><span class="inner_quoted">''s1-wan''</span><span class="main">,</span> <span class="main">(</span>ipv4addr_of_dotdecimal <span class="main">(</span><span class="numeral">10</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0x3</span><span class="main">)</span><span class="main">)</span>
	<span class="comment1">⌦‹(''s1-wan'', (ipv4addr_of_dotdecimal (10,0,2,4), 0xeabad0152059))›</span>
<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_ports</span> <span class="main">≡</span> <span class="main">[</span>
	<span class="main">(</span><span class="inner_quoted">''s1-lan''</span><span class="main">,</span> <span class="inner_quoted">''1''</span><span class="main">)</span><span class="main">,</span>
	<span class="main">(</span><span class="inner_quoted">''s1-wan''</span><span class="main">,</span> <span class="inner_quoted">''2''</span><span class="main">)</span>
<span class="main">]</span>"</span></span>

<span class="comment1">(* preconditions (get checked by lr_of_tran, too) *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="bound">fw</span> <span class="main">=</span> SQRL_fw_simple <span class="keyword1">in</span> no_oif_match <span class="bound">fw</span> <span class="main">∧</span> has_default_policy <span class="bound">fw</span> <span class="main">∧</span> simple_fw_valid <span class="bound">fw</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="bound">rt</span> <span class="main">=</span> SQRL_rtbl_main_sorted <span class="keyword1">in</span> valid_prefixes <span class="bound">rt</span> <span class="main">∧</span> has_default_route <span class="bound">rt</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="bound">ifs</span> <span class="main">=</span> <span class="main">(</span>map iface_name SQRL_ifs<span class="main">)</span> <span class="keyword1">in</span> distinct <span class="bound">ifs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ofi</span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="main">(</span>lr_of_tran SQRL_rtbl_main_sorted SQRL_fw_simple <span class="main">(</span>map iface_name SQRL_ifs<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">of</span> <span class="main">(</span>Inr <span class="bound">openflow_rules</span><span class="main">)</span> <span class="main">⇒</span> map <span class="main">(</span>serialize_of_entry <span class="main">(</span>the <span class="main">∘</span> map_of SQRL_ports<span class="main">)</span><span class="main">)</span> <span class="bound">openflow_rules</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ofi <span class="main">=</span>
<span class="main">[</span><span class="inner_quoted">''priority=11,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_proto=1,nw_dst=10.0.2.0/24,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=1024/0xfc00,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=2048/0xf800,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=4096/0xf000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=8192/0xe000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=16384/0xc000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=32768/0x8000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=1024/0xfc00,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=2048/0xf800,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=4096/0xf000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=8192/0xe000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=16384/0xc000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.2.0/24,tp_src=80,tp_dst=32768/0x8000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=8,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_dst=10.0.2.0/24,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=7,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_proto=1,nw_dst=10.0.1.0/24,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=1024/0xfc00,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=2048/0xf800,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=4096/0xf000,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=8192/0xe000,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=16384/0xc000,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=32768/0x8000,tp_dst=80,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=1024/0xfc00,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=2048/0xf800,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=4096/0xf000,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=8192/0xe000,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=16384/0xc000,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,nw_dst=10.0.1.0/24,tp_src=80,tp_dst=32768/0x8000,action=output:1''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=4,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_dst=10.0.1.0/24,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=3,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_proto=1,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=1024/0xfc00,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=2048/0xf800,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=4096/0xf000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=8192/0xe000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=16384/0xc000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,in_port=1,dl_type=0x800,nw_proto=6,tp_src=32768/0x8000,tp_dst=80,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=1024/0xfc00,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=2048/0xf800,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=4096/0xf000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=8192/0xe000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=16384/0xc000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,in_port=2,dl_type=0x800,nw_proto=6,tp_src=80,tp_dst=32768/0x8000,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=0,hard_timeout=0,idle_timeout=0,dl_type=0x800,action=drop''</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"ofi"</span></span>

<span class="comment1">(*ML‹
	val evterm = the (Code_Evaluation.dynamic_value @{context} @{term "intersperse (Char Nibble0 NibbleA) ofi"});
	val opstr = Syntax.string_of_term (Config.put show_markup false @{context}) evterm;
	File.write (Path.explode (File.platform_path(Resources.master_directory @{theory}) ^ "/pretty_str.txt")) opstr;
›*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RFC2544">
<div class="head">
<h1>Theory RFC2544</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> RFC2544
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Iptables_Semantics/Parser.html">Iptables_Semantics.Parser</a>
  <a href="../Routing/IpRoute_Parser.html">Routing.IpRoute_Parser</a>
  <span class="quoted">"<a href="LinuxRouter_OpenFlow_Translation.html">../../LinuxRouter_OpenFlow_Translation</a>"</span>
  <span class="quoted">"<a href="OpenFlow_Serialize.html">../../OpenFlow_Serialize</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*section‹Example: Simple Test for Translation to OpenFlow›*)</span>


<span class="keyword1"><span class="command">parse_iptables_save</span></span> SQRL_fw<span class="main">=</span><span class="quoted">"iptables-save"</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">SQRL_fw</span>
<span class="keyword1"><span class="command">thm</span></span> SQRL_fw_def
<span class="keyword1"><span class="command">thm</span></span> SQRL_fw_FORWARD_default_policy_def

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">rs</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> map <span class="main">(</span>quote_rewrite <span class="main">∘</span> common_primitive_rule_toString<span class="main">)</span> <span class="bound">rs</span><span class="main">)</span><span class="main">)</span> SQRL_fw"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfolded</span> <span class="main">=</span> unfold_ruleset_FORWARD SQRL_fw_FORWARD_default_policy <span class="main">(</span>map_of_string_ipv4 SQRL_fw<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length unfolded <span class="main">=</span> <span class="numeral">26</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"unfolded"</span></span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>upper_closure unfolded<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>quote_rewrite <span class="main">∘</span> common_primitive_rule_toString<span class="main">)</span> <span class="main">(</span>upper_closure unfolded<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>upper_closure unfolded<span class="main">)</span> <span class="main">=</span> <span class="numeral">26</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>


<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>lower_closure unfolded<span class="main">)</span> <span class="main">=</span> <span class="numeral">26</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"check_simple_fw_preconditions <span class="main">(</span>upper_closure unfolded<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m</span> <span class="main">∈</span> get_match<span class="main">`</span>set <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">.</span> normalized_nnf_match <span class="bound">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m</span> <span class="main">∈</span> get_match<span class="main">`</span>set <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> normalized_nnf_match <span class="bound">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"check_simple_fw_preconditions <span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>to_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">26</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lower_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lower_closure unfolded"</span></span>
      <span class="quoted"><span class="quoted">"lower_closure unfolded <span class="main">=</span> upper_closure unfolded"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> upper_closure unfolded"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>getParts <span class="main">(</span>to_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>lower_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_fw_simple</span> <span class="main">≡</span> remdups_rev <span class="main">(</span>to_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>optimize_matches abstract_for_simple_firewall <span class="main">(</span>upper_closure <span class="main">(</span>packet_assume_new unfolded<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"SQRL_fw_simple"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"simple_fw_valid SQRL_fw_simple"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">parse_ip_route</span></span> SQRL_rtbl_main <span class="main">=</span> <span class="quoted">"ip-route"</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted">SQRL_rtbl_main</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"SQRL_rtbl_main <span class="main">=</span> <span class="main">[</span><span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xC6120100</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''ip1''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="numeral">0xC6130100</span> <span class="numeral">24</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''op1''</span><span class="main">,</span> next_hop <span class="main">=</span> None<span class="main">⦈</span><span class="main">⦈</span><span class="main">,</span>
  <span class="main">⦇</span>routing_match <span class="main">=</span> PrefixMatch <span class="main">0</span> <span class="main">0</span><span class="main">,</span> metric <span class="main">=</span> <span class="main">0</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span>output_iface <span class="main">=</span> <span class="inner_quoted">''op1''</span><span class="main">,</span> next_hop <span class="main">=</span> Some <span class="numeral">0xC6130102</span><span class="main">⦈</span><span class="main">⦈</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"SQRL_rtbl_main <span class="main">=</span> <span class="main">[</span>
	rr_ctor <span class="main">(</span><span class="numeral">198</span><span class="main">,</span><span class="numeral">18</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">24</span> <span class="inner_quoted">''ip1''</span> None <span class="main">0</span><span class="main">,</span>
	rr_ctor <span class="main">(</span><span class="numeral">198</span><span class="main">,</span><span class="numeral">19</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="numeral">24</span> <span class="inner_quoted">''op1''</span> None <span class="main">0</span><span class="main">,</span>
	rr_ctor <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="inner_quoted">''op1''</span> <span class="main">(</span>Some <span class="main">(</span><span class="numeral">198</span><span class="main">,</span><span class="numeral">19</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>
	<span class="main">]</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">SQRL_ports</span> <span class="main">≡</span> <span class="main">[</span>
	<span class="main">(</span><span class="inner_quoted">''ip1''</span><span class="main">,</span> <span class="inner_quoted">''1''</span><span class="main">)</span><span class="main">,</span>
	<span class="main">(</span><span class="inner_quoted">''op1''</span><span class="main">,</span> <span class="inner_quoted">''2''</span><span class="main">)</span>
<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ofi</span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="main">(</span>lr_of_tran SQRL_rtbl_main SQRL_fw_simple <span class="main">(</span>map fst SQRL_ports<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">of</span> <span class="main">(</span>Inr <span class="bound">openflow_rules</span><span class="main">)</span> <span class="main">⇒</span> map <span class="main">(</span>serialize_of_entry <span class="main">(</span>the <span class="main">∘</span> map_of SQRL_ports<span class="main">)</span><span class="main">)</span> <span class="bound">openflow_rules</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"ofi <span class="main">=</span>
<span class="main">[</span><span class="inner_quoted">''priority=27,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_dst=198.18.1.0/24,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=26,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_dst=198.19.1.0/24,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=25,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.1.1/32,nw_dst=192.18.101.1/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=24,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.2.2/32,nw_dst=192.18.102.2/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=23,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.3.3/32,nw_dst=192.18.103.3/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=22,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.4.4/32,nw_dst=192.18.104.4/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=21,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.5.5/32,nw_dst=192.18.105.5/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=20,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.6.6/32,nw_dst=192.18.106.6/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=19,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.7.7/32,nw_dst=192.18.107.7/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=18,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.8.8/32,nw_dst=192.18.108.8/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=17,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.9.9/32,nw_dst=192.18.109.9/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=16,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.10.10/32,nw_dst=192.18.110.10/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=15,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.11.11/32,nw_dst=192.18.111.11/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=14,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.12.12/32,nw_dst=192.18.112.12/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=13,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.19.1.2/32,nw_dst=192.19.65.1/32,action=output:2''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=12,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.13.13/32,nw_dst=192.18.113.13/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=11,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.14.14/32,nw_dst=192.18.114.14/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=10,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.15.15/32,nw_dst=192.18.115.15/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=9,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.16.16/32,nw_dst=192.18.116.16/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=8,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.17.17/32,nw_dst=192.18.117.17/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=7,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.18.18/32,nw_dst=192.18.118.18/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=6,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.19.19/32,nw_dst=192.18.119.19/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=5,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.20.20/32,nw_dst=192.18.120.20/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=4,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.21.21/32,nw_dst=192.18.121.21/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=3,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.22.22/32,nw_dst=192.18.122.22/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=2,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.23.23/32,nw_dst=192.18.123.23/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=1,hard_timeout=0,idle_timeout=0,dl_type=0x800,nw_src=192.18.24.24/32,nw_dst=192.18.124.24/32,action=drop''</span><span class="main">,</span>
  <span class="inner_quoted">''priority=0,hard_timeout=0,idle_timeout=0,dl_type=0x800,action=drop''</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">value</span></span><span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"length ofi"</span></span>

<span class="comment1">(* TODO: Well, that's something… I'd really like to have a proper file with newlines though… *)</span>
<span class="comment1">(*ML‹
	val evterm = the (Code_Evaluation.dynamic_value @{context} @{term "intersperse (Char Nibble0 NibbleA) ofi"});
	val opstr = Syntax.string_of_term (Config.put show_markup false @{context}) evterm;
	File.write (Path.explode (File.platform_path(Resources.master_directory @{theory}) ^ "/pretty_str.txt")) opstr;
›*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="OpenFlow_Documentation">
<div class="head">
<h1>Theory OpenFlow_Documentation</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹
\twocolumn
\columnsep 2pc          %    Space between columns
\textwidth 42pc         % Width of text line.
\part{Documentation}
\label{part2}
›</span></span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Configuration Translation›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:conv}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
All the results we present in this section are formalized and verified in Isabelle/HOL~\cite{nipkow2002isabelle}.
This means that their formal correctness can be trusted a level close to absolute certainty.
The definitions and lemmas stated here are merely a repetition of lemmas stated in other theory files.
This means that they have been directly set to this document from Isabelle and no typos or hidden assumptions are possible.
Additionally, it allows us to omit various helper lemmas that do not help the understanding.
However, it causes some notation inaccuracy, as type and function definitions are stated as lemmas or schematic goals.
›</span></span>
<span class="keyword1"><span class="command">theory</span></span> OpenFlow_Documentation
<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="LinuxRouter_OpenFlow_Translation.html">LinuxRouter_OpenFlow_Translation</a> 
  <a href="Featherweight_OpenFlow_Comparison.html">Featherweight_OpenFlow_Comparison</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/LaTeXsugar.html">HOL-Library.LaTeXsugar</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Linux Firewall Model›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:lfw}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We want to write a program that translates the configuration of a linux firewall to that of an OpenFlow switch.
We furthermore want to verify that translation.
For this purpose, we need a clear definition of the behavior of the two device types -- we need their models and semantics.
In case of a linux firewall, this is problematic because a linux firewall is a highly complex device that is ultimately capable of general purpose computation.
Creating a comprehensive semantics that encompasses all possible configuration types of a linux firewall is thus 
highly non-trivial and not useful for the purpose of analysis.
We decided to approach the problem from the other side: we created a model that includes only the most basic features. (This implies neglecting IPv6.)
Fortunately, many of the highly complex features are rarely essential and even our basic model is still of some use.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We first divided the firewall into subsystems.
Given a routing table <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rt</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the firewall rules <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fw</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  the routing decision for a packet <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be obtained by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"routing_table_semantics <span class="free"><span class="free">rt</span></span> <span class="main"><span class="main">(</span></span>p_dst <span class="free"><span class="free">p</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
  the firewall decision by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"simple_fw <span class="free"><span class="free">fw</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
We draft the first description of our linux router model:
\begin{enumerate}
  \item The destination MAC address of an arriving packet is checked: Does it match the MAC address of the ingress port? 
  If it does, we continue, otherwise, the packet is discarded.
  \item The routing decision <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">rd</span></span> <span class="main"><span class="main">≡</span></span> routing_table_semantics <span class="free"><span class="free">rt</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is obtained.
  \item The packet's output interface is updated based on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rd</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>\footnote{Note that we assume a packet model with input and output interfaces. The origin of this is explained in Section~\ref{sec:lfwfw}}.
  \item The firewall is queried for a decision: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"simple_fw <span class="free"><span class="free">fw</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. If the decision is to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>[names_short] simple_action.Drop<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the packet is discarded.
  \item The next hop is computed: If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rd</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides a next hop, that is used. 
    Otherwise, the destination address of the packet is used.
  \item The MAC address of the next hop is looked up; the packet is updated with it and sent.
\end{enumerate}
We decided that this description is best formalized as an abortable program in the option monad:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">p</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> iface_packet_check <span class="free">ifl</span> <span class="free">p</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">rd</span> <span class="comment1">― ‹(routing decision)›</span> <span class="main">=</span> routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="bound">rd</span><span class="main">⦈</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">fd</span> <span class="comment1">― ‹(firewall decision)›</span> <span class="main">=</span> simple_fw <span class="free">fw</span> <span class="bound">p</span><span class="main">;</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fd</span> <span class="keyword1">of</span> Decision FinalAllow <span class="main">⇒</span> Some <span class="main">()</span> <span class="main">|</span> Decision FinalDeny <span class="main">⇒</span> None<span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">nh</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> next_hop <span class="bound">rd</span> <span class="keyword1">of</span> None <span class="main">⇒</span> p_dst <span class="bound">p</span> <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">)</span><span class="main">;</span>
	<span class="bound">ma</span> <span class="main">←</span> <span class="free">mlf</span> <span class="bound">nh</span><span class="main">;</span>
	Some <span class="main">(</span><span class="bound">p</span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">ma</span><span class="main">⦈</span><span class="main">)</span>
<span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">unfolding</span></span> fromMaybe_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> simple_linux_router_def<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">mlf</span></span> <span class="main"><span class="main">::</span></span> ipv4addr <span class="main"><span class="main">⇒</span></span> <span class="numeral"><span class="numeral">48</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a function that looks up the MAC address for an IP address.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹There are already a few important aspects that have not been modelled, but they are not core essential for the functionality of a firewall.
Namely, there is no local traffic from/to the firewall.
This is problematic since this model can not generate ARP replies --- thus, an equivalent OpenFlow device will not do so, either.
Furthermore, this model is problematic because it requires access to a function that looks up a MAC address, 
something that may not be known at the time of time running a translation to an OpenFlow configuration.
›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹It is possible to circumvent these problems by inserting static ARP table entries in the directly connected devices 
and looking up their MAC addresses \emph{a priori}. 
A test-wise implementation of the translation based on this model showed acceptable results.
However, we deemed the \emph{a priori} lookup of the MAC addresses to be rather inelegant and built a second model.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">simple_linux_router_altered</span> <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="free"><span class="bound"><span class="entity">ifl</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
	<span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> routing_table_semantics <span class="free"><span class="bound"><span class="entity">rt</span></span></span> <span class="main">(</span>p_dst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="bound">rd</span><span class="main">⦈</span><span class="main">;</span>
		<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="keyword1">if</span> p_oiface <span class="bound">p</span> <span class="main">=</span> p_iiface <span class="bound">p</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">()</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">fd</span> <span class="main">=</span> simple_fw <span class="free"><span class="bound"><span class="entity">fw</span></span></span> <span class="bound">p</span><span class="main">;</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fd</span> <span class="keyword1">of</span> Decision FinalAllow <span class="main">⇒</span> Some <span class="main">()</span> <span class="main">|</span> Decision FinalDeny <span class="main">⇒</span> None<span class="main">)</span><span class="main">;</span>
	Some <span class="bound">p</span>
<span class="main">}</span>"</span></span>
<span class="comment1">(* TODO: Would a router actually forward a packet on the same interface? *)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In this model, all access to the MAC layer has been eliminated.
This is done by the approximation that the firewall will be asked to route a packet 
(i.e. be addressed on the MAC layer) iff the destination IP address of the packet causes it to be routed out on a different interface.
Because this model does not insert destination MAC addresses, the destination MAC address has to be already correct when the packet is sent.
This can only be achieved by changing the subnet of all connected device, moving them into one common subnet\footnote{There are cases where this is not possible --- A limitation of our system.}.
›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
While a test-wise implementation based on this model also showed acceptable results, the model is still problematic.
The check <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"p_oiface <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> p_iiface <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the firewall require access to the output interface.
The details of why this cannot be provided are be elaborated in Section~\ref{sec:convi}. 
The intuitive explanation is that an OpenFlow match can not have a field for the output interface.
We thus simplified the model even further:
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
	<span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">p</span><span class="main">)</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> output_iface <span class="bound">rd</span><span class="main">⦈</span><span class="main">;</span>
	<span class="keyword1">let</span> <span class="bound">fd</span> <span class="main">=</span> simple_fw <span class="free">fw</span> <span class="bound">p</span><span class="main">;</span>
	<span class="main"><span class="bound">_</span></span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fd</span> <span class="keyword1">of</span> Decision FinalAllow <span class="main">⇒</span> Some <span class="main">()</span> <span class="main">|</span> Decision FinalDeny <span class="main">⇒</span> None<span class="main">)</span><span class="main">;</span>
	Some <span class="bound">p</span>
<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> simple_linux_router_nol12_def<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We continue with this definition as a basis for our translation.
Even this strongly altered version and the original linux firewall still behave the same in a substantial amount of cases:›</span></span>
<span class="keyword1"><span class="command">theorem</span></span>
	<span class="quoted"><span class="quoted">"<span class="main">⟦</span>iface_packet_check <span class="free">ifl</span> <span class="free">pii</span> <span class="main">≠</span> None<span class="main">;</span>
	<span class="free">mlf</span> <span class="main">(</span><span class="keyword1">case</span> next_hop <span class="main">(</span>routing_table_semantics <span class="free">rt</span> <span class="main">(</span>p_dst <span class="free">pii</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> p_dst <span class="free">pii</span> <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">)</span> <span class="main">≠</span> None<span class="main">⟧</span> <span class="main">⟹</span>
	<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span><span class="main">⦇</span>p_l2dst <span class="main">:=</span> <span class="bound">x</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">pii</span><span class="main">)</span> <span class="main">=</span> simple_linux_router <span class="free">rt</span> <span class="free">fw</span> <span class="free">mlf</span> <span class="free">ifl</span> <span class="free">pii</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> rtr_nomac_eq<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> fromMaybe_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The conditions are to be read as ``The check whether a received packet has the correct destination MAC never returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> False<span class="antiquote"><span class="antiquote">}</span></span></span></span>'' and 
``The next hop MAC address for all packets can be looked up''.
Obviously, these conditions do not hold for all packets. 
We will show an example where this makes a difference in Section~\ref{sec:mnex}.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Routing Table›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:lfwr}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The routing system in linux features multiple tables and a system that can use the iptables firewall and an additional match language to select a routing table.
Based on our directive, we only focused on the single most used \texttt{main} routing table.›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
We define a routing table entry to be a record (named tuple) of a prefix match, a metric and the routing action, which in turn is a record of an output interface and an optional next-hop address.›</span></span>
<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?rtbl_entry</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> routing_rule<span class="main">)</span> <span class="main">=</span> <span class="main">⦇</span> routing_match <span class="main">=</span> PrefixMatch <span class="free">pfx</span> <span class="free">len</span><span class="main">,</span> metric <span class="main">=</span> <span class="free">met</span><span class="main">,</span> routing_action <span class="main">=</span> <span class="main">⦇</span> output_iface <span class="main">=</span> <span class="free">oif_string</span><span class="main">,</span> next_hop <span class="main">=</span> <span class="main">(</span><span class="free">h</span> <span class="main">::</span> <span class="tfree">'a</span> word option<span class="main">)</span> <span class="main">⦈</span> <span class="main">⦈</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A routing table is then a list of these entries:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">rtbl</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> len<span class="main">)</span> prefix_routing<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">rtbl</span> <span class="main">::</span> <span class="tfree">'a</span> routing_rule list<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Not all members of the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prefix_routing<span class="antiquote"><span class="antiquote">}</span></span></span></span> are sane routing tables. There are three different validity criteria that we require so that our definitions are adequate.
\begin{itemize}
  \item The prefixes have to be 0 in bits exceeding their length.
  \item There has to be a default rule, i.e. one with prefix length 0. With the condition above, that implies that all its prefix bits are zero and it thus matches any address.
  \item The entries have to be sorted by prefix length and metric.
\end{itemize}
The first two are set into code in the following way:
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"valid_prefix <span class="main">(</span>PrefixMatch <span class="free">pfx</span> <span class="free">len</span><span class="main">)</span> <span class="main">≡</span> <span class="free">pfx</span> <span class="main">&amp;&amp;</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span><span class="numeral">32</span> <span class="main">-</span> <span class="free">len</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> <span class="numeral">32</span> word<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_prefix_def pfxm_mask_def mask_eq_decr_exp and.commute<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"has_default_route <span class="free">rt</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span> <span class="main">∈</span> set <span class="free">rt</span><span class="main">.</span> pfxm_length <span class="main">(</span>routing_match <span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> has_default_route_alt<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The third is not needed in any of the further proofs, so we omit it.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The semantics of a routing table is to simply traverse the list until a matching entry is found.›</span></span>
<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="quoted"><span class="quoted">"routing_table_semantics <span class="main">(</span><span class="free">rt_entry</span> <span class="main">#</span> <span class="free">rt</span><span class="main">)</span> <span class="free">dst_addr</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> prefix_match_semantics <span class="main">(</span>routing_match <span class="free">rt_entry</span><span class="main">)</span> <span class="free">dst_addr</span> <span class="keyword1">then</span> routing_action <span class="free">rt_entry</span> <span class="keyword1">else</span> routing_table_semantics <span class="free">rt</span> <span class="free">dst_addr</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> routing_table_semantics.simps<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹If no matching entry is found, the behavior is undefined.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹iptables Firewall›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:lfwfw}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The firewall subsystem in a linux router is not any less complex than any of the of the other systems.
Fortunately, this complexity has been dealt with in~\cite{diekmann2016verified,Iptables_Semantics-AFP} already and we can directly use the result.›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In short, one of the results is that a complex \emph{iptables} configuration can be simplified to be represented by a single list of matches that only support the following match conditions:
\begin{itemize}
  \item (String) prefix matches on the input and output interfaces.
  \item A <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> prefix_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> on the source and destination IP address.
  \item An exact match on the layer 4 protocol.
  \item Interval matches on the source or destination port, e.g. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">p<span class="hidden">⇩</span><sub>d</sub></span></span> <span class="main"><span class="main">∈</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">1</span></span><span class="main"><span class="main">::</span></span><span class="numeral"><span class="numeral">16</span></span> word<span class="main"><span class="main">)</span></span><span class="main"><span class="main">..</span></span><span class="numeral"><span class="numeral">1023</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{itemize}
The model/type of the packet is adjusted to fit that: it is a record of the fields matched on.
This also means that input and output interface are coded to the packet.
Given that this information is usually stored alongside the packet content, this can be deemed a reasonable model.
In case the output interface is not needed (e.g., when evaluating an OpenFlow table), it can simply be left blank.

Obviously, a simplification into the above match type cannot always produce an equivalent firewall, and the set of accepted packets has to be over- or underapproximated.
The reader interested in the details of this is strongly referred to~\cite{diekmann2016verified}; we are simply going to continue with the result: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_fw<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹One property of the simplification is worth noting here: The simplified firewall does not know state and the simplification approximates stateful matches by stateless ones. 
Thus, the overapproximation of a stateful firewall ruleset that begins with accepting packets of established connections usually begins with a rule that accepts all packets.
Dealing with this by writing a meaningful simplification of stateful firewalls is future work.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹OpenFlow Switch Model›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In this section, we present our model of an OpenFlow switch.
The requirements for this model are derived from the fact that it models devices that are the target of a configuration translation.
This has two implications:
\begin{itemize}
\item All configurations that are representable in our model should produce the correct behavior wrt. their semantics.
  The problem is that correct here means that the behavior is the same that any real device would produce.
  Since we cannot possibly account for all device types, we instead focus on those that conform to the OpenFlow specifications.
  To account for the multiple different versions of the specification (e.g.~\cite{specification10,specification15}), we tried making our model a subset of 
  both the oldest stable version 1.0~\cite{specification10} and the newest available specification version 1.5.1~\cite{specification15}.
\item Conversely, our model does not need to represent all possible behavior of an OpenFlow switch, just the behavior that can be invoked by the result of our translation.
  This is especially useful regarding for controller interaction, but also for MPLS or VLANs, which we did not model in Section \ref{sec:lfw}.
\end{itemize}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹More concretely, we set the following rough outline for our model.
\begin{itemize}
  \item A switch consists of a single flow table.
  \item A flow table entry consists of a priority, a match condition and an action list.
  \item The only possible action (we require) is to forward the packet on a port.
  \item We do not model controller interaction.
\end{itemize}
Additionally, we decided that we wanted to be able to ensure the validity of the flow table in all qualities,
i.e. we want to model the conditions `no overlapping flow entries appear', `all match conditions have their necessary preconditions'.
The details of this are explained in the following sections.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Matching Flow Table entries›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:of_match}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Table 3 of Section 3.1 of \cite{specification10} gives a list of required packet fields that can be used to match packets.
This directly translates into the type for a match expression on a single field:›</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">field_match</span> <span class="main">::</span> of_match_field<span class="main">)</span> <span class="main">∈</span> <span class="main">{</span>
  IngressPort <span class="main">(</span><span class="var">?s</span><span class="main">::</span>string<span class="main">)</span><span class="main">,</span>
  EtherSrc <span class="main">(</span><span class="var">?as</span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span><span class="main">,</span> EtherDst <span class="main">(</span><span class="var">?ad</span><span class="main">::</span><span class="numeral">48</span> word<span class="main">)</span><span class="main">,</span>
	EtherType <span class="main">(</span><span class="var">?t</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	VlanId <span class="main">(</span><span class="var">?i</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span> VlanPriority <span class="main">(</span><span class="var">?p</span><span class="main">::</span><span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	IPv4Src <span class="main">(</span><span class="var">?pms</span><span class="main">::</span><span class="numeral">32</span> prefix_match<span class="main">)</span><span class="main">,</span> 
	IPv4Dst <span class="main">(</span><span class="var">?pmd</span><span class="main">::</span><span class="numeral">32</span> prefix_match<span class="main">)</span><span class="main">,</span>
	IPv4Proto <span class="main">(</span><span class="var">?ipp</span> <span class="main">::</span> <span class="numeral">8</span> word<span class="main">)</span><span class="main">,</span>
	L4Src <span class="main">(</span><span class="var">?ps</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">(</span><span class="var">?ms</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span><span class="main">,</span>
	L4Dst <span class="main">(</span><span class="var">?pd</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span> <span class="main">(</span><span class="var">?md</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>
<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> of_match_field_typeset<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Two things are worth additional mention: L3 and L4 ``addressess''.
The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Src</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Dst</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> matches are specified as ``can be subnet masked'' in~\cite{specification10}, 
  whereras~\cite{specification15} states clearly that arbitrary bitmasks can be used. We took the conservative approach here.
Our alteration of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">L4Src</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">L4Dst</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is more grave. While~\cite{specification10} does not state anything about layer 4 ports and masks,
\cite{specification15} specifically forbids using masks on them. 
Nevertheless, OpenVSwitch \cite{openvswitch} and some other implementations support them.
We will explain in detail why we must include bitmasks on layer 4 ports to obtain a meaningful translation in Section~\ref{sec:convi}.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹One <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> of_match_field<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not enough to classify a packet. 
To match packets, we thus use entire sets of match fields.
As Guha \emph{et al.}~\cite{guha2013machine} noted\footnote{See also: \cite[§2.3]{michaelis2016middlebox}}, executing a set of given <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> of_match_field<span class="antiquote"><span class="antiquote">}</span></span></span></span>s on a packet requires careful consideration.
For example, it is not meaningful to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Dst</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> if the given packet is not actually an IP packet, i.e.
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Dst</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has the prerequisite of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"EtherType <span class="numeral"><span class="numeral">0x0800</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> being among the match fields.
Guha \emph{et al.} decided to use the fact that the preconditions can be arranged on a directed acyclic graph (or rather: an acyclic forest).
They evaluated match conditions in a manner following that graph:
first, all field matches without preconditions are evaluated.
Upon evaluating a field match (e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"EtherType <span class="numeral"><span class="numeral">0x0800</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>), the matches that had their precondition fulfilled by it
  (e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Src</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IPv4Src</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in this example) are evalutated.
This mirrors the faulty behavior of some implementations (see \cite{guha2013machine}).
Adopting that behavior into our model would mean that any packet matches against the field match set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span>IPv4Dst <span class="main"><span class="main">(</span></span>PrefixMatch <span class="numeral"><span class="numeral">134744072</span></span> <span class="numeral"><span class="numeral">32</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
instead of just those destined for 8.8.8.8 or causing an error. We found this to be unsatisfactory.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹To solve this problem, we made three definitions.
The first, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">match_no_prereq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> matches an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> of_match_field<span class="antiquote"><span class="antiquote">}</span></span></span></span> against a packet without considering prerequisites.
The second, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">prerequisites</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, checks for a given <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> of_match_field<span class="antiquote"><span class="antiquote">}</span></span></span></span> whether its prerequisites are in a set of given match fields.
Especially:
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>VlanPriority <span class="free">pri</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">id</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> VlanId <span class="bound">id</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">m</span> <span class="main">∧</span> prerequisites <span class="bound">v</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>IPv4Proto <span class="free">pr</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">m</span> <span class="main">∧</span> prerequisites <span class="bound">v</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>IPv4Src <span class="free">a</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">m</span> <span class="main">∧</span> prerequisites <span class="bound">v</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>IPv4Dst <span class="free">a</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> EtherType <span class="numeral">0x0800</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">m</span> <span class="main">∧</span> prerequisites <span class="bound">v</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>L4Src <span class="free">p</span> <span class="free">msk</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">proto</span> <span class="main">∈</span> <span class="main">{</span>TCP<span class="main">,</span>UDP<span class="main">,</span>L4_Protocol.SCTP<span class="main">}</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">v</span> <span class="main">=</span> IPv4Proto <span class="bound">proto</span> <span class="keyword1">in</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">m</span> <span class="main">∧</span> prerequisites <span class="bound">v</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"prerequisites <span class="main">(</span>L4Dst <span class="free">p</span> <span class="free">msk</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> prerequisites <span class="main">(</span>L4Src undefined undefined<span class="main">)</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> prerequisites.simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Then, to actually match a set of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> of_match_field<span class="antiquote"><span class="antiquote">}</span></span></span></span> against a packet, we use the option type:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"OF_match_fields <span class="free">m</span> <span class="free">p</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">∃</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">m</span><span class="main">.</span> <span class="main">¬</span>prerequisites <span class="bound">f</span> <span class="free">m</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> 
    <span class="keyword1">if</span> <span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">m</span><span class="main">.</span> match_no_prereq <span class="bound">f</span> <span class="free">p</span> <span class="keyword1">then</span> Some True <span class="keyword1">else</span> Some False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> OF_match_fields_alt<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Evaluating a Flow Table›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In the previous section, we explained how we match the set of match fields belonging to a single flow entry against a packet.
This section explains how the correct flow entry from a table can be selected.
To prevent to much entanglement with the previous section, we assume an arbitrary match function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">γ</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'match_field</span></span> set <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'packet</span></span> <span class="main"><span class="main">⇒</span></span> bool"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
This function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">γ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> takes the match condition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from a flow entry <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"OFEntry <span class="main"><span class="main">(</span></span><span class="free"><span class="free">priority</span></span><span class="main"><span class="main">::</span></span><span class="numeral"><span class="numeral">16</span></span> word<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">m</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'match_field</span></span> set<span class="main"><span class="main">)</span></span> <span class="free"><span class="free">action</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and decides whether a packet matches those.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The flow table is simply a list of flow table entries <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> flow_entry_match<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Deciding the right flow entry to use for a given packet is explained in the OpenFlow specification \cite{specification10}, Section 3.4:
\begin{quote}
  Packets are matched against flow entries based on prioritization. 
  An entry that specifies an exact match (i.e., has no wildcards) is always the highest priority\footnote{This behavior has been deprecated.}.
  All wildcard entries have a priority associated with them. 
  Higher priority entries must match before lower priority ones.
  If multiple entries have the same priority, the switch is free to choose any ordering.
\end{quote}
We use the term ``overlapping'' for  the flow entries that can cause a packet to match multiple flow entries with the same priority.
Guha \emph{et al.}~\cite{guha2013machine} have dealt with overlapping.
However, the semantics for a flow table they presented \cite[Figure 5]{guha2013machine}
  is slightly different from what they actually used in their theory files.
We have tried to reproduce the original inductive definition (while keeping our abstraction <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">γ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>),
 in Isabelle/HOL\footnote{The original is written in Coq~\cite{barras1997coq} and we can not use it directly.}:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">fe</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> True <span class="main">⟹</span>
 <span class="main">∀</span><span class="bound">fe'</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">ft1</span> <span class="main">@</span> <span class="free">ft2</span><span class="main">)</span><span class="main">.</span> ofe_prio <span class="bound">fe'</span> <span class="main">&gt;</span> ofe_prio <span class="free">fe</span> <span class="main">⟶</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe'</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> False <span class="main">⟹</span> 
 guha_table_semantics <span class="free">γ</span> <span class="main">(</span><span class="free">ft1</span> <span class="main">@</span> <span class="free">fe</span> <span class="main">#</span> <span class="free">ft2</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span>Some <span class="main">(</span>ofe_action <span class="free">fe</span><span class="main">)</span><span class="main">)</span>"</span></span> 
 <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">fe</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">fe</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> False <span class="main">⟹</span>
 guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> guha_matched guha_unmatched<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Guha \emph{et al.} have deliberately made their semantics non-deterministic, to match the fact that the switch ``may choose any ordering''.
This can lead to undesired results:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'action</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ff</span><span class="main">.</span> <span class="free">γ</span> <span class="bound">ff</span> <span class="free">p</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ft</span> <span class="main">(</span><span class="bound">a1</span> <span class="main">::</span> <span class="tfree">'action</span><span class="main">)</span> <span class="main">(</span><span class="bound">a2</span> <span class="main">::</span> <span class="tfree">'action</span><span class="main">)</span><span class="main">.</span> <span class="bound">a1</span> <span class="main">≠</span> <span class="bound">a2</span> <span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="bound">a1</span><span class="main">)</span> <span class="main">∧</span> guha_table_semantics <span class="free">γ</span> <span class="bound">ft</span> <span class="free">p</span> <span class="main">(</span>Some <span class="bound">a2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> guha_table_semantics_ex2res<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This means that, given at least two distinct actions exist and our matcher <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">γ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not false for all possible match conditions, 
we can say that a flow table and two actions exist such that both actions are executed. This can be misleading, as the switch might choose an 
ordering on some flow table and never execute some of the (overlapped) actions.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Instead, we decided to follow Section 5.3 of the specification \cite{specification15}, which states:
\begin{quote}
  If there are multiple matching flow entries, the selected flow entry is explicitly undefined.
\end{quote}
This still leaves some room for interpretation, but it clearly states that overlapping flow entries are undefined behavior, 
  and undefined behavior should not be invoked.
Thus, we came up with a semantics that clearly indicates when undefined behavior has been invoked:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"OF_priority_match <span class="free">γ</span> <span class="free">flow_entries</span> <span class="free">packet</span> <span class="main">=</span> <span class="main">(</span>
  <span class="keyword1">let</span> <span class="bound">m</span>  <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">f</span><span class="main">)</span> <span class="free">packet</span><span class="main">)</span> <span class="free">flow_entries</span><span class="main">;</span>
  	  <span class="bound">m'</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">fo</span> <span class="main">∈</span> set <span class="bound">m</span><span class="main">.</span> ofe_prio <span class="bound">fo</span> <span class="main">≤</span> ofe_prio <span class="bound">f</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">in</span>
  	<span class="keyword1">case</span> <span class="bound">m'</span> <span class="keyword1">of</span> <span class="main">[]</span>  <span class="main">⇒</span> NoAction
             <span class="main">|</span> <span class="main">[</span><span class="bound">s</span><span class="main">]</span> <span class="main">⇒</span> Action <span class="main">(</span>ofe_action <span class="bound">s</span><span class="main">)</span>
             <span class="main">|</span>  <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> Undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> OF_priority_match_def <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The definition works the following way\footnote{Note that the order of the flow table entries is irrelevant. 
We could have made this definition on sets but chose not to for consistency.}:
\begin{enumerate}
  \item The flow table is filtered for those entries that match, the result is called $m$.
  \item $m$ is filtered again, leaving only those entries for which no entries with lower priority could be found, i.e. the matching flow table entries with minimal priority. The result is called $m'$.
  \item A case distinction on $m'$ is made. If only one matching entry was found, its action is returned for execution. 
  If $m$ is empty, the flow table semantics returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">NoAction</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to indicate that the flow table does not decide an action for the packet.
  If,  not zero or one entry is found, but more, the special value <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Undefined</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for indicating undefined behavior is returned.
\end{enumerate}
The use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Undefined</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> immediately raises the question in which condition it cannot occur.
We give the following definition:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"check_no_overlap <span class="free">γ</span> <span class="free">ft</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> set <span class="free">ft</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">≠</span> <span class="bound">b</span> <span class="main">∧</span> ofe_prio <span class="bound">a</span> <span class="main">=</span> ofe_prio <span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">a</span><span class="main">)</span> <span class="bound">p</span> <span class="main">∧</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="bound">b</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> check_no_overlap_alt check_no_overlap2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Together with distinctness of the flow table, this provides the abscence of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Undefined</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>\footnote{It is slightly stronger than necessary, overlapping rules might be shadowed and thus never influence the behavior.}:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>check_no_overlap <span class="free">γ</span> <span class="free">ft</span><span class="main">;</span> distinct <span class="free">ft</span><span class="main">⟧</span> <span class="main">⟹</span>
  OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_overlapsI no_overlaps_not_unefined<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Given the absence of overlapping or duplicate flow entries, we can show two interesting equivalences.
the first is the equality to the semantics defined by Guha \emph{et al.}:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>check_no_overlap <span class="free">γ</span> <span class="free">ft</span><span class="main">;</span> distinct <span class="free">ft</span><span class="main">⟧</span> <span class="main">⟹</span> 
OF_priority_match <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="main">=</span> option_to_ftb <span class="free">d</span> <span class="main">⟷</span> guha_table_semantics <span class="free">γ</span> <span class="free">ft</span> <span class="free">p</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> guha_equal no_overlapsI<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">option_to_ftb</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> maps between the return type of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">OF_priority_match</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and an option type as one would expect.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The second equality for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">OF_priority_match</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is one that helps reasoning about flow tables.
We define a simple recursive traversal for flow tables:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="main">[]</span> <span class="free">p</span> <span class="main">=</span> NoAction"</span></span>
  <span class="quoted"><span class="quoted">"OF_match_linear <span class="free">γ</span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">as</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">γ</span> <span class="main">(</span>ofe_fields <span class="free">a</span><span class="main">)</span> <span class="free">p</span> <span class="keyword1">then</span> Action <span class="main">(</span>ofe_action <span class="free">a</span><span class="main">)</span> <span class="keyword1">else</span> OF_match_linear <span class="free">γ</span> <span class="free">as</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> OF_match_linear.simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For this definition to be equivalent, we need the flow table to be sorted:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span><span class="quoted"><span class="quoted">"
	<span class="main">⟦</span>no_overlaps <span class="free">γ</span> <span class="free">f</span> <span class="main">;</span>sorted_descending <span class="main">(</span>map ofe_prio <span class="free">f</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span>
	OF_match_linear <span class="free">γ</span> <span class="free">f</span> <span class="free">p</span> <span class="main">=</span> OF_priority_match <span class="free">γ</span> <span class="free">f</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span>  OF_eq<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹As the last step, we implemented a serialization function for flow entries; it has to remain unverified.
The serialization function deals with one little inaccuracy: We have modelled the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">IngressPort</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> match to use the interface name, but OpenFlow requires numerical interface IDs instead.
We deemed that pulling this translation step into the main translation would only make the correctness lemma of the translation more complicated while not increasing the confidence in the correctness significantly.
We thus made replacing interface names by their ID part of the serialization.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Having collected all important definitions and models, we can move on to the conversion.›</span></span>
<span class="comment1">(*text‹\todo{Maybe I should make a sweet little subsection that merges this all into a single model definition.}›*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Translation Implementation›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:convi}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This section explains how the functions that are executed sequentially in a linux firewall can be compressed into a single OpenFlow table.
Creating this flow table in a single step would be immensely complicated.
We thus divided the task into several steps using the following key insights:
\begin{itemize}
  \item All steps that are executed in the linux router can be formulated as a firewall, more specifically, a generalization of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">simple_fw</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that allows arbitrary actions instead of just accept and drop.
  \item A function that computes the conjunction of two <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">simple_fw</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> matches is already present.
    Extending this to a function that computes the join of two firewalls is relatively simple. This is explained in Section \ref{sec:fwconj}
\end{itemize}
›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Chaining Firewalls›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:fwconj}›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This section explains how to compute the join of two firewalls.›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The basis of this is a generalization of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_fw<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Instead of only allowing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_action.Accept<span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_action.Drop<span class="antiquote"><span class="antiquote">}</span></span></span></span> as actions, it allows arbitrary actions. The type of the function that evaluates this generalized simple firewall is
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'i</span></span><span class="main"><span class="main">::</span></span>len simple_match <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'i</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> simple_packet_scheme <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'i</span></span> simple_match <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
The definition is straightforward:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> 
<span class="quoted"><span class="quoted">"generalized_sfw <span class="main">[]</span> <span class="free">p</span> <span class="main">=</span> None"</span></span> 
<span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">as</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> simple_matches <span class="bound">m</span> <span class="free">p</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="free">a</span> <span class="keyword1">else</span> generalized_sfw <span class="free">as</span> <span class="free">p</span><span class="main">)</span>"</span></span>
	<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> generalized_sfw_simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Based on that, we asked: if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fw<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> makes the decision <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the second element of the result tuple from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> generalized_sfw<span class="antiquote"><span class="antiquote">}</span></span></span></span>) and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fw<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> makes the decision <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, how can we compute the firewall that
makes the decision <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">a</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">b</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>\footnote{Note that tuples are right-associative in Isabelle/HOL, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">a</span></span><span class="main"><span class="main">::</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">b</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">c</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">×</span></span><span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a pair of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the pair <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">b</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">c</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>}.
One possible answer is given by the following definition:
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"generalized_fw_join <span class="free">l1</span> <span class="free">l2</span> <span class="main">≡</span> <span class="main">[</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>m1<span class="main">,</span>a<span class="main">)</span> <span class="main">←</span> <span class="free">l1</span><span class="main">,</span> <span class="main">(</span>m2<span class="main">,</span>b<span class="main">)</span> <span class="main">←</span> <span class="free">l2</span><span class="main">,</span> u <span class="main">←</span> <span class="main">(</span><span class="keyword1">case</span> simple_match_and <span class="bound">m1</span> <span class="bound">m2</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span> <span class="main">|</span> Some <span class="bound">s</span> <span class="main">⇒</span> <span class="main">[</span><span class="bound">s</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> generalized_fw_join_def<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> option2list_def<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This definition validates the following lemma:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"generalized_sfw <span class="main">(</span>generalized_fw_join <span class="free">fw<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">fw<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">d<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="free">d<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">r<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> generalized_sfw <span class="free">fw<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">r<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="free">d<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∧</span> generalized_sfw <span class="free">fw<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">p</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">r<span class="hidden">⇩</span><sub>2</sub></span><span class="main">,</span><span class="free">d<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∧</span> Some <span class="free">u</span> <span class="main">=</span> simple_match_and <span class="bound">r<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">r<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> generalized_fw_joinD sym <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generalized_fw_joinI<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Thus, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> generalized_fw_join<span class="antiquote"><span class="antiquote">}</span></span></span></span> has a number of applications.
For example, it could be used to compute a firewall ruleset that represents two firewalls that are executed in sequence.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">simple_action_conj</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> simple_action.Accept <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> simple_action.Accept <span class="keyword1">then</span> simple_action.Accept <span class="keyword1">else</span> simple_action.Drop<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">simple_rule_conj</span> <span class="main">≡</span> <span class="main">(</span>uncurry SimpleRule <span class="main">∘</span> apsnd <span class="main">(</span>uncurry simple_action_conj<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"simple_fw <span class="free">rs<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">p</span> <span class="main">=</span> Decision FinalAllow <span class="main">∧</span> simple_fw <span class="free">rs<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">p</span> <span class="main">=</span> Decision FinalAllow <span class="main">⟷</span>
simple_fw <span class="main">(</span>map simple_rule_conj <span class="main">(</span>generalized_fw_join <span class="main">(</span>map simple_rule_dtor <span class="free">rs<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>map simple_rule_dtor <span class="free">rs<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> Decision FinalAllow"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> simple_rule_conj_def simple_action_conj_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> simple_fw_join <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def apsnd_def map_prod_def case_prod_unfold uncurry_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Using the join, it should be possible to compute any $n$-ary logical operation on firewalls.
We will use it for something somewhat different in the next section.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Translation Implementation›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹
\begin{figure*}
\begin{framed}
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">≡</span> 
<span class="keyword1">if</span> <span class="main">¬</span> <span class="main">(</span>no_oif_match <span class="free">fw</span> <span class="main">∧</span> has_default_policy <span class="free">fw</span> <span class="main">∧</span> simple_fw_valid <span class="free">fw</span>	<span class="main">∧</span> valid_prefixes <span class="free">rt</span> <span class="main">∧</span> has_default_route <span class="free">rt</span> <span class="main">∧</span> distinct <span class="free">ifs</span><span class="main">)</span>
  <span class="keyword1">then</span> Inl <span class="inner_quoted">''Error in creating OpenFlow table: prerequisites not satisifed''</span>
  <span class="keyword1">else</span> <span class="main">(</span>
<span class="keyword1">let</span>
  <span class="bound">nfw</span> <span class="main">=</span> map simple_rule_dtor <span class="free">fw</span><span class="main">;</span> 
  <span class="bound">frt</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span>route2match <span class="bound">r</span><span class="main">,</span> output_iface <span class="main">(</span>routing_action <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">rt</span><span class="main">;</span> 
  <span class="bound">nrd</span> <span class="main">=</span> generalized_fw_join <span class="bound">frt</span> <span class="bound">nfw</span><span class="main">;</span>
  <span class="bound">ard</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span>apfst of_nat<span class="main">)</span> <span class="main">∘</span> annotate_rlen<span class="main">)</span> <span class="bound">nrd</span>
  <span class="keyword1">in</span>
  <span class="keyword1">if</span> length <span class="bound">nrd</span> <span class="main">&lt;</span> unat <span class="main">(</span>max_word <span class="main">::</span> <span class="numeral">16</span> word<span class="main">)</span>
  <span class="keyword1">then</span> Inr <span class="main">(</span>pack_OF_entries <span class="free">ifs</span> <span class="bound">ard</span><span class="main">)</span>
  <span class="keyword1">else</span> Inl <span class="inner_quoted">''Error in creating OpenFlow table: priority number space exhausted''</span>
<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Let_def lr_of_tran_def lr_of_tran_fbs_def lr_of_tran_s1_def comp_def route2match_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹
  \end{framed}
  \caption{Function for translating a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'i</span></span><span class="main"><span class="main">::</span></span>len simple_rule list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'i</span></span> routing_rule list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and a list of interfaces to a flow table.}
  \label{fig:convi}
\end{figure*}
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
This section shows the actual definition of the translation function, in Figure~\ref{fig:convi}.
Before beginning the translation, the definition checks whether the necessary preconditions are valid.
This first two steps are to convert <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fw</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rt</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to lists that can be evaluated by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> generalized_sfw<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fw</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, this is done by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"map simple_rule_dtor"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which just deconstructs <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_rule<span class="antiquote"><span class="antiquote">}</span></span></span></span>s into tuples of match and action.
For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rt</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we made a firewall ruleset with rules that use prefix matches on the destination IP address.
The next step is to join the two rulesets.
 The result of the join is a ruleset with rules <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that only match if both, the corresponding firewall rule <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fwr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the corresponding routing rule <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> matches.
The data accompanying <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the port from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the firewall decision from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fwr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Next, descending priorities are added to the rules using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"map <span class="main"><span class="main">(</span></span>apfst word_of_nat<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∘</span></span> annotate_rlen"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
If the number of rules is too large to fit into the $2^{16}$ priority classes, an error is returned.
Otherwise, the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> pack_OF_entries<span class="antiquote"><span class="antiquote">}</span></span></span></span> is used to convert the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">16</span></span> word <span class="main"><span class="main">×</span></span> <span class="numeral"><span class="numeral">32</span></span> simple_match <span class="main"><span class="main">×</span></span> char list <span class="main"><span class="main">×</span></span> simple_action<span class="main"><span class="main">)</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to an OpenFlow table.
While converting the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"char list <span class="main"><span class="main">×</span></span> simple_action"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> tuple is straightforward, converting the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> to an equivalent list of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"of_match_field set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is non-trivial.
This is done by the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The main difficulties for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> lie in making sure that the prerequisites are satisfied
 and in the fact that a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> operates on slightly stronger match expressions.
\begin{itemize}
  \item A <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> allows a (string) prefix match on the input and output interfaces.
    Given a list of existing interfaces on the router <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">ifs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the function has to insert flow entries for each interface matching the prefix.
  \item A <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> can match ports by an interval. Now it becomes obvious why Section~\ref{sec:of_match} added bitmasks to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> L4Src<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> L4Dst<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    Using the algorithm to split word intervals into intervals that can be represented by prefix matches from~\cite{diekmann2016verified},
      we can efficiently represent the original interval by a few (32 in the worst case) prefix matches and insert flow entries for each of them.%
      \footnote{It might be possible to represent the interval match more efficiently than a split into prefixes. However, that would produce overlapping matches (which is not a problem if we assing separate priorities) 
        and we did not have a verified implementation of an algorithm that does so.}
\end{itemize}
The following lemma characterizes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> simple_match_to_of_match<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span>
  <span class="quoted"><span class="quoted">"simple_match_valid <span class="free">r</span>"</span></span> 
  <span class="quoted"><span class="quoted">"p_iiface <span class="free">p</span> <span class="main">∈</span> set <span class="free">ifs</span>"</span></span> 
  <span class="quoted"><span class="quoted">"match_iface <span class="main">(</span>oiface <span class="free">r</span><span class="main">)</span> <span class="main">(</span>p_oiface <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"p_l2type <span class="free">p</span> <span class="main">=</span> <span class="numeral">0x800</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"simple_matches <span class="free">r</span> <span class="free">p</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">gr</span> <span class="main">∈</span> set <span class="main">(</span>simple_match_to_of_match <span class="free">r</span> <span class="free">ifs</span><span class="main">)</span><span class="main">.</span> OF_match_fields <span class="bound">gr</span> <span class="free">p</span> <span class="main">=</span> Some True<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms simple_match_to_of_matchD simple_match_to_of_matchI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The assumptions are to be read as follows:
\begin{itemize}
  \item The match <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has to be valid, i.e. it has to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> valid_prefix<span class="antiquote"><span class="antiquote">}</span></span></span></span> matches, and it cannot use anything other than $0$-$65535$ for the port matches unless its protocol match ensures <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> TCP<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> UDP<span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> L4_Protocol.SCTP<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> cannot produce rules for packets that have input interfaces that are not named in the interface list.
  \item The output interface of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has to match the output interface match of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. This is a weakened formulation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"oiface <span class="free"><span class="free">r</span></span> <span class="main"><span class="main">=</span></span> ifaceAny"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, since <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>[display] match_ifaceAny<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    We require this because OpenFlow field matches cannot be used to match on the output port --- they are supposed to match a packet and decide an output port.
  \item The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> type was designed for IP(v4) packets, we limit ourselves to them.
\end{itemize}
The conclusion then states that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">type</span></span> simple_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> matches iff an element of the result of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> matches.
The third assumption is part of the explanation why we did not use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_linux_router_altered<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> simple_match_to_of_match<span class="antiquote"><span class="antiquote">}</span></span></span></span> cannot deal with output interface matches. 
Thus, before passing a generalized simple firewall to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> pack_OF_entries<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we would have to set the output ports to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ifaceAny<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
A system replace output interface matches with destination IP addresses has already been formalized and will be published in a future version of \cite{Iptables_Semantics-AFP}.
For now, we limit ourselves to firewalls that do not do output port matching, i.e., we require <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"no_oif_match <span class="free"><span class="free">fw</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\begin{figure*}
\begin{framed}
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span>
<span class="keyword2"><span class="keyword">fixes</span></span>
  <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">32</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> simple_packet_ext_scheme"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span>
  <span class="quoted"><span class="quoted">"p_iiface <span class="free">p</span> <span class="main">∈</span> set <span class="free">ifs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"p_l2type <span class="free">p</span> <span class="main">=</span> <span class="numeral">0x800</span>"</span></span>
  <span class="quoted"><span class="quoted">"lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">=</span> Inr <span class="free">oft</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[</span>Forward <span class="free">oif</span><span class="main">]</span> <span class="main">⟷</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">p</span><span class="main">⦇</span>p_oiface <span class="main">:=</span> <span class="free">oif</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="main">[]</span> <span class="main">⟷</span> simple_linux_router_nol12 <span class="free">rt</span> <span class="free">fw</span> <span class="free">p</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> NoAction"</span></span> <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">≠</span> Undefined"</span></span>
  <span class="quoted"><span class="quoted">"OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="free">ls</span> <span class="main">⟶</span> length <span class="free">ls</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ls</span><span class="main">.</span> length <span class="bound">ls</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> OF_priority_match OF_match_fields_safe <span class="free">oft</span> <span class="free">p</span> <span class="main">=</span> Action <span class="bound">ls</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms lr_of_tran_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹
\end{framed}
\caption{Central theorem on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> lr_of_tran<span class="antiquote"><span class="antiquote">}</span></span></span></span>}
\label{fig:central}
\end{figure*}
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
Given discussed properties, we present the central theorem for our translation in Figure~\ref{fig:central}.
The first two assumptions are limitations on the traffic we make a statement about.
Obviously, we will never see any packets with an input interface that is not in the interface list.
Furthermore, we do not state anything about non-IPv4 traffic. (The traffic will remain unmatched in by the flow table, but we have not verified that.)
The last assumption is that the translation does not return a run-time error.
The translation will return a run-time error if the rules can not be assigned priorities from a 16 bit integer, 
or when one of the following conditions on the input data is not satisifed:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"
  <span class="main">¬</span> no_oif_match <span class="free">fw</span> <span class="main">∨</span> 
  <span class="main">¬</span> has_default_policy <span class="free">fw</span> <span class="main">∨</span>
  <span class="main">¬</span> simple_fw_valid <span class="free">fw</span>	<span class="main">∨</span>
  <span class="main">¬</span> valid_prefixes <span class="free">rt</span> <span class="main">∨</span>
  <span class="main">¬</span> has_default_route <span class="free">rt</span> <span class="main">∨</span>
  <span class="main">¬</span> distinct <span class="free">ifs</span> <span class="main">⟹</span> 
<span class="main">∃</span><span class="bound">err</span><span class="main">.</span> lr_of_tran <span class="free">rt</span> <span class="free">fw</span> <span class="free">ifs</span> <span class="main">=</span> Inl <span class="bound">err</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lr_of_tran_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Comparison to Exodus›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  We are not the first researchers to attempt automated static migration to SDN.
  The (only) other attempt we are aware of is \emph{Exodus} by Nelson \emph{et al.}~\cite{nelson2015exodus}.
›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
There are some fundamental differences between Exodus and our work:
\begin{itemize}
  \item Exodus focuses on Cisco IOS instead of linux.
  \item Exodus does not produce OpenFlow rulesets, but FlowLog~\cite{nelson2014tierless} controller programs.
  \item Exodus is not limited to using a single flow table.
  \item Exodus requires continuous controller interaction for some of its functions.
  \item Exodus attempts to support as much functionality as possible and has implemented support for dynamic routing, VLANs and NAT.
  \item Nelson \emph{et al.} reject the idea that the translation could or should be proven correct.
\end{itemize}
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>