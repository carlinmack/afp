<div id="Error_Monad_Add">
<div class="head"><h1>Theory Error_Monad_Add</h1>
<span class="command">theory</span> <span class="name">Error_Monad_Add</span><br/>
<span class="keyword">imports</span> <a href="Check_Monad.html"><span class="name">Check_Monad</span></a> <a href="Show_Instances.html"><span class="name">Show_Instances</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Error_Monad_Add</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Certification_Monads.Check_Monad"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Show.Show_Instances"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assert_opt Φ ≡ if Φ then Some () else None"</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_opt m e ≡ case m of Some x ⇒ Error_Monad.return x | None ⇒ Error_Monad.error e"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_opt_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_opt None e = error e"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_opt (Some v) e = return v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lift_opt_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflcl_image_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R<span class="hidden">⇧</span><sup>=</sup>``S = S∪R``S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>return_iff</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_return_iff</span><span class="delimiter">[</span><span>return_iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Error_Monad.bind m f = Inr y ⟷ (∃x. m = Inr x ∧ f x = Inr y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_opt_return_iff</span><span class="delimiter">[</span><span>return_iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_opt m e = Inr x ⟷ m=Some x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_opt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>check_return_iff</span><span class="delimiter">[</span><span>return_iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"check Φ e = Inr uu ⟷ Φ"</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>check_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"check True e = succeed"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"check False e = error e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Let_return_iff</span><span class="delimiter">[</span><span>return_iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(let x=v in f x) = Inr w ⟷ f v = Inr w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ERR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"shows ⇒ (unit ⇒ shows)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ERR s ≡ λ_. s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ERRS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal ⇒ (unit ⇒ shows)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ERRS s ≡ ERR (shows s)"</span></span></span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>error_monad_bind_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (bind m f) ⟷ (∀v. m = Inl v ⟶ P (Inl v)) ∧ (∀v. m = Inr v ⟶ P (f v))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>error_monad_bind_split_asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (bind m f) ⟷ ¬ (∃x. m = Inl x ∧ ¬ P (Inl x) ∨ (∃x. m = Inr x ∧ ¬ P (f x)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>error_monad_bind_splits</span><span> </span><span class="delimiter">=</span><span>error_monad_bind_split</span><span> </span><span>error_monad_bind_split_asm</span><span>
</span><span>  
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Option_Monad_Add">
<div class="head"><h1>Theory Option_Monad_Add</h1>
<span class="command">theory</span> <span class="name">Option_Monad_Add</span><br/>
<span class="keyword">imports</span> <a href="Monad_Syntax.html"><span class="name">Monad_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Option_Monad_Add</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Monad_Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oassert Φ ≡ if Φ then Some () else None"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>omap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a⇀'b) ⇒ 'a list ⇀ 'b list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap f [] = Some []"</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f (x#xs) = do { y ← f x; ys ← omap f xs; Some (y#ys) }"</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x∈set l' ⟹ f x = f' x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l=l'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f l = omap f' l'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assert_eq_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"oassert Φ = None ⟷ ¬Φ"</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"oassert Φ = Some u ⟷ Φ"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oassert_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_length</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f l = Some l' ⟹ length l' = length l"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l'</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f (xs@ys) = do {xs ← omap f xs; ys ← omap f ys; Some (xs@ys)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f l = Some l' ⟷ (l' = map (the o f) l ∧ (∀x∈set l. f x ≠ None))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_alt_None</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f l = None ⟷ (∃x∈set l. f x = None)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_nth</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦omap f l = Some l'; i&lt;length l⟧ ⟹ f (l!i) = Some (l'!i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l'</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_eq_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f xs = Some [] ⟷ xs=[]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_eq_Cons_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f xs = Some (y#ys') ⟷ (∃x xs'. xs=x#xs' ∧ f x = Some y ∧ omap f xs' = Some ys')"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_eq_append_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f xs = Some (ys<span class="hidden">⇩</span><sub>1</sub>@ys<span class="hidden">⇩</span><sub>2</sub>) ⟷ (∃xs<span class="hidden">⇩</span><sub>1</sub> xs<span class="hidden">⇩</span><sub>2</sub>. xs=xs<span class="hidden">⇩</span><sub>1</sub>@xs<span class="hidden">⇩</span><sub>2</sub> ∧ omap f xs<span class="hidden">⇩</span><sub>1</sub> = Some ys<span class="hidden">⇩</span><sub>1</sub> ∧ omap f xs<span class="hidden">⇩</span><sub>2</sub> = Some ys<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ys<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_list_all2_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap f xs = Some ys ⟷ (list_all2 (λx y. f x = Some y)) xs ys"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_all2_Cons1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_all2_Cons1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_all2_Cons1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.inject</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>omap_option</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap_option f None = Some None"</span></span></span><span>    
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap_option f (Some x) = do { x ← f x; Some (Some x) }"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_option_conv</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap_option f xx = None ⟷ (∃x. xx=Some x ∧ f x = None)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap_option f xx = (Some (Some x')) ⟷ (∃x. xx=Some x ∧ f x = Some x')"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap_option f xx = (Some None) ⟷ xx=None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xx</span><span class="delimiter">;</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>omap_option_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"omap_option f x = (case x of None ⇒ Some None | Some x ⇒ do { x ← f x; Some (Some x) })"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>omap_prod</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"omap_prod f<span class="hidden">⇩</span><sub>1</sub> f<span class="hidden">⇩</span><sub>2</sub> (a,b) = do { a←f<span class="hidden">⇩</span><sub>1</sub> a; b←f<span class="hidden">⇩</span><sub>2</sub> b; Some (a,b) }"</span></span></span><span>
</span><span>    
</span><span>      
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Extend map function for datatype to option monad.
    TODO: Show reasonable lemmas, like parametricity, etc. 
    Hopefully only depending on BNF-property of datatype
   *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"omap_dt setf mapf f obj ≡ do {
    oassert (∀x∈setf obj. f x ≠ None);
    Some (mapf (the o f) obj)
  }"</span></span></span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SASP_Semantics">
<div class="head"><h1>Theory SASP_Semantics</h1>
<span class="command">theory</span> <span class="name">SASP_Semantics</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SASP_Semantics</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics of Fast-Downward's Multi-Valued Planning Tasks Language›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>name</span><span> </span><span class="delimiter">=</span><span> </span><span>string</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_variable</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"name × nat option × name list"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* var name, axiom layer, atom names *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_variable_section</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_variable list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_initial_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_goal</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × nat) list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_precond</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × nat)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_effect</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_precond list × nat × nat option × nat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_operator</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"name × ast_precond list × ast_effect list × nat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_operator_section</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_operator list"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ast_problem</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ast_variable_section × ast_initial_state × ast_goal × ast_operator_section"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>plan</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"name list"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-Formedness›</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ast_problem</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>problem</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_problem</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>astDom</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_variable_section</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Dom → Vars, D → X*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"astDom ≡ case problem of (D,I,G,δ) ⇒ D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>astI</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_initial_state</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"astI ≡ case problem of (D,I,G,δ) ⇒ I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>astG</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_goal</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"astG ≡ case problem of (D,I,G,δ) ⇒ G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>astδ</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_operator_section</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"astδ ≡ case problem of (D,I,G,δ) ⇒ δ"</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"numVars ≡ length astDom"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"numVals x ≡ length (snd (snd (astDom!x)))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_partial_state ps ≡ 
        distinct (map fst ps) 
      ∧ (∀(x,v) ∈ set ps. x &lt; numVars ∧ v &lt; numVals x)"</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_operator</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_operator ⇒ bool"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_operator ≡ λ(name, pres, effs, cost). 
        wf_partial_state pres 
      ∧ distinct (map (λ(_, v, _, _). v) effs) ― ‹This may be too restrictive›
      ∧ (∀(epres,x,vp,v)∈set effs. 
          wf_partial_state epres 
        ∧ x &lt; numVars ∧ v &lt; numVals x  
        ∧ (case vp of None ⇒ True | Some v ⇒ v&lt;numVals x)
        )
    "</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_formed ≡ 
      ― ‹Initial state›
      length astI = numVars
    ∧ (∀x&lt;numVars. astI!x &lt; numVals x)

      ― ‹Goal›
    ∧ wf_partial_state astG

    ― ‹Operators›
    ∧ (distinct (map fst astδ))
    ∧ (∀π∈set astδ. wf_operator π)
    "</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="delimiter">=</span><span> </span><span>ast_problem</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span>well_formed</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_initial</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"length astI = numVars"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀x&lt;numVars. astI!x &lt; numVals x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>well_formed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_goal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_partial_state astG"</span></span></span><span>    
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>well_formed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_operators</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst astδ)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀π∈set astδ. wf_operator π"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>well_formed_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>      
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics as Transition System›</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇀ nat"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>pstate</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇀ nat"</span></span></span><span>
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Dom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dom = {0..&lt;numVars}"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>range_of_var</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range_of_var x ≡ {0..&lt;numVals x}"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_states ≡ {
      s. dom s = Dom ∧ (∀x∈Dom. the (s x) ∈ range_of_var x)
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span>state</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I v ≡ if v&lt;length astI then Some (astI!v) else None"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>subsuming_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pstate ⇒ state set"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsuming_states partial ≡ { s∈valid_states. partial ⊆<span class="hidden">⇩</span><sub>m</sub> s }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ≡ subsuming_states (map_of astG)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>implicit_pres</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_effect list ⇒ ast_precond list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"implicit_pres effs ≡ 
      map (λ(_,v,vpre,_). (v,the vpre))
          (filter (λ(_,_,vpre,_). vpre≠None) effs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lookup_operator</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"name ⇒ ast_operator option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"lookup_operator name ≡ find (λ(n,_,_,_). n=name) astδ"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>enabled</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"name ⇒ state ⇒ bool"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled name s ≡
        case lookup_operator name of
          Some (_,pres,effs,_) ⇒ 
              s∈subsuming_states (map_of pres)
            ∧ s∈subsuming_states (map_of (implicit_pres effs))
        | None ⇒ False"</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eff_enabled</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ ast_effect ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"eff_enabled s ≡ λ(pres,_,_,_). s∈subsuming_states (map_of pres)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>execute</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"name ⇒ state ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"execute name s ≡ 
        case lookup_operator name of
          Some (_,_,effs,_) ⇒
            s ++ map_of (map (λ(_,x,_,v). (x,v)) (filter (eff_enabled s) effs))
        | None ⇒ undefined                                    
        "</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>path_to</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"path_to s [] s' ⟷ s'=s"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_to s (π#πs) s' ⟷ enabled π s ∧ path_to (execute π s) πs s'"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan ⇒ bool"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plan πs ≡ ∃s'∈G. path_to I πs s'"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Next steps:
      * well-formed stuff
      * Executable SAS+ validator (well_formed and execute function)

  *)</span></span></span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of well-formedness›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_problem</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ∈ valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_initial</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_states_def</span><span> </span><span>Dom_def</span><span> </span><span>I_def</span><span> </span><span>range_of_var_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_operator_wf</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup_operator name = Some π"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_operator π"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst π = name"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>name'</span><span> </span><span>pres</span><span> </span><span>effs</span><span> </span><span>cost</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"π=(name',pres,effs,cost)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>π</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"name'=name"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IN_AST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name,pres,effs,cost) ∈ set astδ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lookup_operator_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prodD</span><span> </span><span>find_Some_iff</span><span class="delimiter">)</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prodD</span><span> </span><span>find_Some_iff</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>  
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IN_AST</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_operator π"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst π = name"</span></span></span><span>   
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_operators</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>execute_preserves_valid</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled name s"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute name s ∈ valid_states"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹enabled name s›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>name'</span><span> </span><span>pres</span><span> </span><span>effs</span><span> </span><span>cost</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup_operator name = Some (name',pres,effs,cost)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lookup_operator_wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_operator (name,pres,effs,cost)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>   
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ++ m ∈ valid_states"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x v. m x = Some v ⟶ x&lt;numVars ∧ v&lt;numVals x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s∈valid_states›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_states_def</span><span> </span><span>Dom_def</span><span> </span><span>range_of_var_def</span><span> </span><span>map_add_def</span><span> </span><span>dom_def</span><span> 
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>  
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x&lt;numVars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v&lt;numVals x"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of (map (λ(_, x, _, y). (x, y)) (filter (eff_enabled s) effs)) x = Some v"</span></span></span><span>    
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>epres</span><span> </span><span>vp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(epres,x,vp,v) ∈ set effs"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>WF</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x&lt;numVars"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v&lt;numVals x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_operator_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span>execute_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>X1</span><span> </span><span>X2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_to_pres_valid</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_to s πs s'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s'∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>s</span><span> </span><span>πs</span><span> </span><span>s'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>path_to.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>execute_preserves_valid</span><span class="delimiter">)</span><span>  
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SASP_Checker">
<div class="head"><h1>Theory SASP_Checker</h1>
<span class="command">theory</span> <span class="name">SASP_Checker</span><br/>
<span class="keyword">imports</span> <a href="SASP_Semantics.html"><span class="name">SASP_Semantics</span></a> <a href="Code_Target_Nat.html"><span class="name">Code_Target_Nat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SASP_Checker</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>SASP_Semantics</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An Executable Checker for Multi-Valued Planning Problem Solutions›</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary Lemmas›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_of_leI</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst l)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k v. (k,v)∈set l ⟹ m k = Some v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of l ⊆<span class="hidden">⇩</span><sub>m</sub> m"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>domIff</span><span> </span><span>map_le_def</span><span> </span><span>map_of_SomeD</span><span> </span><span>not_Some_eq</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ∘ (λ(a, b, c, d). (f a b c d, g a b c d)) = (λ(a,b,c,d). f a b c d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_mp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m⊆<span class="hidden">⇩</span><sub>m</sub>m' ⟹ m k = Some v ⟹ m' k = Some v"</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_le_def</span><span> </span><span>dom_def</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_add_map_of_fold</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇀ 'b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst ps)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ++ map_of ps = fold (λ(k, v) m. m(k ↦ v)) ps m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fold (λ(k, v) m. m(k ↦ v)) ps m(a ↦ b) 
            = fold (λ(k, v) m. m(k ↦ v)) ps (m(a ↦ b))"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ fst ` set ps"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇀ 'b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ps</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_upd_twist</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ps</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>X1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-formedness Check›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>wf_code_thms</span><span> </span><span class="delimiter">=</span><span> 
</span><span>      </span><span>ast_problem.astDom_def</span><span> </span><span>ast_problem.astI_def</span><span> </span><span>ast_problem.astG_def</span><span> </span><span>ast_problem.astδ_def</span><span>
</span><span>      </span><span>ast_problem.numVars_def</span><span> </span><span>ast_problem.numVals_def</span><span> 
</span><span>      </span><span>ast_problem.wf_partial_state_def</span><span> </span><span>ast_problem.wf_operator_def</span><span> </span><span>ast_problem.well_formed_def</span><span>
</span><span>      
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>wf_code_thms</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>ast_problem.well_formed</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution›</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>match_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_precond ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"match_pre ≡ λ(x,v) s. s x = Some v"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>match_pres</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_precond list ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"match_pres pres s ≡ ∀pre∈set pres. match_pre pre s"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>match_implicit_pres</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_effect list ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"match_implicit_pres effs s ≡ ∀(_,x,vp,_)∈set effs. 
      (case vp of None ⇒ True | Some v ⇒ s x = Some v)"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>enabled_opr'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_operator ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled_opr' ≡ λ(name,pres,effs,cost) s. match_pres pres s ∧ match_implicit_pres effs s"</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eff_enabled'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ ast_effect ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eff_enabled' s ≡ λ(pres,_,_,_). match_pres pres s"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute_opr' ≡ λ(name,_,effs,_) s. 
    let effs = filter (eff_enabled' s) effs
    in fold (λ(_,x,_,v) s. s(x↦v)) effs s
  "</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lookup_operator'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ name ⇀ ast_operator"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup_operator' ≡ λ(D,I,G,δ) name. find (λ(n,_,_,_). n=name) δ"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>enabled'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ name ⇒ state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled' problem name s ≡ 
      case lookup_operator' problem name of 
        Some π ⇒ enabled_opr' π s
      | None ⇒ False"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>execute'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ name ⇒ state ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execute' problem name s ≡ 
      case lookup_operator' problem name of 
        Some π ⇒ execute_opr' π s
      | None ⇒ undefined"</span></span></span><span>
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_pres_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst pres)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_pres pres s ⟷ s∈subsuming_states (map_of pres)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_pres pres s ⟷ map_of pres ⊆<span class="hidden">⇩</span><sub>m</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_pres_def</span><span> </span><span>match_pre_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_le_def</span><span> </span><span>map_of_SomeD</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>D</span><span> </span><span>domIff</span><span> </span><span>map_le_def</span><span> </span><span>map_of_eq_Some_iff</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>          
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsuming_states_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_implicit_pres_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map (λ(_, v, _, _). v) effs)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_implicit_pres effs s ⟷ s∈subsuming_states (map_of (implicit_pres effs))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsuming_states_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>match_implicit_pres_def</span><span> </span><span>implicit_pres_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>option.splits</span><span> 
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_map_filter</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_of_leI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_map_filter</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>map_mp</span><span class="delimiter">)</span><span>  
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enabled_opr'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup_operator name = Some π"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled_opr' π s ⟷ enabled name s"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lookup_operator_wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_opr'_def</span><span> </span><span>enabled_def</span><span> </span><span>wf_operator_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>match_pres_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>V</span><span class="delimiter">]</span><span> </span><span>match_implicit_pres_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>V</span><span class="delimiter">]</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_partial_state_def</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span>
</span><span>          </span><span class="delimiter">)</span><span>  
</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eff_enabled'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case eff of (pres,_,_,_) ⇒ wf_partial_state pres"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eff_enabled' s eff ⟷ eff_enabled s eff"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eff_enabled'_def</span><span> </span><span>eff_enabled_def</span><span> </span><span>wf_partial_state_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>match_pres_correct</span><span class="delimiter">)</span><span>  
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>execute_opr'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>LO</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup_operator name = Some π"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute_opr' π s = execute name s"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>π</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>fields</span><span> </span><span>name</span><span> </span><span>pres</span><span> </span><span>effs</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (eff_enabled' s) effs = filter (eff_enabled s) effs"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filter_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eff_enabled'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>V</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lookup_operator_wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LO</span><span class="delimiter">]</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_operator_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst (map (λ(_, x, _, y). (x, y)) (filter (eff_enabled s) effs)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lookup_operator_wf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>LO</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_operator_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_map_filter</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (eff_enabled s) effs"</span></span></span><span>    
</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"fold (λ(_, x, _, v) s. s(x ↦ v)) l s =
         fold (λ(k, v) m. m(k ↦ v)) (map (λ(_, x, _, y). (x, y)) l) s"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_effect list"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execute_opr'_def</span><span> </span><span>execute_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LO</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_add_map_of_fold</span><span class="delimiter">[</span><span>OF</span><span> </span><span>X1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_operator'_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"lookup_operator' problem name = lookup_operator name"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lookup_operator'_def</span><span> </span><span>lookup_operator_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>astδ_def</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>  
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enabled'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled' problem name s = enabled name s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled'_def</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_opr'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>V</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enabled_def</span><span> </span><span>lookup_operator'_correct</span><span class="delimiter">)</span><span>  
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>execute'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled name s"</span></span></span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Intentionally put this here, also we could resolve non-enabled case by reflexivity (undefined=undefined) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute' problem name s = execute name s"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execute'_def</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execute_opr'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>V</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹enabled name s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enabled_def</span><span> </span><span>lookup_operator'_correct</span><span class="delimiter">)</span><span>  
</span><span>        
</span><span>        
</span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>simulate_plan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan ⇒ state ⇀ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"simulate_plan [] s = Some s"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan (π#πs) s = (
        if enabled π s then 
          let s' = execute π s in
          simulate_plan πs s'
        else
          None
      )"</span></span></span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simulate_plan_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan πs s = Some s' ⟷ path_to s πs s'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>s</span><span> </span><span>πs</span><span> </span><span>s'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>path_to.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>check_plan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"check_plan πs = (
        case simulate_plan πs I of 
          None ⇒ False 
        | Some s' ⇒ s' ∈ G)"</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>check_plan_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"check_plan πs ⟷ valid_plan πs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>check_plan_def</span><span> </span><span>valid_plan_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simulate_plan_correct</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>simulate_plan'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ plan ⇒ state ⇀ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem [] s = Some s"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem (π#πs) s = (
      if enabled' problem π s then
        let s = execute' problem π s in
        simulate_plan' problem πs s
      else
        None
    )"</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Avoiding duplicate lookup.›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*[code]  *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simulate_plan'_code</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem [] s = Some s"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem (π#πs) s = (
      case lookup_operator' problem π of
        None ⇒ None
      | Some π ⇒ 
          if enabled_opr' π s then 
            simulate_plan' problem πs (execute_opr' π s)
          else None
    )"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enabled'_def</span><span> </span><span>execute'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>initial_state'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initial_state' problem ≡ let astI = ast_problem.astI problem in (
       λv. if v&lt;length astI then Some (astI!v) else None
     )"</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>check_plan'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ plan ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"check_plan' problem πs = (
      case simulate_plan' problem πs (initial_state' problem) of 
        None ⇒ False 
      | Some s' ⇒ match_pres (ast_problem.astG problem) s')"</span></span></span><span>
</span><span>      
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_problem</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simulate_plan'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem πs s = simulate_plan πs s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>πs</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>simulate_plan.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enabled'_correct</span><span> </span><span>execute'_correct</span><span> </span><span>execute_preserves_valid</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simulate_plan'_correct_paper</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For presentation in paper. 
        Summarizing intermediate refinement step. *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈valid_states"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan' problem πs s = Some s'
            ⟷ path_to s πs s'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simulate_plan'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>simulate_plan_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initial_state'_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"initial_state' problem = I"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initial_state'_def</span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>check_plan'_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"check_plan' problem πs = check_plan πs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst astG)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_goal</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_partial_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S'V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s'∈valid_states"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"simulate_plan πs I = Some s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simulate_plan_correct</span><span> </span><span>path_to_pres_valid</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I_valid</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>check_plan'_def</span><span> </span><span>check_plan_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> 
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>initial_state'_correct</span><span> </span><span>simulate_plan'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I_valid</span><span class="delimiter">]</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>match_pres_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D</span><span> </span><span>S'V</span><span class="delimiter">]</span><span> </span><span>G_def</span><span>
</span><span>            </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Overall checker *)</span></span></span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>verify_plan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem ⇒ plan ⇒ String.literal + unit"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"verify_plan problem πs = (
      if ast_problem.well_formed problem then
        if check_plan' problem πs then Inr () else Inl (STR ''Invalid plan'')
      else Inl (STR ''Problem not well formed'')
    )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>verify_plan_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"verify_plan problem πs = Inr () 
    ⟷ ast_problem.well_formed problem ∧ ast_problem.valid_plan problem πs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_problem.well_formed problem"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>check_plan'_correct</span><span> </span><span>check_plan_correct</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"check_plan' problem πs = valid_plan πs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>verify_plan_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nat_opt_of_integer</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"integer ⇒ nat option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"nat_opt_of_integer i = (if (i ≥ 0) then Some (nat_of_integer i) else None)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Export functions, which includes constructors*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>verify_plan</span><span> </span><span>nat_of_integer</span><span> </span><span>integer_of_nat</span><span> </span><span>nat_opt_of_integer</span><span> </span><span>Inl</span><span> </span><span>Inr</span><span> </span><span>String.explode</span><span> </span><span>String.implode</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>SASP_Checker_Exported</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"code/SASP_Checker_Exported.sml"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PDDL_STRIPS_Semantics">
<div class="head"><h1>Theory PDDL_STRIPS_Semantics</h1>
<span class="command">theory</span> <span class="name">PDDL_STRIPS_Semantics</span><br/>
<span class="keyword">imports</span> <a href="Consistency.html"><span class="name">Consistency</span></a> <a href="Misc.html"><span class="name">Misc</span></a> <a href="Refine_Util.html"><span class="name">Refine_Util</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹PDDL and STRIPS Semantics›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PDDL_STRIPS_Semantics</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Propositional_Proof_Systems.Formulas"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Propositional_Proof_Systems.Sema"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Propositional_Proof_Systems.Consistency"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Automatic_Refinement.Misc"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Automatic_Refinement.Refine_Util"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ▹ _"</span></span></span><span> </span><span class="delimiter">[</span><span>56</span><span class="delimiter">,</span><span>55</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Utility Functions›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index_by f l ≡ map_of (map (λx. (f x,x)) l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_by_eq_Some_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map f l)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index_by f l n = Some x ⟷ (x∈set l ∧ f x = n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_by_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_by_eq_SomeD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index_by f l n = Some x ⟹ (x∈set l ∧ f x = n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_by_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_zip_idx_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length params = length args"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;length args"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct params"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = params ! i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of (zip params args) k = Some (args ! i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtrancl_image_idem</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R<span class="hidden">⇧</span><sup>*</sup> `` R<span class="hidden">⇧</span><sup>*</sup> `` s = R<span class="hidden">⇧</span><sup>*</sup> `` s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>relcomp_Image</span><span> </span><span>rtrancl_idemp_self_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic Entities›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>name</span><span> </span><span class="delimiter">=</span><span> </span><span>string</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>predicate</span><span> </span><span class="delimiter">=</span><span> </span><span>Pred</span><span> </span><span class="delimiter">(</span><span>name</span><span class="delimiter">:</span><span> </span><span>name</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some of the AST entities are defined over a polymorphic ‹'val› type,
  which gets either instantiated by variables (for domains)
  or objects (for problems).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An atom is either a predicate with arguments, or an equality statement.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'ent</span><span> </span><span>atom</span><span> </span><span class="delimiter">=</span><span> </span><span>predAtm</span><span> </span><span class="delimiter">(</span><span>predicate</span><span class="delimiter">:</span><span> </span><span>predicate</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>arguments</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent list"</span></span></span><span class="delimiter">)</span><span>
</span><span>                     </span><span class="delimiter">|</span><span> </span><span>Eq</span><span> </span><span class="delimiter">(</span><span>lhs</span><span class="delimiter">:</span><span> </span><span class="tfree">'ent</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rhs</span><span class="delimiter">:</span><span> </span><span class="tfree">'ent</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A type is a list of primitive type names.
  To model a primitive type, we use a singleton list.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>type</span><span> </span><span class="delimiter">=</span><span> </span><span>Either</span><span> </span><span class="delimiter">(</span><span>primitives</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"name list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An effect contains a list of values to be added, and a list of values
  to be removed.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'ent</span><span> </span><span>ast_effect</span><span> </span><span class="delimiter">=</span><span> </span><span>Effect</span><span> </span><span class="delimiter">(</span><span>adds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ent atom formula) list"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>dels</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ent atom formula) list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Variables are identified by their names.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>variable</span><span> </span><span class="delimiter">=</span><span> </span><span>varname</span><span class="delimiter">:</span><span> </span><span>Var</span><span> </span><span>name</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Objects and constants are identified by their names›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>object</span><span> </span><span class="delimiter">=</span><span> </span><span>name</span><span class="delimiter">:</span><span> </span><span>Obj</span><span> </span><span>name</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span>VAR</span><span> </span><span>variable</span><span> </span><span class="delimiter">|</span><span> </span><span>CONST</span><span> </span><span>object</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>VAR</span><span> </span><span>CONST</span><span> </span><span class="comment">― ‹Refer to constructors by qualified names only›</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Domains›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An action schema has a name, a typed parameter list, a precondition,
  and an effect.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ast_action_schema</span><span> </span><span class="delimiter">=</span><span> </span><span>Action_Schema</span><span>
</span><span>  </span><span class="delimiter">(</span><span>name</span><span class="delimiter">:</span><span> </span><span>name</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>parameters</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(variable × type) list"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>precondition</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term atom formula"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>effect</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term ast_effect"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A predicate declaration contains the predicate's name and its
  argument types.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>predicate_decl</span><span> </span><span class="delimiter">=</span><span> </span><span>PredDecl</span><span>
</span><span>  </span><span class="delimiter">(</span><span>pred</span><span class="delimiter">:</span><span> </span><span>predicate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>argTs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A domain contains the declarations of primitive types, predicates,
  and action schemas.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ast_domain</span><span> </span><span class="delimiter">=</span><span> </span><span>Domain</span><span>
</span><span>  </span><span class="delimiter">(</span><span>types</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name × name) list"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment">― ‹ ‹(type, supertype)› declarations. ›</span><span>
</span><span>  </span><span class="delimiter">(</span><span>predicates</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"predicate_decl list"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"consts"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object × type) list"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>actions</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_action_schema list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Problems›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A fact is a predicate applied to objects.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fact</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"predicate × object list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A problem consists of a domain, a list of objects,
  a description of the initial state, and a description of the goal state. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ast_problem</span><span> </span><span class="delimiter">=</span><span> </span><span>Problem</span><span>
</span><span>  </span><span class="delimiter">(</span><span>domain</span><span class="delimiter">:</span><span> </span><span>ast_domain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>objects</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object × type) list"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"object atom formula list"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>goal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"object atom formula"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Plans›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>plan_action</span><span> </span><span class="delimiter">=</span><span> </span><span>PAction</span><span>
</span><span>  </span><span class="delimiter">(</span><span>name</span><span class="delimiter">:</span><span> </span><span>name</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>arguments</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"object list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>plan</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ground Actions›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following datatype represents an action scheme that has been
  instantiated by replacing the arguments with concrete objects,
  also called ground action.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ground_action</span><span> </span><span class="delimiter">=</span><span> </span><span>Ground_Action</span><span>
</span><span>  </span><span class="delimiter">(</span><span>precondition</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object atom) formula"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>effect</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ast_effect"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Closed-World Assumption, Equality, and Negation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Discriminator for atomic predicate formulas.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_predAtom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_predAtom (Atom (predAtm _ _)) = True"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_predAtom _ = False"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The world model is a set of (atomic) formulas›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>world_model</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"object atom formula set"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It is basic, if it only contains atoms›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M ≡ ∀a∈M. is_predAtom a"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A valuation extracted from the atoms of the world model›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valuation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ object atom valuation"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation M ≡ λpredAtm p xs ⇒ Atom (predAtm p xs) ∈ M | Eq a b ⇒ a=b"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augment a world model by adding negated versions of all atoms
    not contained in it, as well as interpretations of equality.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>close_world</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ world_model"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_world M =
    M ∪ {<span class="hidden">❙</span><span class="bold">¬</span>(Atom (predAtm p as)) | p as. Atom (predAtm p as) ∉ M}
    ∪ {Atom (Eq a a) | a. True} ∪ {<span class="hidden">❙</span><span class="bold">¬</span>(Atom (Eq a b)) | a b. a≠b}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_neg M ≡ M ∪ {<span class="hidden">❙</span><span class="bold">¬</span>(Atom a) | a. Atom a ∉ M}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M ⟹ close_world M = close_neg (M ∪ {Atom (Eq a a) | a. True})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>close_world_def</span><span> </span><span>close_neg_def</span><span> </span><span>wm_basic_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atom.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cw_entailment</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub>"</span></span></span><span> </span><span>53</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> φ ≡ close_world M ⊫ φ"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>    </span><span>close_world_extensive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆ close_world M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>close_world_idem</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"close_world (close_world M) = close_world M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_world_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_close_world_conv</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"φ ∈ close_world M ⟷ (
        φ∈M
      ∨ (∃p as. φ=<span class="hidden">❙</span><span class="bold">¬</span>(Atom (predAtm p as)) ∧ Atom (predAtm p as)∉M)
      ∨ (∃a. φ=Atom (Eq a a))
      ∨ (∃a b. φ=<span class="hidden">❙</span><span class="bold">¬</span>(Atom (Eq a b)) ∧ a≠b)
    )"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_world_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuation_aux_1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>M</span><span> </span><span class="delimiter">::</span><span> </span><span>world_model</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object atom formula"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≡ close_world M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀φ∈C. 𝒜 ⊨ φ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜 = valuation M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_def</span><span> </span><span>Ball_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atom.collapse</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>is_predAtm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuation_aux_2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀G∈close_world M. valuation M ⊨ G)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wm_basic_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>is_predAtom.elims</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_imp_close_world</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation M ⊨ φ ⟹ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailment_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valuation_aux_1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>close_world_imp_val</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wm_basic M ⟹ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> φ ⟹ valuation M ⊨ φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailment_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valuation_aux_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main theorem of this section:
    If a world model ‹M› contains only atoms, its induced valuation
    satisfies a formula ‹φ› if and only if the closure of ‹M› entails ‹φ›.

    Note that there are no syntactic restrictions on ‹φ›,
    in particular, ‹φ› may contain negation.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>valuation_iff_close_world</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation M ⊨ φ ⟷ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>val_imp_close_world</span><span> </span><span>close_world_imp_val</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proper Generalization›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adding negation and equality is a proper generalization of the
  case without negation and equality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_STRIPS_fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent atom formula ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla (Atom (predAtm _ _)) ⟷ True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla (⊥) ⟷ True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla (φ<span class="hidden">⇩</span><sub>1</sub> <span class="hidden">❙</span><span class="bold">∧</span> φ<span class="hidden">⇩</span><sub>2</sub>) ⟷ is_STRIPS_fmla φ<span class="hidden">⇩</span><sub>1</sub> ∧ is_STRIPS_fmla φ<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla (φ<span class="hidden">⇩</span><sub>1</sub> <span class="hidden">❙</span><span class="bold">∨</span> φ<span class="hidden">⇩</span><sub>2</sub>) ⟷ is_STRIPS_fmla φ<span class="hidden">⇩</span><sub>1</sub> ∧ is_STRIPS_fmla φ<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla (<span class="hidden">❙</span><span class="bold">¬</span>⊥) ⟷ True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla _ ⟷ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦wm_basic M; is_STRIPS_fmla φ; valuation M ⊨ φ; ∀G∈M. 𝒜 ⊨ G⟧ ⟹ 𝒜 ⊨ φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_STRIPS_fmla.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦wm_basic M; is_STRIPS_fmla φ; ∀𝒜. (∀G∈M. 𝒜 ⊨ G) ⟶ 𝒜 ⊨ φ⟧ ⟹ valuation M ⊨ φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_STRIPS_fmla.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuation_iff_STRIPS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_STRIPS_fmla φ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuation M ⊨ φ ⟷ M ⊫ φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀𝒜. ⟦valuation M ⊨ φ; ∀G∈M. 𝒜 ⊨ G⟧ ⟹ 𝒜 ⊨ φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_STRIPS_fmla.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuation_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦∀𝒜. (∀G∈M. 𝒜 ⊨ G) ⟶ 𝒜 ⊨ φ⟧ ⟹ valuation M ⊨ φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_STRIPS_fmla.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_close_world_conv</span><span> </span><span>valuation_aux_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>entailment_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>aux1</span><span> </span><span>aux2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Our extension to negation and equality is a proper generalization of the
  standard STRIPS semantics for formula without negation and equality›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>proper_STRIPS_generalization</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦wm_basic M; is_STRIPS_fmla φ⟧ ⟹ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> φ ⟷ M ⊫ φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valuation_iff_close_world</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>valuation_iff_STRIPS</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹STRIPS Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For this section, we fix a domain ‹D›, using Isabelle's
  locale mechanism.›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ast_domain</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>D</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_domain</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It seems to be agreed upon that, in case of a contradictory effect,
    addition overrides deletion. We model this behaviour by first executing
    the deletions, and then the additions.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>apply_effect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ast_effect ⇒ world_model ⇒ world_model"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"apply_effect (Effect a d) s = (s - set d) ∪ (set a)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execute a ground action›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>execute_ground_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action ⇒ world_model ⇒ world_model"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execute_ground_action a M = apply_effect (effect a) M"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicate to model that the given list of action instances is
    executable, and transforms an initial world model ‹M› into a final
    model ‹M'›.

    Note that this definition over the list structure is more convenient in HOL
    than to explicitly define an indexed sequence ‹M<span class="hidden">⇩</span><sub>0</sub>…M<span class="hidden">⇩</span><sub>N</sub>› of intermediate world
     models, as done in [Lif87].
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ground_action_path</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ ground_action list ⇒ world_model ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ground_action_path M [] M' ⟷ (M = M')"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action_path M (α#αs) M' ⟷ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> precondition α
    ∧ ground_action_path (execute_ground_action α M) αs M'"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Function equations as presented in paper,
    with inlined @{const execute_ground_action}.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ground_action_path_in_paper</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ground_action_path M [] M' ⟷ (M = M')"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ground_action_path M (α#αs) M' ⟷ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> precondition α
    ∧ (ground_action_path (apply_effect (effect α) M) αs M')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>execute_ground_action_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-Formedness of PDDL›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Well-formedness *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Compute signature: predicate/arity
  Check that all atoms (schemas and facts) satisfy signature

  for action:
    Check that used parameters ⊆ declared parameters

  for init/goal: Check that facts only use declared objects
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ty_term</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ty_term varT objT (term.VAR v) = varT v"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_term varT objT (term.CONST c) = objT c"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ty_term_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"varT ⊆<span class="hidden">⇩</span><sub>m</sub> varT' ⟹ objT ⊆<span class="hidden">⇩</span><sub>m</sub> objT' ⟹
  ty_term varT objT ⊆<span class="hidden">⇩</span><sub>m</sub> ty_term varT' objT'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_leI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_leD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The signature is a partial function that maps the predicates
    of the domain to lists of argument types.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sig</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"predicate ⇀ type list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sig ≡ map_of (map (λPredDecl p n ⇒ (p,n)) (predicates D))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We use a flat subtype hierarchy, where every type is a subtype
    of object, and there are no other subtype relations.

    Note that we do not need to restrict this relation to declared types,
    as we will explicitly ensure that all types used in the problem are
    declared.
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subtype_edge</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subtype_edge (ty,superty) = (superty,ty)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subtype_rel ≡ set (map subtype_edge (types D))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  definition "subtype_rel ≡ {''object''}×UNIV"
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>of_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"type ⇒ type ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"of_type oT T ≡ set (primitives oT) ⊆ subtype_rel<span class="hidden">⇧</span><sup>*</sup> `` set (primitives T)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This checks that every primitive on the LHS is contained in or a
    subtype of a primitive on the RHS›</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For the next few definitions, we fix a partial function that maps
    a polymorphic entity type @{typ "'e"} to types. An entity can be
    instantiated by variables or objects later.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ty_ent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent ⇀ type"</span></span></span><span>  </span><span class="comment">― ‹Entity's type, None if invalid›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Checks whether an entity has a given type›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_of_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent ⇒ type ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_of_type v T ⟷ (
        case ty_ent v of
          Some vT ⇒ of_type vT T
        | None ⇒ False)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_pred_atom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"predicate × 'ent list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_pred_atom (p,vs) ⟷ (
        case sig p of
          None ⇒ False
        | Some Ts ⇒ list_all2 is_of_type vs Ts)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicate-atoms are well-formed if their arguments match the
      signature, equalities are well-formed if the arguments are valid
      objects (have a type).

      TODO: We could check that types may actually overlap
    ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_atom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent atom ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_atom (predAtm p vs) ⟷ wf_pred_atom (p,vs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom (Eq a b) ⟷ ty_ent a ≠ None ∧ ty_ent b ≠ None"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A formula is well-formed if it consists of valid atoms,
      and does not contain negations, except for the encoding ‹<span class="hidden">❙</span><span class="bold">¬</span>⊥› of true.
    ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ent atom) formula ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (Atom a) ⟷ wf_atom a"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (⊥) ⟷ True"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (φ1 <span class="hidden">❙</span><span class="bold">∧</span> φ2) ⟷ (wf_fmla φ1 ∧ wf_fmla φ2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (φ1 <span class="hidden">❙</span><span class="bold">∨</span> φ2) ⟷ (wf_fmla φ1 ∧ wf_fmla φ2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (<span class="hidden">❙</span><span class="bold">¬</span>φ) ⟷ wf_fmla φ"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (φ1 <span class="hidden">❙</span><span class="bold">→</span> φ2) ⟷ (wf_fmla φ1 ∧ wf_fmla φ2)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla φ = (∀a∈atoms φ. wf_atom a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma wf_fmla_add_simps[simp]: "wf_fmla (<span class="hidden">❙</span><span class="bold">¬</span>φ) ⟷ φ=⊥"
      by (cases φ) auto*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Special case for a well-formed atomic predicate formula›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_fmla_atom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom (Atom (predAtm a vs)) ⟷ wf_pred_atom (a,vs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom _ ⟷ False"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atom_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom φ ⟷ is_predAtom φ ∧ wf_fmla φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An effect is well-formed if the added and removed formulas
      are atomic›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_effect</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_effect (Effect a d) ⟷
          (∀ae∈set a. wf_fmla_atom ae)
        ∧ (∀de∈set d.  wf_fmla_atom de)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context fixing ‹ty_ent››</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>constT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ⇀ type"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"constT ≡ map_of (consts D)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An action schema is well-formed if the parameter names are distinct,
    and the precondition and effect is well-formed wrt.\ the parameters.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_action_schema</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_action_schema ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema (Action_Schema n params pre eff) ⟷ (
      let
        tyt = ty_term (map_of params) constT
      in
        distinct (map fst params)
      ∧ wf_fmla tyt pre
      ∧ wf_effect tyt eff)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A type is well-formed if it consists only of declared primitive types,
     and the type object.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_type</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_type (Either Ts) ⟷ set Ts ⊆ insert ''object'' (fst`set (types D))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A predicate is well-formed if its argument types are well-formed.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_predicate_decl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_predicate_decl (PredDecl p Ts) ⟷ (∀T∈set Ts. wf_type T)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The types declaration is well-formed, if all supertypes are declared types (or object)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_types ≡ snd`set (types D) ⊆ insert ''object'' (fst`set (types D))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A domain is well-formed if
    ▪ there are no duplicate declared predicate names,
    ▪ all declared predicates are well-formed,
    ▪ there are no duplicate action names,
    ▪ and all declared actions are well-formed
    ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_domain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_domain ≡
      wf_types
    ∧ distinct (map (predicate_decl.pred) (predicates D))
    ∧ (∀p∈set (predicates D). wf_predicate_decl p)
    ∧ distinct (map fst (consts D))
    ∧ (∀(n,T)∈set (consts D). wf_type T)
    ∧ distinct (map ast_action_schema.name (actions D))
    ∧ (∀a∈set (actions D). wf_action_schema a)
    "</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹locale ‹ast_domain››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We fix a problem, and also include the definitions for the domain
  of this problem.›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ast_problem</span><span> </span><span class="delimiter">=</span><span> </span><span>ast_domain</span><span> </span><span class="string"><span class="delete"><span class="delete">"domain P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span>ast_problem</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We refer to the problem domain as ‹D››</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≡ ast_problem.domain P"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>objT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ⇀ type"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"objT ≡ map_of (objects P) ++ constT"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>objT_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"objT = map_of (consts D @ objects P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>objT_def</span><span> </span><span>constT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_fact</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fact ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_fact = wf_pred_atom objT"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This definition is needed for well-formedness of the initial model,
    and forward-references to the concept of world model.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_world_model</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M = (∀f∈M. wf_fmla_atom objT f)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Note: current semantics assigns each object a unique type *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_problem</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_problem ≡
      wf_domain
    ∧ distinct (map fst (objects P) @ map fst (consts D))
    ∧ (∀(n,T)∈set (objects P). wf_type T)
    ∧ distinct (init P)
    ∧ wf_world_model (set (init P))
    ∧ wf_fmla objT (goal P)
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_effect_inst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ast_effect ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst (Effect (a) (d))
      ⟷ (∀a∈set a ∪ set d. wf_fmla_atom objT a)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_effect_inst_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst eff = wf_effect objT eff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹locale ‹ast_problem››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale to express a well-formed domain›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>wf_ast_domain</span><span> </span><span class="delimiter">=</span><span> </span><span>ast_domain</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf_domain</span><span class="delimiter">:</span><span> </span><span>wf_domain</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale to express a well-formed problem›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="delimiter">=</span><span> </span><span>ast_problem</span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf_problem</span><span class="delimiter">:</span><span> </span><span>wf_problem</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>wf_ast_domain</span><span> </span><span class="string"><span class="delete"><span class="delete">"domain P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_problem</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_problem_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹locale ‹wf_ast_problem››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹PDDL Semantics›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Semantics *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  To apply plan_action:
    find action schema, instantiate, check precond, apply effect
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve_action_schema</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"name ⇀ ast_action_schema"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"resolve_action_schema n = index_by ast_action_schema.name (actions D) n"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subst_term</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"subst_term psubst (term.VAR x) = psubst x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_term psubst (term.CONST c) = c"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹To instantiate an action schema, we first compute a substitution from
    parameters to objects, and then apply this substitution to the
    precondition and effect. The substitution is applied via the ‹map_xxx›
    functions generated by the datatype package.
    ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>instantiate_action_schema</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ast_action_schema ⇒ object list ⇒ ground_action"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"instantiate_action_schema (Action_Schema n params pre eff) args = (let
        tsubst = subst_term (the o (map_of (zip (map fst params) args)));
        pre_inst = (map_formula o map_atom) tsubst pre;
        eff_inst = (map_ast_effect) tsubst eff
      in
        Ground_Action pre_inst eff_inst
      )"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Initial model›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I ≡ set (init P)"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Resolve a plan action and instantiate the referenced action schema.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>resolve_instantiate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action ⇒ ground_action"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"resolve_instantiate (PAction n args) =
      instantiate_action_schema
        (the (resolve_action_schema n))
        args"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Check whether object has specified type›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_obj_of_type n T ≡ case objT n of
    None ⇒ False
  | Some oT ⇒ of_type oT T"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We can also use the generic ‹is_of_type› function.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_obj_of_type_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_obj_of_type = is_of_type objT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_obj_of_type_def</span><span> </span><span>is_of_type_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HOL encoding of matching an action's formal parameters against an
    argument list.
    The parameters of the action are encoded as a list of ‹name×type› pairs,
    such that we map it to a list of types first. Then, the list
    relator @{const list_all2} checks that arguments and types have the same
    length, and each matching pair of argument and type
    satisfies the predicate @{const is_obj_of_type}.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"action_params_match a args
    ≡ list_all2 is_obj_of_type args (map snd (parameters a))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹At this point, we can define well-formedness of a plan action:
    The action must refer to a declared action schema, the arguments must
    be compatible with the formal parameters' types.
  ›</span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Objects are valid and match parameter types *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_plan_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_plan_action (PAction n args) = (
      case resolve_action_schema n of
        None ⇒ False
      | Some a ⇒
          action_params_match a args
        ∧ wf_effect_inst (effect (instantiate_action_schema a args))
        )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    TODO: The second conjunct is redundant, as instantiating a well formed
      action with valid objects yield a valid effect.
  ›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A sequence of plan actions form a path, if they are well-formed and
    their instantiations form a path.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>plan_action_path</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ plan_action list ⇒ world_model ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plan_action_path M πs M' =
        ((∀π ∈ set πs. wf_plan_action π)
      ∧ ground_action_path M (map resolve_instantiate πs) M')"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A plan is valid wrt.\ a given initial model, if it forms a path to a
    goal model ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plan_from</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ plan ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"valid_plan_from M πs = (∃M'. plan_action_path M πs M' ∧ M' <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> (goal P))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Implementation note: resolve and instantiate already done inside
      enabledness check, redundancy! *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, a plan is valid if it is valid wrt.\ the initial world
    model @{const I}›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plan</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plan ≡ valid_plan_from I"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concise definition used in paper:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plan πs ≡ ∃M'. plan_action_path I πs M' ∧ M' <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> (goal P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_plan_def</span><span> </span><span>valid_plan_from_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_problem››</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of Well-Formedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-Formed Action Instances›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The goal of this section is to establish that well-formedness of
  world models is preserved by execution of well-formed plan actions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As plan actions are executed by first instantiating them, and then
    executing the action instance, it is natural to define a well-formedness
    concept for action instances.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_ground_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_ground_action (Ground_Action pre eff) ⟷ (
        wf_fmla objT pre
      ∧ wf_effect objT eff
      )
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first prove that instantiating a well-formed action schema will yield
    a well-formed action instance.

    We begin with some auxiliary lemmas before the actual theorem.
  ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ast_domain</span><span class="delimiter">)</span><span> </span><span>of_type_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type T T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_type_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ast_domain</span><span class="delimiter">)</span><span> </span><span>of_type_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"of_type T1 T2 ⟹ of_type T2 T3 ⟹ of_type T1 T3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_type_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span>
</span><span>      </span><span>Image_mono</span><span> </span><span>contra_subsetD</span><span> </span><span>order_refl</span><span> </span><span>rtrancl_image_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_of_type_map_ofE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type (map_of params) x T"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>i</span><span> </span><span>xT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;length params"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"params!i = (x,xT)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type xT T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_of_type_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_atom_mono</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tys ⊆<span class="hidden">⇩</span><sub>m</sub> tys'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom tys a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom tys' a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type tys') xs Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type tys) xs Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>Ts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_of_type_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_leD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>WF</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_leD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atom_mono</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tys ⊆<span class="hidden">⇩</span><sub>m</sub> tys'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom tys a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom tys' a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type tys') xs Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type tys) xs Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>Ts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_of_type_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_leD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>WF</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_leD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constT_ss_objT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"constT ⊆<span class="hidden">⇩</span><sub>m</sub> objT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>constT_def</span><span> </span><span>objT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_add_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_atom_constT_imp_objT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom (ty_term Q constT) a ⟹ wf_atom (ty_term Q objT) a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>wf_atom_mono</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ty_term_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>constT_ss_objT</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atom_constT_imp_objT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom (ty_term Q constT) a ⟹ wf_fmla_atom (ty_term Q objT) a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>wf_fmla_atom_mono</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ty_term_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>constT_ss_objT</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"variable ⇒ object"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type Q x T ⟹ is_of_type objT (f x) T"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_of_type_var_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type (ty_term Q objT) (term.VAR x) T  ⟷ is_of_type Q x T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_of_type_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_of_type_const_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type (ty_term Q objT) (term.CONST x) T  ⟷ is_of_type objT x T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_of_type_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>INST'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type (ty_term Q objT) x T ⟹ is_of_type objT (subst_term f x) T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INST</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_of_type_var_conv</span><span> </span><span>is_of_type_const_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_eq_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q x = Some T ⟹ objT (f x) ≠ None"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INST</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_of_type_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_eq_aux'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_term Q objT x = Some T ⟹ objT (subst_term f x) ≠ None"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_inst_eq_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_atom</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom (ty_term Q constT) a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom objT (map_atom (subst_term f) a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type objT) (map (subst_term f) xs) Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"list_all2 (is_of_type (ty_term Q objT)) xs Ts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>Ts</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INST'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>wf_atom_constT_imp_objT</span><span class="delimiter">]</span><span> </span><span>wf_inst_eq_aux'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_formula_atom</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom (ty_term Q constT) a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom objT ((map_formula o map_atom o subst_term) f a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>wf_fmla_atom_constT_imp_objT</span><span class="delimiter">]</span><span> </span><span>wf_inst_atom</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>INST'</span><span> </span><span>list.rel_map</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list_all2_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_effect</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect (ty_term Q constT) φ"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect objT ((map_ast_effect o subst_term) f φ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Effect</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_inst_formula_atom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_inst_formula</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla (ty_term Q constT) φ"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla objT ((map_formula o map_atom o subst_term) f φ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_inst_atom</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wf_inst_eq_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instantiating a well-formed action schema with compatible arguments
    will yield a well-formed action instance.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_instantiate_action_schema</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"action_params_match a args"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_ground_action (instantiate_action_schema a args)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Action_Schema</span><span> </span><span>name</span><span> </span><span>params</span><span> </span><span>pre</span><span> </span><span>eff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INST</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_of_type objT ((the ∘ map_of (zip (map fst params) args)) x) T"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type (map_of params) x T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>T</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_of_type_map_ofE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>xT</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>action_params_match_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>lookup_zip_idx_eq</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>          </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_all2_lengthD</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>list_all2_nthD2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>                </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_obj_of_type_alt</span><span> </span><span>is_of_type_def</span><span>
</span><span>                </span><span>intro</span><span class="delimiter">:</span><span> </span><span>of_type_trans</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wf_inst_formula</span><span> </span><span>wf_inst_effect</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>term.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>comp_apply</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_problem››</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We start by defining two shorthands for enabledness and execution of
    a plan action.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shorthand for enabled plan action: It is well-formed, and the
    precondition holds for its instance.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>plan_action_enabled</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action ⇒ world_model ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plan_action_enabled π M
      ⟷ wf_plan_action π ∧ M <span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub> precondition (resolve_instantiate π)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shorthand for executing a plan action: Resolve, instantiate, and
    apply effect›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>execute_plan_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action ⇒ world_model ⇒ world_model"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execute_plan_action π M
      = (apply_effect (effect (resolve_instantiate π)) M)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The @{const plan_action_path} predicate can be decomposed naturally
    using these shorthands: ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plan_action_path_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action_path M [] M' ⟷ M'=M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>plan_action_path_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plan_action_path_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plan_action_path M (π#πs) M' ⟷
      plan_action_enabled π M
    ∧ plan_action_path (execute_plan_action π M) πs M'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>plan_action_path_def</span><span> </span><span>execute_plan_action_def</span><span>
</span><span>            </span><span>execute_ground_action_def</span><span> </span><span>plan_action_enabled_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_problem››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The initial world model is well-formed›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model I"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_problem</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>wf_world_model_def</span><span> </span><span>wf_problem_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Application of a well-formed effect preserves well-formedness
    of the model›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_apply_effect</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect objT e"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model (apply_effect e s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>wf_problem</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_world_model_def</span><span> </span><span>wf_problem_def</span><span> </span><span>wf_domain_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>formula.splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution of plan actions preserves well-formedness›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_execute</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action_enabled π s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model (execute_plan_action π s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>π</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>PAction</span><span> </span><span>name</span><span> </span><span>args</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹plan_action_enabled π s›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_plan_action π"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plan_action_enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"resolve_action_schema name = Some a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"action_params_match a args"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wf_domain</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map ast_action_schema.name (actions D))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹resolve_action_schema name = Some a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (actions D)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_action_schema_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wf_domain</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_ground_action (resolve_instantiate π)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹resolve_action_schema name = Some a›</span></span></span><span> </span><span>T</span><span>
</span><span>        </span><span>wf_instantiate_action_schema</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execute_plan_action_def</span><span> </span><span>execute_ground_action_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_apply_effect</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"resolve_instantiate π"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wf_world_model s›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_execute_compact_notation</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plan_action_enabled π s ⟹ wf_world_model s
    ⟹ wf_world_model (execute_plan_action π s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_execute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution of a plan preserves well-formedness›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>wf_plan_action_path</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" plan_action_path M πs M'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>πs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wf_execute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹wf_ast_problem››</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="PDDL_STRIPS_Checker">
<div class="head"><h1>Theory PDDL_STRIPS_Checker</h1>
<span class="command">theory</span> <span class="name">PDDL_STRIPS_Checker</span><br/>
<span class="keyword">imports</span> <a href="PDDL_STRIPS_Semantics.html"><span class="name">PDDL_STRIPS_Semantics</span></a> <a href="Error_Monad_Add.html"><span class="name">Error_Monad_Add</span></a> <a href="Code_Target_Nat.html"><span class="name">Code_Target_Nat</span></a> <a href="While_Combinator.html"><span class="name">While_Combinator</span></a> <a href="Containers.html"><span class="name">Containers</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Executable PDDL Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PDDL_STRIPS_Checker</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>PDDL_STRIPS_Semantics</span><span>
</span><span>
</span><span>  </span><span>Error_Monad_Add</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL.String"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*"HOL-Library.Code_Char"     TODO: This might lead to performance loss! CHECK! *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Nat"</span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.While_Combinator"</span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Containers.Containers"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic DFS Reachability Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Used for subtype checks›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E_of_succ succ ≡ { (u,v). v∈set (succ u) }"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_as_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (succ x) = E_of_succ succ `` {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_of_succ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>succ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ≡ E_of_succ succ"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dfs_reachable D w ≡
  let (V,w,brk) = while (λ(V,w,brk). ¬brk ∧ w≠[]) (λ(V,w,_).
    case w of v#w ⇒
    if D v then (V,v#w,True)
    else if v∈V then (V,w,False)
    else
      let V = insert v V in
      let w = succ v @ w in
      (V,w,False)
    ) ({},w,False)
  in brk"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>w<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_dfs_reachable</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E<span class="hidden">⇧</span><sup>*</sup> `` set w<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"W<span class="hidden">⇩</span><sub>0</sub> ≡ set w<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dfs_reachable_invar D V W brk ⟷
    W<span class="hidden">⇩</span><sub>0</sub> ⊆ W ∪ V
  ∧ W ∪ V ⊆ E<span class="hidden">⇧</span><sup>*</sup> `` W<span class="hidden">⇩</span><sub>0</sub>
  ∧ E``V ⊆ W ∪ V
  ∧ Collect D ∩ V = {}
  ∧ (brk ⟶ Collect D ∩ E<span class="hidden">⇧</span><sup>*</sup> `` W<span class="hidden">⇩</span><sub>0</sub> ≠ {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_decreases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"
   ⟦finite V; y ∉ V; dfs_reachable_invar D V (Set.insert y W) brk ⟧
   ⟹ card (E<span class="hidden">⇧</span><sup>*</sup> `` W<span class="hidden">⇩</span><sub>0</sub> - Set.insert y V) &lt; card (E<span class="hidden">⇧</span><sup>*</sup> `` W<span class="hidden">⇩</span><sub>0</sub> - V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubset_card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dfs_reachable_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_neq_Cons_is_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Odd term remaining in goal … *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀y ys. x2 ≠ y # ys) ⟷ x2 = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dfs_reachable_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dfs_reachable D w<span class="hidden">⇩</span><sub>0</sub> ⟷ Collect D ∩ E<span class="hidden">⇧</span><sup>*</sup> `` set w<span class="hidden">⇩</span><sub>0</sub> ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dfs_reachable_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>while_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(V,w,brk). dfs_reachable_invar D V (set w) brk ∧ finite V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure (λV. card (E<span class="hidden">⇧</span><sup>*</sup> `` (set w<span class="hidden">⇩</span><sub>0</sub>) - V)) &lt;*lex*&gt; measure length &lt;*lex*&gt; measure (λTrue⇒0 | False⇒1)"</span></span></span><span>
</span><span>    </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dfs_reachable_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neq_Nil_conv</span><span> </span><span>succ_as_E</span><span class="delimiter">[</span><span>of</span><span> </span><span>succ</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dfs_reachable_invar_def</span><span> </span><span>Image_iff</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl.rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dfs_reachable_invar_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Image_closed_trancl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neq_Nil_conv</span><span> </span><span>card_decreases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tab_succ l ≡ Mapping.lookup_default [] (fold (λ(u,v). Mapping.map_default u [] (Cons v)) l Mapping.empty)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Some_eq_map_option</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Some y = map_option f xo) = (∃z. xo = Some z ∧ f z = y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_option_case</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tab_succ_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E_of_succ (tab_succ l) = set l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (Mapping.lookup_default [] (fold (λ(u,v). Mapping.map_default u [] (Cons v)) l m) u) = set l `` {u} ∪ set (Mapping.lookup_default [] m u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>u</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Mapping.lookup_default_def</span><span> </span><span>Mapping.map_default_def</span><span> </span><span>Mapping.default_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lookup_map_entry'</span><span> </span><span>lookup_update'</span><span> </span><span>keys_is_none_rep</span><span> </span><span>Option.is_none_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>Mapping.empty</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_of_succ_def</span><span> </span><span>tab_succ_def</span><span> </span><span>lookup_default_empty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_imp_finite_dfs_reachable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦finite E; finite S⟧ ⟹ finite (E<span class="hidden">⇧</span><sup>*</sup>``S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"S ∪ (Relation.Domain E ∪ Relation.Range E)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Domain</span><span> </span><span>finite_Range</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dfs_reachable_tab_succ_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dfs_reachable (tab_succ l) D vs<span class="hidden">⇩</span><sub>0</sub> ⟷ Collect D ∩ (set l)<span class="hidden">⇧</span><sup>*</sup>``set vs<span class="hidden">⇩</span><sub>0</sub> ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>dfs_reachable_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tab_succ_correct</span><span> </span><span>finite_imp_finite_dfs_reachable</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation Refinements›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Of-Type›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type_impl G oT T ≡ (∀pt∈set (primitives oT). dfs_reachable G ((=) pt) (primitives T))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ty_term'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ty_term' varT objT (term.VAR v) = varT v"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_term' varT objT (term.CONST c) = Mapping.lookup objT c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ty_term'_correct_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_term' varT objT t = ty_term varT (Mapping.lookup objT) t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ty_term'_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty_term' varT objT = ty_term varT (Mapping.lookup objT)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ty_term'_correct_aux</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type1 pt T ⟷ pt ∈ subtype_rel<span class="hidden">⇧</span><sup>*</sup> `` set (primitives T)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_type_refine1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type oT T ⟷ (∀pt∈set (primitives oT). of_type1 pt T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_type_def</span><span> </span><span>of_type1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"STG ≡ (tab_succ (map subtype_edge (types D)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtype_rel_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subtype_rel = E_of_succ (tab_succ (map subtype_edge (types D)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tab_succ_correct</span><span> </span><span>subtype_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_type1_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type1 pt T ⟷ dfs_reachable (tab_succ (map subtype_edge (types D))) ((=)pt) (primitives T)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subtype_rel_impl</span><span> </span><span>of_type1_def</span><span> </span><span>dfs_reachable_tab_succ_correct</span><span> </span><span>tab_succ_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_type_impl_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_type_impl STG oT T ⟷ of_type oT T"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_type1_impl</span><span> </span><span>STG_def</span><span> </span><span>of_type_impl_def</span><span> </span><span>of_type_refine1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mp_constT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object, type) mapping"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mp_constT = Mapping.of_alist (consts D)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mp_objT_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Mapping.lookup mp_constT = constT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mp_constT_def</span><span> </span><span>constT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Map_To_Mapping.map_apply_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting the subtype-graph through wf-checker›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ty_ent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ent ⇀ type"</span></span></span><span>  </span><span class="comment">― ‹Entity's type, None if invalid›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type' stg v T ⟷ (
      case ty_ent v of
        Some vT ⇒ of_type_impl stg vT T
      | None ⇒ False)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_of_type'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_of_type' STG v T = is_of_type ty_ent v T"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_of_type'_def</span><span> </span><span>is_of_type_def</span><span> </span><span>of_type_impl_correct</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_pred_atom'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_pred_atom' stg (p,vs) ⟷ (case sig p of
          None ⇒ False
        | Some Ts ⇒ list_all2 (is_of_type' stg) vs Ts)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_pred_atom'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_pred_atom' STG pvs = wf_pred_atom ty_ent pvs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pvs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_of_type'_correct</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_atom'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ 'ent atom ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_atom' stg (atom.predAtm p vs) ⟷ wf_pred_atom' stg (p,vs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom' stg (atom.Eq a b) = (ty_ent a ≠ None ∧ ty_ent b ≠ None)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_atom'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_atom' STG a = wf_atom ty_ent a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_pred_atom'_correct</span><span> </span><span>is_of_type'_correct</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_fmla'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ ('ent atom) formula ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg (Atom a) ⟷ wf_atom' stg a"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg ⊥ ⟷ True"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg (φ1 <span class="hidden">❙</span><span class="bold">∧</span> φ2) ⟷ (wf_fmla' stg φ1 ∧ wf_fmla' stg φ2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg (φ1 <span class="hidden">❙</span><span class="bold">∨</span> φ2) ⟷ (wf_fmla' stg φ1 ∧ wf_fmla' stg φ2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg (φ1 <span class="hidden">❙</span><span class="bold">→</span> φ2) ⟷ (wf_fmla' stg φ1 ∧ wf_fmla' stg φ2)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' stg (<span class="hidden">❙</span><span class="bold">¬</span>φ) ⟷ wf_fmla' stg φ"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla' STG φ ⟷ wf_fmla ty_ent φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_atom'_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_fmla_atom1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom1' stg (Atom (predAtm p vs)) ⟷ wf_pred_atom' stg (p,vs)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom1' stg _ ⟷ False"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atom1'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom1' STG φ = wf_fmla_atom ty_ent φ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_atom'_correct</span><span> </span><span>is_of_type'_correct</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_effect'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_effect' stg (Effect a d) ⟷
          (∀ae∈set a. wf_fmla_atom1' stg ae)
        ∧ (∀de∈set d.  wf_fmla_atom1' stg de)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_effect'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect' STG e = wf_effect ty_ent e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom1'_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context fixing ‹ty_ent››</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wf_action_schema'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ _ ⇒ ast_action_schema ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema' stg conT (Action_Schema n params pre eff) ⟷ (
      let
        tyv = ty_term' (map_of params) conT
      in
        distinct (map fst params)
      ∧ wf_fmla' tyv stg pre
      ∧ wf_effect' tyv stg eff)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_action_schema'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema' STG mp_constT s = wf_action_schema s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fmla'_correct</span><span> </span><span>wf_effect'_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_domain'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ _ ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_domain' stg conT ≡
      wf_types
    ∧ distinct (map (predicate_decl.pred) (predicates D))
    ∧ (∀p∈set (predicates D). wf_predicate_decl p)
    ∧ distinct (map fst (consts D))
    ∧ (∀(n,T)∈set (consts D). wf_type T)
    ∧ distinct (map ast_action_schema.name (actions D))
    ∧ (∀a∈set (actions D). wf_action_schema' stg conT a)
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_domain'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_domain' STG mp_constT = wf_domain"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_domain_def</span><span> </span><span>wf_domain'_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_action_schema'_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Application of Effects›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We implement the application of an effect by explicit iteration over
    the additions and deletions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>apply_effect_exec</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"object ast_effect ⇒ world_model ⇒ world_model"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"apply_effect_exec (Effect a d) s
      = fold (λadd s. Set.insert add s) a
          (fold (λdel s. Set.remove del s) d s)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_effect_exec_refine</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"apply_effect_exec (Effect (a) (d)) s
    = apply_effect (Effect (a) (d)) s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>d</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>d</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>Set.insert_def</span><span> </span><span>sup_assoc</span><span> </span><span>insert_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>minus_set_fold</span><span> </span><span>union_set_fold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>apply_effect_eq_impl_eq</span><span>
</span><span>    </span><span class="delimiter">=</span><span> </span><span>apply_effect_exec_refine</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>apply_effect_exec.simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-Formedness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We start by defining a mapping from objects to types. The container
    framework will generate efficient, red-black tree based code for that
    later. ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>objT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object, type) mapping"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mp_objT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(object, type) mapping"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mp_objT = Mapping.of_alist (consts D @ objects P)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mp_objT_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Mapping.lookup mp_objT = objT"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mp_objT_def</span><span> </span><span>objT_alt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Map_To_Mapping.map_apply_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We refine the typecheck to use the mapping›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_obj_of_type_impl stg mp n T = (
    case Mapping.lookup mp n of None ⇒ False | Some oT ⇒ of_type_impl stg oT T
  )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_obj_of_type_impl_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_obj_of_type_impl STG mp_objT = is_obj_of_type"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_obj_of_type_impl_def</span><span> </span><span>is_obj_of_type_def</span><span> </span><span>of_type_impl_correct</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We refine the well-formedness checks to use the mapping›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_fact'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"objT ⇒ _ ⇒ fact ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_fact' ot stg ≡ wf_pred_atom' (Mapping.lookup ot) stg"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fact'_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fact' mp_objT STG = wf_fact"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fact'_def</span><span> </span><span>wf_fact_def</span><span> </span><span>wf_pred_atom'_correct</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom2' mp stg f
    = (case f of formula.Atom (predAtm p vs) ⇒ (wf_fact' mp stg (p,vs)) | _ ⇒ False)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atom2'_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom2' mp_objT STG φ = wf_fmla_atom objT φ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom2'_def</span><span> </span><span>wf_fact_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_problem' stg conT mp ≡
      wf_domain' stg conT
    ∧ distinct (map fst (objects P) @ map fst (consts D))
    ∧ (∀(n,T)∈set (objects P). wf_type T)
    ∧ distinct (init P)
    ∧ (∀f∈set (init P). wf_fmla_atom2' mp stg f)
    ∧ wf_fmla' (Mapping.lookup mp) stg (goal P)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_problem'_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_problem' STG mp_constT mp_objT = wf_problem"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_problem_def</span><span> </span><span>wf_problem'_def</span><span> </span><span>wf_world_model_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_domain'_correct</span><span> </span><span>wf_fmla'_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instantiating actions will yield well-founded effects.
    Corollary of @{thm wf_instantiate_action_schema}.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_effect_inst_weak</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>args</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ai ≡ instantiate_action_schema a args"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"action_params_match a args"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst (effect ai)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_instantiate_action_schema</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ai_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ai</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_effect_inst_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_problem››</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Resolving an action yields a well-founded action schema.›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This must be implicitly proved when showing that plan execution
    preserves wf. Try to remove this redundancy!*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_action_wf</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resolve_action_schema n = Some a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wf_domain</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>X1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map ast_action_schema.name (actions D))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈set (actions D). wf_action_schema a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_domain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_action_schema_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>index_by_eq_Some_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>X1</span><span class="delimiter">]</span><span> </span><span>X2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution of Plan Actions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We will perform two refinement steps, to summarize redundant operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first lift action schema lookup into the error monad. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resolve_action_schemaE n ≡
    lift_opt
      (resolve_action_schema n)
      (ERR (shows ''No such action schema '' o shows n))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Lifschitz_Consistency">
<div class="head"><h1>Theory Lifschitz_Consistency</h1>
<span class="command">theory</span> <span class="name">Lifschitz_Consistency</span><br/>
<span class="keyword">imports</span> <a href="PDDL_STRIPS_Semantics.html"><span class="name">PDDL_STRIPS_Semantics</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness theorem for the STRIPS semantics›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We prove the soundness theorem according to ~\cite{lifschitz1987semantics}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lifschitz_Consistency</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>PDDL_STRIPS_Semantics</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹States are modeled as valuations of our underlying predicate logic.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(predicate×object list) valuation"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>ast_domain</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An action is a partial function from states to states. ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>action</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇀ state"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Isabelle/HOL formula @{prop ‹f s = Some s'›} means
    that ‹f› is applicable in state ‹s›, and the result is ‹s'›. ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition B (i)--(iv) in Lifschitz's paper~\cite{lifschitz1987semantics}›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_NegPredAtom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_NegPredAtom (Not x) = is_predAtom x"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_NegPredAtom _ = False"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq s = (λpredAtm p xs ⇒ s (p,xs) | Eq a b ⇒ a=b)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>close_eq_predAtm</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq s (predAtm p xs) ⟷ s (p,xs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span class="delimiter">)</span><span>                    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>close_eq_Eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq s (Eq a b) ⟷ a=b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>entail_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ object atom formula ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>=</sub>"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"entail_eq s f ≡ close_eq s ⊨ f"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>sound_opr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action ⇒ action ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sound_opr (Ground_Action pre (Effect add del)) f ⟷
      (∀s. s ⊨<span class="hidden">⇩</span><sub>=</sub> pre ⟶
        (∃s'. f s = Some s' ∧ (∀atm. is_predAtom atm ∧ atm ∉ set del ∧ s ⊨<span class="hidden">⇩</span><sub>=</sub> atm ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> atm)
              ∧  (∀atm. is_predAtom atm ∧ atm ∉ set add ∧ s ⊨<span class="hidden">⇩</span><sub>=</sub> Not atm ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> Not atm)
              ∧ (∀fmla. fmla ∈ set add ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> fmla)
              ∧ (∀fmla. fmla ∈ set del ∧ fmla ∉ set add ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> (Not fmla))
              ))
        ∧ (∀fmla∈set add. is_predAtom fmla)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sound_opr_alt</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sound_opr opr f =
      ((∀s. s ⊨<span class="hidden">⇩</span><sub>=</sub> (precondition opr) ⟶
          (∃s'. f s = (Some s')
                ∧ (∀atm. is_predAtom atm ∧ atm ∉ set(dels (effect opr)) ∧ s ⊨<span class="hidden">⇩</span><sub>=</sub> atm ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> atm)
                ∧ (∀atm. is_predAtom atm ∧ atm ∉ set (adds (effect opr)) ∧ s ⊨<span class="hidden">⇩</span><sub>=</sub> Not atm ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> Not atm)
                ∧ (∀atm. atm ∈ set(adds (effect opr)) ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> atm)
                ∧ (∀fmla. fmla ∈ set (dels (effect opr)) ∧ fmla ∉ set(adds (effect opr)) ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> (Not fmla))
                ∧ (∀a b. s ⊨<span class="hidden">⇩</span><sub>=</sub> Atom (Eq a b) ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> Atom (Eq a b))
                ∧ (∀a b. s ⊨<span class="hidden">⇩</span><sub>=</sub> Not (Atom (Eq a b)) ⟶ s' ⊨<span class="hidden">⇩</span><sub>=</sub> Not (Atom (Eq a b)))
                ))
        ∧ (∀fmla∈set(adds (effect opr)). is_predAtom fmla))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(opr,f)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sound_opr.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition B (v)--(vii) in  Lifschitz's paper~\cite{lifschitz1987semantics}›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sound_system</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action set
      ⇒ world_model
      ⇒ state
      ⇒ (ground_action ⇒ action)
      ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sound_system Σ M<span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>0</sub> f ⟷
      ((∀fmla∈close_world M<span class="hidden">⇩</span><sub>0</sub>. s<span class="hidden">⇩</span><sub>0</sub>  ⊨<span class="hidden">⇩</span><sub>=</sub> fmla)
      ∧ wm_basic M<span class="hidden">⇩</span><sub>0</sub>
      ∧ (∀α∈Σ. sound_opr α (f α)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Composing two actions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compose_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"action ⇒ action ⇒ action"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"compose_action f1 f2 x = (case f2 x of Some y ⇒ f1 y | None ⇒ None)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Composing a list of actions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compose_actions</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"action list ⇒ action"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"compose_actions fs ≡ fold compose_action fs Some"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Composing a list of actions satisfies some natural lemmas: ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compose_actions_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"compose_actions [] = Some"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compose_actions_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compose_actions_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f s = Some s' ⟹ compose_actions (f#fs) s = compose_actions fs s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>monoid_add</span><span> </span><span>compose_action</span><span> </span><span>Some</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compose_action_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f s = Some s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compose_actions_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>compose_action_def</span><span> </span><span>fold_plus_sum_list_rev</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness Theorem in Lifschitz's paper~\cite{lifschitz1987semantics}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>STRIPS_sema_sound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_system Σ M<span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>0</sub> f"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹For a sound system ‹Σ››</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set αs ⊆ Σ"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹And a plan ‹αs››</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ground_action_path M<span class="hidden">⇩</span><sub>0</sub> αs M'"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Which is accepted by the system, yielding result ‹M'›
          (called ‹R(αs)› in Lifschitz's paper~\cite{lifschitz1987semantics}.)›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s'</span><span>
</span><span>    </span><span class="comment">― ‹We have that ‹f(αs)› is applicable
          in initial state, yielding state ‹s'› (called ‹f<span class="hidden">⇩</span><sub>α</sub><span class="hidden">⇩</span><sub>s</sub>(s<span class="hidden">⇩</span><sub>0</sub>)› in Lifschitz's paper~\cite{lifschitz1987semantics}.)›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compose_actions (map f αs) s<span class="hidden">⇩</span><sub>0</sub> = Some s'"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹The result world model ‹M'› is satisfied in state ‹s'››</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀fmla∈close_world M'. s' ⊨<span class="hidden">⇩</span><sub>=</sub> fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(valuation M' ⊨ fmla)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic M'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmla∈M'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fmla</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>fmla</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuation_def</span><span> </span><span>wm_basic_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'. compose_actions (map f αs) s<span class="hidden">⇩</span><sub>0</sub> = Some s' ∧ (∀fmla∈close_world M'. s' ⊨<span class="hidden">⇩</span><sub>=</sub> fmla)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>αs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>M<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>close_world_def</span><span> </span><span>compose_action_def</span><span> </span><span>sound_system_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>α</span><span> </span><span>αs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pre</span><span> </span><span>add</span><span> </span><span>del</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α = Ground_Action pre (Effect add del)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_action.exhaust</span><span> </span><span>ast_effect.exhaust</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"execute_ground_action α M<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_world M<span class="hidden">⇩</span><sub>0</sub> ⊫ precondition α"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0_ent_cwM0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀fmla∈(close_world M<span class="hidden">⇩</span><sub>0</sub>). close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ fmla"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0_ent_alpha_precond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ precondition α"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailment_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f α) s<span class="hidden">⇩</span><sub>0</sub> = Some s<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀atm. is_predAtom atm ⟶ atm ∉ set(dels (effect α))
                                            ⟶ close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ atm
                                            ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ atm)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀fmla. fmla ∈ set(adds (effect α))
                                            ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ fmla)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀atm. is_predAtom atm ∧ atm ∉ set (adds (effect α)) ∧ close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ Not atm ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ Not atm)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀fmla. fmla ∈ set (dels (effect α)) ∧ fmla ∉ set(adds (effect α)) ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ (Not fmla))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀a b. close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ Atom (Eq a b) ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ Atom (Eq a b))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀a b. close_eq s<span class="hidden">⇩</span><sub>0</sub> ⊨ Not (Atom (Eq a b)) ⟶ close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ Not (Atom (Eq a b)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span>-</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span> </span><span>sound_opr_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq s<span class="hidden">⇩</span><sub>1</sub> ⊨ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmla∈close_world ?M<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fmla</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>s1</span><span> </span><span>s0_ent_cwM0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span> </span><span>execute_ground_action_def</span><span> </span><span>wm_basic_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_close_world_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>DiffE</span><span> </span><span>UnE</span><span> </span><span>a</span><span> </span><span>apply_effect.simps</span><span> </span><span>ground_action.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ast_effect.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ast_effect.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>close_world_extensive</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diff_iff</span><span> </span><span>Un_iff</span><span> </span><span>a</span><span> </span><span>ground_action.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ast_domain.apply_effect.simps</span><span> </span><span>ast_domain.close_eq_predAtm</span><span> </span><span>ast_effect.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ast_effect.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>formula_semantics.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>in_close_world_conv</span><span> </span><span>is_predAtom.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀atm. fmla ≠ formula.Atom atm) ⟶ s ⊨ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fmla∈?M<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fmla</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alpha</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s.∀fmla∈set(adds (effect α)). ¬ is_predAtom fmla ⟶ s ⊨ fmla)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span> </span><span>ast_domain.sound_opr_alt</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a</span><span> </span><span>execute_ground_action_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>sound_system_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>fmla</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_basic_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀opr∈Σ. sound_opr opr (f opr))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic ?M<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span> </span><span>execute_ground_action_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>sound_opr.cases</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(α,f α)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sound_opr.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_basic_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_system Σ ?M<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>1</sub> f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_basic_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ass.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>ass.prems</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"compose_actions (map f αs) s<span class="hidden">⇩</span><sub>1</sub> = Some s' ∧ (∀a∈close_world M'. s' ⊨<span class="hidden">⇩</span><sub>=</sub> a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹More compact notation of the soundness theorem.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>STRIPS_sema_sound_compact_version</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sound_system Σ M<span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>0</sub> f ⟹ set αs ⊆ Σ
    ⟹ ground_action_path M<span class="hidden">⇩</span><sub>0</sub> αs M'
    ⟹ ∃s'. compose_actions (map f αs) s<span class="hidden">⇩</span><sub>0</sub> = Some s'
          ∧ (∀fmla∈close_world M'. s' ⊨<span class="hidden">⇩</span><sub>=</sub> fmla)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>STRIPS_sema_sound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹ast_domain››</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness Theorem for PDDL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>wf_ast_problem</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping world models to states›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>state_to_wm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state ⇒ world_model"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_to_wm s = ({formula.Atom (predAtm p xs) | p xs. s (p,xs)})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wm_to_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"world_model ⇒ state"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_to_state M = (λ(p,xs). (formula.Atom (predAtm p xs)) ∈ M)"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wm_to_state_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_to_state M (p, as) ⟷ Atom (predAtm p as) ∈ M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_to_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wm_to_state_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_to_state (state_to_wm s) = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_to_state_def</span><span>
</span><span>      </span><span>state_to_wm_def</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Mapping AST action instances to actions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pddl_opr_to_act g_opr s = (
    let M = state_to_wm s in
    if (wm_to_state (close_world M)) ⊨<span class="hidden">⇩</span><sub>=</sub> (precondition g_opr) then
      Some (wm_to_state (apply_effect (effect g_opr) M))
    else
      None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq_M M = (M ∩ {Atom (predAtm p xs) | p xs. True }) ∪ {Atom (Eq a a) | a. True} ∪ {<span class="hidden">❙</span><span class="bold">¬</span>(Atom (Eq a b)) | a b. a≠b}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_in_wm_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"s ⊨<span class="hidden">⇩</span><sub>=</sub> (formula.Atom atm)
      ⟷ ((formula.Atom atm) ∈ close_eq_M (state_to_wm s))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_to_state_def</span><span>
</span><span>      </span><span>state_to_wm_def</span><span> </span><span>image_def</span><span> </span><span>close_eq_M_def</span><span> </span><span>close_eq_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_in_wm_2_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"close_eq (wm_to_state M) ⊨ (formula.Atom atm)
      ⟷ ((formula.Atom atm) ∈ close_eq_M M)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_to_state_def</span><span>
</span><span>      </span><span>state_to_wm_def</span><span> </span><span>image_def</span><span> </span><span>close_eq_def</span><span> </span><span>close_eq_M_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_dels_preserved</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ (set d)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">" f ∈ M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ apply_effect (Effect a d) M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adds_satisfied</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ (set a)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ apply_effect (Effect a d) M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dels_unsatisfied</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ (set d)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ set a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ apply_effect (Effect a d) M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dels_unsatisfied_2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ set (dels eff)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ set (adds eff)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ apply_effect eff M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_fmla_atm_is_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_fmla_atom objT f ⟹ is_predAtom f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_act_adds_are_atoms</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst effs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ae ∈ set (adds effs)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_predAtom ae"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>effs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_act_adds_dels_atoms</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst effs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ae ∈ set (dels effs)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_predAtom ae"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>effs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_state_close_from_state_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_to_state (close_world (state_to_wm s)) = s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wm_to_state_def</span><span> </span><span>close_world_def</span><span>
</span><span>      </span><span>state_to_wm_def</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_eff_pddl_ground_act_is_sound_opr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect_inst (effect g_opr)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr g_opr ((pddl_opr_to_act g_opr))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_opr_alt</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>g_opr</span><span class="delimiter">;</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pre</span><span> </span><span>eff</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"wm_to_state(apply_effect eff (state_to_wm s))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pddl_opr_to_act_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>atm</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>atm</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span> </span><span>state_to_wm_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>atm</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>atm</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span> </span><span>state_to_wm_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>atm</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>atm</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span> </span><span>state_to_wm_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fmla</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>fmla</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span> </span><span>state_to_wm_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pre</span><span> </span><span>eff</span><span> </span><span>fmla</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>fmla</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">;</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_eff_impt_wf_eff_inst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_effect objT eff ⟹ wf_effect_inst eff"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>eff</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_pddl_ground_act_is_sound_opr</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_ground_action g_opr"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr g_opr (pddl_opr_to_act g_opr)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_eff_impt_wf_eff_inst</span><span> </span><span>wf_eff_pddl_ground_act_is_sound_opr</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>g_opr</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_action_schema_sound_inst</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"action_params_match act args"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_action_schema act"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr
      (instantiate_action_schema act args)
      ((pddl_opr_to_act (instantiate_action_schema act args)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>wf_pddl_ground_act_is_sound_opr</span><span class="delimiter">[</span><span>
</span><span>        </span><span>OF</span><span> </span><span>wf_instantiate_action_schema</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_plan_act_is_sound</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_plan_action (PAction n args)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr
      (instantiate_action_schema (the (resolve_action_schema n)) args)
      ((pddl_opr_to_act
        (instantiate_action_schema (the (resolve_action_schema n)) args)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_action_schema_sound_inst</span><span> </span><span>wf_eff_pddl_ground_act_is_sound_opr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_plan_act_is_sound'</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_plan_action π"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr
      (resolve_instantiate π)
      ((pddl_opr_to_act (resolve_instantiate π)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>wf_plan_act_is_sound</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>π</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_world_model_has_atoms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈M ⟹ wf_world_model M ⟹ is_predAtom f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_fmla_atm_is_atom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_world_model_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wm_to_state_works_for_wf_wm_closed</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M ⟹ fmla∈close_world M ⟹ close_eq (wm_to_state M) ⊨ fmla"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>fmla</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_world_model_def</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span> </span><span>close_world_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wm_to_state_works_for_wf_wm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M ⟹ fmla∈M ⟹ close_eq (wm_to_state M) ⊨ fmla"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>fmla</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_fmla_atom.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_world_model_def</span><span> </span><span>close_eq_def</span><span> </span><span>wm_to_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wm_to_state_works_for_I_closed</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ close_world I"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq (wm_to_state I) ⊨ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wm_to_state_works_for_wf_wm_closed</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>wf_I</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_wm_imp_basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf_world_model M ⟹ wm_basic M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_world_model_def</span><span> </span><span>wm_basic_def</span><span> </span><span>wf_fmla_atm_is_atom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_plan_sound_system</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀π∈ set πs. wf_plan_action π"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_system
      (set (map resolve_instantiate πs))
      I
      (wm_to_state I)
      ((λα. pddl_opr_to_act α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sound_system_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"close_eq(wm_to_state I) ⊨ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ close_world I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>in_close_world_conv</span><span class="delimiter">]</span><span>
</span><span>      </span><span>wm_to_state_works_for_I_closed</span><span> </span><span>wm_to_state_works_for_wf_wm</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_I</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wm_basic I"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_wm_imp_basic</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_I</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sound_opr α (pddl_opr_to_act α)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈ set (map resolve_instantiate πs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_plan_act_is_sound'</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_plan_soundness_theorem</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"plan_action_path I πs M"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"αs ≡ map (pddl_opr_to_act ∘ resolve_instantiate) πs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">⇩</span><sub>0</sub> ≡ wm_to_state I"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'. compose_actions αs s<span class="hidden">⇩</span><sub>0</sub> = Some s' ∧ (∀φ∈close_world M. s' ⊨<span class="hidden">⇩</span><sub>=</sub> φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>STRIPS_sema_sound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_plan_sound_system</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plan_action_path_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Context of ‹wf_ast_problem››</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>