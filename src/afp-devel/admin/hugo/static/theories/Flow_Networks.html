<div id="Fofu_Abs_Base">
<div class="head">
<h1>Theory Fofu_Abs_Base</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Fofu_Abs_Base
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/Rewrite.html">HOL-Library.Rewrite</a>"</span>
  <a href="../Automatic_Refinement/Misc.html">Automatic_Refinement.Misc</a>
  <a href="../Refine_Imperative_HOL/Sepref_Misc.html">Refine_Imperative_HOL.Sepref_Misc</a>
  <span class="quoted">"<a href="../Program-Conflict-Analysis/LTS.html">Program-Conflict-Analysis.LTS</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>  

  <span class="comment1">(* TODO: Move *)</span>
  <span class="keyword1"><span class="command">lemma</span></span> swap_in_iff_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"prod.swap <span class="free">p</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">S</span><span class="main">¯</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
      
<span class="comment1">(* TODO: Move *)</span>  
<span class="keyword1"><span class="command">lemma</span></span> length_filter_disj_or_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span> <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span><span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="main">[</span><span class="bound">x</span> <span class="main">←</span> <span class="free">xs</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∨</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">]</span> <span class="main">=</span> length <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">+</span> length <span class="main">(</span>filter <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>  

<span class="comment1">(* TODO: Move. Extract an element from a summation, combined with congruence. *)</span>  
<span class="keyword1"><span class="command">lemma</span></span> sum_arb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> x_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> x_dif<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">g</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">h</span> <span class="bound">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">g</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">.</span> <span class="free">h</span> <span class="bound">a</span><span class="main">)</span> <span class="main">+</span> <span class="free">g</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_mem <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> sum.union_disjoint<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> sum.cong<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">h</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A_fin x_dif <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
  
    
    
    
<span class="keyword1"><span class="command">lemma</span></span> trcl_cons_conv<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">a</span><span class="main">#</span><span class="free">xs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>trcl <span class="free">R</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">uh</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="bound">uh</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">uh</span><span class="main">,</span><span class="free">xs</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>trcl <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trcl_uncons<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> trcl_conc_conv<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">xs</span><span class="main">@</span><span class="free">ys</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>trcl <span class="free">R</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">uh</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">xs</span><span class="main">,</span><span class="bound">uh</span><span class="main">)</span><span class="main">∈</span>trcl <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">uh</span><span class="main">,</span><span class="free">ys</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>trcl <span class="free">R</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trcl_unconcat <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trcl_concat<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemmas</span></span> trcl_conv <span class="main">=</span> trcl_cons_conv trcl_conc_conv
  <span class="comment1">― ‹Adding these to simpset will split all cons and append operations in paths›</span>

      
      
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Fofu_Impl_Base">
<div class="head">
<h1>Theory Fofu_Impl_Base</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Fofu_Impl_Base
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Fofu_Abs_Base.html">Fofu_Abs_Base</a>
  <a href="../Refine_Imperative_HOL/IICF.html">Refine_Imperative_HOL.IICF</a>
  <a href="../Refine_Imperative_HOL/Sepref_ICF_Bindings.html">Refine_Imperative_HOL.Sepref_ICF_Bindings</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Rewrite.html">HOL-Library.Rewrite</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">hide_type</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> List_Seg.node

  <span class="keyword1"><span class="command">interpretation</span></span> Refine_Monadic_Syntax <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Refine_Add_Fofu">
<div class="head">
<h1>Theory Refine_Add_Fofu</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Refine_Add_Fofu
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Fofu_Impl_Base.html">Fofu_Impl_Base</a> 
  <a href="../DFS_Framework/DFS_Framework_Refine_Aux.html">DFS_Framework.DFS_Framework_Refine_Aux</a>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">hide_type</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> List_Seg.node    
    
  <span class="keyword1"><span class="command">notation</span></span> Heap_Monad.return <span class="main">(</span><span class="quoted">"<span class="keyword1">return</span>"</span><span class="main">)</span>

<span class="comment1">(* Refinement Framework VCG control:
  Idea: Put a frame around stuff in the program where the VCG shall not look into
    on outermost pass, and discharge the frame's content with nested vcg call.
    Very useful with subgoal command, to set up some auxiliary context before
    discharging, e.g., interpret locales, etc.
 
*)</span>  
<span class="comment1">(* TODO: Make this a generic technique:
  Problems: 
    * Splitter will split inside VCG_FRAME (e.g., ifs)

*)</span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">VCG_FRAME</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> nres <span class="main">⇒</span> <span class="main">_</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">VCG_FRAME</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> VCG_FRAME_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"VCG_FRAME <span class="free">x</span> <span class="main">≡</span> VCG_FRAME <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> vcg_intro_frame<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≡</span> VCG_FRAME <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> VCG_FRAME_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> vcg_rem_frame<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">≤</span><span class="free">m'</span> <span class="main">⟹</span> VCG_FRAME <span class="free">m</span> <span class="main">≤</span> <span class="free">m'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> VCG_FRAME_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Graph">
<div class="head">
<h1>Theory Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Directed Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Graph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a specialized graph library for graphs that are induced by 
  capacity matrices.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_Image<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">R</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">R</span> <span class="main">⟧</span> <span class="main">⟹</span> finite <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Image_iff finite_Range Range.intros finite_subset subsetI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_eq_appendE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">ls</span> <span class="main">=</span> <span class="free">fl</span><span class="main">@</span><span class="free">fl'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">l</span> <span class="free">l'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ls</span><span class="main">=</span><span class="free">l</span><span class="main">@</span><span class="free">l'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">l</span><span class="main">=</span><span class="free">fl</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">l'</span> <span class="main">=</span> <span class="free">fl'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> that<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"take <span class="main">(</span>length <span class="free">fl</span><span class="main">)</span> <span class="free">ls</span>"</span></span> <span class="quoted"><span class="quoted">"drop <span class="main">(</span>length <span class="free">fl</span><span class="main">)</span> <span class="free">ls</span>"</span></span><span class="main">]</span> assms 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> drop_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Definitions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We fix the nodes to be natural numbers.
›</span></span>  
  <span class="keyword1"><span class="command">type_synonym</span></span> node <span class="main">=</span> <span class="quoted">nat</span> 
  <span class="keyword1"><span class="command">type_synonym</span></span> edge <span class="main">=</span> <span class="quoted"><span class="quoted">"node <span class="main">×</span> node"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The capacities are left polymorphic, however, they
  are restricted to linearly ordered domains.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'capacity</span> graph <span class="main">=</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> Graph <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">E</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge set"</span></span> <span class="comment1">― ‹Edges of the graph›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node set"</span></span> <span class="comment1">― ‹Nodes of the graph. Exactly the nodes 
  that have adjacent edges.›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∨</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">incoming</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Incoming edges into a node›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">incoming</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">outgoing</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Outgoing edges from a node›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">outgoing</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adjacent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Adjacent edges of a node›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adjacent</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> incoming <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∪</span> outgoing <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">incoming'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node set <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Incoming edges into 
  a set of nodes›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">incoming'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">outgoing'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node set <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Outgoing edges from 
  a set of nodes›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">outgoing'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adjacent'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node set <span class="main">⇒</span> edge set"</span></span> <span class="comment1">― ‹Edges adjacent to a 
  set of nodes›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adjacent'</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> incoming' <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∪</span> outgoing' <span class="free"><span class="bound"><span class="entity">k</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_adj_map</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_adj_map</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">adjacent_nodes</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span> <span class="main">∪</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span>"</span></span>
  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Graph›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Finite Graphs›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Finite_Graph <span class="main">=</span> Graph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_V<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> path <span class="main">=</span> <span class="quoted"><span class="quoted">"edge list"</span></span>

<span class="keyword1"><span class="command">context</span></span> Graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">isPath</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> path <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">isPath</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">isPath</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∧</span> <span class="free">isPath</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">pathVertices</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> path <span class="main">⇒</span> node list"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">pathVertices</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">pathVertices</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="main">=</span> fst <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">#</span> <span class="main">(</span><span class="free">pathVertices</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span>"</span></span>
  
  <span class="comment1">(* TODO: This characterization is probably nicer to work with! Exchange! *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> <span class="entity">pathVertices_fwd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> edge list <span class="main">⇒</span> node list"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pathVertices_fwd</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">#</span>map snd <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> pathVertices_fwd<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">u</span> <span class="free">p</span> <span class="main">=</span> pathVertices_fwd <span class="free">u</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pathVertices_fwd_def
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">connected</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">connected</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> isPath <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span> 
  
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">isReachable</span> <span class="main">≡</span> connected"</span></span> <span class="comment1">(* Deprecated *)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">reachableNodes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node set"</span></span>  
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reachableNodes</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> connected <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">v</span><span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">isShortestPath</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> path <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isShortestPath</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
    <span class="main">≡</span> isPath <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> isPath <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">p'</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟶</span> length <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≤</span> length <span class="bound">p'</span><span class="main">)</span>"</span></span>
      
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">isSimplePath</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> path <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isSimplePath</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> isPath <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∧</span> distinct <span class="main">(</span>pathVertices <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">dist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> nat <span class="main">⇒</span> node <span class="main">⇒</span> bool"</span></span> 
    <span class="comment1">― ‹There is a path of given length between the nodes›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dist</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> isPath <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">∧</span> length <span class="bound">p</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_dist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node <span class="main">⇒</span> nat"</span></span>
    <span class="comment1">― ‹Minimum distance between two connected nodes›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">min_dist</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">d</span><span class="main">.</span> dist <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">d</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Properties›</span></span>
<span class="keyword1"><span class="command">context</span></span> Graph
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> V_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"V <span class="main">=</span> fst<span class="main">`</span>E <span class="main">∪</span> snd<span class="main">`</span>E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> E_ss_VxV<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">⊆</span> V<span class="main">×</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> adjacent_nodes_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"adjacent_nodes <span class="free">u</span> <span class="main">⊆</span> V"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">using</span></span> E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">lemma</span></span> Vfin_imp_Efin<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite V"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite E"</span></span>
  <span class="keyword1"><span class="command">using</span></span> E_ss_VxV assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Efin_imp_Vfin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite E <span class="main">⟹</span> finite V"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> V_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> zero_cap_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E <span class="main">⟹</span> <span class="free">c</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> E_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> succ_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pred_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> 
  incoming_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"incoming <span class="free">u</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  outgoing_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"outgoing <span class="free">u</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  incoming'_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"incoming' <span class="free">U</span> <span class="main">⊆</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  outgoing'_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"outgoing' <span class="free">U</span> <span class="main">⊆</span> E"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def incoming'_def outgoing'_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> 
  incoming_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"incoming <span class="free">u</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span><span class="main">`</span><span class="main">(</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  outgoing_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"outgoing <span class="free">u</span> <span class="main">=</span> Pair <span class="free">u</span><span class="main">`</span><span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  finite_incoming<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V <span class="main">⟹</span> finite <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  finite_outgoing<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V <span class="main">⟹</span> finite <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_alt outgoing_alt <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> 
  finite_incoming'<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V <span class="main">⟹</span> finite <span class="main">(</span>incoming' <span class="free">U</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  finite_outgoing'<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V <span class="main">⟹</span> finite <span class="main">(</span>outgoing' <span class="free">U</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> incoming'_edges<span class="main"><span class="main">]</span></span> 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> outgoing'_edges<span class="main"><span class="main">]</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Summations over Edges and Nodes›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide useful alternative characterizations for summation over 
    all incoming or outgoing edges.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> sum_outgoing_pointwise<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">`</span><span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.reindex<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> sum_incoming_pointwise<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span><span class="main">`</span><span class="main">(</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.reindex<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extend summations over incoming/outgoing edges to summations over
  all nodes, provided the summed-up function is zero for non-edges.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> sum_incoming_extend<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">v</span><span class="main">∈</span>V<span class="main">;</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>E <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum_incoming_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.mono_neutral_left<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms pred_ss_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> sum_outgoing_extend<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">v</span><span class="main">∈</span>V<span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∉</span>E <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">u</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum_outgoing_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.mono_neutral_left<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms succ_ss_V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When summation is done over something that satisfies the capacity 
  constraint, e.g., a flow, the summation can be extended to all 
  outgoing/incoming edges, as the additional edges must have zero capacity.›</span></span>
<span class="comment1">(* TODO: Historical lemmas. Get rid of ∀ quantifier. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> sum_outgoing_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">∀</span><span class="bound">e</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">g</span> <span class="bound">e</span> <span class="main">∧</span> <span class="free">g</span> <span class="bound">e</span> <span class="main">≤</span> <span class="free">c</span> <span class="bound">e</span><span class="main">⟧</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="bound">v</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span> <span class="main">∈</span> V<span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum_outgoing_extend<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym zero_cap_simp<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> sum_incoming_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">∀</span><span class="bound">e</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">g</span> <span class="bound">e</span> <span class="main">∧</span> <span class="free">g</span> <span class="bound">e</span> <span class="main">≤</span> <span class="free">c</span> <span class="bound">e</span><span class="main">⟧</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V<span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="bound">v</span><span class="main">.</span> <span class="free">g</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span> <span class="main">∈</span> V<span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum_incoming_extend<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym zero_cap_simp<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Finite Graphs›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> finite_E<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> Finite_Graph_EI<span class="main">:</span> <span class="quoted"><span class="quoted">"finite E <span class="main">⟹</span> Finite_Graph <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Efin_imp_Vfin<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> adjacent_nodes_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>adjacent_nodes <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
    
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> split_path_simps <span class="quoted">‹Simplification lemmas to split paths›</span>

<span class="keyword1"><span class="command">lemma</span></span> transfer_path<span class="main">:</span>
  <span class="comment1">― ‹Transfer path to another graph›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">p</span><span class="main">∩</span>E <span class="main">⊆</span> Graph.E <span class="free">c'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="free">c'</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> isPath.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.isPath.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_append<span class="main">[</span><span class="operator">split_path_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="main">(</span><span class="free">p1</span> <span class="main">@</span> <span class="free">p2</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> isPath <span class="free">u</span> <span class="free">p1</span> <span class="bound">w</span> <span class="main">∧</span> isPath <span class="bound">w</span> <span class="free">p2</span> <span class="free">v</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span> 
  
<span class="keyword1"><span class="command">lemma</span></span> isPath_head<span class="main">[</span><span class="operator">split_path_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟷</span> fst <span class="free">e</span> <span class="main">=</span> <span class="free">u</span> <span class="main">∧</span> <span class="free">e</span> <span class="main">∈</span> E <span class="main">∧</span> isPath <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_head2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">(</span><span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> fst <span class="main">(</span>hd <span class="free">p</span><span class="main">)</span> <span class="main">=</span> snd <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.isPath_head list.collapse<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> isPath_tail<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="free">e</span><span class="main">]</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟷</span> isPath <span class="free">u</span> <span class="free">p</span> <span class="main">(</span>fst <span class="free">e</span><span class="main">)</span> <span class="main">∧</span> <span class="free">e</span> <span class="main">∈</span> E <span class="main">∧</span> snd <span class="free">e</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append isPath_head<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_tail2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="free">e</span><span class="main">]</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">(</span><span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∧</span> snd <span class="main">(</span>last <span class="free">p</span><span class="main">)</span> <span class="main">=</span> fst <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.isPath_tail append_butlast_last_id<span class="main">)</span>
      
<span class="comment1">(* TODO: Really needed? *)</span>  
<span class="keyword1"><span class="command">lemma</span></span> isPath_append_edge<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isPath <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v''</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> isPath <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">v''</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_edgeset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span><span class="main">;</span> <span class="free">e</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">e</span> <span class="main">∈</span> E"</span></span>
  <span class="keyword1"><span class="command">using</span></span> E_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> isPath_head isPath_append in_set_conv_decomp_first<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> isPath_rtc<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">es</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u1</span></span> <span class="skolem"><span class="skolem">u2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">u2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> <span class="skolem">u1</span> <span class="main">∧</span> isPath <span class="skolem">u2</span> <span class="skolem">es</span> <span class="free">v</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">u2</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
    <span class="keyword1"><span class="command">using</span></span> isPath.simps<span class="main">(</span>2<span class="main">)</span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">u2</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u2</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> rtc_isPath<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> isPath <span class="free">u</span> <span class="bound">p</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtrancl.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>rtrancl_refl <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">a</span> <span class="main">[]</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>rtrancl_into_rtrancl <span class="skolem">u</span> <span class="skolem">u'</span> <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p1</span> <span class="skolem">u'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">using</span></span> rtrancl_into_rtrancl.hyps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="main">(</span><span class="skolem">p1</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> isPath_tail <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> rtci_isPath<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>E<span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> isPath <span class="free">u</span> <span class="bound">p</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E<span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_converseD<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtc_isPath<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1"><span class="command">lemma</span></span> isPath_ex_edge1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u1</span> <span class="main">≠</span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u2</span><span class="main">.</span> <span class="main">(</span><span class="bound">u2</span><span class="main">,</span> <span class="free">u1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w1</span></span> <span class="skolem"><span class="skolem">w2</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="skolem">w1</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">w2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons append_Nil in_set_conv_decomp_first<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="skolem">w1</span> <span class="free">u1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> isPath_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w1</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">w1</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">=</span> <span class="free">u1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹isPath <span class="free">u</span> <span class="skolem">w1</span> <span class="free">u1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> isPath.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="skolem"><span class="skolem">w1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">w1</span> <span class="main">=</span> <span class="skolem">w1'</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">e</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_butlast_last_id<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u2</span><span class="main">,</span> <span class="free">u1</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹isPath <span class="free">u</span> <span class="skolem">w1</span> <span class="free">u1</span>›</span></span> isPath_tail <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.collapse<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="skolem">w1'</span> <span class="main">@</span> <span class="main">(</span><span class="skolem">u2</span><span class="main">,</span> <span class="free">u1</span><span class="main">)</span> <span class="main">#</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">w2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt1 obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_ex_edge2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v1</span> <span class="main">≠</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v2</span><span class="main">.</span> <span class="main">(</span><span class="free">v1</span><span class="main">,</span> <span class="bound">v2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w1</span></span> <span class="skolem"><span class="skolem">w2</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="skolem">w1</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">w2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons append_Nil in_set_conv_decomp_first<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">v1</span> <span class="skolem">w2</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> isPath_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w2</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">w2</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">v1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹isPath <span class="free">v1</span> <span class="skolem">w2</span> <span class="free">v</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> isPath.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="skolem"><span class="skolem">w2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">w2</span> <span class="main">=</span>  <span class="skolem">e</span> <span class="main">#</span> <span class="skolem">w2'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> neq_Nil_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="free">v1</span><span class="main">,</span> <span class="skolem">v2</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹isPath <span class="free">v1</span> <span class="skolem">w2</span> <span class="free">v</span>›</span></span> isPath_head <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.collapse<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="skolem">w1</span> <span class="main">@</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">#</span> <span class="main">(</span><span class="free">v1</span><span class="main">,</span> <span class="skolem">v2</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">w2'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt1 obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Vertices of Paths›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> pathVertices_fwd_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="main">(</span><span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">s</span><span class="main">]</span>"</span></span>  
  <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span><span class="main">#</span>pathVertices_fwd <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="free">p</span>"</span></span>  
  <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="free">e</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">@</span><span class="main">[</span>snd <span class="free">e</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">e</span><span class="main">#</span><span class="free">p2</span><span class="main">)</span> 
    <span class="main">=</span> pathVertices_fwd <span class="free">s</span> <span class="free">p1</span> <span class="main">@</span> pathVertices_fwd <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="free">p2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_fwd_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pathVertices_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span> 
    <span class="main">⟹</span> pathVertices <span class="free">u</span> <span class="free">p</span> <span class="main">=</span> map fst <span class="free">p</span> <span class="main">@</span> <span class="main">[</span>snd <span class="main">(</span>last <span class="free">p</span><span class="main">)</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> pathVertices_singleton_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">s</span> <span class="free">p</span> <span class="main">=</span> <span class="main">[</span><span class="free">u</span><span class="main">]</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="free">s</span><span class="main">=</span><span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_pathVertices_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> length <span class="free">p</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> pathVertices_edgeset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span><span class="main">∈</span>V<span class="main">;</span> isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> set <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> V"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> isPath_edgeset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt V_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> pathVertices_append<span class="main">:</span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">u</span> <span class="main">(</span><span class="free">p1</span> <span class="main">@</span> <span class="free">p2</span><span class="main">)</span> <span class="main">=</span> 
butlast <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p1</span><span class="main">)</span> <span class="main">@</span> pathVertices <span class="main">(</span>last <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p1</span><span class="main">)</span><span class="main">)</span> <span class="free">p2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">es</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pathVertices <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">@</span> <span class="free">p2</span><span class="main">)</span> <span class="main">=</span>  fst <span class="skolem">e</span> <span class="main">#</span> pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="main">(</span><span class="skolem">es</span> <span class="main">@</span> <span class="free">p2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.pathVertices.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> append_Cons<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="main">(</span><span class="skolem">es</span> <span class="main">@</span> <span class="free">p2</span><span class="main">)</span> 
    <span class="main">=</span> butlast <span class="main">(</span>pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span> 
      <span class="main">@</span> pathVertices <span class="main">(</span>last <span class="main">(</span>pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span> <span class="free">p2</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> Cons.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="skolem">e</span> <span class="main">#</span> butlast <span class="main">(</span>pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">=</span> 
    butlast <span class="main">(</span>fst <span class="skolem">e</span> <span class="main">#</span> pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.pathVertices.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
        Graph.pathVertices_alt Nil_is_append_conv butlast.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
        list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="skolem">e</span> <span class="main">#</span> pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span> <span class="main">=</span> pathVertices <span class="skolem">u</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.pathVertices.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span>pathVertices <span class="main">(</span>snd <span class="skolem">e</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">=</span> last <span class="main">(</span>pathVertices <span class="skolem">u</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.pathVertices.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Graph.pathVertices_alt 
    last.simps last_snoc list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> split_path_at_vertex<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">p2</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p1</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p2</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="comment1">(*unfolding pathVertices_fwd*)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> pathVertices_fwd_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp isPath_append<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.isPath_append_edge append_Cons append_Nil append_assoc<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> split_path_at_vertex_complete<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="free">p</span> <span class="main">=</span> <span class="free">pv1</span><span class="main">@</span><span class="free">u</span><span class="main">#</span><span class="free">pv2</span>"</span></span> 
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">p2</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span>"</span></span> 
    <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p1</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="free">p1</span> <span class="main">=</span> <span class="free">pv1</span><span class="main">@</span><span class="main">[</span><span class="free">u</span><span class="main">]</span>"</span></span> 
    <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p2</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">u</span> <span class="free">p2</span> <span class="main">=</span> <span class="free">u</span><span class="main">#</span><span class="free">pv2</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> PV<span class="main">:</span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">s</span> <span class="free">p</span> <span class="main">=</span> <span class="free">pv1</span><span class="main">@</span><span class="free">u</span><span class="main">#</span><span class="free">pv2</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pathVertices_fwd<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> 
    <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">s</span> <span class="skolem">p1</span> <span class="main">=</span> <span class="free">pv1</span><span class="main">@</span><span class="main">[</span><span class="free">u</span><span class="main">]</span>"</span></span> 
    <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="skolem">p2</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices <span class="free">u</span> <span class="skolem">p2</span> <span class="main">=</span> <span class="free">u</span><span class="main">#</span><span class="free">pv2</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="skolem">thesis</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> PV
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">[]</span></span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">[]</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_eq_append_conv<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">pv2</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">[]</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> 
        <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isPath_append pathVertices_alt
      <span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> append_eq_append_conv2<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_eq_appendE append_eq_Cons_conv<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">,</span></span> <span class="operator">elim_format</span><span class="main"><span class="main">]</span></span>
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … l
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> that<span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> 
          <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … l
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> that<span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> 
          <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … l u1 u2 u3
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> that<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> 
          <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> that<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_eq_append_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … l
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> 
            <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span> <span class="keyword1"><span class="command">unfolding</span></span> pathVertices_fwd <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_fwd_cases<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">=</span><span class="free">s</span>"</span></span>
    <span class="main">|</span> <span class="free">p'</span> <span class="free">u</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">#</span><span class="free">p'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p'</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_bwd_cases<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">=</span><span class="free">s</span>"</span></span>
    <span class="main">|</span> <span class="free">p'</span> <span class="free">u</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">t</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p'</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">t</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> pathVertices_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">e</span> <span class="main">∈</span> set <span class="free">p</span> <span class="main">⟹</span> 
  <span class="main">∃</span><span class="bound">vs1</span> <span class="bound">vs2</span><span class="main">.</span> pathVertices_fwd <span class="free">s</span> <span class="free">p</span> <span class="main">=</span> <span class="bound">vs1</span> <span class="main">@</span> fst <span class="free">e</span> <span class="main">#</span> snd <span class="free">e</span> <span class="main">#</span> <span class="bound">vs2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> isPath_bwd_cases<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> isPath_fwd_cases<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> t<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> isPath_fwd_cases<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> t<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  


<span class="comment1">(* TODO: Really needed? *)</span>
<span class="keyword1"><span class="command">lemma</span></span> pathVertices_edge_old<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="free">e</span> <span class="main">∈</span> set <span class="free">p</span> <span class="main">⟹</span> 
  <span class="main">∃</span><span class="bound">vs1</span> <span class="bound">vs2</span><span class="main">.</span> pathVertices <span class="free">u</span> <span class="free">p</span> <span class="main">=</span> <span class="bound">vs1</span> <span class="main">@</span> fst <span class="free">e</span> <span class="main">#</span> snd <span class="free">e</span> <span class="main">#</span> <span class="bound">vs2</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pathVertices_fwd
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pathVertices_edge<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reachability›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> connected_refl<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">v</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> connected_append_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">u</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> connected <span class="free">u</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> isPath_append_edge<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> connected_inV_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>connected <span class="free">u</span> <span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>V <span class="main">⟷</span> <span class="free">u</span><span class="main">∈</span>V"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> connected_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append V_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> connected_edgeRtc<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">u</span> <span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> isPath_rtc rtc_isPath
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> V <span class="main">⟹</span> reachableNodes <span class="free">s</span> <span class="main">⊆</span> V"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> V"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> reachableNodes <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> isPath <span class="free">s</span> <span class="skolem">p</span> <span class="bound">v</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reachableNodes_def connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> V"</span></span> <span class="keyword1"><span class="command">using</span></span> asm
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_head V_alt<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> reachableNodes_E_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span>reachableNodes <span class="free">s</span> <span class="main">⊆</span> reachableNodes <span class="free">s</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> reachableNodes_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> connected_append_edge<span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> reachableNodes_append_edge<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>reachableNodes <span class="free">s</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>reachableNodes <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> reachableNodes_E_closed <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Simple Paths›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> isSimplePath_fwd<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> 
  <span class="main">⟷</span> isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">∧</span> distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def pathVertices_fwd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isSimplePath_singelton<span class="main">[</span><span class="operator">split_path_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="main">[</span><span class="free">e</span><span class="main">]</span> <span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∧</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span> <span class="main">∧</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def isPath_head<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> isSimplePath_append<span class="main">[</span><span class="operator">split_path_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">t</span> 
    <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span><span class="main">.</span> 
      isSimplePath <span class="free">s</span> <span class="free">p1</span> <span class="bound">u</span> 
    <span class="main">∧</span> isSimplePath <span class="bound">u</span> <span class="free">p2</span> <span class="free">t</span> 
    <span class="main">∧</span> set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p1</span><span class="main">)</span> <span class="main">∩</span> set <span class="main">(</span>pathVertices_fwd <span class="bound">u</span> <span class="free">p2</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span>  
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⟷</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> isSimplePath_fwd
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">p2</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> isSimplePath_cons<span class="main">[</span><span class="operator">split_path_simps</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">t</span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span><span class="main">.</span> <span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="main">∧</span> <span class="free">s</span><span class="main">≠</span><span class="bound">u</span> <span class="main">∧</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span>E 
        <span class="main">∧</span> isSimplePath <span class="bound">u</span> <span class="free">p</span> <span class="free">t</span> <span class="main">∧</span> <span class="free">s</span><span class="main">∉</span>set <span class="main">(</span>pathVertices_fwd <span class="bound">u</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> isSimplePath_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">e</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Finite_Graph<span class="main">)</span> simplePath_length_less_V<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&lt;</span> card V"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> pathVertices_edgeset<span class="main">[</span><span class="operator">OF</span> UIV 1<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">with</span></span> 2 finite_V <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>pathVertices <span class="free">u</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> card V"</span></span>
    <span class="keyword1"><span class="command">using</span></span> distinct_card card_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">lemma</span></span> split_simple_path<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">v</span> 
  <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> isSimplePath <span class="free">u</span> <span class="free">p1</span> <span class="bound">w</span> <span class="main">∧</span> isSimplePath <span class="bound">w</span> <span class="free">p2</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def isPath_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p2</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p2</span></span>  <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pathVertices_alt isPath_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
      
<span class="keyword1"><span class="command">lemma</span></span> simplePath_empty_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="main">[]</span> <span class="free">t</span> <span class="main">⟷</span> <span class="free">s</span><span class="main">=</span><span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> simplePath_same_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> e pp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">pp</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def pathVertices_alt isPath_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> isSPath_pathLE<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p'</span><span class="main">.</span> isSimplePath <span class="free">s</span> <span class="bound">p'</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p'</span><span class="main">.</span> <span class="main">⟦</span>length <span class="bound">p'</span> <span class="main">&lt;</span> length <span class="skolem">p</span><span class="main">;</span> isPath <span class="free">s</span> <span class="bound">p'</span> <span class="free">t</span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p'</span><span class="main">.</span> isSimplePath <span class="free">s</span> <span class="bound">p'</span> <span class="free">t</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> isSimplePath <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span>"</span></span>  
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="skolem">p</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> PATH <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_fwd<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="skolem">p</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pv1</span></span> <span class="skolem"><span class="skolem">pv2</span></span> <span class="skolem"><span class="skolem">pv3</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">pv1</span><span class="main">@</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv2</span><span class="main">@</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv3</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> not_distinct_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="skolem"><span class="skolem">p3</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span><span class="main">@</span><span class="skolem">p3</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p3</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> PATH
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> split_path_at_vertex_complete<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> split_path_at_vertex_complete<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">u</span></span><span class="main"><span class="main">#</span></span><span class="skolem"><span class="skolem">pv2</span></span>"</span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">pv3</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p3</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="main">(</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p3</span><span class="main">)</span> <span class="free">t</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> IH<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
      

<span class="keyword1"><span class="command">lemma</span></span> isSPath_no_selfloop<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">u1</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> isSPath_sg_outgoing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span><span class="main">;</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">;</span> <span class="free">v1</span> <span class="main">≠</span> <span class="free">v2</span><span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v2</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp isSimplePath_def pathVertices_alt 
      append_eq_append_conv2 Cons_eq_append_conv append_eq_Cons_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isSPath_sg_incoming<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span><span class="main">;</span> <span class="main">(</span><span class="free">u1</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">;</span> <span class="free">u1</span> <span class="main">≠</span> <span class="free">u2</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u2</span><span class="main">,</span> <span class="free">v1</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp isSimplePath_fwd pathVertices_fwd_def
      append_eq_append_conv2 append_eq_Cons_conv Cons_eq_append_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isSPath_nt_parallel<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EIP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prod.swap <span class="free">e</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> SP <span class="keyword1"><span class="command">have</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_fwd<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"prod.swap <span class="free">e</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> D EIP
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pathVertices_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> P<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> append_eq_append_conv2 Cons_eq_append_conv append_eq_Cons_conv<span class="main">)</span>

<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> isSPath_nt_parallel_old<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> isSPath_nt_parallel<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> isSPath_nt_parallel_pf<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">⟹</span> set <span class="free">p</span> <span class="main">∩</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> isSPath_nt_parallel<span class="main">)</span>
      
<span class="keyword1"><span class="command">lemma</span></span> isSPath_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> distinct <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> not_distinct_decomp <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Edges adjacent to a node that does not lie on a path 
  are not contained in that path:›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> adjacent_edges_not_on_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VNV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adjacent <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> VNV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> pathVertices_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PATH<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"adjacent <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def adjacent_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">corollary</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> incoming_edges_not_on_path<span class="main">:</span> <span class="quoted"><span class="quoted">"incoming <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> outgoing_edges_not_on_path<span class="main">:</span> <span class="quoted"><span class="quoted">"outgoing <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> adjacent_edges_not_on_path<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> adjacent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A simple path over a vertex can be split at this vertex, 
  and there are exactly two edges on the path touching this vertex.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> adjacent_edges_on_simple_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SPATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> VNV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>set <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">u</span> <span class="free">w</span> <span class="free">p2</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">p1</span><span class="main">@</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">#</span><span class="free">p2</span>"</span></span> 
    <span class="quoted"><span class="quoted">"incoming <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="quoted"><span class="quoted">"outgoing <span class="free">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> SPATH <span class="keyword1"><span class="command">have</span></span> 
    PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    DIST<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def pathVertices_fwd<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> split_path_at_vertex<span class="main">[</span><span class="operator">OF</span> VNV<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> PATH<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">v</span> <span class="skolem">p2</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="free">s</span>›</span></span> P1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1'</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p1</span><span class="main">=</span><span class="skolem">p1'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P1'<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1'</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="free">t</span>›</span></span> P2 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="skolem"><span class="skolem">p2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span><span class="main">=</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> VW<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P2'<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">w</span> <span class="skolem">p2'</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p2</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p1'</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">w</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p2'</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">using</span></span> 
      isSPath_sg_outgoing<span class="main">[</span><span class="operator">OF</span> SPATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="skolem">w</span></span><span class="main">]</span> 
      isSPath_sg_incoming<span class="main">[</span><span class="operator">OF</span> SPATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
      isPath_edgeset<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def outgoing_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Distance›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> connected_by_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">v'</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">d</span><span class="main">.</span> dist <span class="free">v</span> <span class="bound">d</span> <span class="free">v'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def connected_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> isPath_distD<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> dist <span class="free">u</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> connected_distI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="free">d</span> <span class="free">v'</span> <span class="main">⟹</span> connected <span class="free">v</span> <span class="free">v'</span>"</span></span>
    <span class="comment1">(*and connectedI_succ: "connected v v' ⟹ (v',v'') ∈ E ⟹ connected v v''"*)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def connected_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> isPath_append_edge<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> min_distI2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>connected <span class="free">v</span> <span class="free">v'</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="main">⟦</span>dist <span class="free">v</span> <span class="bound">d</span> <span class="free">v'</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">d'</span><span class="main">.</span> dist <span class="free">v</span> <span class="bound">d'</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="bound">d</span> <span class="main">≤</span> <span class="bound">d'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">d</span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">Q</span> <span class="main">(</span>min_dist <span class="free">v</span> <span class="free">v'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> min_dist_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> LeastI2_wellorder<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">Q</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> a<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">SOME</span></span> <span class="bound"><span class="bound">d</span></span><span class="main"><span class="main">.</span></span> dist <span class="free"><span class="free">v</span></span> <span class="bound"><span class="bound">d</span></span> <span class="free"><span class="free">v'</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> connected_by_dist <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> someI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> min_distI_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> dist <span class="free">v</span> <span class="free">d</span> <span class="free">v'</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">d'</span><span class="main">.</span> dist <span class="free">v</span> <span class="bound">d'</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">≤</span> <span class="bound">d'</span> <span class="main">⟧</span> <span class="main">⟹</span> min_dist <span class="free">v</span> <span class="free">v'</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> min_distI2 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> connected_by_dist<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Two nodes are connected by a path of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>0›</span></span></span></span>, 
  iff they are equal.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> dist_z_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="main">0</span> <span class="free">v'</span> <span class="main">⟷</span> <span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> dist_z<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="main">0</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> dist_suc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>dist <span class="free">v</span> <span class="free">d</span> <span class="free">v'</span><span class="main">;</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v''</span><span class="main">)</span><span class="main">∈</span>E<span class="main">⟧</span> <span class="main">⟹</span> dist <span class="free">v</span> <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span> <span class="free">v''</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> isPath_append_edge<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dist_cases<span class="main">[</span><span class="operator">case_names</span> dist_z dist_suc<span class="main">,</span> <span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword">pred</span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="free">d</span> <span class="free">v'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">=</span><span class="free">v'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span><span class="main">=</span><span class="main">0</span>"</span></span>
   <span class="main">|</span> <span class="free">vh</span> <span class="free">dd</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span><span class="main">=</span>Suc <span class="free">dd</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="free">dd</span> <span class="free">vh</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">vh</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … p <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The same holds for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>min_dist›</span></span></span></span>, i.e., 
  the shortest path between two nodes has length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>0›</span></span></span></span>, 
  iff these nodes are equal.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> min_dist_z<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">v</span> <span class="free">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min_distI2<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> min_dist_z_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">v'</span> <span class="main">⟹</span> min_dist <span class="free">v</span> <span class="free">v'</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> min_distI2<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> min_dist_is_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">v'</span> <span class="main">⟹</span> dist <span class="free">v</span> <span class="main">(</span>min_dist <span class="free">v</span> <span class="free">v'</span><span class="main">)</span> <span class="free">v'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> min_distI2<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> min_dist_minD<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="free">d</span> <span class="free">v'</span> <span class="main">⟹</span> min_dist <span class="free">v</span> <span class="free">v'</span> <span class="main">≤</span> <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> min_distI2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We also provide introduction and destruction rules for the
  pattern <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>min_dist v v' = Suc d›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> min_dist_succ<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> connected <span class="free">v</span> <span class="free">v'</span><span class="main">;</span> <span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v''</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">⟧</span> <span class="main">⟹</span> min_dist <span class="free">v</span> <span class="free">v''</span> <span class="main">≤</span> Suc <span class="main">(</span>min_dist <span class="free">v</span> <span class="free">v'</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> min_distI2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> v'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">v'</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> min_dist_minD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> dist_suc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> min_dist_suc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">v'</span>"</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">v</span> <span class="free">v'</span> <span class="main">=</span> Suc <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v''</span><span class="main">.</span> connected <span class="free">v</span> <span class="bound">v''</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v''</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∧</span> min_dist <span class="free">v</span> <span class="bound">v''</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> min_dist_is_dist<span class="main">[</span><span class="operator">OF</span> c<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">v</span> <span class="free">v'</span> <span class="main">=</span> Suc <span class="free">d</span> <span class="main">⟶</span> <span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>dist_suc <span class="skolem">v''</span> <span class="skolem">d'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> min_dist_succ<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="skolem">v''</span></span> <span class="quoted"><span class="free">v'</span></span><span class="main">]</span> min_dist_minD<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="skolem">v''</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> connected_distI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> c <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If there is a node with a shortest path of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d›</span></span></span></span>, 
  then, for any <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d'&lt;d›</span></span></span></span>, there is also a node with a shortest path
  of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d'›</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> min_dist_less<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">src</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">src</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d'</span> <span class="main">&lt;</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v'</span><span class="main">.</span> connected <span class="free">src</span> <span class="bound">v'</span> <span class="main">∧</span> min_dist <span class="free">src</span> <span class="bound">v'</span> <span class="main">=</span> <span class="free">d'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">d</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">d</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> min_dist_suc<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">src</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">d'</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>min_dist_less›</span></span></span></span> can be weakened to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d'≤d›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">corollary</span></span> min_dist_le<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">src</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> d'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">d'</span> <span class="main">≤</span> min_dist <span class="free">src</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v'</span><span class="main">.</span> connected <span class="free">src</span> <span class="bound">v'</span> <span class="main">∧</span> min_dist <span class="free">src</span> <span class="bound">v'</span> <span class="main">=</span> <span class="free">d'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> min_dist_less<span class="main">[</span><span class="operator">OF</span> c<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">src</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="free">d'</span></span><span class="main">]</span> d' c
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> le_less<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> dist_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="free">d1</span> <span class="free">w</span> <span class="main">⟹</span> dist <span class="free">w</span> <span class="free">d2</span> <span class="free">v</span> <span class="main">⟹</span> dist <span class="free">u</span> <span class="main">(</span><span class="free">d1</span><span class="main">+</span><span class="free">d2</span><span class="main">)</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> p1 p2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">p1</span><span class="main">@</span><span class="improper">p2</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> min_dist_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D1<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="free">d1</span> <span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> D2<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">w</span> <span class="free">d2</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d1</span><span class="main">+</span><span class="free">d2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">=</span> <span class="free">d1</span>"</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">w</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> assms ab_semigroup_add_class.add.commute add_le_cancel_left 
    dist_trans min_distI_eq min_dist_minD<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms add_le_cancel_left dist_trans min_distI_eq min_dist_minD<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="comment1">― ‹Manual proof›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D1<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="free">d1</span> <span class="free">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> D2<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">w</span> <span class="free">d2</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d1</span><span class="main">+</span><span class="free">d2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">=</span> <span class="free">d1</span>"</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">w</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> min_dist_minD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹dist <span class="free">u</span> <span class="free">d1</span> <span class="free">w</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">≤</span> <span class="free">d1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">(</span>min_dist <span class="free">u</span> <span class="free">w</span><span class="main">)</span> <span class="free">w</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> min_dist_is_dist<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> D1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> D2
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">(</span>min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">+</span> <span class="free">d2</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">&lt;</span> <span class="free">d1</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> MIN
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> min_dist_minD<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">w</span> <span class="main">=</span> <span class="free">d1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_less<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> nat_neq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">from</span></span> min_dist_minD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹dist <span class="free">w</span> <span class="free">d2</span> <span class="free">v</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">w</span> <span class="free">v</span> <span class="main">≤</span> <span class="free">d2</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">note</span></span> D1
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">w</span> <span class="main">(</span>min_dist <span class="free">w</span> <span class="free">v</span><span class="main">)</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> min_dist_is_dist<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> D2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">(</span><span class="free">d1</span> <span class="main">+</span> min_dist <span class="free">w</span> <span class="free">v</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">w</span> <span class="free">v</span> <span class="main">&lt;</span> <span class="free">d2</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> MIN
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> min_dist_minD<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">w</span> <span class="free">v</span> <span class="main">=</span> <span class="free">d2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> not_less<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> nat_neq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Shortest Paths›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Characterization of shortest path in terms of minimum distance›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> isShortestPath_min_dist_def<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isShortestPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟷</span> isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">∧</span> length <span class="free">p</span> <span class="main">=</span> min_dist <span class="free">u</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> isShortestPath_def min_dist_def dist_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Least_equality<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Least_le<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

<span class="keyword1"><span class="command">lemma</span></span> obtain_shortest_path<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> CONN<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">u</span> <span class="free">v</span>"</span></span>  
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> min_dist_is_dist<span class="main">[</span><span class="operator">OF</span> CONN<span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> dist_def isShortestPath_min_dist_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> shortestPath_is_simple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> SHORTEST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> isPath <span class="free">s</span> <span class="bound">p'</span> <span class="free">t</span> <span class="main">⟶</span> length <span class="free">p</span> <span class="main">≤</span> length <span class="bound">p'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_def<span class="main">)</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>  
  <span class="keyword1"><span class="command">with</span></span> PATH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>distinct <span class="main">(</span>pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_fwd<span class="main">)</span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pv1</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">pv2</span></span> <span class="skolem"><span class="skolem">pv3</span></span> <span class="keyword2"><span class="keyword">where</span></span> PV<span class="main">:</span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="free">p</span> <span class="main">=</span> <span class="skolem">pv1</span><span class="main">@</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv2</span><span class="main">@</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv3</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> not_distinct_decomp<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> split_path_at_vertex_complete<span class="main">[</span><span class="operator">OF</span> PATH PV<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p23</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p23</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      P1<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="free">s</span> <span class="skolem">p1</span> <span class="main">=</span> <span class="skolem">pv1</span><span class="main">@</span><span class="main">[</span><span class="skolem">u</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      P23<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p23</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="skolem">u</span> <span class="skolem">p23</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv2</span><span class="main">)</span><span class="main">@</span><span class="skolem">u</span><span class="main">#</span><span class="skolem">pv3</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1"><span class="command">from</span></span> split_path_at_vertex_complete<span class="main">[</span><span class="operator">OF</span> P23<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="skolem"><span class="skolem">p3</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p23</span> <span class="main">=</span> <span class="skolem">p2</span><span class="main">@</span><span class="skolem">p3</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    P2<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p2</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="skolem">u</span> <span class="skolem">p2</span> <span class="main">=</span> <span class="skolem">u</span><span class="main">#</span><span class="skolem">pv2</span><span class="main">@</span><span class="main">[</span><span class="skolem">u</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    P3<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p3</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"pathVertices_fwd <span class="skolem">u</span> <span class="skolem">p3</span> <span class="main">=</span> <span class="skolem">u</span><span class="main">#</span><span class="skolem">pv3</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> P1<span class="main">(</span>1<span class="main">)</span> P3<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> SHORTER_PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="main">(</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p3</span><span class="main">)</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> P2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> LESS<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p3</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> SHORTER_PATH SHORTEST <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide yet another characterization of shortest paths:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> isShortestPath_alt<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isShortestPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟷</span> isSimplePath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">∧</span> length <span class="free">p</span> <span class="main">=</span> min_dist <span class="free">u</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> shortestPath_is_simple isShortestPath_min_dist_def
  <span class="keyword1"><span class="command">unfolding</span></span> isSimplePath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shortestPath_is_path<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> isPath <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> split_shortest_path<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">u</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">v</span> 
  <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> isShortestPath <span class="free">u</span> <span class="free">p1</span> <span class="bound">w</span> <span class="main">∧</span> isShortestPath <span class="bound">w</span> <span class="free">p2</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_min_dist_def isPath_append<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> isPath_distD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command">using</span></span> min_dist_split <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> isPath_distD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command">using</span></span> min_dist_split <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Edges in a shortest path connect nodes with increasing 
  minimum distance from the source›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> isShortestPath_level_edge<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> EIP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"connected <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">u</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="free">u</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">t</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> min_dist <span class="free">v</span> <span class="free">t</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="free">u</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> min_dist <span class="free">v</span> <span class="free">t</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="comment1">― ‹Split the original path at the edge›</span>
  <span class="keyword1"><span class="command">from</span></span> EIP <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
    MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      P<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
     DV<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_alt isSimplePath_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> DISTS<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">s</span> <span class="main">(</span>length <span class="skolem">p1</span><span class="main">)</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">1</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="main">(</span>length <span class="skolem">p2</span><span class="main">)</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append dist_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> DISTS <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">u</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">v</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="comment1">― ‹Express the minimum distances in terms of the split original path›</span>  
  <span class="keyword1"><span class="command">from</span></span> MIN <span class="keyword1"><span class="command">have</span></span> MIN'<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> length <span class="skolem">p1</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> length <span class="skolem">p2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> min_dist_split<span class="main">[</span><span class="operator">OF</span> dist_trans<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> DISTS<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">,</span></span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span> DISTS<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span> MIN'<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
      MDSV<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> length <span class="skolem">p1</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p2</span> <span class="main">=</span> min_dist <span class="free">v</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> min_dist_split<span class="main">[</span><span class="operator">OF</span> DISTS<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span> dist_trans<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> DISTS<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">,</span></span></span></span></span>3<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span> MIN' <span class="keyword1"><span class="command">have</span></span>
      MDUT<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">t</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> length <span class="skolem">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p1</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="free">u</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

  <span class="keyword1"><span class="command">from</span></span> MDSV MDUT MIN' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Graph›</span>

<span class="keyword1"><span class="command">context</span></span> Finite_Graph <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a finite graph, the length of a shortest path is less 
  than the number of nodes›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> isShortestPath_length_less_V<span class="main">:</span>   
  <span class="keyword2"><span class="keyword">assumes</span></span> SV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&lt;</span> card V"</span></span>
  <span class="keyword1"><span class="command">using</span></span> simplePath_length_less_V<span class="main">[</span><span class="operator">OF</span> SV<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> shortestPath_is_simple<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">corollary</span></span> min_dist_less_V<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CONN<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> card V"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> obtain_shortest_path<span class="main"><span class="main">[</span></span><span class="operator">OF</span> CONN<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> isShortestPath_length_less_V<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SV<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> isShortestPath_min_dist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Finite_Graph›</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Network">
<div class="head">
<h1>Theory Network</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Flows, Cuts, and Networks›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Network
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Graph.html">Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we define the basic concepts of flows, cuts, 
  and (flow) networks.
  ›</span></span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Flows›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span>-<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span> preflow on a graph is a labeling of the edges with 
  values from a linearly ordered integral domain, such that: 
  \begin{description}
    \item[capacity constraint] the flow on each edge is non-negative and 
      does not exceed the edge's capacity;
    \item[non-deficiency constraint] for all nodes except <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span>, 
      the incoming flow greater or equal to the outgoing flow.
  \end{description}    
›</span></span>
  
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'capacity</span> flow <span class="main">=</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> Preflow <span class="main">=</span> Graph <span class="quoted"><span class="free">c</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">node</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow"</span></span>  
  <span class="comment1">(* TODO: Move ∀-quantifiers to meta-level!? *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> capacity_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">≤</span> <span class="free">c</span> <span class="bound">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_deficient_nodes<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span>
    <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>  
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span>-<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹flow›</span></span> on a graph is a preflow that has no active nodes except 
  source and sink, where a node is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹active›</span></span> iff it has more incoming flow 
  than outgoing flow.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Flow <span class="main">=</span> Preflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">node</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_active_nodes<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≥</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For a flow, inflow equals outflow for all nodes except sink and source.
    This is called <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹conservation›</span></span>. ›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> conservation_const<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_deficient_nodes no_active_nodes 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The value of a flow is the flow that leaves $s$ and does not return.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">val</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span>"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">val</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> Finite_Preflow <span class="main">=</span> Preflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">+</span> Finite_Graph <span class="quoted"><span class="free">c</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>
  
<span class="keyword1"><span class="command">locale</span></span> Finite_Flow <span class="main">=</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">+</span> Finite_Preflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Cuts›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹cut›</span></span> is a partitioning of the nodes into two sets. 
  We define it by just specifying one of the partitions. 
  The other partition is implicitly given by the remaining nodes.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> cut <span class="main">=</span> <span class="quoted"><span class="quoted">"node set"</span></span> 

<span class="keyword1"><span class="command">locale</span></span> Cut <span class="main">=</span> Graph <span class="main">+</span>  <span class="comment1">(* TODO: We probably do not need the cut-locale, 
  only NCut.*)</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted">cut</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cut_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">⊆</span> V"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Networks›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹network›</span></span> is a finite graph with two distinct nodes, source and sink, 
  such that all edges are labeled with positive capacities. 
  Moreover, we assume that 
  <span class="antiquoted"><span class="antiquoted">▪</span></span> The source has no incoming edges, and the sink has no outgoing edges.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> There are no parallel edges, i.e., for any edge, the reverse edge must not be in the network.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Every node must lay on a path from the source to the sink.

  Notes on the formalization
  <span class="antiquoted"><span class="antiquoted">▪</span></span> We encode the graph by a mapping <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>c›</span></span></span></span>, such that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>c (u,v)›</span></span></span></span> is 
    the capacity of edge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(u,v)›</span></span></span></span>, or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>0›</span></span></span></span>, if there is no edge from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>.
    Thus, in the formalization below, we only demand 
    that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>c (u,v) ≥ 0›</span></span></span></span> for all <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> We only demand the set of nodes reachable from the source to be finite.
    Together with the constraint that all nodes lay on a path from the source,
    this implies that the graph is finite.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Network <span class="main">=</span> Graph <span class="quoted"><span class="free">c</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">node</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s_node<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> t_node<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s_not_t<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
    
  <span class="keyword2"><span class="keyword">assumes</span></span> cap_non_negative<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_incoming_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_outgoing_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_parallel_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">⟶</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nodes_on_st_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V<span class="main">.</span> connected <span class="free">s</span> <span class="bound">v</span> <span class="main">∧</span> connected <span class="bound">v</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>reachableNodes <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Edges have positive capacity›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> edge_cap_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> <span class="free">c</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">using</span></span> cap_non_negative<span class="main">[</span><span class="operator">THEN</span> spec2<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The network constraints implies that all nodes are 
    reachable from the source node›</span></span>  
  <span class="keyword1"><span class="command">lemma</span></span> reachable_is_V<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"reachableNodes <span class="free">s</span> <span class="main">=</span> V"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"V <span class="main">⊆</span> reachableNodes <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reachableNodes_def <span class="keyword1"><span class="command">using</span></span> s_node nodes_on_st_path
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_ss_V<span class="main">)</span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus, the network is actually a finite graph.›</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> Finite_Graph 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> reachable_is_V finite_reachable <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our assumptions imply that there are no self loops›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> no_self_loop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> adjacent_not_self<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∉</span> adjacent_nodes <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def <span class="keyword1"><span class="command">using</span></span> no_self_loop 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A flow is maximal, if it has a maximal value›</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">isMaxFlow</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> flow <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isMaxFlow</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">f'</span><span class="main">.</span> Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f'</span> <span class="main">⟶</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="bound">f'</span> <span class="main">≤</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_max_flow_val</span> <span class="free"><span class="bound"><span class="entity">fv</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">f</span><span class="main">.</span> isMaxFlow <span class="bound">f</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">fv</span></span></span><span class="main">=</span>Flow.val <span class="free">c</span> <span class="free">s</span> <span class="bound">f</span>"</span></span>

<span class="comment1">(* TODO: Can we prove existence of a maximum flow *easily*, i.e.,
  without going over the min-cut-max-flow theorem or the Ford-Fulkerson method?
  definition "max_flow_val ≡ THE fv. is_max_flow_val fv"
*)</span>  
    
  <span class="keyword1"><span class="command">lemma</span></span> t_not_s<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s_not_t <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The excess of a node is the difference between incoming and 
    outgoing flow.›</span></span> <span class="comment1">(* TODO: Define in context of preflow!? *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">excess</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> node <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">excess</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">e</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Networks with Flows and Cuts›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For convenience, we define locales for a network with a fixed flow,
  and a network with a fixed cut›</span></span>

<span class="keyword1"><span class="command">locale</span></span> NPreflow <span class="main">=</span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="main">+</span> Preflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>
    
<span class="keyword1"><span class="command">locale</span></span> NFlow <span class="main">=</span> NPreflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">+</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> isMaxFlow_alt<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span> <span class="main">⟷</span> NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">f'</span><span class="main">.</span> NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f'</span> <span class="main">⟶</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="bound">f'</span> <span class="main">≤</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> isMaxFlow_def     
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFlow_def Flow_def NPreflow_def<span class="main">)</span> <span class="operator">intro_locales</span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A cut in a network separates the source from the sink›</span></span>
<span class="keyword1"><span class="command">locale</span></span> NCut <span class="main">=</span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="main">+</span> Cut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">k</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">k</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s_in_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> t_ni_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∉</span> <span class="free">k</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The capacity of the cut is the capacity of all edges going from the 
    source's side to the sink's side.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span>"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cap</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A minimum cut is a cut with minimum capacity.›</span></span> 
<span class="comment1">(* TODO: The definitions of min-cut and max-flow are done in different contexts. 
  Align, probably both in network context! *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isMinCut</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> graph <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> cut <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isMinCut</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> NCut <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">k'</span><span class="main">.</span> NCut <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">k'</span> <span class="main">⟶</span> NCut.cap <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≤</span> NCut.cap <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">k'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Flows›</span></span>

<span class="keyword1"><span class="command">context</span></span> Preflow 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Only edges are labeled with non-zero flows›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> zero_flow_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>E <span class="main">⟹</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> capacity_const eq_iff zero_cap_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> f_non_negative<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">lemma</span></span> sum_f_non_negative<span class="main">:</span> <span class="quoted"><span class="quoted">"sum <span class="free">f</span> <span class="free">X</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> capacity_const
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_nonneg f_non_negative<span class="main">)</span> 
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Preflow›</span>   
    
<span class="keyword1"><span class="command">context</span></span> Flow
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide a useful equivalent formulation of the 
  conservation constraint.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> conservation_const_pointwise<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> conservation_const assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_incoming_pointwise sum_outgoing_pointwise<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The value of the flow is bounded by the capacity of the 
  outgoing edges of the source node›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> val_bounded<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">s</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≤</span> val"</span></span>
  <span class="quoted"><span class="quoted">"val <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">s</span><span class="main">)</span> <span class="main">≤</span> sum <span class="free">c</span> <span class="main">(</span>outgoing <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">s</span><span class="main">)</span> <span class="main">≤</span> sum <span class="free">c</span> <span class="main">(</span>incoming <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum_mono<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">s</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≤</span> val"</span></span> <span class="quoted"><span class="quoted">"val <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> sum_f_non_negative<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"incoming <span class="free">s</span>"</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">using</span></span> sum_f_non_negative<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"outgoing <span class="free">s</span>"</span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command">unfolding</span></span> val_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
<span class="keyword1"><span class="command">qed</span></span>    
    
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Flow›</span>   

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Introduce a flow via the conservation constraint›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> intro_Flow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">≤</span> <span class="free">c</span> <span class="bound">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span><span class="main">.</span> 
    <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>  
  
<span class="keyword1"><span class="command">context</span></span> Finite_Preflow 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The summation of flows over incoming/outgoing edges can be 
  extended to a summation over all possible predecessor/successor nodes,
  as the additional flows are all zero.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> sum_outgoing_alt_flow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum_outgoing_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms capacity_const
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> sum_incoming_alt_flow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum_incoming_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms capacity_const
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Finite Preflow›</span>   

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Networks›</span></span>  
<span class="keyword1"><span class="command">context</span></span> Network
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> no_incoming_s no_outgoing_t
  
<span class="keyword1"><span class="command">lemma</span></span> incoming_s_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"incoming <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> incoming_def <span class="keyword1"><span class="command">using</span></span> no_incoming_s <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> outgoing_t_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"outgoing <span class="free">t</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> outgoing_def <span class="keyword1"><span class="command">using</span></span> no_outgoing_t <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> cap_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> E <span class="main">⟹</span> <span class="free">c</span> <span class="free">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">using</span></span> cap_non_negative le_neq_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 

<span class="keyword1"><span class="command">lemma</span></span> V_not_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"V<span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s_node <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> E_not_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> V_not_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">lemma</span></span> card_V_ge2<span class="main">:</span> <span class="quoted"><span class="quoted">"card V <span class="main">≥</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">=</span> card <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span> <span class="main">≤</span> card V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> card_mono<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>   
<span class="keyword1"><span class="command">qed</span></span>  
    
<span class="keyword1"><span class="command">lemma</span></span> zero_is_flow<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cap_non_negative <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>  

<span class="keyword1"><span class="command">lemma</span></span> max_flow_val_unique<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_max_flow_val <span class="free">fv1</span><span class="main">;</span> is_max_flow_val <span class="free">fv2</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">fv1</span><span class="main">=</span><span class="free">fv2</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> is_max_flow_val_def isMaxFlow_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> antisym<span class="main">)</span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Networks with Flow›</span></span>

<span class="keyword1"><span class="command">context</span></span> NPreflow 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Finite_Preflow <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As there are no edges entering the source/leaving the sink, 
  also the corresponding flow values are zero:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> no_inflow_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> incoming <span class="free">s</span> <span class="main">∧</span> <span class="free">f</span> <span class="skolem">e</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">using</span></span> incoming_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> obt1 no_incoming_s incoming_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> no_outflow_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">t</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">t</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> outgoing <span class="free">t</span> <span class="main">∧</span> <span class="free">f</span> <span class="skolem">e</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">using</span></span> outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> obt1 no_outgoing_t outgoing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For an edge, there is no reverse edge, and thus, 
  no flow in the reverse direction:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> zero_rev_flow_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E <span class="main">⟹</span> <span class="free">f</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    
<span class="keyword1"><span class="command">lemma</span></span> excess_non_negative<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> excess_def <span class="keyword1"><span class="command">using</span></span> no_deficient_nodes <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> excess_nodes_only<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">v</span> <span class="main">∈</span> V"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> excess_def incoming_def outgoing_def V_def 
  <span class="keyword1"><span class="command">using</span></span> sum.not_neutral_contains_not_neutral <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  
<span class="keyword1"><span class="command">lemma</span></span> excess_non_negative'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> excess <span class="free">f</span> <span class="bound">v</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">t</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> excess_def outgoing_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> capacity_const sum_nonneg<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> excess_non_negative <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> excess_s_non_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">s</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> excess_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> capacity_const sum_nonneg<span class="main">)</span>  
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with preflow›</span>

<span class="keyword1"><span class="command">context</span></span> NFlow <span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">sublocale</span></span> Finite_Preflow <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
      
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There is no outflow from the sink in a network. 
    Thus, we can simplify the definition of the value:›</span></span>  
  <span class="keyword1"><span class="command">corollary</span></span> val_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> val_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_inflow_s<span class="main">)</span>
      
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Residual_Graph">
<div class="head">
<h1>Theory Residual_Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Residual Graph›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Residual_Graph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Network.html">Network</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we define the residual graph.
  ›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹residual graph›</span></span> of a network and a flow indicates how much 
  flow can be effectively pushed along or reverse to a network edge,
  by increasing or decreasing the flow on that edge:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">residualGraph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> graph <span class="main">⇒</span> <span class="main">_</span> flow <span class="main">⇒</span> <span class="main">_</span> graph"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">residualGraph</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> Graph.E <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">then</span>
    <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> Graph.E <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">then</span>
    <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span>
  <span class="keyword1">else</span>
    <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> Network <span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_of</span> <span class="main">≡</span> residualGraph <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cfE_of</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> Graph.E <span class="main">(</span>cf_of <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The edges of the residual graph are either parallel or reverse 
  to the edges of the network.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> cfE_of_ss_invE<span class="main">:</span> <span class="quoted"><span class="quoted">"cfE_of <span class="free">cf</span> <span class="main">⊆</span> E <span class="main">∪</span> E<span class="main">¯</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def Graph.E_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> cfE_of_ss_VxV<span class="main">:</span> <span class="quoted"><span class="quoted">"cfE_of <span class="free">f</span> <span class="main">⊆</span> V<span class="main">×</span>V"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> V_def
  <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def Graph.E_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  

<span class="keyword1"><span class="command">lemma</span></span> cfE_of_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>cfE_of <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> cfE_of_ss_VxV<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cf_no_self_loop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>cfE_of <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> cfE_of <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">using</span></span> a1 <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def residualGraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> 
  
<span class="keyword2"><span class="keyword">end</span></span>
  
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Let's fix a network with a preflow <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on it›</span></span>
<span class="keyword1"><span class="command">context</span></span> NPreflow
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We abbreviate the residual graph by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cf</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="main">≡</span> residualGraph <span class="free">c</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> cf<span class="main">:</span> Graph <span class="quoted">cf</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> cf_def <span class="main">=</span> residualGraph_def<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> cfE_ss_invE <span class="main">=</span> cfE_of_ss_invE<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span>  
<span class="comment1">(*lemma cfE_ss_invE: "Graph.E cf ⊆ E ∪ E¯"
  unfolding residualGraph_def Graph.E_def
  by auto*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The nodes of the residual graph are exactly the nodes of the network.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> resV_netV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cf.V <span class="main">=</span> V"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"V <span class="main">⊆</span> Graph.V cf"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> V"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="main">∨</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="comment1">(* TODO: Use nifty new Isabelle2016 case-distinction features here! *)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> Graph.E cf <span class="main">∨</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> Graph.E cf"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> Graph.E cf <span class="main">∨</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> Graph.E cf"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E›</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>cf.V"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Graph.V cf <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note, that Isabelle is powerful enough to prove the above case 
  distinctions completely automatically, although it takes some time:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"cf.V <span class="main">=</span> V"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def Graph.E_def Graph.V_def
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge<span class="main">[</span><span class="operator">unfolded</span> E_def<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As the residual graph has the same nodes as the network, it is also finite:›</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> cf<span class="main">:</span> Finite_Graph <span class="quoted">cf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The capacities on the edges of the residual graph are non-negative›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> resE_nonNegative<span class="main">:</span> <span class="quoted"><span class="quoted">"cf <span class="free">e</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> capacity_const cap_non_negative <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">unfolding</span></span> cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∉</span> E"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Again, there is an automatic proof›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"cf <span class="free">e</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge capacity_const cap_positive
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹All edges of the residual graph are labeled with positive capacities:›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> resE_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> cf.E <span class="main">⟹</span> cf <span class="free">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> cf.E"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="free">e</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> resE_nonNegative <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_iff not_le<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> 
      
<span class="comment1">(* TODO: Only one usage: Move or remove! *)</span>  
<span class="keyword1"><span class="command">lemma</span></span> reverse_flow<span class="main">:</span> <span class="quoted"><span class="quoted">"Preflow cf <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span> <span class="main">⟹</span> <span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"Preflow cf <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> f'<span class="main">:</span> Preflow <span class="quoted">cf</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f'</span></span> <span class="keyword1"><span class="command">.</span></span>
      
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E"</span></span>
    
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≤</span> cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">flow_of_cf</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">∈</span>E<span class="main">)</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="comment1">(* TODO: We have proved/used this fact already for Edka-Analysis! (uE) *)</span>  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NPreflow<span class="main">)</span> E_ss_cfinvE<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">⊆</span> Graph.E cf <span class="main">∪</span> <span class="main">(</span>Graph.E cf<span class="main">)</span><span class="main">¯</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def Graph.E_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="comment1">(* Speed optimization: Adding this directly takes very long *)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> E_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Nodes with positive excess must have an outgoing edge in the 
  residual graph. 

  Intuitively: The excess flow must come from somewhere.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> active_has_cf_outgoing<span class="main">:</span> <span class="quoted"><span class="quoted">"excess <span class="free">f</span> <span class="free">u</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> cf.outgoing <span class="free">u</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> excess_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span> <span class="main">-</span> sum <span class="free">f</span> <span class="main">(</span>outgoing <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> sum <span class="free">f</span> <span class="main">(</span>incoming <span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> diff_gt_0_iff_gt linorder_neqE_linordered_idom linorder_not_le 
        sum_f_non_negative<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> f_non_negative <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>incoming <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> not_le sum_nonpos<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> incoming_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.outgoing_def cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>   
<span class="keyword1"><span class="command">qed</span></span>      
    
    
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with preflow›</span>
  
  
<span class="keyword1"><span class="command">locale</span></span> RPreGraph <span class="comment1">― ‹Locale that characterizes a residual graph of a network›</span>
<span class="main">=</span> Network <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cf</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EX_RPG<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> NPreflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="main">∧</span> <span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="bound">f</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

  <span class="keyword1"><span class="command">lemma</span></span> this_loc_rpg<span class="main">:</span> <span class="quoted"><span class="quoted">"RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">≡</span> flow_of_cf <span class="free">cf</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> f_unique<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"NPreflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="free">f'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">=</span> f"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> f'<span class="main">:</span> NPreflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> f_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> flow_of_cf_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> A residualGraph_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">unfolding</span></span> E_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> is_NPreflow<span class="main">:</span> <span class="quoted"><span class="quoted">"NPreflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> f_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> EX_RPG f_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    
  <span class="keyword1"><span class="command">sublocale</span></span> f<span class="main">:</span> NPreflow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f</span> <span class="keyword1"><span class="command">unfolding</span></span> f_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_NPreflow<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> rg_is_cf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"residualGraph <span class="free">c</span> f <span class="main">=</span> <span class="free">cf</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> EX_RPG f_unique <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> rg_fo_inv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"residualGraph <span class="free">c</span> <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span> <span class="main">=</span> <span class="free">cf</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> rg_is_cf
    <span class="keyword1"><span class="command">unfolding</span></span> f_def
    <span class="keyword1"><span class="command">.</span></span>
    

  <span class="keyword1"><span class="command">sublocale</span></span> cf<span class="main">:</span> Graph <span class="quoted"><span class="free">cf</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> resV_netV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cf.V <span class="main">=</span> V"</span></span>
    <span class="keyword1"><span class="command">using</span></span> f.resV_netV <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">sublocale</span></span> cf<span class="main">:</span> Finite_Graph <span class="quoted"><span class="free">cf</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> E_ss_cfinvE<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">⊆</span> cf.E <span class="main">∪</span> cf.E<span class="main">¯</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> f.E_ss_cfinvE <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> cfE_ss_invE<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.E <span class="main">⊆</span> E <span class="main">∪</span> E<span class="main">¯</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> f.cfE_ss_invE <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> resE_nonNegative<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="free">e</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> f.resE_nonNegative <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> NPreflow <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> is_RPreGraph<span class="main">:</span> <span class="quoted"><span class="quoted">"RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> cf"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fo_rg_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"flow_of_cf cf <span class="main">=</span> <span class="free">f</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> flow_of_cf_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">unfolding</span></span> E_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>    

<span class="comment1">(* For snippet*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NPreflow<span class="main">)</span>
  <span class="quoted"><span class="quoted">"flow_of_cf <span class="main">(</span>residualGraph <span class="free">c</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fo_rg_inv<span class="main">)</span>


<span class="keyword1"><span class="command">locale</span></span> RGraph <span class="comment1">― ‹Locale that characterizes a residual graph of a network›</span>
<span class="main">=</span> Network <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cf</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EX_RG<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="main">∧</span> <span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="bound">f</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">sublocale</span></span> RPreGraph 
  <span class="keyword1"><span class="command">proof</span></span>    
    <span class="keyword1"><span class="command">from</span></span> EX_RG <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>    

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> NPreflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="main">∧</span> <span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="bound">f</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">f</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>  
  <span class="keyword1"><span class="command">qed</span></span>  

  <span class="keyword1"><span class="command">lemma</span></span> this_loc<span class="main">:</span> <span class="quoted"><span class="quoted">"RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">lemma</span></span> this_loc_rpg<span class="main">:</span> <span class="quoted"><span class="quoted">"RPreGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> is_NFlow<span class="main">:</span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> EX_RG f_unique is_NPreflow NFlow.axioms<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> f_def<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>  
    
  <span class="keyword1"><span class="command">sublocale</span></span> f<span class="main">:</span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f</span> <span class="keyword1"><span class="command">unfolding</span></span> f_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_NFlow<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>        
      
<span class="keyword1"><span class="command">context</span></span> NFlow <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_RGraph<span class="main">:</span> <span class="quoted"><span class="quoted">"RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> cf"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The value of the flow can be computed from the residual graph.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> val_by_cf<span class="main">:</span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> cf <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> val_alt outgoing_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum.cong<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>  
      
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with Flow›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RPreGraph<span class="main">)</span> maxflow_imp_rgraph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">interpret</span></span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f</span> 
    <span class="keyword1"><span class="command">unfolding</span></span> isMaxFlow_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_def<span class="main">)</span>
 
  <span class="keyword1"><span class="command">interpret</span></span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted">f</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>     
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">f</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NFlow_axioms<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Augmenting_Flow">
<div class="head">
<h1>Theory Augmenting_Flow</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Augmenting Flows›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Augmenting_Flow
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Residual_Graph.html">Residual_Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we define the concept of an augmenting flow,
  augmentation with a flow, and show that augmentation of a flow 
  with an augmenting flow yields a valid flow again.
  ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We assume that there is a network with a flow <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on it›</span></span>
<span class="keyword1"><span class="command">context</span></span> NFlow
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Augmentation of a Flow›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The flow can be augmented by another flow, by adding the flows 
  of edges parallel to edges in the network, and subtracting the edges 
  reverse to edges in the network.›</span></span>
<span class="comment1">(* TODO: Define in network locale, with ↑ syntax. *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">augment</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow <span class="main">⇒</span> <span class="tfree">'capacity</span> flow"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">augment</span> <span class="free"><span class="bound"><span class="entity">f'</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E <span class="keyword1">then</span>
    <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">f'</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">f'</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span>
  <span class="keyword1">else</span>
    <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a syntax similar to Cormen et el.:›</span></span>    
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">augment_syntax</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">↑</span>"</span> 55<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">f'</span><span class="main">.</span> <span class="bound">f</span><span class="main"><span class="free">↑</span></span><span class="bound">f'</span> <span class="main">≡</span> NFlow.augment <span class="free">c</span> <span class="bound">f</span> <span class="bound">f'</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹such that we can write <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span><span class="main"><span class="main">↑</span></span><span class="free"><span class="free">f'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for the flow <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  augmented by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Augmentation yields Valid Flow›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that, if we augment the flow with a valid flow of
  the residual graph, the augmented flow is a valid flow again, i.e. 
  it satisfies the capacity and conservation constraints:›</span></span>
<span class="keyword1"><span class="command">context</span></span> 
  <span class="comment1">― ‹Let the \emph{residual flow} <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">f'</span></span><span class="antiquote">}</span></span> be a flow in the residual graph›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> flow"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f'_flow<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow cf <span class="free">s</span> <span class="free">t</span> <span class="free">f'</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">interpretation</span></span> f'<span class="main">:</span> Flow <span class="quoted">cf</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> f'_flow<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Capacity Constraint›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, we have to show that the new flow satisfies the capacity constraint:›</span></span>
<span class="comment1">(* FIXME: Indentation unfortunate, but required to extract snippet for latex presentation *)</span>    
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\DefineSnippet{augment_flow_presv_cap}{›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> augment_flow_presv_cap<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">≤</span> <span class="free">c</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> conjI<span class="main">)</span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> cf<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> residualGraph_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">≥</span> <span class="free">f'</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span><span class="comment1">(*&lt;*)</span><span class="main">(</span>xtrans<span class="main">)</span><span class="comment1">(*&gt;*)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">trans</span><span class="main">]</span> <span class="main">=</span> xtrans
  <span class="comment1">(*&gt;*)</span><span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\isanewline›</span></span>

  <span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\ \ ›</span></span><span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f'</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≥</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="comment1">(*&lt;*)</span><span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≥</span> <span class="main">…</span>"</span></span><span class="main">)</span><span class="comment1">(*&gt;*)</span>  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f'</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">}</span></span><span class="comment1">(*&gt;*)</span>
    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f'</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> cf<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f'.capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">c</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> residualGraph_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">c</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">≤</span> <span class="free">c</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def cap_positive<span class="main">)</span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹}%EndSnippet›</span></span>

  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Conservation Constraint›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In order to show the conservation constraint, we need some 
  auxiliary lemmas first.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As there are no parallel edges in the network, and all edges 
  in the residual graph are either parallel or reverse to a network edge,
  we can split summations of the residual flow over outgoing/incoming edges in the 
  residual graph to summations over outgoing/incoming edges in the network.

  Note that the term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹E<span class="main"><span class="main">``</span></span><span class="main"><span class="main">{</span></span><span class="free"><span class="free">u</span></span><span class="main"><span class="main">}</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> characterizes the successor nodes of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">u</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹E<span class="main"><span class="main">¯</span></span><span class="main"><span class="main">``</span></span><span class="main"><span class="main">{</span></span><span class="free"><span class="free">u</span></span><span class="main"><span class="main">}</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> characterizes the predecessor nodes of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">u</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="comment1">(* TODO: Introduce pred/succ functions on Graph *)</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> split_rflow_outgoing<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> no_parallel_edge <span class="keyword1"><span class="command">have</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">∩</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.mono_neutral_left<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.union_disjoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ DJ<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> split_rflow_incoming<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> no_parallel_edge <span class="keyword1"><span class="command">have</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">∩</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.mono_neutral_left<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.union_disjoint<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ DJ<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For proving the conservation constraint, let's fix a node <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which
  is neither the source nor the sink: ›</span></span>
<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">u</span> <span class="main">::</span> <span class="quoted">node</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> U_ASM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span><span class="free">t</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first show an auxiliary lemma to compare the 
  effective residual flow on incoming network edges to
  the effective residual flow on outgoing network edges.
  
  Intuitively, this lemma shows that the effective residual flow added to the 
  network edges satisfies the conservation constraint.
›</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> flow_summation_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>  <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>
       <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">-</span> <span class="var">?B</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The proof is by splitting the flows, and careful 
    cancellation of the summands.›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_rflow_outgoing<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> U_ASM
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f'.conservation_const_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>cf.E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_rflow_incoming<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">-</span> <span class="var">?B</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we are ready to prove that the augmented flow satisfies the 
  conservation constraint:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> augment_flow_presv_con<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">u</span><span class="main">.</span> augment <span class="free">f'</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">u</span><span class="main">.</span> augment <span class="free">f'</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define shortcuts for the successor and predecessor nodes of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
    in the network:›</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Vo</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Vi</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"E<span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using the auxiliary lemma for the effective residual flow,
    the proof is straightforward:›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vo</span><span class="main">.</span> augment <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_outgoing_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vo</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">f'</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vo</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vo</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vo</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_subtractf sum.distrib<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vi</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vi</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vi</span><span class="main">.</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> conservation_const_pointwise<span class="main"><span class="main">[</span></span><span class="operator">OF</span> U_ASM<span class="main"><span class="main">]</span></span> flow_summation_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vi</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">f'</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_subtractf sum.distrib<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span><span class="var">?Vi</span><span class="main">.</span> augment <span class="free">f'</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> 
    <span class="main">=</span> <span class="var">?RHS</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_incoming_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">=</span> <span class="var">?RHS</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that we tried to follow the proof presented by Cormen et al.~\cite{CLRS09} 
  as closely as possible. Unfortunately, this proof generalizes the summation to all 
  nodes immediately, rendering the first equation invalid.
  Trying to fix this error, we encountered that the step that uses the conservation 
  constraints on the augmenting flow is more subtle as indicated in the original proof.
  Thus, we moved this argument to an auxiliary lemma. ›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">u</span></span><span class="antiquote">}</span></span> is node›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As main result, we get that the augmented flow is again a valid flow.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> augment_flow_presv<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> augment_flow_presv_cap augment_flow_presv_con 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> intro_Flow<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Value of the Augmented Flow›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we show that the value of the augmented flow is the sum of the values
  of the original flow and the augmenting flow.›</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> augment_flow_value<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow.val <span class="free">c</span> <span class="free">s</span> <span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span> <span class="main">=</span> val <span class="main">+</span> Flow.val cf <span class="free">s</span> <span class="free">f'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> f''<span class="main">:</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">↑</span><span class="free">f'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> augment_flow_presv <span class="keyword1"><span class="command">.</span></span> 

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹For this proof, we set up Isabelle's rewriting engine for rewriting of sums.
    In particular, we add lemmas to convert sums over incoming or outgoing 
    edges to sums over all vertices. This allows us to write the summations
    from Cormen et al.~a bit more concise, leaving some of the tedious 
    calculation work to the computer.›</span></span>
  <span class="keyword1"><span class="command">note</span></span> sum_simp_setup<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
    sum_outgoing_alt<span class="main">[</span><span class="operator">OF</span> capacity_const<span class="main">]</span> s_node
    sum_incoming_alt<span class="main">[</span><span class="operator">OF</span> capacity_const<span class="main">]</span>
    cf.sum_outgoing_alt<span class="main">[</span><span class="operator">OF</span> f'.capacity_const<span class="main">]</span>
    cf.sum_incoming_alt<span class="main">[</span><span class="operator">OF</span> f'.capacity_const<span class="main">]</span>
    sum_outgoing_alt<span class="main">[</span><span class="operator">OF</span> f''.capacity_const<span class="main">]</span>
    sum_incoming_alt<span class="main">[</span><span class="operator">OF</span> f''.capacity_const<span class="main">]</span>
    sum_subtractf sum.distrib
  
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Note that, if neither an edge nor its reverse is in the graph,
    there is also no edge in the residual graph, and thus the flow value
    is zero.›</span></span>  
  <span class="keyword1"><span class="command">have</span></span> aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f'</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>E"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> that cfE_ss_invE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>cf.E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Now, the proposition follows by straightforward rewriting of 
    the summations:›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"f''.val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">.</span> augment <span class="free">f'</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">-</span> augment <span class="free">f'</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> f''.val_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">u</span><span class="main">∈</span>V<span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">f'</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">-</span> <span class="free">f'</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹Note that this is the crucial step of the proof, which Cormen et al. leave as an exercise.›</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def no_parallel_edge aux1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> val <span class="main">+</span> Flow.val cf <span class="free">s</span> <span class="free">f'</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> val_def f'.val_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"f''.val <span class="main">=</span> val <span class="main">+</span> f'.val"</span></span> <span class="keyword1"><span class="command">.</span></span>  
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Note, there is also an automatic proof. When creating the above 
    explicit proof, this automatic one has been used to extract meaningful
    subgoals, abusing Isabelle as a term rewriter.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Flow.val <span class="free">c</span> <span class="free">s</span> <span class="main">(</span><span class="free">f</span><span class="main">↑</span><span class="free">f'</span><span class="main">)</span> <span class="main">=</span> val <span class="main">+</span> Flow.val cf <span class="free">s</span> <span class="free">f'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> f''<span class="main">:</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">↑</span><span class="free">f'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> augment_flow_presv <span class="keyword1"><span class="command">.</span></span> 

  <span class="keyword1"><span class="command">have</span></span> aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f'</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>E"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A cfE_ss_invE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>cf.E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> val_def f'.val_def f''.val_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 
      sum_outgoing_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> capacity_const<span class="main"><span class="main">]</span></span> s_node
      sum_incoming_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> capacity_const<span class="main"><span class="main">]</span></span>
      sum_outgoing_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f''.capacity_const<span class="main"><span class="main">]</span></span>
      sum_incoming_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f''.capacity_const<span class="main"><span class="main">]</span></span>
      cf.sum_outgoing_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f'.capacity_const<span class="main"><span class="main">]</span></span>
      cf.sum_incoming_alt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f'.capacity_const<span class="main"><span class="main">]</span></span>
      sum_subtractf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> sum.distrib<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def no_parallel_edge aux1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Augmenting flow›</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network flow›</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Augmenting_Path">
<div class="head">
<h1>Theory Augmenting_Path</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Augmenting Paths›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Augmenting_Path
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Residual_Graph.html">Residual_Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the concept of an augmenting path in the residual graph,
  and the residual flow induced by an augmenting path.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a network with a preflow <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on it.›</span></span>
<span class="keyword1"><span class="command">context</span></span> NPreflow
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An \emph{augmenting path} is a simple path from the source to the sink in the residual graph:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isAugmentingPath</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isAugmentingPath</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> cf.isSimplePath <span class="free">s</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free">t</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The \emph{residual capacity} of an augmenting path is the smallest capacity 
  annotated to its edges:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">resCap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> <span class="tfree">'capacity</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">resCap</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> Min <span class="main">{</span>cf <span class="bound">e</span> <span class="main">|</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> resCap_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"resCap <span class="free">p</span> <span class="main">=</span> Min <span class="main">(</span>cf<span class="main">`</span>set <span class="free">p</span><span class="main">)</span>"</span></span>  
  <span class="comment1">― ‹Useful characterization for finiteness arguments›</span>
  <span class="keyword1"><span class="command">unfolding</span></span> resCap_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">Min</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An augmenting path induces an \emph{augmenting flow}, which pushes as 
  much flow as possible along the path:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">augmentingFlow</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"path <span class="main">⇒</span> <span class="tfree">'capacity</span> flow"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">augmentingFlow</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">then</span>
    resCap <span class="free"><span class="bound"><span class="entity">p</span></span></span>
  <span class="keyword1">else</span>
    <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Augmenting Flow is Valid Flow›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we show that the augmenting flow induced by an 
  augmenting path is a valid flow in the residual graph.

  We start with some auxiliary lemmas.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The residual capacity of an augmenting path is always positive.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> resCap_gzero_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">⟹</span> <span class="main">0</span><span class="main">&lt;</span>resCap <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="free">p</span><span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> s_not_t <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="free">p</span><span class="main">.</span> cf <span class="bound">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cf.isPath_edgeset<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">]</span> resE_positive <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> resCap_alt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> resCap_gzero<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span> <span class="main">⟹</span> <span class="main">0</span><span class="main">&lt;</span>resCap <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> resCap_gzero_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def cf.isSimplePath_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As all edges of the augmenting flow have the same value, we can factor 
  this out from a summation:›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> sum_augmenting_alt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>          
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="bound">e</span><span class="main">)</span> 
        <span class="main">=</span> resCap <span class="free">p</span> <span class="main">*</span> of_nat <span class="main">(</span>card <span class="main">(</span><span class="free">A</span><span class="main">∩</span>set <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> sum <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> resCap <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">A</span><span class="main">∩</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.inter_restrict<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augmentingFlow_def assms<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> augFlow_resFlow<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span> <span class="main">⟹</span> Flow cf <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> cf.intro_Flow<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> allI ballI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> SPATH<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cf.isSimplePath_def<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first show the capacity constraint›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">∧</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">≤</span> cf <span class="skolem">e</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span> 
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"resCap <span class="free">p</span> <span class="main">≤</span> cf <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> resCap_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> augmentingFlow_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">e</span> <span class="main">∈</span> set <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> resCap <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> resCap_gzero<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> augmentingFlow_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> resE_nonNegative <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> 

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we show the conservation constraint›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> asm_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> Graph.V cf <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">,</span> <span class="free">t</span><span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Graph.incoming cf <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>Graph.outgoing cf <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>  
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>set <span class="main">(</span>cf.pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> cf.split_path_at_vertex<span class="main">[</span><span class="operator">OF</span> this PATH<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        P_FMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="skolem">v</span> <span class="skolem">p2</span> <span class="free">t</span>"</span></span> 
        <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1'</span></span> <span class="skolem"><span class="skolem">u1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p1</span><span class="main">=</span><span class="skolem">p1'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">]</span>"</span></span>    
        <span class="keyword1"><span class="command">using</span></span> asm_s <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">split_path_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p2'</span></span> <span class="skolem"><span class="skolem">u2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p2</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u2</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2'</span>"</span></span>    
        <span class="keyword1"><span class="command">using</span></span> asm_s <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p2</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 
        cf.isSPath_sg_outgoing<span class="main">[</span><span class="operator">OF</span> SPATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">u2</span></span><span class="main">]</span>  
        cf.isSPath_sg_incoming<span class="main">[</span><span class="operator">OF</span> SPATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">u1</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span>
        cf.isPath_edgeset<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf.outgoing <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u2</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"cf.incoming <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> P_FMT cf.outgoing_def cf.incoming_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span>set <span class="main">(</span>cf.pathVertices_fwd <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> cf.pathVertices_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> PATH<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf.incoming <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"cf.outgoing <span class="skolem">v</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.incoming_def cf.outgoing_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>  
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> Graph.incoming cf <span class="skolem">v</span><span class="main">.</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> Graph.outgoing cf <span class="skolem">v</span><span class="main">.</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_augmenting_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Value of Augmenting Flow is Residual Capacity›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we show that the value of the augmenting flow is the residual 
  capacity of the augmenting path›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> augFlow_val<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span> <span class="main">⟹</span> Flow.val cf <span class="free">s</span> <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> augFlow_resFlow <span class="keyword1"><span class="command">interpret</span></span> f<span class="main">:</span> Flow <span class="quoted">cf</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"augmentingFlow <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">note</span></span> AUG 
  <span class="keyword1"><span class="command">hence</span></span> SPATH<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cf.isSimplePath_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> s_not_t <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf.outgoing <span class="free">s</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> cf.isSPath_sg_outgoing<span class="main">[</span><span class="operator">OF</span> SPATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">using</span></span> cf.isPath_edgeset<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.outgoing_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf.incoming <span class="free">s</span> <span class="main">∩</span> set <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> SPATH no_incoming_s
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.incoming_def <span class="quoted"><span class="quoted">‹<span class="free">p</span><span class="main">=</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p'</span>›</span></span> in_set_conv_decomp<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">p'</span></span><span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.isSimplePath_append cf.isSimplePath_cons<span class="main">)</span>  
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> f.val_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_augmenting_alt<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with flow›</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Ford_Fulkerson">
<div class="head">
<h1>Theory Ford_Fulkerson</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Ford-Fulkerson Theorem›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Ford_Fulkerson
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Augmenting_Flow.html">Augmenting_Flow</a> <a href="Augmenting_Path.html">Augmenting_Path</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this theory, we prove the Ford-Fulkerson theorem, 
  and its well-known corollary, the min-cut max-flow theorem.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a network with a flow and a cut›</span></span>
<span class="keyword1"><span class="command">locale</span></span> NFlowCut <span class="main">=</span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">+</span> NCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">k</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span><span class="main">::</span>linordered_idom graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">k</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_k<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">k</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> cut_ss_V finite_V finite_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">k</span></span> <span class="quoted">V</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Net Flow›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the \emph{net flow} to be the amount of flow effectively 
  passed over the cut from the source to the sink:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">netFlow</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">netFlow</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can show that the net flow equals the value of the flow.
  Note: Cormen et al.~\cite{CLRS09} present a whole page full of 
  summation calculations for this proof, and our formal proof also 
  looks quite complicated.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> flow_value<span class="main">:</span> <span class="quoted"><span class="quoted">"netFlow <span class="main">=</span> val"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?LCL</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?AOG</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?AIN</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> E<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?SOG</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="bound">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?SIN</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="bound">u</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?SOG'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?SIN'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some setup to make finiteness reasoning implicit›</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> finite_Collect<span class="main">]</span><span class="main">]</span>

  <span class="keyword1"><span class="command">have</span></span>  
    <span class="quoted"><span class="quoted">"netFlow <span class="main">=</span> <span class="var">?SOG'</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> <span class="var">?LCL</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="var">?SIN'</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> <span class="var">?LCL</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span>   <span class="main">=</span>        <span class="var">?SAOG</span>              <span class="main">-</span>          <span class="var">?SAIN</span>"</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> netFlow_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?SAOG</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SOG</span> <span class="bound">y</span><span class="main">)</span> <span class="main">+</span> <span class="var">?SOG</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?SAOG</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span>outgoing' <span class="free">k</span> <span class="main">∪</span> <span class="var">?LCL</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.union_disjoint<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"outgoing' <span class="free">k</span> <span class="main">∪</span> <span class="var">?LCL</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">k</span><span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> outgoing <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> outgoing <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def outgoing'_def s_in_cut<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>outgoing <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> outgoing <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> 
      <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>outgoing <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.union_disjoint<span class="main">)</span> 
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>outgoing <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> 
      <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SOG</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.UNION_disjoint<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>     
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?SAIN</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SIN</span> <span class="bound">y</span><span class="main">)</span> <span class="main">+</span> <span class="var">?SIN</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?SAIN</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span>incoming' <span class="free">k</span> <span class="main">∪</span> <span class="var">?LCL</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.union_disjoint<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"incoming' <span class="free">k</span> <span class="main">∪</span> <span class="var">?LCL</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">k</span><span class="main">-</span><span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> incoming <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> incoming <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def incoming'_def s_in_cut<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>incoming <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> incoming <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> 
      <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>incoming <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>incoming <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.union_disjoint<span class="main">)</span> 
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span>incoming <span class="main">`</span> <span class="main">(</span><span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> 
      <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SIN</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.UNION_disjoint<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"netFlow <span class="main">=</span>  
      <span class="main">(</span><span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SOG</span> <span class="bound">y</span><span class="main">)</span> <span class="main">+</span> <span class="var">?SOG</span> <span class="free">s</span><span class="main">)</span> 
    <span class="main">-</span> <span class="main">(</span><span class="main">(</span><span class="main">∑</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="var">?SIN</span> <span class="bound">y</span><span class="main">)</span> <span class="main">+</span> <span class="var">?SIN</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"netFlow <span class="main">=</span> <span class="var">?R</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="main">=</span> <span class="var">?SOG</span> <span class="free">s</span> <span class="main">-</span> <span class="var">?SIN</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> <span class="free">k</span> <span class="main">-</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">⟹</span> <span class="var">?SOG</span> <span class="bound">u</span> <span class="main">=</span> <span class="var">?SIN</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> conservation_const cut_ss_V t_ni_cut <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> val_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The value of any flow is bounded by the capacity of any cut.
  This is intuitively clear, as all flow from the source to the sink has to go
  over the cut.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> weak_duality<span class="main">:</span> <span class="quoted"><span class="quoted">"val <span class="main">≤</span> cap"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">c</span> <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">≤</span> <span class="var">?R</span>"</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sum_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">≤</span> cap"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cap_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"val <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="free">k</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> netFlow_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> capacity_const flow_value sum_nonneg<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Cut›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Ford-Fulkerson Theorem›</span></span>
<span class="keyword1"><span class="command">context</span></span> NFlow <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove three auxiliary lemmas first, and the state the theorem as a corollary›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> fofu_I_II<span class="main">:</span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> isAugmentingPath <span class="bound">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> isMaxFlow_alt
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f'</span><span class="main">.</span> NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f'</span> <span class="main">⟶</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="bound">f'</span> <span class="main">≤</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> asm_c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> isAugmentingPath <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> fct1<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow cf <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>augmentingFlow <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt augFlow_resFlow <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> fct2<span class="main">:</span> <span class="quoted"><span class="quoted">"Flow.val cf <span class="free">s</span> <span class="main">(</span>augmentingFlow <span class="skolem">p</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt augFlow_val
    resCap_gzero isAugmentingPath_def cf.isSimplePath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>augment <span class="main">(</span>augmentingFlow <span class="skolem">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> fct1 augment_flow_presv Network_axioms 
    <span class="keyword1"><span class="command">unfolding</span></span> Flow_def NFlow_def NPreflow_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Flow.val <span class="free">c</span> <span class="free">s</span> <span class="main">(</span>augment <span class="main">(</span>augmentingFlow <span class="skolem">p</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> val"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> fct1 fct2 augment_flow_value <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> asm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fofu_II_III<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> isAugmentingPath <span class="bound">p</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">k'</span><span class="main">.</span> NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">k'</span> <span class="main">∧</span> val <span class="main">=</span> NCut.cap <span class="free">c</span> <span class="bound">k'</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"cf.reachableNodes <span class="free">s</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> isAugmentingPath <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">∉</span><span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def cf.reachableNodes_def cf.connected_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> cf.isSPath_pathLE<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> CUT<span class="main">:</span> <span class="quoted"><span class="quoted">"NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="var">?S</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">unfold_locales</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Graph.reachableNodes cf <span class="free">s</span> <span class="main">⊆</span> V"</span></span>  
      <span class="keyword1"><span class="command">using</span></span> cf.reachable_ss_V s_node resV_netV <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> Graph.reachableNodes cf <span class="free">s</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> Graph.reachableNodes_def Graph.connected_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Graph.isPath.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> mem_Collect_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> NCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> NFlowCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>outgoing' <span class="var">?S</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span> <span class="comment1">― ‹Proof by contradiction›</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>outgoing' <span class="var">?S</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span><span class="var">?S</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> outgoing'_def<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="free">c</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">c</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> capacity_const <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> eq_iff not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span><span class="var">?S</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cf.reachableNodes_append_edge<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∉</span><span class="var">?S</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing' <span class="var">?S</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> cap"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>incoming' <span class="var">?S</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>  
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span> <span class="comment1">― ‹Proof by contradiction›</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>incoming' <span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span><span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> incoming'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>E"</span></span> <span class="keyword1"><span class="command">using</span></span> no_parallel_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>E›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> cf.E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cf.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="var">?S</span>›</span></span> cf.reachableNodes_append_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span><span class="var">?S</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming' <span class="var">?S</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> cap"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> flow_value<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> netFlow_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1"><span class="command">lemma</span></span> fofu_III_I<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">k</span><span class="main">.</span> NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">k</span> <span class="main">∧</span> val <span class="main">=</span> NCut.cap <span class="free">c</span> <span class="bound">k</span> <span class="main">⟹</span> isMaxFlow <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">k</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> NCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> NFlowCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> cap"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Flow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">f'</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fc'<span class="main">:</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">interpret</span></span> fc'<span class="main">:</span> NFlowCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="skolem">f'</span></span> <span class="quoted"><span class="skolem">k</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fc'.val <span class="main">≤</span> cap"</span></span> <span class="keyword1"><span class="command">using</span></span> fc'.weak_duality <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹val <span class="main">=</span> cap›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fc'.val <span class="main">≤</span> val"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> isMaxFlow_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally we can state the Ford-Fulkerson theorem: ›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> ford_fulkerson<span class="main">:</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span> <span class="main">⟷</span> 
  <span class="main">¬</span> Ex isAugmentingPath"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> Ex isAugmentingPath <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">k</span><span class="main">.</span> NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">k</span> <span class="main">∧</span> val <span class="main">=</span> NCut.cap <span class="free">c</span> <span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> fofu_I_II fofu_II_III fofu_III_I <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Corollaries›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this subsection we present a few corollaries of the 
  flow-cut relation and the Ford-Fulkerson theorem.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The outgoing flow of the source is the same as the incoming flow of 
  the sink. Intuitively, this means that no flow is generated or lost in the 
  network, except at the source and sink.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> inflow_t_outflow_s<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">t</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We choose a cut between the sink and all other nodes›</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?K</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"V <span class="main">-</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> NFlowCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="var"><span class="quoted"><span class="var">?K</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> s_node s_not_t <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The cut is chosen such that its outgoing edges are the incoming edges
    to the sink, and its incoming edges are the outgoing edges from the sink.
    Note that the sink has no outgoing edges.›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"outgoing' <span class="var">?K</span> <span class="main">=</span> incoming <span class="free">t</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"incoming' <span class="var">?K</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> no_self_loop no_outgoing_t
    <span class="keyword1"><span class="command">unfolding</span></span> outgoing'_def incoming_def incoming'_def outgoing_def V_def  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> incoming <span class="free">t</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> netFlow"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> netFlow_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"netFlow <span class="main">=</span> val"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> flow_value<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span> <span class="main">∈</span> outgoing <span class="free">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">e</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> val_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As an immediate consequence of the Ford-Fulkerson theorem, we get that
  there is no augmenting path if and only if the flow is maximal.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> noAugPath_iff_maxFlow<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∄</span><span class="bound">p</span><span class="main">.</span> isAugmentingPath <span class="bound">p</span><span class="main">)</span> <span class="main">⟷</span> isMaxFlow <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ford_fulkerson <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with flow›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The value of the maximum flow equals the capacity of the minimum cut›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> maxFlow_minCut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isMaxFlow <span class="free">f</span><span class="main">;</span> isMinCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">k</span><span class="main">⟧</span> 
  <span class="main">⟹</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="free">f</span> <span class="main">=</span> NCut.cap <span class="free">c</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isMaxFlow <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"isMinCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">+</span> NCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">k</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> isMaxFlow_def isMinCut_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">interpret</span></span> NFlowCut <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">k</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span> 
  
  
  <span class="keyword1"><span class="command">from</span></span> ford_fulkerson <span class="quoted"><span class="quoted">‹isMaxFlow <span class="free">f</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"NCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="skolem">k'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> NCut.cap <span class="free">c</span> <span class="skolem">k'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"val <span class="main">=</span> cap"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹isMinCut <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">k</span>›</span></span> weak_duality
    <span class="keyword1"><span class="command">unfolding</span></span> isMinCut_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Graph_Impl">
<div class="head">
<h1>Theory Graph_Impl</h1>
</div>
<pre class="source"><span class="comment1">(* TODO: That's quite specific to the BFS alg. Move to Edka! *)</span>
<span class="keyword1"><span class="command">theory</span></span> Graph_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Refine_Add_Fofu.html">Lib/Refine_Add_Fofu</a>"</span> <a href="Graph.html">Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">― ‹Fixing capacities to integer values›</span>
<span class="keyword1"><span class="command">type_synonym</span></span> capacity_impl <span class="main">=</span> <span class="quoted">int</span> <span class="comment1">(* TODO: DUP in Network_Impl. Remove here!*)</span>


<span class="keyword1"><span class="command">locale</span></span> Impl_Succ <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">absG</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ga</span> <span class="main">⇒</span> capacity_impl graph"</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ifT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ig</span> itself"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ga</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">isG</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ga</span> <span class="main">⇒</span> <span class="tfree">'gi</span> <span class="main">⇒</span> assn"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'gi</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list Heap"</span></span>
  <span class="comment1">(*assumes [constraint_rules]: "precise isG"*)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> si_rule<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="free">succ_impl</span><span class="main">,</span><span class="main">(</span>uncurry <span class="free">succ</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">.</span> <span class="bound">u</span><span class="main">∈</span>Graph.V <span class="main">(</span><span class="free">absG</span> <span class="bound">c</span><span class="main">)</span><span class="keyword1">]<span class="hidden">⇩</span><sub>a</sub></span> <span class="free">isG</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure nat_rel<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="main">→</span> list_assn <span class="main">(</span>pure nat_rel<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> this_loc<span class="main">:</span> <span class="quoted"><span class="quoted">"Impl_Succ <span class="free">absG</span> <span class="free">succ</span> <span class="free">isG</span> <span class="free">succ_impl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ig</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span> <span class="comment1">(* TODO: Will not work if succ is not a constant! *)</span> 
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Network_Impl">
<div class="head">
<h1>Theory Network_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Flow Networks›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Network_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Refine_Add_Fofu.html">Lib/Refine_Add_Fofu</a>"</span>
  <a href="Ford_Fulkerson.html">Ford_Fulkerson</a> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type Constraints›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We constrain the types that we use for implementation.›</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define capacities to be integer values.›</span></span>  
<span class="keyword1"><span class="command">type_synonym</span></span> capacity_impl <span class="main">=</span> <span class="quoted">int</span>
<span class="keyword1"><span class="command">type_synonym</span></span> flow_impl <span class="main">=</span> <span class="quoted"><span class="quoted">"capacity_impl flow"</span></span>  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a locale that assumes that the nodes are natural numbers in the 
  range <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="main"><span class="main">0</span></span><span class="main"><span class="main">..&lt;</span></span><span class="free"><span class="free">N</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>  

<span class="keyword1"><span class="command">locale</span></span> Network_Impl <span class="main">=</span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">N</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> V_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"V<span class="main">⊆</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">lemma</span></span> E_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span><span class="main">×</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> E_ss_VxV V_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Residual Graph›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Get the residual capacity of an edge.›</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cf_get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"flow_impl <span class="main">⇒</span> edge <span class="main">⇒</span> capacity_impl nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_get</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">∈</span>E <span class="main">∪</span> E<span class="main">¯</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>
    <span class="main">}</span>"</span></span>  
    
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Update the residual capacity of an edge.›</span></span>    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cf_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"flow_impl <span class="main">⇒</span> edge <span class="main">⇒</span> capacity_impl <span class="main">⇒</span> flow_impl nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_set</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">∈</span>E <span class="main">∪</span> E<span class="main">¯</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">:=</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>  
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain the initial residual graph.›</span></span>    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cf_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"flow_impl nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_init</span> <span class="main">≡</span> <span class="keyword1">return</span> <span class="main">(</span>op_mtx_new <span class="free">c</span><span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Adjacency Map›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obtain the list of adjacent nodes for a specified node.›</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">am_get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span>    
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">am_get</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
      
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Test whether a node identifier is actually a node. 
    As not all numbers in the range <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">{</span></span><span class="main"><span class="main">0</span></span><span class="main"><span class="main">..&lt;</span></span><span class="free"><span class="free">N</span></span><span class="main"><span class="main">}</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must identify nodes, 
    this function uses the adjacency map to check whether there are adjacent
    edges. Due to the network constraints, all nodes have adjacent edges.
  ›</span></span>    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">am_is_in_V</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> bool nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">am_is_in_V</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> am_is_in_V_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span><span class="main">,</span>adjacent_nodes<span class="main">)</span> <span class="main">∈</span> nat_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"am_is_in_V <span class="free">am</span> <span class="free">u</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="free">u</span><span class="main">∈</span>V<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V <span class="main">⟷</span> adjacent_nodes <span class="free">u</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> V_def adjacent_nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="free">am</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> fun_relD<span class="main">[</span><span class="operator">OF</span> assms IdI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> am_is_in_V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_vcg</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Registration of Basic Operations to Sepref›</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Bundles the setup for registration of abstract operations.›</span></span>  
<span class="keyword1"><span class="command">bundle</span></span> Network_Impl_Sepref_Register <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Automatically rewrite to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i_mtx›</span></span></span></span> interface type›</span></span>  
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">map_type_eqs</span><span class="main">]</span> <span class="main">=</span> 
    map_type_eqI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl flow<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span><span class="main">]</span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Bundle›</span>
 
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Registration of Abstract Operations›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="free">N</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span>
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="free">c</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>

<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">cf_get</span> <span class="quoted">cf_set</span> <span class="quoted">cf_init</span>
  
<span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">am_get</span> <span class="quoted">am_is_in_V</span>    
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Anonymous Context›</span> 

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement To Efficient Data Structures›</span></span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Functions from Nodes by Arrays›</span></span>  
<span class="comment1">(*
  TODO: Move to own file in IICF
 
  This has more general uses than implementing nodes!
  It can implement functions from any objects represented by an initial
  segment of the natural numbers, a very often recurring pattern.
*)</span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide a template for implementing functions from nodes by arrays.
  Outside the node range, the abstract functions have a default value.

  This template is then used for refinement of various data structures.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_nf</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">dflt</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> 
  <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span><span class="bound">l</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>length <span class="bound">l</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">≥</span><span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">dflt</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> nf_init_rule<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> Array.new <span class="free">N</span> <span class="free">dflt</span> <span class="main">&lt;</span>is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">dflt</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>

<span class="keyword1"><span class="command">lemma</span></span> nf_copy_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="free">a</span><span class="main">&gt;</span> array_copy <span class="free">a</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="free">a</span> <span class="main">*</span> is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="bound">r</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> nf_lookup_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">&lt;</span><span class="free">N</span> <span class="main">⟹</span> <span class="main">&lt;</span>is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="free">a</span><span class="main">&gt;</span> Array.nth <span class="free">a</span> <span class="free">v</span> <span class="main">&lt;</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="free">a</span> <span class="main">*</span><span class="main">↑</span><span class="main">(</span><span class="bound">r</span> <span class="main">=</span> <span class="free">f</span> <span class="free">v</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> nf_update_rule<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">&lt;</span><span class="free">N</span> <span class="main">⟹</span> <span class="main">&lt;</span>is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="free">f</span> <span class="free">a</span><span class="main">&gt;</span> Array.upd <span class="free">v</span> <span class="free">x</span> <span class="free">a</span> <span class="main">&lt;</span>is_nf <span class="free">N</span> <span class="free">dflt</span> <span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">v</span><span class="main">:=</span><span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">&gt;</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> is_nf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>
  
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Automation Setup for Side-Condition Discharging›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>
  

<span class="keyword1"><span class="command">lemma</span></span> mtx_nonzero_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mtx_nonzero <span class="free">c</span> <span class="main">=</span> E"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mtx_nonzero_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mtx_nonzeroN<span class="main">:</span> <span class="quoted"><span class="quoted">"mtx_nonzero <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span><span class="main">×</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> E_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> in_mtx_nonzeroN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> mtx_nonzero <span class="free">c</span> <span class="main">⟹</span> <span class="free">u</span><span class="main">&lt;</span><span class="free">N</span> <span class="main">∧</span> <span class="free">v</span><span class="main">&lt;</span><span class="free">N</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> mtx_nonzeroN <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>   
    
<span class="keyword1"><span class="command">lemma</span></span> inV_less_N<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>V <span class="main">⟹</span> <span class="free">v</span><span class="main">&lt;</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> V_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> inEIE_lessN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span>E <span class="main">∨</span> <span class="free">e</span><span class="main">∈</span>E<span class="main">¯</span> <span class="main">⟹</span> <span class="keyword1">case</span> <span class="free">e</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">u</span><span class="main">&lt;</span><span class="free">N</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">&lt;</span><span class="free">N</span>"</span></span>    
  <span class="keyword1"><span class="command">using</span></span> E_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> nested_case_prod_simp

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Network Parameters by Identity›</span></span>    
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">cap_assn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cap_assn</span> <span class="main">≡</span> id_assn"</span></span>  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">edge_assn</span> <span class="main">≡</span> nat_assn <span class="keyword1">×<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span>  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">node_assn</span> <span class="main">≡</span> nat_assn"</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Refine number of nodes, and source and sink node by themselves›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> 
  IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">N</span></span><span class="main">]</span>
  IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span><span class="main">]</span>
  IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> c_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="main">(</span><span class="keyword1">return</span> <span class="free">c</span><span class="main">)</span><span class="main">,</span>uncurry0 <span class="main">(</span>RETURN <span class="free">c</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∈</span>unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> pure <span class="main">(</span>nat_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> nat_rel <span class="main">→</span> Id<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sepref_to_hoare</span><span class="main">)</span> <span class="operator">sep_auto</span> 
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Residual Graph by Adjacency Matrix›</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">cf_assn</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> asmtx_assn <span class="free"><span class="bound"><span class="entity">N</span></span></span> cap_assn"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cf_assn</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_assn</span> <span class="main">≡</span> Network_Impl.cf_assn <span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">intf_of_assn</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"intf_of_assn <span class="main">(</span>cf_assn<span class="main">)</span> <span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
<span class="keyword1"><span class="command">sepref_thm</span></span> cf_get_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST cf_get<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> edge_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cap_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> cf_get_def cf_assn_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">cf_get_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.cf_get_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
    
<span class="keyword1"><span class="command">sepref_thm</span></span> cf_set_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST cf_set<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> edge_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cap_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> cf_set_def cf_assn_def PR_CONST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">cf_set_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.cf_set_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>

<span class="keyword1"><span class="command">sepref_thm</span></span> cf_init_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry0 <span class="main">(</span>PR_CONST cf_init<span class="main">)</span>"</span></span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cf_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> PR_CONST_def cf_assn_def cf_init_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> amtx_fold_custom_new<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">cf_init_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.cf_init_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> 
  cf_get_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span> 
  cf_set_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span> 
  cf_init_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Adjacency Map by Array›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">am_assn</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> is_nf <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">(</span><span class="main">[]</span><span class="main">::</span>nat list<span class="main">)</span>"</span></span>    
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">am_assn</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">am_assn</span> <span class="main">≡</span> Network_Impl.am_assn <span class="free">N</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> am_get_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry Array.nth<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST am_get<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> list_assn id_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> am_assn_def am_get_def list_assn_pure_conv
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref_to_hoare</span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

    
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">am_is_in_V_impl</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">amu</span> <span class="main">←</span> Array.nth <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="main">(</span><span class="main">¬</span>is_Nil <span class="bound">amu</span><span class="main">)</span>
<span class="main">}</span>"</span></span>    
<span class="keyword1"><span class="command">lemma</span></span> am_is_in_V_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry am_is_in_V_impl<span class="main">,</span> uncurry <span class="main">(</span>am_is_in_V<span class="main">)</span><span class="main">)</span> 
  <span class="main">∈</span> <span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span><span class="main">&lt;</span><span class="free">N</span><span class="keyword1">]<span class="hidden">⇩</span><sub>a</sub></span> am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> node_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="main">→</span> bool_assn"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> am_assn_def am_is_in_V_def am_is_in_V_impl_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Flow Value›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define an algorithm to compute the value of a flow from 
  the residual graph
›</span></span>  
  
<span class="keyword1"><span class="command">locale</span></span> RGraph_Impl <span class="main">=</span> RGraph <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">cf</span></span> <span class="main">+</span> Network_Impl <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">N</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl flow"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">cf</span>
  
<span class="keyword1"><span class="command">lemma</span></span> rgraph_and_network_impl_imp_rgraph_impl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Network_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">cf</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Network_Impl.RGraph_Impl.intro<span class="main">)</span>  
  
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> val_by_adj_map<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f.val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> E<span class="main">``</span><span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> AM <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">note</span></span> f.val_by_cf
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> rg_is_cf
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">∈</span>outgoing <span class="free">s</span><span class="main">.</span> <span class="free">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> 
          <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">cf</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_outgoing_pointwise<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>    
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl 
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_flow_val_aux</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">succs</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
    sum_impl <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>set <span class="bound">succs</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph_Impl<span class="main">)</span> compute_flow_val_aux_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"compute_flow_val_aux <span class="free">am</span> <span class="free">cf</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> f.val<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> val_by_adj_map<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val_aux_def cf_get_def am_get_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> sum_impl_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s_node<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For technical reasons (poor foreach-support of Sepref tool), 
  we have to add another refinement step: ›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_flow_val</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">succs</span> <span class="main">←</span> am_get <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
  nfoldli <span class="bound">succs</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">a</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">b</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> 
     <span class="keyword1">return</span> <span class="main">(</span><span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span>
   <span class="main">}</span><span class="main">)</span> <span class="main">0</span>
<span class="main">}</span><span class="main">)</span>"</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph_Impl<span class="main">)</span> compute_flow_val_correct<span class="main">[</span><span class="operator">THEN</span> order_trans<span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"compute_flow_val <span class="free">am</span> <span class="free">cf</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> f.val<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES <span class="main">(</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ compute_flow_val_aux_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val_def compute_flow_val_aux_def sum_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> LFO_refine bind_refine'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def br_def am_get_def is_adj_map_def 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    
    
<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">compute_flow_val</span>
<span class="keyword2"><span class="keyword">end</span></span>  
  
<span class="keyword1"><span class="command">sepref_thm</span></span> compute_flow_val_impl
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST compute_flow_val<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> cf_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> cap_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>  
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">compute_flow_val_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.compute_flow_val_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> compute_flow_val_impl_hnr<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> 
    <span class="main">=</span> compute_flow_val_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
    
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We also export a correctness theorem on the separation logic level›</span></span>    

<span class="keyword1"><span class="command">lemma</span></span> compute_flow_val_impl_correct<span class="main">[</span><span class="operator">sep_heap_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"RGraph_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">cf</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.is_adj_map <span class="free">c</span> <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">&lt;</span>cf_assn <span class="free">N</span> <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> am_assn <span class="free">N</span> <span class="free">am</span> <span class="free">ami</span><span class="main">&gt;</span> 
          compute_flow_val_impl <span class="free">s</span> <span class="free">N</span> <span class="free">ami</span> <span class="free">cfi</span> 
        <span class="main">&lt;</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> cf_assn <span class="free">N</span> <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> am_assn <span class="free">N</span> <span class="free">am</span> <span class="free">ami</span> 
            <span class="main">*</span> <span class="main">↑</span><span class="main">(</span> <span class="bound">v</span> <span class="main">=</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="main">(</span>RPreGraph.f <span class="free">c</span> <span class="free">cf</span><span class="main">)</span> <span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> RGraph_Impl <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">N</span></span> <span class="quoted"><span class="free">cf</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

      
  <span class="keyword1"><span class="command">from</span></span> hn_refine_ref<span class="main">[</span><span class="operator">OF</span> 
      compute_flow_val_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM order_refl<span class="main"><span class="main">]</span></span> 
      compute_flow_val_impl_hnr<span class="main"><span class="main">[</span></span><span class="operator">to_hnr</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hn_ctxt_def pure_def hn_refine_def f_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_post_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Computing the Exact Number of Nodes›</span></span>  
  
<span class="keyword1"><span class="command">context</span></span> Network_Impl
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> am_to_adj_nodes_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">am</span> <span class="free">u</span><span class="main">,</span> adjacent_nodes <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> AM  
  <span class="keyword1"><span class="command">unfolding</span></span> adjacent_nodes_def is_adj_map_def  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def in_br_conv<span class="main">)</span>  

  
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_C</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">cardV</span><span class="main">=</span><span class="main">0</span><span class="main">;</span>
  nfoldli <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">]</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">cardV</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">v</span><span class="main">&lt;</span><span class="free">N</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">inV</span> <span class="main">←</span> am_is_in_V <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">v</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">inV</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cardV</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span>
      <span class="keyword1">return</span> <span class="bound">cardV</span>
  <span class="main">}</span><span class="main">)</span> <span class="bound">cardV</span>
<span class="main">}</span>"</span></span>    

<span class="keyword1"><span class="command">lemma</span></span> init_C_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AM<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"init_C <span class="free">am</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">C</span><span class="main">.</span> <span class="bound">C</span> <span class="main">=</span> card V<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> init_C_def  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> 
      nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l1</span> <span class="main"><span class="bound">_</span></span> <span class="bound">C</span><span class="main">.</span> <span class="bound">C</span> <span class="main">=</span> card <span class="main">(</span>V<span class="main">∩</span>set <span class="bound">l1</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span>
      <span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>  
  <span class="keyword1"><span class="command">using</span></span> V_ss  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upt_eq_lel_conv Int_absorb2 am_to_adj_nodes_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AM<span class="main"><span class="main">]</span></span><span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">includes</span></span> Network_Impl_Sepref_Register
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">init_C</span>    
<span class="keyword2"><span class="keyword">end</span></span>    
  
<span class="keyword1"><span class="command">sepref_thm</span></span> fifo_init_C_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>PR_CONST init_C<span class="main">)</span>"</span></span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"am_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> nat_assn"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> init_C_def PR_CONST_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">fifo_init_C_impl</span> 
  <span class="keyword2"><span class="keyword">uses</span></span> Network_Impl.fifo_init_C_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> fifo_init_C_impl.refine<span class="main">[</span><span class="operator">OF</span> Network_Impl_axioms<span class="main">]</span>
  
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network Implementation Locale›</span>
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="NetCheck">
<div class="head">
<h1>Theory NetCheck</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Checking for Valid Network›</span></span>
<span class="keyword1"><span class="command">theory</span></span> NetCheck
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="Refine_Add_Fofu.html">Lib/Refine_Add_Fofu</a>"</span>
  <a href="Network.html">Network</a>
  <a href="Graph_Impl.html">Graph_Impl</a>
  <a href="../DFS_Framework/Reachable_Nodes.html">DFS_Framework.Reachable_Nodes</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory contains code to read a network from an edge list, 
  and verify that the network is a valid input for the 
  Edmonds Karp Algorithm.
›</span></span>

<span class="comment1">(*&lt;*)</span>
  <span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion_delete</span> <span class="quoted">int</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion_delete</span> <span class="quoted"><span class="quoted">"real<span class="main">::</span>nat<span class="main">⇒</span>real"</span></span><span class="main">]</span><span class="main">]</span>
<span class="comment1">(*&gt;*)</span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Graphs as Lists of Edges›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Graphs can be represented as lists of edges, each edge being a triple of 
    start node, end node, and capacity. Capacities must be positive, and there
    must not be multiple edges with the same start and end node. ›</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> edge_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">×</span> node <span class="main">×</span> capacity_impl<span class="main">)</span> list"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ln_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge_list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">ln_invar</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="main">≡</span> 
      distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">)</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">.</span> <span class="bound">c</span><span class="main">&gt;</span><span class="main">0</span><span class="main">)</span> 
    "</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ln_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge_list <span class="main">⇒</span> capacity_impl graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">ln_α</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> 
      <span class="keyword1">if</span> <span class="main">∃</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> 
        <span class="keyword1">SOME</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span>
      <span class="keyword1">else</span> <span class="main">0</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ln_rel</span> <span class="main">≡</span> br ln_α ln_invar"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> ln_equivalence<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="free">c'</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">⟷</span> ln_invar <span class="free">el</span> <span class="main">∧</span> <span class="free">c'</span> <span class="main">=</span> ln_α <span class="free">el</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ln_N</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node<span class="main">×</span>node<span class="main">×</span><span class="main">_</span><span class="main">)</span> list <span class="main">⇒</span> nat"</span></span> 
    <span class="comment1">― ‹Maximum node number plus one. I.e. the size of an array to be indexed by nodes.›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ln_N</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="main">≡</span> Max <span class="main">(</span><span class="main">(</span>fst<span class="main">`</span>set <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">(</span>fst <span class="keyword1">o</span> snd<span class="main">)</span><span class="main">`</span>set <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ln_α_imp_in_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ln_α <span class="free">el</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">≠</span><span class="main">(</span><span class="main">0</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span>ln_α <span class="free">el</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>set <span class="free">el</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> someI_ex<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ln_N_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>ln_N <span class="free">el</span><span class="main">}</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.V_def Graph.E_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ln_α_imp_in_set<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_N_def less_Suc_eq_le <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_N_def less_Suc_eq_le <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Max_ge<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pre-Networks›</span></span>  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This data structure is used to convert an edge-list to a network and 
    check validity. It maintains additional information, like a adjacency maps. ›</span></span>

  <span class="keyword1"><span class="command">record</span></span> pre_network <span class="main">=</span>
    pn_c <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
    pn_V <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span>
    pn_succ <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list"</span></span>
    pn_pred <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list"</span></span>
    pn_adjmap <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list"</span></span>
    pn_s_node <span class="main">::</span> <span class="quoted">bool</span>
    pn_t_node <span class="main">::</span> <span class="quoted">bool</span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">read</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge_list <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> pre_network option"</span></span> 
    <span class="comment1">― ‹Read a pre-network from an edge list, and source/sink node numbers.›</span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">read</span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> Some <span class="main">⦇</span>
      pn_c <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> 
      pn_V <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> 
      pn_succ <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">)</span><span class="main">,</span>
      pn_pred <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">)</span><span class="main">,</span>
      pn_adjmap <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">)</span><span class="main">,</span> 
      pn_s_node <span class="main">=</span> False<span class="main">,</span> 
      pn_t_node <span class="main">=</span> False
    <span class="main">⦈</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">read</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">read</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
      Some <span class="bound">x</span> <span class="main">⇒</span>
        <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span>
          <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">then</span>
            None
          <span class="keyword1">else</span>
            Some <span class="main">(</span><span class="bound">x</span><span class="main">⦇</span> 
              pn_c <span class="main">:=</span> <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">,</span>
              pn_V <span class="main">:=</span> insert <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>pn_V <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              pn_succ <span class="main">:=</span> <span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="main">(</span><span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              pn_pred <span class="main">:=</span> <span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">#</span> <span class="main">(</span><span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              pn_adjmap <span class="main">:=</span> <span class="main">(</span>pn_adjmap <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>
                <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="main">(</span>pn_adjmap <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> 
                <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">#</span> <span class="main">(</span>pn_adjmap <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">,</span>
              pn_s_node <span class="main">:=</span> pn_s_node <span class="bound">x</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span>
              pn_t_node <span class="main">:=</span> pn_t_node <span class="bound">x</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>
            <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">else</span>
          None<span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
      
  <span class="comment1">(* TODO: These proofs look overly verbose. *)</span>  
  <span class="keyword1"><span class="command">lemma</span></span> read_correct1<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">es</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="free">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="free">V</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="free">succ</span><span class="main">,</span> 
    pn_pred <span class="main">=</span> <span class="free">pred</span> <span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="free">adjmap</span><span class="main">,</span> pn_s_node <span class="main">=</span> <span class="free">s_n</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="free">t_n</span><span class="main">⦈</span> <span class="main">⟹</span> 
    <span class="main">(</span><span class="free">es</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">∧</span> Graph.V <span class="free">c</span> <span class="main">=</span> <span class="free">V</span> <span class="main">∧</span> finite <span class="free">V</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="free">s_n</span> <span class="main">⟶</span> <span class="free">s</span> <span class="main">∈</span> <span class="free">V</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">t_n</span> <span class="main">⟶</span> <span class="free">t</span> <span class="main">∈</span> <span class="free">V</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">s_n</span> <span class="main">⟶</span> <span class="free">s</span> <span class="main">∉</span> <span class="free">V</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">t_n</span> <span class="main">⟶</span> <span class="free">t</span> <span class="main">∉</span> <span class="free">V</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="free">c</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="free">c</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="free">succ</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="free">c</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="free">succ</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="free">pred</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="free">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="free">pred</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="free">adjmap</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="free">c</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="free">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
      <span class="main">∧</span> distinct <span class="main">(</span><span class="free">adjmap</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">es</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">V</span></span> <span class="quoted"><span class="free">succ</span></span> <span class="quoted"><span class="free">pred</span></span> <span class="quoted"><span class="free">adjmap</span></span> <span class="quoted"><span class="free">s_n</span></span> <span class="quoted"><span class="free">t_n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def Graph.E_def ln_rel_def br_def 
            ln_α_def ln_invar_def 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">es</span><span class="main">)</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u1</span></span> <span class="skolem"><span class="skolem">v1</span></span> <span class="skolem"><span class="skolem">c1</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">c1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> prod_cases3<span class="main">)</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="skolem">es</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Cons.prems obt1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> fct0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Cons.prems obt1 obt2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_splits<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> fct1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">u1</span> <span class="main">≠</span> <span class="skolem">v1</span> <span class="main">∧</span> <span class="skolem">v1</span> <span class="main">≠</span> <span class="free">s</span> <span class="main">∧</span> <span class="skolem">u1</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> Cons.prems obt1 obt2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_splits<span class="main">)</span>
        
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c'</span></span> <span class="skolem"><span class="skolem">V'</span></span> <span class="skolem"><span class="skolem">sc'</span></span> <span class="skolem"><span class="skolem">ps'</span></span> <span class="skolem"><span class="skolem">pd'</span></span> <span class="skolem"><span class="skolem">s_n'</span></span> <span class="skolem"><span class="skolem">t_n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt3<span class="main">:</span> 
          <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c'</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V'</span><span class="main">,</span>
                pn_succ <span class="main">=</span> <span class="skolem">sc'</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd'</span><span class="main">,</span>  pn_adjmap <span class="main">=</span> <span class="skolem">ps'</span><span class="main">,</span> 
                pn_s_node <span class="main">=</span> <span class="skolem">s_n'</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="skolem">t_n'</span><span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="skolem">es</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c'</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V'</span><span class="main">,</span> 
          pn_succ <span class="main">=</span> <span class="skolem">sc'</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd'</span><span class="main">,</span>
          pn_adjmap <span class="main">=</span> <span class="skolem">ps'</span><span class="main">,</span> pn_s_node <span class="main">=</span> <span class="skolem">s_n'</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="skolem">t_n'</span><span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> fct2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s_n</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">s_n'</span> <span class="main">∨</span> <span class="skolem">u1</span> <span class="main">=</span> <span class="free">s</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t_n</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">t_n'</span> <span class="main">∨</span> <span class="skolem">v1</span> <span class="main">=</span> <span class="free">t</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">:=</span> <span class="skolem">c1</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">=</span> <span class="skolem">V'</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">}</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">succ</span> <span class="main">=</span> <span class="skolem">sc'</span> <span class="main">(</span><span class="skolem">u1</span> <span class="main">:=</span> <span class="skolem">v1</span> <span class="main">#</span> <span class="skolem">sc'</span> <span class="skolem">u1</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct7<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pred</span> <span class="main">=</span> <span class="skolem">pd'</span> <span class="main">(</span><span class="skolem">v1</span> <span class="main">:=</span> <span class="skolem">u1</span> <span class="main">#</span> <span class="skolem">pd'</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> fct8<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">adjmap</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">ps'</span> <span class="main">(</span><span class="skolem">u1</span> <span class="main">:=</span> <span class="skolem">v1</span> <span class="main">#</span> <span class="skolem">ps'</span> <span class="skolem">u1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">v1</span> <span class="main">:=</span> <span class="skolem">u1</span> <span class="main">#</span> <span class="skolem">ps'</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fct0 fct1 Cons.prems obt1 obt2 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        
          
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">es</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ln_invar <span class="skolem">es</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">es</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
              <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">.</span> <span class="bound">c</span><span class="main">&gt;</span><span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹ln_invar <span class="skolem">es</span>›</span></span> fct0 obt1
                <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">have</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="skolem">es</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹ln_invar <span class="skolem">es</span>›</span></span>
                <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c1'</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">c1'</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                    <span class="keyword1"><span class="command">using</span></span> obt1 f2 f1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>"</span></span> 
                    <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">c1'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">c1'</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">es</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">es</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">c1'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">c1'</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> f1
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
              <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="skolem">a</span> <span class="main">=</span> ln_α <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span> <span class="skolem">a</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">c1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct4 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ln_α <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span> <span class="skolem">a</span> 
                        <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">=</span> <span class="var">?R</span>"</span></span><span class="main">)</span> 
                        <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def <span class="keyword1"><span class="command">using</span></span> obt1 fct0 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="main">=</span> <span class="skolem">c1</span>"</span></span>
                        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
                            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">c1'</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">c1'</span> <span class="main">≠</span> <span class="skolem">c1</span>"</span></span> 
                            <span class="keyword1"><span class="command">using</span></span> fct0 obt1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 
                            <span class="quoted"><span class="quoted">"<span class="main">¬</span>distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                            <span class="keyword1"><span class="command">using</span></span> obt1 
                            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Pair_inject 
                              distinct_map_eq list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> split_conv<span class="main">)</span> 
                          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                        <span class="keyword1"><span class="command">qed</span></span>
                      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">=</span> <span class="skolem">c1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                    <span class="keyword1"><span class="command">}</span></span>
                    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> 
                      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u1'</span> <span class="bound">v1'</span> <span class="bound">c1'</span><span class="main">.</span> <span class="bound">u1'</span> <span class="main">≠</span> <span class="skolem">u1</span> <span class="main">∨</span> <span class="bound">v1'</span> <span class="main">≠</span> <span class="skolem">v1</span> 
                      <span class="main">⟶</span> <span class="main">(</span><span class="main">(</span><span class="bound">u1'</span><span class="main">,</span> <span class="bound">v1'</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>
                            <span class="main">⟷</span> <span class="main">(</span><span class="bound">u1'</span><span class="main">,</span> <span class="bound">v1'</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">es</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> obt1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u1'</span></span> <span class="skolem"><span class="skolem">v1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
                    <span class="keyword1"><span class="command">{</span></span>
                      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ln_α <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>ln_α <span class="skolem">es</span><span class="main">)</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">)</span>"</span></span>
                        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> 
                            <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c1'</span> <span class="main">≠</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                          <span class="keyword3"><span class="command">case</span></span> True
                            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def 
                              <span class="keyword1"><span class="command">using</span></span> f1 False True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                        <span class="keyword1"><span class="command">next</span></span>
                          <span class="keyword3"><span class="command">case</span></span> False
                            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                        <span class="keyword1"><span class="command">qed</span></span>
                      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ln_α <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span><span class="main">)</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span>ln_α <span class="skolem">es</span><span class="main">)</span> <span class="skolem">a</span>"</span></span> 
                        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1'</span><span class="main">,</span> <span class="skolem">v1'</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">}</span></span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False fct4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="skolem">a</span> <span class="main">=</span> ln_α <span class="skolem">es</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">es</span>›</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">es</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.V <span class="skolem">c</span> <span class="main">=</span> Graph.V <span class="skolem">c'</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">}</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct0 fct4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.V <span class="skolem">c'</span> <span class="main">=</span> <span class="skolem">V'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.V <span class="skolem">c</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s_n</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s_n'</span> <span class="main">∨</span> <span class="skolem">u1</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="skolem">V</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s_n'</span>"</span></span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u1</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t_n</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t_n'</span> <span class="main">∨</span> <span class="skolem">v1</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> <span class="skolem">V</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t_n'</span>"</span></span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">s_n</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">s_n'</span> <span class="main">∧</span> <span class="skolem">u1</span> <span class="main">≠</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct5 fct1  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">t_n</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">t_n'</span> <span class="main">∧</span> <span class="skolem">v1</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∉</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct5 fct1  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≥</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct4 fct1 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct4 fct1 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct4 fct1 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct fct4 fct1 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">case</span></span> True
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct4 <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">case</span></span> False
                <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span><span class="main">)</span>
                    <span class="keyword3"><span class="command">case</span></span> True
                      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct4 <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">b</span>›</span></span> 
                        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">next</span></span>
                    <span class="keyword3"><span class="command">case</span></span> False
                      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> 
                        <span class="keyword1"><span class="command">using</span></span> False <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">≠</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span>›</span></span> fct4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
                  <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> n_fct <span class="main">=</span> this
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">u1</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">succ</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">sc'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct6 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">sc'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">sc'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">succ</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">succ</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">u1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>"</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">succ</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">succ</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> True
                  <span class="keyword1"><span class="command">have</span></span> fct<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">sc'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">sc'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  
                  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">succ</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span> <span class="main">#</span> <span class="skolem">sc'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> fct6 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
                    <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">sc'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                        <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">qed</span></span>
                  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> False
                  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">succ</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">succ</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v1</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pred</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">pd'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct7 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">pd'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="skolem">c'</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">pd'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">pred</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">pred</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>"</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">pred</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">pred</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> True
                  <span class="keyword1"><span class="command">have</span></span> fct<span class="main">:</span> 
                    <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">pd'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="skolem">c'</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">pd'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  
                  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pred</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span> <span class="main">#</span> <span class="skolem">pd'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> fct7 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
                    <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u1</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">pd'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                        <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">qed</span></span>
                  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> False
                  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">pred</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">pred</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">u1</span> <span class="main">∧</span> <span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v1</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">adjmap</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">ps'</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct8 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> 
              Graph.E <span class="skolem">c'</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c'</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">adjmap</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">adjmap</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">u1</span> <span class="main">∧</span> <span class="skolem">a</span> <span class="main">≠</span> <span class="skolem">v1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span> <span class="main">∨</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">adjmap</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="skolem">a</span><span class="main">}</span> 
              <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">adjmap</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>"</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword1"><span class="command">have</span></span> fct<span class="main">:</span> 
                      <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c'</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> 
                      <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                    
                    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">adjmap</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span> <span class="main">#</span> <span class="skolem">ps'</span> <span class="skolem">a</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> fct8 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
                      <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
                          <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                      <span class="keyword1"><span class="command">qed</span></span>
                    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span>›</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
                <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>"</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword1"><span class="command">have</span></span> fct<span class="main">:</span> 
                      <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c'</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> 
                      <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                    
                    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">adjmap</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">u1</span> <span class="main">#</span> <span class="skolem">ps'</span> <span class="skolem">a</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> fct8 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">=</span> Graph.E <span class="skolem">c'</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
                      <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">using</span></span> fct4 fct0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u1</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">ps'</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
                      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
                        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
                          <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                      <span class="keyword1"><span class="command">qed</span></span>
                    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">v1</span>›</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct0 obt3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">adjmap</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="skolem">c</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
          <span class="main">∧</span> distinct <span class="main">(</span><span class="skolem">adjmap</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  
    <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> read_correct2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="main">¬</span>ln_invar <span class="free">el</span> 
    <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> 
    <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c1</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">el</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">el</span><span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"read <span class="skolem">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> None"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
              <span class="keyword1"><span class="command">note</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
                <span class="keyword1"><span class="command">proof</span></span>
                  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="skolem">el</span>"</span></span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> 
                    <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span><span class="main">&gt;</span><span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                    <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
                  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"
                    <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> 
                  <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> 
                  <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> 
                  <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> 
                  <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> 
                      <span class="main">∧</span> <span class="bound">c1</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                  
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">}</span></span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">}</span></span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">}</span></span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">}</span></span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> 
                      <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> 
                        <span class="main">∧</span> <span class="bound">c1</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span>
                      <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c1</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">}</span></span>
                  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt1<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="skolem">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u1</span></span> <span class="skolem"><span class="skolem">v1</span></span> <span class="skolem"><span class="skolem">c1</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">c1</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c'</span></span> <span class="skolem"><span class="skolem">V'</span></span> <span class="skolem"><span class="skolem">sc'</span></span> <span class="skolem"><span class="skolem">pd'</span></span> <span class="skolem"><span class="skolem">ps'</span></span> <span class="skolem"><span class="skolem">s_n'</span></span> <span class="skolem"><span class="skolem">t_n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> obt3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> 
              <span class="main">⦇</span>
                pn_c <span class="main">=</span> <span class="skolem">c'</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V'</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="skolem">sc'</span><span class="main">,</span>
                pn_pred <span class="main">=</span> <span class="skolem">pd'</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">ps'</span><span class="main">,</span>
                pn_s_node <span class="main">=</span> <span class="skolem">s_n'</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="skolem">t_n'</span>
              <span class="main">⦈</span>"</span></span> 
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">el</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> obt1 read_correct1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">el</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">c1</span> <span class="main">≤</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> 
              <span class="main">(</span><span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">u1</span> <span class="main">=</span> <span class="skolem">v1</span> <span class="main">∨</span> <span class="skolem">v1</span> <span class="main">=</span> <span class="free">s</span> <span class="main">∨</span> <span class="skolem">u1</span> <span class="main">=</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> obt1 obt2 obt3 False Cons.prems 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>option.splits if_splits<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">u1</span> <span class="main">=</span> <span class="skolem">v1</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">v1</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">u1</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">u1</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">el</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span> <span class="main">∧</span> <span class="bound">c1'</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c'</span> <span class="main">=</span> ln_α <span class="skolem">el</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>
                <span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span>
                  <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span> 
                  <span class="main">∧</span> <span class="bound">c1</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c1</span> <span class="main">≠</span> <span class="main">0</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∃</span><span class="bound">c1'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">u1</span><span class="main">,</span> <span class="bound">c1'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">el</span>  <span class="main">∧</span> <span class="bound">c1'</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> obt2 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="main">(</span><span class="skolem">e</span> <span class="main">#</span> <span class="skolem">el</span><span class="main">)</span>"</span></span> 
                      <span class="keyword1"><span class="command">unfolding</span></span> ln_invar_def <span class="keyword1"><span class="command">using</span></span> obt2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Pre-Networks›</span></span>  

  <span class="keyword1"><span class="command">record</span></span> <span class="tfree">'capacity</span><span class="main">::</span><span class="quoted">linordered_idom</span> pre_network' <span class="main">=</span>
    pn_c' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">*</span>nat<span class="main">,</span><span class="tfree">'capacity</span><span class="main">)</span> ArrayHashMap.ahm"</span></span>
    pn_V' <span class="main">::</span> <span class="quoted"><span class="quoted">"nat ahs"</span></span>
    pn_succ' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat list<span class="main">)</span> ArrayHashMap.ahm"</span></span>
    pn_pred' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat list<span class="main">)</span> ArrayHashMap.ahm"</span></span>
    pn_adjmap' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat list<span class="main">)</span> ArrayHashMap.ahm"</span></span>
    pn_s_node' <span class="main">::</span> <span class="quoted">bool</span>
    pn_t_node' <span class="main">::</span> <span class="quoted">bool</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pnet_α</span> <span class="free"><span class="bound"><span class="entity">pn'</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
      pn_c <span class="main">=</span> the_default <span class="main">0</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="main">(</span>pn_c' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
      pn_V <span class="main">=</span> ahs_α <span class="main">(</span>pn_V' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">,</span> 
      pn_succ <span class="main">=</span> the_default <span class="main">[]</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="main">(</span>pn_succ' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      pn_pred <span class="main">=</span> the_default <span class="main">[]</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="main">(</span>pn_pred' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      pn_adjmap <span class="main">=</span> the_default <span class="main">[]</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="main">(</span>pn_adjmap' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
      pn_s_node <span class="main">=</span> pn_s_node' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">,</span> 
      pn_t_node <span class="main">=</span> pn_t_node' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span>
  <span class="main">⦈</span>"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pnet_rel</span> <span class="main">≡</span> br pnet_α <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ahm_ld</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">ahm</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> the_default <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>ahm.lookup <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">ahm</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">cap_lookup</span> <span class="main">≡</span> ahm_ld <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ_lookup</span> <span class="main">≡</span> ahm_ld <span class="main">[]</span>"</span></span>


  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">read'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> nat <span class="main">×</span> <span class="tfree">'capacity</span><span class="main">::</span>linordered_idom<span class="main">)</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span>
    <span class="tfree">'capacity</span> pre_network' option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">read'</span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> Some <span class="main">⦇</span>
      pn_c' <span class="main">=</span> ahm.empty <span class="main">()</span><span class="main">,</span> 
      pn_V' <span class="main">=</span> ahs.empty <span class="main">()</span><span class="main">,</span> 
      pn_succ' <span class="main">=</span> ahm.empty <span class="main">()</span><span class="main">,</span>
      pn_pred' <span class="main">=</span> ahm.empty <span class="main">()</span><span class="main">,</span>
      pn_adjmap' <span class="main">=</span> ahm.empty <span class="main">()</span><span class="main">,</span> 
      pn_s_node' <span class="main">=</span> False<span class="main">,</span> 
      pn_t_node' <span class="main">=</span> False
    <span class="main">⦈</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">read'</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">read'</span> <span class="free"><span class="bound"><span class="entity">es</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
      Some <span class="bound">x</span> <span class="main">⇒</span>
        <span class="main">(</span><span class="keyword1">if</span> 
          cap_lookup <span class="main">(</span>pn_c' <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> 
          <span class="main">∧</span> cap_lookup <span class="main">(</span>pn_c' <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> 
         <span class="keyword1">then</span>
          <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">then</span>
            None
          <span class="keyword1">else</span>
            Some <span class="main">(</span><span class="bound">x</span><span class="main">⦇</span> 
              pn_c' <span class="main">:=</span> ahm.update <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>pn_c' <span class="bound">x</span><span class="main">)</span><span class="main">,</span>
              pn_V' <span class="main">:=</span> ahs.ins <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span>ahs.ins <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>pn_V' <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              pn_succ' <span class="main">:=</span> 
                ahm.update <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="main">(</span>succ_lookup <span class="main">(</span>pn_succ' <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pn_succ' <span class="bound">x</span><span class="main">)</span><span class="main">,</span>
              pn_pred' <span class="main">:=</span> 
                ahm.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">#</span> <span class="main">(</span>succ_lookup <span class="main">(</span>pn_pred' <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pn_pred' <span class="bound">x</span><span class="main">)</span><span class="main">,</span>
              pn_adjmap' <span class="main">:=</span> ahm.update 
                <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">#</span> <span class="main">(</span>succ_lookup <span class="main">(</span>pn_adjmap' <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ahm.update 
                <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">#</span> <span class="main">(</span>succ_lookup <span class="main">(</span>pn_adjmap' <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span> 
                <span class="main">(</span>pn_adjmap' <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              pn_s_node' <span class="main">:=</span> pn_s_node' <span class="bound">x</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">,</span>
              pn_t_node' <span class="main">:=</span> pn_t_node' <span class="bound">x</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>
            <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1">else</span>
          None<span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> None<span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> read'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> map_option pnet_α <span class="main">(</span>read' <span class="free">el</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> read.induct<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pnet_α_def o_def ahm.correct ahs.correct ahm_ld_def 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> <span class="comment1">(* Takes long *)</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> read'_correct_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>read' <span class="free">el</span> <span class="free">s</span> <span class="free">t</span><span class="main">,</span> read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>pnet_rel<span class="main">⟩</span>option_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def br_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option_rel_def read'_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> domIff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">read</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML     
  
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Usefulness Check›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    We have to check that every node in the network is useful,
    i.e., lays on a path from source to sink.
    ›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reachable_spec</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reaching_spec</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">checkNet</span> <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">then</span>
      RETURN None
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> read <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">rd</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> RETURN None
      <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>                
          <span class="keyword1">if</span> pn_s_node <span class="bound">x</span> <span class="main">∧</span> pn_t_node <span class="bound">x</span> <span class="keyword1">then</span>
            <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>   
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              
              <span class="bound">succ_s</span> <span class="main">←</span> reachable_spec <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
              <span class="bound">pred_t</span> <span class="main">←</span> reaching_spec <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="main">(</span>pn_V <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">succ_s</span> <span class="main">∧</span> <span class="main">(</span>pn_V <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">pred_t</span> <span class="keyword1">then</span>
                RETURN <span class="main">(</span>Some <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">,</span> pn_adjmap <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1">else</span>
                RETURN None
            <span class="main">}</span>
          <span class="keyword1">else</span>
            RETURN None
        <span class="main">}</span>
      <span class="main">}</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> checkNet_pre_correct1 <span class="main">:</span> <span class="quoted"><span class="quoted">"checkNet <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> 
    SPEC <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">c</span><span class="main">,</span> <span class="free">adjmap</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">∧</span> Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="free">adjmap</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="free">c</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="free">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
      <span class="main">∧</span> distinct <span class="main">(</span><span class="free">adjmap</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> checkNet_def reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">adjmap</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> 
            <span class="main">⦇</span>
              pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span>
              pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span>  pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
              pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True
            <span class="main">⦈</span>"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm3 asm4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>
            pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> 
            pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
          
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obt<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>  
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_rtrancl_Image<span class="main">)</span>
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm5<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm6<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="skolem">x</span>"</span></span> 
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">adjmap</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span>
            pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span>  pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
            pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm5 asm6 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> 
            pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
            pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
          
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> 
            <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> 
            distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span>  distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
        <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm5<span class="main">:</span> 
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm6<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_V <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span> 
          <span class="keyword3"><span class="command">assume</span></span> asm7<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> pn_c <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> asm8<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">adjmap</span> <span class="main">=</span> pn_adjmap <span class="skolem">x</span>"</span></span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="free">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span>
            pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span>  pn_adjmap <span class="main">=</span> <span class="free">adjmap</span><span class="main">,</span> 
            pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm3 asm4 asm7 asm8 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="free">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> 
            pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="free">adjmap</span><span class="main">,</span> 
            pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
          
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
            <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> 
            distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> fct asm7 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword1"><span class="command">{</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> asm6 obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span><span class="main">.</span> Graph.isReachable <span class="free">c</span> <span class="free">s</span> <span class="bound">v</span>"</span></span> 
                  <span class="keyword1"><span class="command">unfolding</span></span> Graph.connected_def <span class="keyword1"><span class="command">using</span></span> Graph.rtc_isPath<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="main">_</span> <span class="quoted"><span class="free">c</span></span><span class="main">]</span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">}</span></span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="free">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> asm5 asm6 obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span><span class="main">.</span> Graph.isReachable <span class="free">c</span> <span class="bound">v</span> <span class="free">t</span>"</span></span>
                  <span class="keyword1"><span class="command">unfolding</span></span> Graph.connected_def <span class="keyword1"><span class="command">using</span></span> Graph.rtci_isPath 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
              <span class="keyword1"><span class="command">}</span></span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
                <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span><span class="main">.</span> Graph.isReachable <span class="free">c</span> <span class="free">s</span> <span class="bound">v</span> 
                <span class="main">∧</span> Graph.isReachable <span class="free">c</span> <span class="bound">v</span> <span class="free">t</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> <span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">note</span></span> Graph.reachable_ss_V<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">s</span> <span class="main">∈</span> <span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span>›</span></span><span class="main">]</span>
              <span class="keyword1"><span class="command">note</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this <span class="quoted"><span class="quoted">‹finite <span class="main">(</span>Graph.V <span class="free">c</span><span class="main">)</span>›</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span> 
              <span class="keyword1"><span class="command">unfolding</span></span> Network_def <span class="keyword1"><span class="command">using</span></span> asm1 fct asm7 
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span><span class="main">(</span>set <span class="main">(</span>pn_adjmap <span class="skolem">x</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span>
            Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span>pn_adjmap <span class="skolem">x</span> <span class="bound">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span>pn_adjmap <span class="skolem">x</span> <span class="bound">u</span><span class="main">)</span> 
              <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span>pn_adjmap <span class="skolem">x</span> <span class="bound">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> checkNet_pre_correct2_aux<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> asm3<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span>pn_succ <span class="free">x</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="main">(</span>pn_succ <span class="free">x</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span>pn_pred <span class="free">x</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
      <span class="main">∧</span> distinct <span class="main">(</span>pn_pred <span class="free">x</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm5<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_V <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> 
      <span class="main">⟶</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">≠</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm6<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="free">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm7<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="free">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm8<span class="main">:</span> <span class="quoted"><span class="quoted">"ln_invar <span class="free">el</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> asm9<span class="main">:</span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>          
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">ps</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> 
        pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">ps</span><span class="main">,</span> 
        pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm3 asm4 asm6 asm7 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> 
        pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">ps</span><span class="main">,</span> 
        pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pn_V <span class="free">x</span> <span class="main">≠</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> 
        <span class="main">∨</span> <span class="main">(</span>pn_V <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> 
            <span class="main">∧</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">≠</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> asm5 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"pn_V <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">∧</span> 
            <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">≠</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>Graph.V <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">¬</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">⊆</span> Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> asm5  obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">∈</span><span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span>Graph.isReachable <span class="skolem">c</span> <span class="bound">v</span> <span class="free">t</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">⊆</span> Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
                o1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∉</span> Graph.V <span class="skolem">c</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="bound">p</span> <span class="free">t</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> Graph.rtci_isPath <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="skolem">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="free">t</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="skolem">p</span> <span class="free">t</span>›</span></span> Graph.isPath.simps<span class="main">(</span>1<span class="main">)</span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p1</span> <span class="main">#</span> <span class="skolem">ps</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> neq_Nil_conv<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="main">(</span><span class="skolem">p1</span> <span class="main">#</span> <span class="skolem">ps</span><span class="main">)</span> <span class="free">t</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="skolem">p</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="skolem">p1</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">c</span> <span class="skolem">p1</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> Graph.isPath_head<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">c</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">p1</span></span> <span class="quoted"><span class="skolem">ps</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.collapse<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span> 
                      <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> o1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>Graph.V <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
                o1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Image_singleton_iff rtrancl_converseI<span class="main">)</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="main">¬</span>Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="bound">p</span> <span class="free">t</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="skolem">x</span> <span class="skolem">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> Graph.isPath_rtc <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span> <span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> 
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Graph.isReachable <span class="skolem">c</span> <span class="skolem">x</span> <span class="free">t</span>"</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> Graph.connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> o1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="free">el</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Network_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> asm9 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"pn_V <span class="free">x</span> <span class="main">≠</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span>"</span></span>
          
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>Graph.V <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">¬</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">⊆</span> Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> asm5  obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">∈</span><span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span>Graph.isReachable <span class="skolem">c</span> <span class="free">s</span> <span class="bound">v</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">⊆</span> Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> o1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∉</span> Graph.V <span class="skolem">c</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="bound">p</span> <span class="skolem">x</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> Graph.rtc_isPath <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="skolem">p</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
                  <span class="keyword3"><span class="command">case</span></span> True
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="free">s</span>"</span></span> 
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="skolem">p</span> <span class="skolem">x</span>›</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.isPath.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">next</span></span>
                  <span class="keyword3"><span class="command">case</span></span> False
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">p1</span><span class="main">]</span>"</span></span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_butlast_last_id<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="main">(</span><span class="skolem">ps</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">p1</span><span class="main">]</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
                      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="skolem">p</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"snd <span class="skolem">p1</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">c</span> <span class="skolem">p1</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
                      <span class="keyword1"><span class="command">using</span></span> Graph.isPath_tail<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="skolem">ps</span></span> <span class="quoted"><span class="skolem">p1</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> 
                      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prod.collapse<span class="main">)</span>
                    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span> 
                      <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def Graph.E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> o1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>Graph.V <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> o1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">∈</span> Graph.V <span class="skolem">c</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span> <span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Image_singleton_iff rtrancl_converseI<span class="main">)</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="main">¬</span>Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="bound">p</span> <span class="skolem">x</span>"</span></span>
                <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="var">?thesis</span>"</span></span>
                  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="skolem">c</span> <span class="free">s</span> <span class="skolem">p</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> Graph.isPath_rtc <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>Graph.E <span class="skolem">c</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> 
                    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Graph.isReachable <span class="skolem">c</span> <span class="free">s</span> <span class="skolem">x</span>"</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> Graph.connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> o1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="free">el</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Network_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> asm9 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> checkNet_pre_correct2<span class="main">:</span>
    <span class="quoted"><span class="quoted">"checkNet <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> 
    <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> checkNet_def reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">=</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ln_invar <span class="free">el</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">t</span> <span class="free">t</span>"</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> Network_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> None"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ln_invar <span class="free">el</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">note</span></span> read_correct2<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> None›</span></span><span class="main">]</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="free">el</span>"</span></span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹ln_invar <span class="free">el</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"
              <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span> 
            <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> 
                <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c1</span><span class="main">≠</span><span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span>"</span></span>
            
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">c</span><span class="main">&gt;</span><span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>ln_invar <span class="free">el</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> not_less <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_invar_def<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹ln_invar <span class="free">el</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">u</span><span class="main">.</span> ln_α <span class="free">el</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>›</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> Network_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">u</span><span class="main">.</span> ln_α <span class="free">el</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Network_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">u</span><span class="main">.</span> ln_α <span class="free">el</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
              <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Network_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> 
                <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">,</span> <span class="bound">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="bound">c1</span><span class="main">≠</span><span class="main">0</span> <span class="main">∧</span> <span class="bound">c2</span><span class="main">≠</span><span class="main">0</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">c1</span></span> <span class="skolem"><span class="skolem">c2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
                o1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">,</span> <span class="skolem">c1</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">,</span> <span class="skolem">c2</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">el</span> 
                    <span class="main">∧</span> <span class="skolem">c1</span><span class="main">≠</span><span class="main">0</span> <span class="main">∧</span> <span class="skolem">c2</span><span class="main">≠</span><span class="main">0</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ln_α <span class="free">el</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ln_α <span class="free">el</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_α_def <span class="keyword1"><span class="command">using</span></span> o1 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> tfl_some<span class="main">)</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
                <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟶</span> <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
                <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Network_def 
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
            <span class="keyword1"><span class="command">}</span></span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
          <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
        <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">adjmap</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span>
          pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span>  pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
          pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm3 asm4 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> 
          pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
          pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
        
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="skolem">c</span> <span class="main">⊆</span> <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span>Graph.V <span class="skolem">c</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> Graph.V_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obt<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>  
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_rtrancl_Image<span class="main">)</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
        <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">t</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm5<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm6<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_t_node <span class="skolem">x</span>"</span></span> 
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">adjmap</span></span>  <span class="keyword2"><span class="keyword">where</span></span> obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span>
          pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> 
          pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> asm5 asm6 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> 
          pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">adjmap</span><span class="main">,</span> pn_s_node <span class="main">=</span> True<span class="main">,</span> pn_t_node <span class="main">=</span> True<span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
        
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
          <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∧</span> 
          distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span>  distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="skolem">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
        <span class="keyword3"><span class="command">assume</span></span> asm1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">t</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm2<span class="main">:</span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm3<span class="main">:</span> <span class="quoted"><span class="quoted">"pn_s_node <span class="skolem">x</span> <span class="main">⟶</span> <span class="main">¬</span>pn_t_node <span class="skolem">x</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm4<span class="main">:</span> <span class="quoted"><span class="quoted">"ln_invar <span class="free">el</span>"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> asm5<span class="main">:</span> <span class="quoted"><span class="quoted">"Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="skolem"><span class="skolem">sc</span></span> <span class="skolem"><span class="skolem">pd</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="skolem"><span class="skolem">s_node</span></span> <span class="skolem"><span class="skolem">t_node</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
          obt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> 
          pn_adjmap <span class="main">=</span> <span class="skolem">ps</span><span class="main">,</span> pn_s_node <span class="main">=</span> <span class="skolem">s_node</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="skolem">t_node</span><span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> 
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"read <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> Some <span class="main">⦇</span>pn_c <span class="main">=</span> <span class="skolem">c</span><span class="main">,</span> pn_V <span class="main">=</span> <span class="skolem">V</span><span class="main">,</span> pn_succ <span class="main">=</span> <span class="skolem">sc</span><span class="main">,</span> 
          pn_pred <span class="main">=</span> <span class="skolem">pd</span><span class="main">,</span> pn_adjmap <span class="main">=</span> <span class="skolem">ps</span><span class="main">,</span> pn_s_node <span class="main">=</span> <span class="skolem">s_node</span><span class="main">,</span> pn_t_node <span class="main">=</span> <span class="skolem">t_node</span><span class="main">⦈</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> asm2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">note</span></span> fct <span class="main">=</span> read_correct1<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
        
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel"</span></span> <span class="keyword1"><span class="command">using</span></span> fct obt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="free">el</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ln_rel_def br_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>pn_s_node <span class="skolem">x</span> <span class="main">∨</span> <span class="main">¬</span>pn_t_node <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> asm3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>pn_s_node <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">s_node</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∉</span> Graph.V <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="free">el</span>›</span></span> asm5 Network_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>pn_t_node <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="skolem">t_node</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> obt fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∉</span> Graph.V <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">=</span> ln_α <span class="free">el</span>›</span></span> asm5 Network_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> checkNet_pre_correct2_aux<span class="main">)</span>  

  <span class="keyword1"><span class="command">lemma</span></span> checkNet_correct' <span class="main">:</span> <span class="quoted"><span class="quoted">"checkNet <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">adjmap</span><span class="main">)</span> <span class="main">⇒</span>
        <span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="bound">adjmap</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="bound">c</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>Graph.E <span class="bound">c</span><span class="main">)</span><span class="main">¯</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
           <span class="main">∧</span> distinct <span class="main">(</span><span class="bound">adjmap</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> checkNet_pre_correct1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> checkNet_pre_correct2<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> checkNet_correct <span class="main">:</span> <span class="quoted"><span class="quoted">"checkNet <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">adjmap</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> 
        <span class="main">∧</span> Graph.is_adj_map <span class="bound">c</span> <span class="bound">adjmap</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> checkNet_pre_correct1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> checkNet_pre_correct2<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.is_adj_map_def pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Usefulness Check›</span></span>  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We use the DFS framework to implement the usefulness check.
    We have to convert between our graph representation and the CAVA automata 
    library's graph representation used by the DFS framework.
    ›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_of</span> <span class="free"><span class="bound"><span class="entity">pn</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    g_V <span class="main">=</span> UNIV<span class="main">,</span>
    g_E <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="free"><span class="bound"><span class="entity">pn</span></span></span><span class="main">)</span><span class="main">,</span>
    g_V0 <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span>
  <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rev_graph_of</span> <span class="free"><span class="bound"><span class="entity">pn</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    g_V <span class="main">=</span> UNIV<span class="main">,</span>
    g_E <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free"><span class="bound"><span class="entity">pn</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">,</span>
    g_V0 <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span>
  <span class="main">⦈</span>"</span></span>

  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">checkNet2</span> <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">then</span>
      RETURN None
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> read <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">rd</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> RETURN None
      <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>                
          <span class="keyword1">if</span> pn_s_node <span class="bound">x</span> <span class="main">∧</span> pn_t_node <span class="bound">x</span> <span class="keyword1">then</span>
            <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="bound">x</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              
              <span class="keyword1">let</span> <span class="bound">succ_s</span> <span class="main">=</span> <span class="main">(</span>op_reachable <span class="main">(</span>graph_of <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">let</span> <span class="bound">pred_t</span> <span class="main">=</span> <span class="main">(</span>op_reachable <span class="main">(</span>rev_graph_of <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="main">(</span>pn_V <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">succ_s</span> <span class="main">∧</span> <span class="main">(</span>pn_V <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">pred_t</span> <span class="keyword1">then</span>
                RETURN <span class="main">(</span>Some <span class="main">(</span>pn_c <span class="bound">x</span><span class="main">,</span> pn_adjmap <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1">else</span>
                RETURN None
            <span class="main">}</span>
          <span class="keyword1">else</span>
            RETURN None
        <span class="main">}</span>
      <span class="main">}</span>
    <span class="main">}</span>"</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> checkNet2_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"checkNet2 <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> checkNet <span class="free">c</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> checkNet_def checkNet2_def graph_of_def rev_graph_of_def 
      reachable_spec_def reaching_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_of_impl</span> <span class="free"><span class="bound"><span class="entity">pn'</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    gi_V <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span>
    gi_E <span class="main">=</span> succ_lookup <span class="main">(</span>pn_succ' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">,</span>
    gi_V0 <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">]</span>
  <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rev_graph_of_impl</span> <span class="free"><span class="bound"><span class="entity">pn'</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    gi_V <span class="main">=</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span>
    gi_E <span class="main">=</span> succ_lookup <span class="main">(</span>pn_pred' <span class="free"><span class="bound"><span class="entity">pn'</span></span></span><span class="main">)</span><span class="main">,</span>
    gi_V0 <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">]</span>
  <span class="main">⦈</span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">well_formed_pn</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> Graph.E <span class="main">(</span>pn_c <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
      <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rev_well_formed_pn</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
      <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> id_slg_rel_alt_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">⟩</span>slg_rel 
    <span class="main">=</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">E</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">u</span><span class="main">.</span> distinct <span class="main">(</span><span class="bound">s</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span><span class="bound">s</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> <span class="bound">E</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> slg_rel_def br_def list_set_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>  
    
  <span class="keyword1"><span class="command">lemma</span></span> graph_of_impl_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"well_formed_pn <span class="free">pn</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">pn'</span><span class="main">,</span> <span class="free">pn</span><span class="main">)</span> <span class="main">∈</span> pnet_rel <span class="main">⟹</span>
    <span class="main">(</span>graph_of_impl <span class="free">pn'</span> <span class="free">s</span><span class="main">,</span> graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>unit_rel<span class="main">,</span>Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def graph_of_impl_def graph_of_def
      g_impl_rel_ext_def gen_g_impl_rel_ext_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_set_rel_def br_def list_set_rel_def 
        id_slg_rel_alt_a ahm_ld_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> well_formed_pn_def Graph.E_def 
        pnet_α_def o_def ahm_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> rev_graph_of_impl_correct<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⟦</span>rev_well_formed_pn <span class="free">pn</span><span class="main">;</span> <span class="main">(</span><span class="free">pn'</span><span class="main">,</span><span class="free">pn</span><span class="main">)</span><span class="main">∈</span>pnet_rel<span class="main">⟧</span> 
    <span class="main">⟹</span> 
    <span class="main">(</span>rev_graph_of_impl <span class="free">pn'</span> <span class="free">s</span><span class="main">,</span> rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>unit_rel<span class="main">,</span>Id<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def rev_graph_of_impl_def rev_graph_of_def
      g_impl_rel_ext_def gen_g_impl_rel_ext_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_set_rel_def br_def list_set_rel_def 
        id_slg_rel_alt_a ahm_ld_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rev_well_formed_pn_def Graph.E_def pnet_α_def 
        o_def ahm_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>   
  
  <span class="keyword1"><span class="command">schematic_goal</span></span> reachable_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Gi</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>unit_rel<span class="main">,</span>nat_rel<span class="main">⟩</span>g_impl_rel_ext"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">)</span> <span class="main">≤</span> <span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>RETURN <span class="main">(</span>op_reachable <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">autoref_monadic</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">reachable_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> reachable_impl
  <span class="keyword1"><span class="command">thm</span></span> reachable_impl.refine

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">schematic_goal</span></span> sets_eq_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ai</span><span class="main">,</span><span class="free">a</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>ahs.rel"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">bi</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>dflt_ahs_rel"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">(</span><span class="free">a</span> <span class="main">:::</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>ahs.rel<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="main">:::</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>dflt_ahs_rel <span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> bool_rel"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">sets_eq_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> sets_eq_impl  

  <span class="keyword2"><span class="keyword">end</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">net_α</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">ci</span><span class="main">,</span> <span class="bound">adjmapi</span><span class="main">)</span> <span class="main">.</span> 
    <span class="main">(</span><span class="main">(</span>the_default <span class="main">0</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="bound">ci</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>the_default <span class="main">[]</span> <span class="keyword1">o</span> <span class="main">(</span>ahm.α <span class="bound">adjmapi</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"net_α <span class="main">(</span><span class="free">ci</span><span class="main">,</span> <span class="free">adjmapi</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    cap_lookup <span class="free">ci</span><span class="main">,</span> succ_lookup <span class="free">adjmapi</span>
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> net_α_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ahm.correct ahm_ld_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">checkNet3</span> <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">then</span>
      RETURN None
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">rd</span> <span class="main">=</span> read' <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">rd</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> RETURN None
      <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>                
          <span class="keyword1">if</span> pn_s_node' <span class="bound">x</span> <span class="main">∧</span> pn_t_node' <span class="bound">x</span> <span class="keyword1">then</span>
            <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span>finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_succ <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span>
                Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_succ <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              ASSERT<span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> set <span class="main">(</span><span class="main">(</span>pn_pred <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span> <span class="main">=</span> 
                <span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span> 
                <span class="main">∧</span> distinct <span class="main">(</span><span class="main">(</span>pn_pred <span class="main">(</span>pnet_α <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            
              <span class="keyword1">let</span> <span class="bound">succ_s</span> <span class="main">=</span> <span class="main">(</span>reachable_impl <span class="main">(</span>graph_of_impl <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">let</span> <span class="bound">pred_t</span> <span class="main">=</span> <span class="main">(</span>reachable_impl <span class="main">(</span>rev_graph_of_impl <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="main">(</span>sets_eq_impl <span class="main">(</span>pn_V' <span class="bound">x</span><span class="main">)</span> <span class="bound">succ_s</span><span class="main">)</span> 
                <span class="main">∧</span> <span class="main">(</span>sets_eq_impl <span class="main">(</span>pn_V' <span class="bound">x</span><span class="main">)</span> <span class="bound">pred_t</span><span class="main">)</span> 
              <span class="keyword1">then</span>
                RETURN <span class="main">(</span>Some <span class="main">(</span>net_α <span class="main">(</span>pn_c' <span class="bound">x</span><span class="main">,</span> pn_adjmap' <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1">else</span>
                RETURN None
            <span class="main">}</span>
          <span class="keyword1">else</span>
            RETURN None
        <span class="main">}</span>
      <span class="main">}</span>
    <span class="main">}</span>"</span></span>     
  
  <span class="keyword1"><span class="command">lemma</span></span> aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x'</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> pnet_rel <span class="main">⟹</span> <span class="main">(</span>pn_V' <span class="free">x'</span><span class="main">,</span> pn_V <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> br ahs.α ahs.invar"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def br_def pnet_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_of_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">unfolding</span></span> rev_graph_of_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> sets_eq_impl_correct_aux1<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">pn'</span><span class="main">,</span> <span class="free">pn</span><span class="main">)</span> <span class="main">∈</span> pnet_rel"</span></span>  
    <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"well_formed_pn <span class="free">pn</span>"</span></span> 

    <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="free">pn'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sets_eq_impl <span class="main">(</span>pn_V' <span class="free">pn'</span><span class="main">)</span> <span class="main">(</span>reachable_impl <span class="main">(</span>graph_of_impl <span class="free">pn'</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> pn_V <span class="free">pn</span> <span class="main">=</span> <span class="main">(</span>g_E <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> S1i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pn_V' <span class="free">pn'</span><span class="main">,</span> pn_V <span class="free">pn</span><span class="main">)</span> <span class="main">∈</span> br ahs.α ahs.invar"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def br_def pnet_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">note</span></span> GI <span class="main">=</span> graph_of_impl_correct<span class="main">[</span><span class="operator">OF</span> WF A<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> F'<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="main">(</span>graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> F A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> graph_of_def pnet_α_def pnet_rel_def br_def<span class="main">)</span>

    <span class="keyword1"><span class="command">note</span></span> S2i <span class="main">=</span> reachable_impl.refine<span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> F' G GI<span class="main">]</span>  

    <span class="keyword1"><span class="command">from</span></span> sets_eq_impl.refine<span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> S1i S2i<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> 

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> sets_eq_impl_correct_aux2<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">pn'</span><span class="main">,</span> <span class="free">pn</span><span class="main">)</span> <span class="main">∈</span> pnet_rel"</span></span>  
    <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"rev_well_formed_pn <span class="free">pn</span>"</span></span> 

    <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="main">(</span>Graph.E <span class="main">(</span>pn_c <span class="main">(</span>pnet_α <span class="free">pn'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sets_eq_impl <span class="main">(</span>pn_V' <span class="free">pn'</span><span class="main">)</span> <span class="main">(</span>reachable_impl <span class="main">(</span>rev_graph_of_impl <span class="free">pn'</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> pn_V <span class="free">pn</span> <span class="main">=</span> <span class="main">(</span>g_E <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> S1i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pn_V' <span class="free">pn'</span><span class="main">,</span> pn_V <span class="free">pn</span><span class="main">)</span> <span class="main">∈</span> br ahs.α ahs.invar"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pnet_rel_def br_def pnet_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">note</span></span> GI <span class="main">=</span> rev_graph_of_impl_correct<span class="main">[</span><span class="operator">OF</span> WF A<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> F'<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="main">(</span>rev_graph_of <span class="free">pn</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> F A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rev_graph_of_def pnet_α_def pnet_rel_def br_def<span class="main">)</span>

    <span class="keyword1"><span class="command">note</span></span> S2i <span class="main">=</span> reachable_impl.refine<span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> F' G GI<span class="main">]</span>  

    <span class="keyword1"><span class="command">from</span></span> sets_eq_impl.refine<span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> S1i S2i<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> 



  <span class="keyword1"><span class="command">lemma</span></span> checkNet3_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"checkNet3 <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> checkNet2 <span class="free">el</span> <span class="free">s</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> checkNet3_def checkNet2_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> introR<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>pnet_rel<span class="main">⟩</span>option_rel"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> read'_correct_alt<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pnet_rel_def br_def pnet_α_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>7<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sets_eq_impl_correct_aux1<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> well_formed_pn_def<span class="main">)</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sets_eq_impl_correct_aux2<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rev_well_formed_pn_def<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> net_α_def o_def pnet_α_def pnet_rel_def br_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword2"><span class="keyword">end</span></span>  


  <span class="keyword1"><span class="command">schematic_goal</span></span> checkNet4<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> checkNet3 <span class="free">el</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> checkNet3_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">checkNet4</span> <span class="keyword2"><span class="keyword">for</span></span> el s t <span class="keyword2"><span class="keyword">uses</span></span> checkNet4
    

  <span class="keyword1"><span class="command">lemma</span></span> checkNet4_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> checkNet4 <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">adjmap</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel 
        <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">∧</span> Graph.is_adj_map <span class="bound">c</span> <span class="bound">adjmap</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
    <span class="keyword1"><span class="command">note</span></span> checkNet4.refine 
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> checkNet3_correct 
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> checkNet2_correct
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> checkNet_correct
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Executable Network Checker›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">prepareNet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge_list <span class="main">⇒</span> node <span class="main">⇒</span> node 
    <span class="main">⇒</span> <span class="main">(</span>capacity_impl graph <span class="main">×</span> <span class="main">(</span>node<span class="main">⇒</span>node list<span class="main">)</span> <span class="main">×</span> nat<span class="main">)</span> option"</span></span>
    <span class="comment1">― ‹Read an edge list and a source/sink node, and return a network graph,
      an adjacency map, and the maximum node number plus one. 
      If the edge list or network is invalid, return <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>NONE›</span></span>.›</span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">prepareNet</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">adjmap</span><span class="main">)</span> <span class="main">←</span> checkNet4 <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">N</span> <span class="main">=</span> ln_N <span class="free"><span class="bound"><span class="entity">el</span></span></span><span class="main">;</span>
      Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">adjmap</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">prepareNet</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML  

  <span class="keyword1"><span class="command">theorem</span></span> prepareNet_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="main">(</span>prepareNet <span class="free">el</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">adjmap</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="free">el</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> ln_rel <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> 
        <span class="main">∧</span> Graph.is_adj_map <span class="bound">c</span> <span class="bound">adjmap</span> <span class="main">∧</span> Graph.V <span class="bound">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="bound">N</span><span class="main">}</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> checkNet4_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> ln_N_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> prepareNet_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_rel_def br_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>