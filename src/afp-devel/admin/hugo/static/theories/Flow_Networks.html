<div id="Fofu_Abs_Base">
<div class="head"><h1>Theory Fofu_Abs_Base</h1>
<span class="command">theory</span> <span class="name">Fofu_Abs_Base</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a> <a href="../Sepref_Basic/Rewrite.html"><span class="name">Rewrite</span></a> <a href="../Sepref_Basic/Sepref_Misc.html"><span class="name">Sepref_Misc</span></a> <a href="LTS.html"><span class="name">LTS</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Fofu_Abs_Base</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Complex_Main</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Rewrite"</span></span></span><span>
</span><span>  </span><span>Automatic_Refinement.Misc</span><span>
</span><span>  </span><span>Refine_Imperative_HOL.Sepref_Misc</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Program-Conflict-Analysis.LTS"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_in_iff_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap p ∈ S ⟷ p ∈ S¯"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>      
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_filter_disj_or_conv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x∈set xs ⟶ ¬(P x ∧ Q x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length [x ← xs. P x ∨ Q x] = length (filter P xs) + length (filter Q xs)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move. Extract an element from a summation, combined with congruence. *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_arb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A_fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_dif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈A. y ≠ x ⟶ g y = h y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑a∈A. g a) = (∑a∈A - {x}. h a) + g x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = (A - {x}) ∪ {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"A - {x}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x}"</span></span></span><span> </span><span>g</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"A - {x}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A - {x}"</span></span></span><span> </span><span>g</span><span> </span><span>h</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A_fin</span><span> </span><span>x_dif</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>    
</span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trcl_cons_conv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(u,a#xs,v)∈trcl R ⟷ (∃uh. (u,a,uh)∈R ∧ (uh,xs,v)∈trcl R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trcl_uncons</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trcl_conc_conv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(u,xs@ys,v)∈trcl R ⟷ (∃uh. (u,xs,uh)∈trcl R ∧ (uh,ys,v)∈trcl R)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trcl_unconcat</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>trcl_concat</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>trcl_conv</span><span> </span><span class="delimiter">=</span><span> </span><span>trcl_cons_conv</span><span> </span><span>trcl_conc_conv</span><span>
</span><span>  </span><span class="comment">― ‹Adding these to simpset will split all cons and append operations in paths›</span><span>
</span><span>
</span><span>      
</span><span>      
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Fofu_Impl_Base">
<div class="head"><h1>Theory Fofu_Impl_Base</h1>
<span class="command">theory</span> <span class="name">Fofu_Impl_Base</span><br/>
<span class="keyword">imports</span> <a href="Fofu_Abs_Base.html"><span class="name">Fofu_Abs_Base</span></a> <a href="Sepref_ICF_Bindings.html"><span class="name">Sepref_ICF_Bindings</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Fofu_Impl_Base</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Fofu_Abs_Base</span><span>
</span><span>  </span><span>Refine_Imperative_HOL.IICF</span><span>
</span><span>  </span><span>Refine_Imperative_HOL.Sepref_ICF_Bindings</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Rewrite"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hide_type</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>List_Seg.node</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>Refine_Monadic_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Refine_Add_Fofu">
<div class="head"><h1>Theory Refine_Add_Fofu</h1>
<span class="command">theory</span> <span class="name">Refine_Add_Fofu</span><br/>
<span class="keyword">imports</span> <a href="Fofu_Impl_Base.html"><span class="name">Fofu_Impl_Base</span></a> <a href="DFS_Framework_Refine_Aux.html"><span class="name">DFS_Framework_Refine_Aux</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Refine_Add_Fofu</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Fofu_Impl_Base</span><span> 
</span><span>  </span><span>DFS_Framework.DFS_Framework_Refine_Aux</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hide_type</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>List_Seg.node</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Heap_Monad.return</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"return"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Refinement Framework VCG control:
  Idea: Put a frame around stuff in the program where the VCG shall not look into
    on outermost pass, and discharge the frame's content with nested vcg call.
    Very useful with subgoal command, to set up some auxiliary context before
    discharging, e.g., interpret locales, etc.
 
*)</span></span></span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Make this a generic technique:
  Problems: 
    * Splitter will split inside VCG_FRAME (e.g., ifs)

*)</span></span></span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VCG_FRAME</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ nres ⇒ _ nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"VCG_FRAME m ≡ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VCG_FRAME_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"VCG_FRAME x ≡ VCG_FRAME x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_intro_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≡ VCG_FRAME m"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VCG_FRAME_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_rem_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m≤m' ⟹ VCG_FRAME m ≤ m'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VCG_FRAME_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Graph">
<div class="head"><h1>Theory Graph</h1>
<span class="command">theory</span> <span class="name">Graph</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Directed Graphs›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We define a specialized graph library for graphs that are induced by 
  capacity matrices.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_Image</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite R ⟧ ⟹ finite (R `` A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Image_iff</span><span> </span><span>finite_Range</span><span> </span><span>Range.intros</span><span> </span><span>finite_subset</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_eq_appendE</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map f ls = fl@fl'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>l</span><span> </span><span>l'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ls=l@l'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map f l=fl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"map f l' = fl'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length fl) ls"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop (length fl) ls"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>take_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>drop_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Definitions›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We fix the nodes to be natural numbers.
›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>node</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>edge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"node × node"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The capacities are left polymorphic, however, they
  are restricted to linearly ordered domains.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'capacity</span><span> </span><span>graph</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge ⇒ 'capacity"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Graph</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge set"</span></span></span><span> </span><span class="comment">― ‹Edges of the graph›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ≡ {(u, v). c (u, v) ≠ 0}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set"</span></span></span><span> </span><span class="comment">― ‹Nodes of the graph. Exactly the nodes 
  that have adjacent edges.›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ≡ {u. ∃v. (u, v) ∈ E ∨ (v, u) ∈ E}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>incoming</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Incoming edges into a node›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming v ≡ {(u, v) | u. (u, v) ∈ E}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>outgoing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Outgoing edges from a node›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing v ≡ {(v, u) | u. (v, u) ∈ E}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjacent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Adjacent edges of a node›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent v ≡ incoming v ∪ outgoing v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>incoming'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Incoming edges into 
  a set of nodes›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming' k ≡ {(u, v) | u v. u ∉ k ∧ v ∈ k ∧ (u, v) ∈ E}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>outgoing'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Outgoing edges from 
  a set of nodes›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing' k ≡ {(v, u) | u v. u ∉ k ∧ v ∈ k ∧ (v, u) ∈ E}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjacent'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set ⇒ edge set"</span></span></span><span> </span><span class="comment">― ‹Edges adjacent to a 
  set of nodes›</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent' k ≡ incoming' k ∪ outgoing' k"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_adj_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_adj_map ps ≡ (∀u. distinct (ps u) ∧ set (ps u) = E``{u} ∪ E¯``{u})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent_nodes u ≡ E``{u} ∪ E¯``{u}"</span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Graph›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite Graphs›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Finite_Graph</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_V</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paths›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>path</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>isPath</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ path ⇒ node ⇒ bool"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isPath u [] v ⟷ u = v"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u ((x,y)#p) v ⟷ u = x ∧ (x, y) ∈ E ∧ isPath y p v"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>pathVertices</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ path ⇒ node list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pathVertices u [] = [u]"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices u (e # es) = fst e # (pathVertices (snd e) es)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This characterization is probably nicer to work with! Exchange! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>pathVertices_fwd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ edge list ⇒ node list"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd u p = u#map snd p"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>pathVertices_fwd</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices u p = pathVertices_fwd u p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pathVertices_fwd_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>connected</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node ⇒ bool"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v ≡ ∃p. isPath u p v"</span></span></span><span> 
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReachable ≡ connected"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Deprecated *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reachableNodes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node set"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachableNodes u ≡ {v. connected u v}"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isShortestPath</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ path ⇒ node ⇒ bool"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u p v 
    ≡ isPath u p v ∧ (∀p'. isPath u p' v ⟶ length p ≤ length p')"</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isSimplePath</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ path ⇒ node ⇒ bool"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u p v ≡ isPath u p v ∧ distinct (pathVertices u p)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ nat ⇒ node ⇒ bool"</span></span></span><span> 
</span><span>    </span><span class="comment">― ‹There is a path of given length between the nodes›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v d v' ≡ ∃p. isPath v p v' ∧ length p = d"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>min_dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Minimum distance between two connected nodes›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist v v' = (LEAST d. dist v d v')"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Properties›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V = fst`E ∪ snd`E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_ss_VxV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ⊆ V×V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjacent_nodes_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent_nodes u ⊆ V"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjacent_nodes_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss_VxV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vfin_imp_Efin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss_VxV</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Efin_imp_Vfin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E ⟹ finite V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_cap_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉E ⟹ c (u,v) = 0"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>E_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``{u} ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E¯``{u} ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span>incoming_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming u ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>outgoing_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing u ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>incoming'_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming' U ⊆ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>outgoing'_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing' U ⊆ E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>outgoing_def</span><span> </span><span>incoming'_def</span><span> </span><span>outgoing'_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span>incoming_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming u = (λv. (v,u))`(E¯``{u})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>outgoing_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing u = Pair u`(E``{u})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>outgoing_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span>finite_incoming</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V ⟹ finite (incoming u)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>finite_outgoing</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V ⟹ finite (outgoing u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_alt</span><span> </span><span>outgoing_alt</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span>finite_incoming'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V ⟹ finite (incoming' U)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>finite_outgoing'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V ⟹ finite (outgoing' U)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>incoming'_edges</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outgoing'_edges</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Summations over Edges and Nodes›</span></span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We provide useful alternative characterizations for summation over 
    all incoming or outgoing edges.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_outgoing_pointwise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈outgoing u. g e) = (∑v∈E``{u}. g (u,v))"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈outgoing u. g e) = (∑e∈(λv. (u,v))`(E``{u}). g e)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑v∈E``{u}. g (u,v))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.reindex</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_incoming_pointwise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈incoming u. g e) = (∑v∈E¯``{u}. g (v,u))"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈incoming u. g e) = (∑e∈(λv. (v,u))`(E¯``{u}). g e)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑v∈E¯``{u}. g (v,u))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.reindex</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extend summations over incoming/outgoing edges to summations over
  all nodes, provided the summed-up function is zero for non-edges.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>sum_incoming_extend</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⟦ v∈V; (v,u)∉E ⟧ ⟹ g (v,u) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈incoming u. g e) = (∑v∈V. g (v,u))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_incoming_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>pred_ss_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>sum_outgoing_extend</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⟦ v∈V; (u,v)∉E ⟧ ⟹ g (u,v) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈outgoing u. g e) = (∑v∈V. g (u,v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_outgoing_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>succ_ss_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹When summation is done over something that satisfies the capacity 
  constraint, e.g., a flow, the summation can be extended to all 
  outgoing/incoming edges, as the additional edges must have zero capacity.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Historical lemmas. Get rid of ∀ quantifier. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>sum_outgoing_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦∀e. 0 ≤ g e ∧ g e ≤ c e⟧ ⟹
  ∀v ∈ V. (∑e ∈ outgoing v. g e) = (∑u ∈ V. g (v, u))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_outgoing_extend</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>zero_cap_simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>sum_incoming_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦∀e. 0 ≤ g e ∧ g e ≤ c e⟧ ⟹
  ∀v ∈ V. (∑e ∈ incoming v. g e) = (∑u ∈ V. g (u, v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_incoming_extend</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>zero_cap_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite Graphs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>finite_E</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>Finite_Graph_EI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E ⟹ Finite_Graph c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Efin_imp_Vfin</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>adjacent_nodes_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (adjacent_nodes u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjacent_nodes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>split_path_simps</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simplification lemmas to split paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transfer_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="comment">― ‹Transfer path to another graph›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set p∩E ⊆ Graph.E c'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c' u p v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>u</span><span> </span><span>p</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>isPath.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.isPath.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_append</span><span class="delimiter">[</span><span>split_path_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath u (p1 @ p2) v ⟷ (∃w. isPath u p1 w ∧ isPath w p2 v)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span>auto</span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_head</span><span class="delimiter">[</span><span>split_path_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath u (e#p) v ⟷ fst e = u ∧ e ∈ E ∧ isPath (snd e) p v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_head2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath u (e#p) v ⟹ (p = [] ∨ (p ≠ [] ∧ fst (hd p) = snd e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.isPath_head</span><span> </span><span>list.collapse</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_tail</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath u (p@[e]) v ⟷ isPath u p (fst e) ∧ e ∈ E ∧ snd e = v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>isPath_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_tail2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath u (p@[e]) v ⟹ (p = [] ∨ (p ≠ [] ∧ snd (last p) = fst e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.isPath_tail</span><span> </span><span>append_butlast_last_id</span><span class="delimiter">)</span><span>
</span><span>      
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Really needed? *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_append_edge</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isPath v p v' ⟹ (v',v'')∈E ⟹ isPath v (p@[(v',v'')]) v''"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_edgeset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦isPath u p v; e ∈ set p⟧ ⟹ e ∈ E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isPath_head</span><span> </span><span>isPath_append</span><span> </span><span>in_set_conv_decomp_first</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_rtc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v ⟹ (u, v) ∈ E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1</span><span> </span><span>u2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e = (u1, u2)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = u1 ∧ isPath u2 es v ∧ (u1, u2) ∈ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isPath.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, u2) ∈ E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u2, v) ∈ E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtc_isPath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ E<span class="hidden">⇧</span><sup>*</sup> ⟹ (∃p. isPath u p v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rtrancl_refl</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath a [] a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rtrancl_into_rtrancl</span><span> </span><span>u</span><span> </span><span>u'</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p1 u'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u', v) ∈ E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtrancl_into_rtrancl.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u (p1 @ [(u', v)]) v"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isPath_tail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtci_isPath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∈ (E¯)<span class="hidden">⇧</span><sup>*</sup> ⟹ (∃p. isPath u p v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∈(E¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_converseD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtc_isPath</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_ex_edge1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u1, v1) ∈ set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u1 ≠ u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u2. (u2, u1) ∈ set p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w1</span><span> </span><span>w2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = w1 @ [(u1, v1)] @ w2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>in_set_conv_decomp_first</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u w1 u1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>isPath_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w1 ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ w1 ≠ []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = u1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath u w1 u1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isPath.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>w1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"w1 = w1' @ [e]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_butlast_last_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e = (u2, u1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath u w1 u1›</span></span></span><span> </span><span>isPath_tail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = w1' @ (u2, u1) # (u1, v1) # w2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_ex_edge2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u1, v1) ∈ set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ≠ v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v2. (v1, v2) ∈ set p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w1</span><span> </span><span>w2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = w1 @ [(u1, v1)] @ w2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>in_set_conv_decomp_first</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath v1 w2 v"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>isPath_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w2 ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ w2 ≠ []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = v1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath v1 w2 v›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isPath.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>w2'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"w2 =  e # w2'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e = (v1, v2)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath v1 w2 v›</span></span></span><span> </span><span>isPath_head</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = w1 @ (u1, v1) # (v1, v2) # w2'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Vertices of Paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>pathVertices_fwd_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s ([]) = [s]"</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s (e#p) = s#pathVertices_fwd (snd e) p"</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s (p@[e]) = pathVertices_fwd s p@[snd e]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s (p1@e#p2) 
    = pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s∈set (pathVertices_fwd s p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_fwd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ [] 
    ⟹ pathVertices u p = map fst p @ [snd (last p)]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_singleton_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices s p = [u] ⟷ (p=[] ∧ s=u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_pathVertices_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (pathVertices u p) = length p + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=[]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_edgeset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦u∈V; isPath u p v⟧ ⟹ set (pathVertices u p) ⊆ V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isPath_edgeset</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices u (p1 @ p2) = 
butlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices u ((e # es) @ p2) =  fst e # pathVertices (snd e) (es @ p2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.pathVertices.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices (snd e) (es @ p2) 
    = butlast (pathVertices (snd e) es) 
      @ pathVertices (last (pathVertices (snd e) es)) p2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst e # butlast (pathVertices (snd e) es) = 
    butlast (fst e # pathVertices (snd e) es)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.pathVertices.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span>Graph.pathVertices_alt</span><span> </span><span>Nil_is_append_conv</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst e # pathVertices (snd e) es = pathVertices u (e # es)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.pathVertices.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (pathVertices (snd e) es) = last (pathVertices u (e # es))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.pathVertices.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Graph.pathVertices_alt</span><span> 
</span><span>    </span><span>last.simps</span><span> </span><span>last_snoc</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_path_at_vertex</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈set (pathVertices_fwd s p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p2 t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding pathVertices_fwd*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pathVertices_fwd_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.isPath_append_edge</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>append_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_path_at_vertex_complete</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s p = pv1@u#pv2"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s p1 = pv1@[u]"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isPath u p2 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd u p2 = u#pv2"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices s p = pv1@u#pv2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pathVertices_fwd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices s p1 = pv1@[u]"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"isPath u p2 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices u p2 = u#pv2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>PV</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pv2</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> 
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>pathVertices_alt</span><span>
</span><span>      </span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>append_eq_append_conv2</span><span class="delimiter">;</span><span>
</span><span>        </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_eq_appendE</span><span> </span><span>append_eq_Cons_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>elim_format</span><span class="delimiter">]</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>…</span><span> </span><span>l</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>that</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> 
</span><span>          </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>…</span><span> </span><span>l</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>that</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> 
</span><span>          </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>…</span><span> </span><span>l</span><span> </span><span>u1</span><span> </span><span>u2</span><span> </span><span>u3</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>that</span><span class="delimiter">)</span><span>  
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> 
</span><span>          </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>that</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>…</span><span> </span><span>l</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> 
</span><span>            </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pathVertices_fwd</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_fwd_cases</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t=s"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>p'</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=(s,u)#p'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,u)∈E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p' t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_bwd_cases</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t=s"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>p'</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p'@[(u,t)]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p' u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,t)∈E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_edge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t ⟹ e ∈ set p ⟹ 
  ∃vs1 vs2. pathVertices_fwd s p = vs1 @ fst e # snd e # vs2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>isPath_bwd_cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>isPath_fwd_cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">=</span><span>t</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>isPath_fwd_cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">=</span><span>t</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Really needed? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pathVertices_edge_old</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v ⟹ e ∈ set p ⟹ 
  ∃vs1 vs2. pathVertices u p = vs1 @ fst e # snd e # vs2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pathVertices_fwd</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pathVertices_edge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reachability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v v"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_append_edge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v ⟹ (v,w)∈E ⟹ connected u w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isPath_append_edge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_inV_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦connected u v⟧ ⟹ v∈V ⟷ u∈V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>connected_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>V_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_edgeRtc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v ⟷ (u, v) ∈ E<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isPath_rtc</span><span> </span><span>rtc_isPath</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ V ⟹ reachableNodes s ⊆ V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ reachableNodes s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {v. isPath s p v}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachableNodes_def</span><span> </span><span>connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_head</span><span> </span><span>V_alt</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachableNodes_E_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``reachableNodes s ⊆ reachableNodes s"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachableNodes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>connected_append_edge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>reachableNodes_append_edge</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"u∈reachableNodes s ⟹ (u,v)∈E ⟹ v∈reachableNodes s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachableNodes_E_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simple Paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSimplePath_fwd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p t 
  ⟷ isPath s p t ∧ distinct (pathVertices_fwd s p)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span> </span><span>pathVertices_fwd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSimplePath_singelton</span><span class="delimiter">[</span><span>split_path_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u [e] v ⟷ (e=(u,v) ∧ u≠v ∧ (u,v)∈E)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span> </span><span>isPath_head</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>isSimplePath_append</span><span class="delimiter">[</span><span>split_path_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s (p1@p2) t 
    ⟷ (∃u. 
      isSimplePath s p1 u 
    ∧ isSimplePath u p2 t 
    ∧ set (pathVertices_fwd s p1) ∩ set (pathVertices_fwd u p2) = {u})"</span></span></span><span>  
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⟷ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isSimplePath_fwd</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p2</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>isSimplePath_cons</span><span class="delimiter">[</span><span>split_path_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s (e#p) t 
  ⟷ (∃u. e=(s,u) ∧ s≠u ∧ (s,u)∈E 
        ∧ isSimplePath u p t ∧ s∉set (pathVertices_fwd u p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isSimplePath_append</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">"[e]"</span></span></span><span> </span><span>p</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Graph</span><span class="delimiter">)</span><span> </span><span>simplePath_length_less_V</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>UIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u p v"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p &lt; card V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices u p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pathVertices_edgeset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>UIV</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (pathVertices u p) ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span>finite_V</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (pathVertices u p) ≤ card V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span> </span><span>card_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + 1 ≤ card V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_simple_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u (p1@p2) v 
  ⟹ (∃w. isSimplePath u p1 w ∧ isSimplePath w p2 v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p2</span><span>  </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simplePath_empty_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s [] t ⟷ s=t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simplePath_same_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p s ⟷ p=[]"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>e</span><span> </span><span>pp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>pp</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span> </span><span>pathVertices_alt</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_pathLE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t ⟹ ∃p'. isSimplePath s p' t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p'. ⟦length p' &lt; length p; isPath s p' t⟧ 
    ⟹ ∃p'. isSimplePath s p' t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. isSimplePath s p t"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices_fwd s p)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PATH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_fwd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(distinct (pathVertices_fwd s p))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pv1</span><span> </span><span>pv2</span><span> </span><span>pv3</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s p = pv1@u#pv2@u#pv3"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_distinct_decomp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"p = p1@p2@p3"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p2≠[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p3 t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PATH</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split_path_at_vertex_complete</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>split_path_at_vertex_complete</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"u#pv2"</span></span></span><span> </span><span>u</span><span> </span><span>pv3</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (p1@p3) &lt; length p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s (p1@p3) t"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_no_selfloop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u p v ⟹ (u1, u1) ∉ set p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_sg_outgoing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦isSimplePath u p v; (u1, v1) ∈ set p; v1 ≠ v2⟧ 
  ⟹ (u1, v2) ∉ set p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>isSimplePath_def</span><span> </span><span>pathVertices_alt</span><span> 
</span><span>      </span><span>append_eq_append_conv2</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>append_eq_Cons_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_sg_incoming</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦isSimplePath u p v; (u1, v1) ∈ set p; u1 ≠ u2⟧ ⟹ (u2, v1) ∉ set p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>isSimplePath_fwd</span><span> </span><span>pathVertices_fwd_def</span><span>
</span><span>      </span><span>append_eq_append_conv2</span><span> </span><span>append_eq_Cons_conv</span><span> </span><span>Cons_eq_append_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_nt_parallel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap e ∉ set p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SP</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices_fwd s p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_fwd</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap e ∉ set p"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>EIP</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pathVertices_edge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>append_eq_append_conv2</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>append_eq_Cons_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_nt_parallel_old</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u p v ⟹ (∀(u, v) ∈ set p. (v, u) ∉ set p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isSPath_nt_parallel</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>isSPath_nt_parallel_pf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p t ⟹ set p ∩ (set p)¯ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>isSPath_nt_parallel</span><span class="delimiter">)</span><span>
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isSPath_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath u p v ⟹ distinct p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>not_distinct_decomp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Edges adjacent to a node that does not lie on a path 
  are not contained in that path:›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjacent_edges_not_on_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VNV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∉set (pathVertices_fwd s p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent v ∩ set p = {}"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>VNV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. (u,v)∉set p ∧ (v,u)∉set p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>pathVertices_edge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjacent v ∩ set p = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>outgoing_def</span><span> </span><span>adjacent_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∉set (pathVertices_fwd s p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>incoming_edges_not_on_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming v ∩ set p = {}"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>outgoing_edges_not_on_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing v ∩ set p = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adjacent_edges_not_on_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjacent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A simple path over a vertex can be split at this vertex, 
  and there are exactly two edges on the path touching this vertex.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjacent_edges_on_simple_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SPATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VNV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈set (pathVertices_fwd s p)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>u</span><span> </span><span>w</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p = p1@(u,v)#(v,w)#p2"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"incoming v ∩ set p = {(u,v)}"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"outgoing v ∩ set p = {(v,w)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SPATH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>DIST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices_fwd s p)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span> </span><span>pathVertices_fwd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_path_at_vertex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>VNV</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath v p2 t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v≠s›</span></span></span><span> </span><span>P1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1'</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p1=p1'@[(u,v)]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1' u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>UV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v≠t›</span></span></span><span> </span><span>P2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span>p2'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2=(v,w)#p2'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w)∈E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath w p2' t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span>p1'</span><span> </span><span>u</span><span> </span><span>w</span><span> </span><span>p2'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>      </span><span>isSPath_sg_outgoing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SPATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v</span><span> </span><span>w</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>isSPath_sg_incoming</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SPATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span>
</span><span>      </span><span>isPath_edgeset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>outgoing_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distance›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>connected_by_dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v v' = (∃d. dist v d v')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span> </span><span>connected_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isPath_distD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p v ⟹ dist u (length p) v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>connected_distI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v d v' ⟹ connected v v'"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*and connectedI_succ: "connected v v' ⟹ (v',v'') ∈ E ⟹ connected v v''"*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span> </span><span>connected_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isPath_append_edge</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_distI2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦connected v v'; ⋀d. ⟦dist v d v'; ⋀d'. dist v d' v' ⟹ d ≤ d'⟧ ⟹ Q d⟧ 
    ⟹ Q (min_dist v v')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_dist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LeastI2_wellorder</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"SOME d. dist v d v'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>connected_by_dist</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_distI_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ dist v d v'; ⋀d'. dist v d' v' ⟹ d ≤ d' ⟧ ⟹ min_dist v v' = d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>min_distI2</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>connected_by_dist</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two nodes are connected by a path of length ‹0›, 
  iff they are equal.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_z_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v 0 v' ⟷ v'=v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_z</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v 0 v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦dist v d v'; (v',v'')∈E⟧ ⟹ dist v (Suc d) v''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isPath_append_edge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>dist_z</span><span> </span><span>dist_suc</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>pred</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v d v'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v=v'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span>
</span><span>   </span><span class="delimiter">|</span><span> </span><span>vh</span><span> </span><span>dd</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d=Suc dd"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v dd vh"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(vh,v')∈E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>…</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The same holds for ‹min_dist›, i.e., 
  the shortest path between two nodes has length ‹0›, 
  iff these nodes are equal.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_z</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist v v = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_distI2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_z_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v v' ⟹ min_dist v v' = 0 ⟷ v'=v"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_distI2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_is_dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v v' ⟹ dist v (min_dist v v') v'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>min_distI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_minD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v d v' ⟹ min_dist v v' ≤ d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>min_distI2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also provide introduction and destruction rules for the
  pattern ‹min_dist v v' = Suc d›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_succ</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ connected v v'; (v',v'') ∈ E ⟧ ⟹ min_dist v v'' ≤ Suc (min_dist v v') "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_distI2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v'</span><span class="delimiter">=</span><span>v'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>min_dist_minD</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dist_suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_suc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v v'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist v v' = Suc d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v''. connected v v'' ∧ (v'',v') ∈ E ∧ min_dist v v'' = d"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_is_dist</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist v v' = Suc d ⟶ ?thesis"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>dist_suc</span><span> </span><span>v''</span><span> </span><span>d'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_succ</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span>v''</span><span> </span><span>v'</span><span class="delimiter">]</span><span> </span><span>min_dist_minD</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span> </span><span>d</span><span> </span><span>v''</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>connected_distI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  If there is a node with a shortest path of length ‹d›, 
  then, for any ‹d'&lt;d›, there is also a node with a shortest path
  of length ‹d'›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected src v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist src v = d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d' &lt; d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v'. connected src v' ∧ min_dist src v' = d'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>d</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>d</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>min_dist_suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>src</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"d' = d"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Lemma ‹min_dist_less› can be weakened to ‹d'≤d›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>min_dist_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected src v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d' ≤ min_dist src v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v'. connected src v' ∧ min_dist src v' = d'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist src v"</span></span></span><span> </span><span>d'</span><span class="delimiter">]</span><span> </span><span>d'</span><span> </span><span>c</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u d1 w ⟹ dist w d2 v ⟹ dist u (d1+d2) v"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p1</span><span> </span><span>p2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"p1@p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_dist_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>D1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u d1 w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist w d2 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u v = d1+d2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u w = d1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist w v = d2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>ab_semigroup_add_class.add.commute</span><span> </span><span>add_le_cancel_left</span><span> 
</span><span>    </span><span>dist_trans</span><span> </span><span>min_distI_eq</span><span> </span><span>min_dist_minD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>add_le_cancel_left</span><span> </span><span>dist_trans</span><span> </span><span>min_distI_eq</span><span> </span><span>min_dist_minD</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="comment">― ‹Manual proof›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>D1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u d1 w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist w d2 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u v = d1+d2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u w = d1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist w v = d2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_minD</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dist u d1 w›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u w ≤ d1"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u (min_dist u w) w"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_dist_is_dist</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>D2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u (min_dist u w + d2) v"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u w &lt; d1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>MIN</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>min_dist_minD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u w = d1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>not_less</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_neq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_minD</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dist w d2 v›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist w v ≤ d2"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>D1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist w (min_dist w v) v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>min_dist_is_dist</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u (d1 + min_dist w v) v"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist w v &lt; d2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>MIN</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>min_dist_minD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist w v = d2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>not_less</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_neq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Shortest Paths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Characterization of shortest path in terms of minimum distance›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_min_dist_def</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u p v ⟷ isPath u p v ∧ length p = min_dist u v"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isShortestPath_def</span><span> </span><span>min_dist_def</span><span> </span><span>dist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Least_equality</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Least_le</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>      
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obtain_shortest_path</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>CONN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u p v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_is_dist</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CONN</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dist_def</span><span> </span><span>isShortestPath_min_dist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shortestPath_is_simple</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s p t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SHORTEST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p'. isPath s p' t ⟶ length p ≤ length p'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬isSimplePath s p t"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PATH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬distinct (pathVertices_fwd s p)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_fwd</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pv1</span><span> </span><span>u</span><span> </span><span>pv2</span><span> </span><span>pv3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>PV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s p = pv1@u#pv2@u#pv3"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_distinct_decomp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_path_at_vertex_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span> </span><span>PV</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p23</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@p23"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>P1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd s p1 = pv1@[u]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>P23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p23 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd u p23 = (u#pv2)@u#pv3"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>split_path_at_vertex_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P23</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p23 = p2@p3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>P2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p2 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd u p2 = u#pv2@[u]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>P3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p3 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pathVertices_fwd u p3 = u#pv3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>P3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SHORTER_PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s (p1@p3) t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p2≠[]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>LESS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (p1@p3) &lt; length p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SHORTER_PATH</span><span> </span><span>SHORTEST</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We provide yet another characterization of shortest paths:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_alt</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u p v ⟷ isSimplePath u p v ∧ length p = min_dist u v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>shortestPath_is_simple</span><span> </span><span>isShortestPath_min_dist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isSimplePath_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shortestPath_is_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u p v ⟹ isPath u p v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_shortest_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath u (p1@p2) v 
  ⟹ (∃w. isShortestPath u p1 w ∧ isShortestPath w p2 v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_min_dist_def</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>isPath_distD</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_split</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>isPath_distD</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_split</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Edges in a shortest path connect nodes with increasing 
  minimum distance from the source›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_level_edge</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"connected s u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"min_dist s v = min_dist s u + 1"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"min_dist u t = 1 + min_dist v t"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = min_dist s u + 1 + min_dist v t"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G3</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="comment">― ‹Split the original path at the edge›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EIP</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@(u,v)#p2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isShortestPath s p t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = length p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>     </span><span>DV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices s p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_alt</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISTS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist s (length p1) u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u 1 v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v (length p2) t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>dist_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[(u,v)]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DISTS</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected s u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected u v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected v t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Express the minimum distances in terms of the split original path›</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MIN'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = length p1 + 1 + length p2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>MIN'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>MDSV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s v = length p1 + 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p2 = min_dist v t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dist_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>MIN'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>MDUT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u t = 1 + length p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p1 = min_dist s u"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MDSV</span><span> </span><span>MDUT</span><span> </span><span>MIN'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span> </span><span class="var">?G2</span><span> </span><span class="var">?G3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Graph›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Finite_Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In a finite graph, the length of a shortest path is less 
  than the number of nodes›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_length_less_V</span><span class="delimiter">:</span><span>   
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p &lt; card V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplePath_length_less_V</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SV</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>shortestPath_is_simple</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>min_dist_less_V</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>CONN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected s t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t &lt; card V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_shortest_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CONN</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>isShortestPath_length_less_V</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SV</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isShortestPath_min_dist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Finite_Graph›</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Network">
<div class="head"><h1>Theory Network</h1>
<span class="command">theory</span> <span class="name">Network</span><br/>
<span class="keyword">imports</span> <a href="Graph.html"><span class="name">Graph</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Flows, Cuts, and Networks›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Network</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we define the basic concepts of flows, cuts, 
  and (flow) networks.
  ›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Flows›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An ‹s›-‹t› preflow on a graph is a labeling of the edges with 
  values from a linearly ordered integral domain, such that: 
  \begin{description}
    \item[capacity constraint] the flow on each edge is non-negative and 
      does not exceed the edge's capacity;
    \item[non-deficiency constraint] for all nodes except ‹s› and ‹t›, 
      the incoming flow greater or equal to the outgoing flow.
  \end{description}    
›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'capacity</span><span> </span><span>flow</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge ⇒ 'capacity"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Preflow</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity flow"</span></span></span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move ∀-quantifiers to meta-level!? *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>capacity_const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e. 0 ≤ f e ∧ f e ≤ c e"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_deficient_nodes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V-{s,t}.
    (∑e∈outgoing v. f e) ≤ (∑e∈incoming v. f e)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An ‹s›-‹t› ∗‹flow› on a graph is a preflow that has no active nodes except 
  source and sink, where a node is ∗‹active› iff it has more incoming flow 
  than outgoing flow.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Flow</span><span> </span><span class="delimiter">=</span><span> </span><span>Preflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_active_nodes</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V - {s,t}. (∑e∈outgoing v. f e) ≥ (∑e∈incoming v. f e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For a flow, inflow equals outflow for all nodes except sink and source.
    This is called ∗‹conservation›. ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conservation_const</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V - {s, t}. (∑e ∈ incoming v. f e) = (∑e ∈ outgoing v. f e)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_deficient_nodes</span><span> </span><span>no_active_nodes</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The value of a flow is the flow that leaves $s$ and does not return.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>val</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val ≡ (∑e ∈ outgoing s. f e) - (∑e ∈ incoming s. f e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Finite_Preflow</span><span> </span><span class="delimiter">=</span><span> </span><span>Preflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span> </span><span>Finite_Graph</span><span> </span><span>c</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Finite_Flow</span><span> </span><span class="delimiter">=</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span> </span><span>Finite_Preflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cuts›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ∗‹cut› is a partitioning of the nodes into two sets. 
  We define it by just specifying one of the partitions. 
  The other partition is implicitly given by the remaining nodes.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>cut</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Cut</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span class="delimiter">+</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: We probably do not need the cut-locale, 
  only NCut.*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>cut</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cut_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ⊆ V"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Networks›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ∗‹network› is a finite graph with two distinct nodes, source and sink, 
  such that all edges are labeled with positive capacities. 
  Moreover, we assume that 
  ▪ The source has no incoming edges, and the sink has no outgoing edges.
  ▪ There are no parallel edges, i.e., for any edge, the reverse edge must not be in the network.
  ▪ Every node must lay on a path from the source to the sink.

  Notes on the formalization
  ▪ We encode the graph by a mapping ‹c›, such that ‹c (u,v)› is 
    the capacity of edge ‹(u,v)›, or ‹0›, if there is no edge from ‹u› to ‹v›.
    Thus, in the formalization below, we only demand 
    that ‹c (u,v) ≥ 0› for all ‹u› and ‹v›.
  ▪ We only demand the set of nodes reachable from the source to be finite.
    Together with the constraint that all nodes lay on a path from the source,
    this implies that the graph is finite.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Network</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s_node</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t_node</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s_not_t</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cap_non_negative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u v. c (u, v) ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_incoming_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. (u, s) ∉ E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_outgoing_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. (t, u) ∉ E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>no_parallel_edge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u v. (u, v) ∈ E ⟶ (v, u) ∉ E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nodes_on_st_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V. connected s v ∧ connected v t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (reachableNodes s)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Edges have positive capacity›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edge_cap_positive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E ⟹ c (u,v) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cap_non_negative</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>spec2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The network constraints implies that all nodes are 
    reachable from the source node›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_is_V</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachableNodes s = V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ reachableNodes s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachableNodes_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_node</span><span> </span><span>nodes_on_st_path</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_ss_V</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Thus, the network is actually a finite graph.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Finite_Graph</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_is_V</span><span> </span><span>finite_reachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Our assumptions imply that there are no self loops›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_self_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. (u, u) ∉ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjacent_not_self</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∉ adjacent_nodes v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjacent_nodes_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_self_loop</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A flow is maximal, if it has a maximal value›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isMaxFlow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ flow ⇒ bool"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f ≡ Flow c s t f ∧ 
    (∀f'. Flow c s t f' ⟶ Flow.val c s f' ≤ Flow.val c s f)"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_max_flow_val fv ≡ ∃f. isMaxFlow f ∧ fv=Flow.val c s f"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Can we prove existence of a maximum flow *easily*, i.e.,
  without going over the min-cut-max-flow theorem or the Ford-Fulkerson method?
  definition "max_flow_val ≡ THE fv. is_max_flow_val fv"
*)</span></span></span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_not_s</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_not_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The excess of a node is the difference between incoming and 
    outgoing flow.›</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Define in context of preflow!? *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>excess</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity flow ⇒ node ⇒ 'capacity"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"excess f v ≡ (∑e∈incoming v. f e) - (∑e∈outgoing v. f e)"</span></span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Networks with Flows and Cuts›</span></span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For convenience, we define locales for a network with a fixed flow,
  and a network with a fixed cut›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NPreflow</span><span> </span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">+</span><span> </span><span>Preflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NFlow</span><span> </span><span class="delimiter">=</span><span> </span><span>NPreflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network</span><span class="delimiter">)</span><span> </span><span>isMaxFlow_alt</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f ⟷ NFlow c s t f ∧ 
    (∀f'. NFlow c s t f' ⟶ Flow.val c s f' ≤ Flow.val c s f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMaxFlow_def</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NFlow_def</span><span> </span><span>Flow_def</span><span> </span><span>NPreflow_def</span><span class="delimiter">)</span><span> </span><span>intro_locales</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A cut in a network separates the source from the sink›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NCut</span><span> </span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">+</span><span> </span><span>Cut</span><span> </span><span>c</span><span> </span><span>k</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>k</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s_in_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t_ni_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∉ k"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The capacity of the cut is the capacity of all edges going from the 
    source's side to the sink's side.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cap ≡ (∑e ∈ outgoing' k. c e)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A minimum cut is a cut with minimum capacity.›</span></span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: The definitions of min-cut and max-flow are done in different contexts. 
  Align, probably both in network context! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isMinCut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ graph ⇒ nat ⇒ nat ⇒ cut ⇒ bool"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMinCut c s t k ≡ NCut c s t k ∧
  (∀k'. NCut c s t k' ⟶ NCut.cap c k ≤ NCut.cap c k')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Flows›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Preflow</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Only edges are labeled with non-zero flows›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_flow_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉E ⟹ f(u,v) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>capacity_const</span><span> </span><span>eq_iff</span><span> </span><span>zero_cap_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_non_negative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ f e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_f_non_negative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum f X ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_nonneg</span><span> </span><span>f_non_negative</span><span class="delimiter">)</span><span> 
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Preflow›</span><span>   
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Flow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We provide a useful equivalent formulation of the 
  conservation constraint.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conservation_const_pointwise</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V - {s,t}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑v∈E``{u}. f (u,v)) = (∑v∈E¯``{u}. f (v,u))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conservation_const</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_incoming_pointwise</span><span> </span><span>sum_outgoing_pointwise</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The value of the flow is bounded by the capacity of the 
  outgoing edges of the source node›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_bounded</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"-(∑e∈incoming s. c e) ≤ val"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val ≤ (∑e∈outgoing s. c e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sum f (outgoing s) ≤ sum c (outgoing s)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"sum f (incoming s) ≤ sum c (incoming s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-(∑e∈incoming s. c e) ≤ val"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val ≤ (∑e∈outgoing s. c e)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_f_non_negative</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming s"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_f_non_negative</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing s"</span></span></span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Flow›</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introduce a flow via the conservation constraint›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>intro_Flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e. 0 ≤ f e ∧ f e ≤ c e"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V - {s, t}. 
    (∑e ∈ incoming v. f e) = (∑e ∈ outgoing v. f e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow c s t f"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Finite_Preflow</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The summation of flows over incoming/outgoing edges can be 
  extended to a summation over all possible predecessor/successor nodes,
  as the additional flows are all zero.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_outgoing_alt_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge ⇒ 'capacity"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈outgoing u. f e) = (∑v∈V. f (u,v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_outgoing_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>capacity_const</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_incoming_alt_flow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge ⇒ 'capacity"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈incoming u. f e) = (∑v∈V. f (v,u))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_incoming_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>capacity_const</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Finite Preflow›</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Networks›</span></span></span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>no_incoming_s</span><span> </span><span>no_outgoing_t</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>incoming_s_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming s = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>incoming_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_incoming_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outgoing_t_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing t = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outgoing_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_outgoing_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cap_positive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E ⟹ c e &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cap_non_negative</span><span> </span><span>le_neq_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V≠{}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_node</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E≠{}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_V_ge2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card V ≥ 2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 = card {s,t}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{s,t} ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {s,t} ≤ card V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_is_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow c s t (λ_. 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cap_non_negative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_flow_val_unique</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦is_max_flow_val fv1; is_max_flow_val fv2⟧ ⟹ fv1=fv2"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_max_flow_val_def</span><span> </span><span>isMaxFlow_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Networks with Flow›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NPreflow</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Finite_Preflow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As there are no edges entering the source/leaving the sink, 
  also the corresponding flow values are zero:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_inflow_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e ∈ incoming s. f e = 0"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?thesis</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∀e ∈ incoming s. f e = 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ incoming s ∧ f e ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>incoming_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>no_incoming_s</span><span> </span><span>incoming_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_outflow_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e ∈ outgoing t. f e = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∀e ∈ outgoing t. f e = 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ outgoing t ∧ f e ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outgoing_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>no_outgoing_t</span><span> </span><span>outgoing_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For an edge, there is no reverse edge, and thus, 
  no flow in the reverse direction:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_rev_flow_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E ⟹ f(v,u) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>excess_non_negative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈V-{s,t}. excess f v ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>excess_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_deficient_nodes</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>excess_nodes_only</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"excess f v &gt; 0 ⟹ v ∈ V"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>excess_def</span><span> </span><span>incoming_def</span><span> </span><span>outgoing_def</span><span> </span><span>V_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.not_neutral_contains_not_neutral</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>excess_non_negative'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ V - {s}. excess f v ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"excess f t ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>excess_def</span><span> </span><span>outgoing_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>capacity_const</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>excess_non_negative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>excess_s_non_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"excess f s ≤ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>excess_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>capacity_const</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>  
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with preflow›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NFlow</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Finite_Preflow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹There is no outflow from the sink in a network. 
    Thus, we can simplify the definition of the value:›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>val_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val = (∑e ∈ outgoing s. f e)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_inflow_s</span><span class="delimiter">)</span><span>
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Residual_Graph">
<div class="head"><h1>Theory Residual_Graph</h1>
<span class="command">theory</span> <span class="name">Residual_Graph</span><br/>
<span class="keyword">imports</span> <a href="Network.html"><span class="name">Network</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Residual Graph›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Residual_Graph</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Network</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we define the residual graph.
  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ∗‹residual graph› of a network and a flow indicates how much 
  flow can be effectively pushed along or reverse to a network edge,
  by increasing or decreasing the flow on that edge:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>residualGraph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ graph ⇒ _ flow ⇒ _ graph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"residualGraph c f ≡ λ(u, v).
  if (u, v) ∈ Graph.E c then
    c (u, v) - f (u, v)
  else if (v, u) ∈ Graph.E c then
    f (v, u)
  else
    0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_of ≡ residualGraph c"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfE_of f ≡ Graph.E (cf_of f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The edges of the residual graph are either parallel or reverse 
  to the edges of the network.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cfE_of_ss_invE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfE_of cf ⊆ E ∪ E¯"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span>Graph.E_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cfE_of_ss_VxV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfE_of f ⊆ V×V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span>Graph.E_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cfE_of_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (cfE_of f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cfE_of_ss_VxV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_no_self_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,u)∉cfE_of f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, u) ∈ cfE_of f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, u) ∉ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Let's fix a network with a preflow @{term f} on it›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NPreflow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We abbreviate the residual graph by @{term cf}.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf ≡ residualGraph c f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span>Graph</span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>cf_def</span><span> </span><span class="delimiter">=</span><span> </span><span>residualGraph_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>cfE_ss_invE</span><span> </span><span class="delimiter">=</span><span> </span><span>cfE_of_ss_invE</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma cfE_ss_invE: "Graph.E cf ⊆ E ∪ E¯"
  unfolding residualGraph_def Graph.E_def
  by auto*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The nodes of the residual graph are exactly the nodes of the network.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resV_netV</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.V = V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ Graph.V cf"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ E ∨ (v, u) ∈ E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Use nifty new Isabelle2016 case-distinction features here! *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ Graph.E cf ∨ (v, u) ∈ Graph.E cf"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (u, v) = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) = c (u, v)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u, v) ∈ E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u, v) ∈ E›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (u, v) ≠ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) = f (u, v)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u, v) ∈ E›</span></span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f (u, v) ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∈ E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∈ Graph.E cf ∨ (u, v) ∈ Graph.E cf"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (v, u) = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) = c (v, u)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v, u) ∈ E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v, u) ∈ E›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (v, u) ≠ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) = f (v, u)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v, u) ∈ E›</span></span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f (v, u) ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈cf.V"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V cf ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfE_ss_invE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note, that Isabelle is powerful enough to prove the above case 
  distinctions completely automatically, although it takes some time:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.V = V"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span>Graph.E_def</span><span> </span><span>Graph.V_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>E_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As the residual graph has the same nodes as the network, it is also finite:›</span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span>Finite_Graph</span><span> </span><span>cf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The capacities on the edges of the residual graph are non-negative›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resE_nonNegative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) = c (u, v) - f (u, v)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) ≥ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span>cap_non_negative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∈ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) = f (v, u)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) ≥ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∉ E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∉ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Again, there is an automatic proof›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span>capacity_const</span><span> </span><span>cap_positive</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹All edges of the residual graph are labeled with positive capacities:›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>resE_positive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ cf.E ⟹ cf e &gt; 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ cf.E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resE_nonNegative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_iff</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>      
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Only one usage: Move or remove! *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reverse_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preflow cf s t f' ⟹ ∀(u, v) ∈ E. f' (v, u) ≤ f (u, v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Preflow cf s t f'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f'</span><span class="delimiter">:</span><span> </span><span>Preflow</span><span> </span><span>cf</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f'</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ E"</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) = f (u, v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' (v, u) ≤ cf (v, u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' (v, u) ≤ f (u, v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_of_cf cf e ≡ (if (e∈E) then c e - cf e else 0)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: We have proved/used this fact already for Edka-Analysis! (uE) *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NPreflow</span><span class="delimiter">)</span><span> </span><span>E_ss_cfinvE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ⊆ Graph.E cf ∪ (Graph.E cf)¯"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span>Graph.E_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Speed optimization: Adding this directly takes very long *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Nodes with positive excess must have an outgoing edge in the 
  residual graph. 

  Intuitively: The excess flow must come from somewhere.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_has_cf_outgoing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"excess f u &gt; 0 ⟹ cf.outgoing u ≠ {}"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>excess_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; sum f (incoming u) - sum f (outgoing u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; sum f (incoming u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_gt_0_iff_gt</span><span> </span><span>linorder_neqE_linordered_idom</span><span> </span><span>linorder_not_le</span><span> 
</span><span>        </span><span>sum_f_non_negative</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>f_non_negative</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈incoming u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f e &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>not_le</span><span> </span><span>sum_nonpos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∈E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (v,u) &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>incoming_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u,v) &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.outgoing_def</span><span> </span><span>cf.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with preflow›</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RPreGraph</span><span> </span><span class="comment">― ‹Locale that characterizes a residual graph of a network›</span><span>
</span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EX_RPG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. NPreflow c s t f ∧ cf = residualGraph c f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>this_loc_rpg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RPreGraph c s t cf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≡ flow_of_cf cf"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_unique</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NPreflow c s t f'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf = residualGraph c f'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' = f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f'</span><span class="delimiter">:</span><span> </span><span>NPreflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>flow_of_cf_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A</span><span> </span><span>residualGraph_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_NPreflow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NPreflow c s t (flow_of_cf cf)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EX_RPG</span><span> </span><span>f_unique</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span>NPreflow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_NPreflow</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rg_is_cf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"residualGraph c f = cf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EX_RPG</span><span> </span><span>f_unique</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rg_fo_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"residualGraph c (flow_of_cf cf) = cf"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rg_is_cf</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span>Graph</span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resV_netV</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.V = V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f.resV_netV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span>Finite_Graph</span><span> </span><span>cf</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_ss_cfinvE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ⊆ cf.E ∪ cf.E¯"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f.E_ss_cfinvE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cfE_ss_invE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.E ⊆ E ∪ E¯"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f.cfE_ss_invE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resE_nonNegative</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e ≥ 0"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f.resE_nonNegative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NPreflow</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_RPreGraph</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RPreGraph c s t cf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">;</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fo_rg_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_of_cf cf = f"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flow_of_cf_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For snippet*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NPreflow</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"flow_of_cf (residualGraph c f) = f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fo_rg_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RGraph</span><span> </span><span class="comment">― ‹Locale that characterizes a residual graph of a network›</span><span>
</span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EX_RG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. NFlow c s t f ∧ cf = residualGraph c f"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>RPreGraph</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EX_RG</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf = residualGraph c f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>    
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. NPreflow c s t f ∧ cf = residualGraph c f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>this_loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph c s t cf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>this_loc_rpg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RPreGraph c s t cf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_NFlow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t (flow_of_cf cf)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EX_RG</span><span> </span><span>f_unique</span><span> </span><span>is_NPreflow</span><span> </span><span>NFlow.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>f_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_NFlow</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>        
</span><span>      
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NFlow</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_RGraph</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph c s t cf"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">;</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The value of the flow can be computed from the residual graph.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_by_cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val = (∑(u,v)∈outgoing s. cf (v,u))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (s,v) = cf (v,s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_alt</span><span> </span><span>outgoing_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with Flow›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RPreGraph</span><span class="delimiter">)</span><span> </span><span>maxflow_imp_rgraph</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow (flow_of_cf cf)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph c s t cf"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMaxFlow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>     
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NFlow_axioms</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Augmenting_Flow">
<div class="head"><h1>Theory Augmenting_Flow</h1>
<span class="command">theory</span> <span class="name">Augmenting_Flow</span><br/>
<span class="keyword">imports</span> <a href="Residual_Graph.html"><span class="name">Residual_Graph</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmenting Flows›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Augmenting_Flow</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Residual_Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we define the concept of an augmenting flow,
  augmentation with a flow, and show that augmentation of a flow 
  with an augmenting flow yields a valid flow again.
  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We assume that there is a network with a flow @{term f} on it›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NFlow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmentation of a Flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The flow can be augmented by another flow, by adding the flows 
  of edges parallel to edges in the network, and subtracting the edges 
  reverse to edges in the network.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Define in network locale, with ↑ syntax. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>augment</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity flow ⇒ 'capacity flow"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment f' ≡ λ(u, v).
  if (u, v) ∈ E then
    f (u, v) + f' (u, v) - f' (v, u)
  else
    0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a syntax similar to Cormen et el.:›</span></span></span><span>    
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>augment_syntax</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↑"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f f'. f↑f' ≡ NFlow.augment c f f'"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹such that we can write @{term [source] "f↑f'"} for the flow @{term f} 
  augmented by @{term f'}.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmentation yields Valid Flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We show that, if we augment the flow with a valid flow of
  the residual graph, the augmented flow is a valid flow again, i.e. 
  it satisfies the capacity and conservation constraints:›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="comment">― ‹Let the \emph{residual flow} @{term f'} be a flow in the residual graph›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity flow"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f'_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow cf s t f'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>f'</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>cf</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f'_flow</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Capacity Constraint›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First, we have to show that the new flow satisfies the capacity constraint:›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME: Indentation unfortunate, but required to extract snippet for latex presentation *)</span></span></span></span></span><span>    
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\DefineSnippet{augment_flow_presv_cap}{›</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_flow_presv_cap</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (f↑f')(u,v) ∧ (f↑f')(u,v) ≤ c(u,v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f(u,v) = cf(v,u)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>residualGraph_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(v,u) ≥ f'(v,u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="delimiter">(</span><span>xtrans</span><span class="delimiter">)</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f'(v,u) ≤ f(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>xtrans</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\isanewline›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\ \ ›</span></span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f↑f')(u,v) = f(u,v) + f'(u,v) - f'(v,u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≥ f(u,v) + f'(u,v) - f(u,v)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≥ …"</span></span></span><span class="delimiter">)</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f'(v,u) ≤ f(u,v)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = f'(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f↑f')(u,v) ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword1"><span class="command">}</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f↑f')(u,v) = f(u,v) + f'(u,v) - f'(v,u)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ f(u,v) + f'(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ f(u,v) + cf(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f'.capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = f(u,v) + c(u,v) - f(u,v)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>residualGraph_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = c(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f↑f')(u, v) ≤ c(u, v)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span> </span><span>cap_positive</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹}%EndSnippet›</span></span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conservation Constraint›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In order to show the conservation constraint, we need some 
  auxiliary lemmas first.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As there are no parallel edges in the network, and all edges 
  in the residual graph are either parallel or reverse to a network edge,
  we can split summations of the residual flow over outgoing/incoming edges in the 
  residual graph to summations over outgoing/incoming edges in the network.

  Note that the term @{term ‹E``{u}›} characterizes the successor nodes of @{term ‹u›},
  and @{term ‹E¯``{u}›} characterizes the predecessor nodes of @{term ‹u›}.
›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Introduce pred/succ functions on Graph *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_rflow_outgoing</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∑v∈cf.E``{u}. f' (u,v)) = (∑v∈E``{u}. f'(u,v)) + (∑v∈E¯``{u}. f'(u,v))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``{u} ∩ E¯``{u} = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = (∑v∈E``{u} ∪ E¯``{u}. f' (u,v))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfE_ss_invE</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?RHS"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>DJ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_rflow_incoming</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∑v∈cf.E¯``{u}. f' (v,u)) = (∑v∈E``{u}. f'(v,u)) + (∑v∈E¯``{u}. f'(v,u))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``{u} ∩ E¯``{u} = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = (∑v∈E``{u} ∪ E¯``{u}. f' (v,u))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfE_ss_invE</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?RHS"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>DJ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For proving the conservation constraint, let's fix a node @{term u}, which
  is neither the source nor the sink: ›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>U_ASM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V - {s,t}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first show an auxiliary lemma to compare the 
  effective residual flow on incoming network edges to
  the effective residual flow on outgoing network edges.
  
  Intuitively, this lemma shows that the effective residual flow added to the 
  network edges satisfies the conservation constraint.
›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flow_summation_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑v∈E``{u}. f' (u,v))  - (∑v∈E``{u}. f' (v,u))
       = (∑v∈E¯``{u}. f' (v,u)) - (∑v∈E¯``{u}. f' (u,v))"</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A - ?B = ?RHS"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The proof is by splitting the flows, and careful 
    cancellation of the summands.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A = (∑v∈cf.E``{u}. f' (u, v)) - (∑v∈E¯``{u}. f' (u, v))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_rflow_outgoing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑v∈cf.E``{u}. f' (u, v)) = (∑v∈cf.E¯``{u}. f' (v, u))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U_ASM</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f'.conservation_const_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A = (∑v∈cf.E¯``{u}. f' (v, u)) - (∑v∈E¯``{u}. f' (u, v))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?B = (∑v∈cf.E¯``{u}. f' (v, u)) - (∑v∈E¯``{u}. f' (v, u))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_rflow_incoming</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A - ?B = ?RHS"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we are ready to prove that the augmented flow satisfies the 
  conservation constraint:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_flow_presv_con</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ outgoing u. augment f' e) = (∑e ∈ incoming u. augment f' e)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define shortcuts for the successor and predecessor nodes of @{term u} 
    in the network:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Vo</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"E``{u}"</span></span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Vi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"E¯``{u}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Using the auxiliary lemma for the effective residual flow,
    the proof is straightforward:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = (∑v∈?Vo. augment f' (u,v))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_outgoing_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = (∑v∈?Vo. f (u,v) + f'(u,v) - f'(v,u))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = (∑v∈?Vo. f (u,v)) + (∑v∈?Vo. f' (u,v)) - (∑v∈?Vo. f' (v,u))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_subtractf</span><span> </span><span>sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = (∑v∈?Vi. f (v,u)) + (∑v∈?Vi. f' (v,u)) - (∑v∈?Vi. f' (u,v))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conservation_const_pointwise</span><span class="delimiter">[</span><span>OF</span><span> </span><span>U_ASM</span><span class="delimiter">]</span><span> </span><span>flow_summation_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = (∑v∈?Vi. f (v,u) + f' (v,u) - f' (u,v))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_subtractf</span><span> </span><span>sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = (∑v∈?Vi. augment f' (v,u))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… 
    = ?RHS"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_incoming_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS = ?RHS"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note that we tried to follow the proof presented by Cormen et al.~\cite{CLRS09} 
  as closely as possible. Unfortunately, this proof generalizes the summation to all 
  nodes immediately, rendering the first equation invalid.
  Trying to fix this error, we encountered that the step that uses the conservation 
  constraints on the augmenting flow is more subtle as indicated in the original proof.
  Thus, we moved this argument to an auxiliary lemma. ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹@{term u} is node›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As main result, we get that the augmented flow is again a valid flow.›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>augment_flow_presv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow c s t (f↑f')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_flow_presv_cap</span><span> </span><span>augment_flow_presv_con</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>intro_Flow</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Value of the Augmented Flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we show that the value of the augmented flow is the sum of the values
  of the original flow and the augmenting flow.›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_flow_value</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow.val c s (f↑f') = val + Flow.val cf s f'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f''</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"f↑f'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_flow_presv</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For this proof, we set up Isabelle's rewriting engine for rewriting of sums.
    In particular, we add lemmas to convert sums over incoming or outgoing 
    edges to sums over all vertices. This allows us to write the summations
    from Cormen et al.~a bit more concise, leaving some of the tedious 
    calculation work to the computer.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>sum_simp_setup</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>capacity_const</span><span class="delimiter">]</span><span> </span><span>s_node</span><span>
</span><span>    </span><span>sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>capacity_const</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cf.sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f'.capacity_const</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cf.sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f'.capacity_const</span><span class="delimiter">]</span><span>
</span><span>    </span><span>sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f''.capacity_const</span><span class="delimiter">]</span><span>
</span><span>    </span><span>sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f''.capacity_const</span><span class="delimiter">]</span><span>
</span><span>    </span><span>sum_subtractf</span><span> </span><span>sum.distrib</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note that, if neither an edge nor its reverse is in the graph,
    there is also no edge in the residual graph, and thus the flow value
    is zero.›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f'(u,v) = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∉E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span>cfE_ss_invE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉cf.E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f'(u,v) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now, the proposition follows by straightforward rewriting of 
    the summations:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f''.val = (∑u∈V. augment f' (s, u) - augment f' (u, s))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f''.val_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑u∈V. f (s, u) - f (u, s) + (f' (s, u) - f' (u, s)))"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Note that this is the crucial step of the proof, which Cormen et al. leave as an exercise.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span> </span><span>no_parallel_edge</span><span> </span><span>aux1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = val + Flow.val cf s f'"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_def</span><span> </span><span>f'.val_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f''.val = val + f'.val"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note, there is also an automatic proof. When creating the above 
    explicit proof, this automatic one has been used to extract meaningful
    subgoals, abusing Isabelle as a term rewriter.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow.val c s (f↑f') = val + Flow.val cf s f'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f''</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"f↑f'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_flow_presv</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f'(u,v) = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∉E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span>cfE_ss_invE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉cf.E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f'(u,v) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_def</span><span> </span><span>f'.val_def</span><span> </span><span>f''.val_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>
</span><span>      </span><span>add</span><span class="delimiter">:</span><span> 
</span><span>      </span><span>sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>capacity_const</span><span class="delimiter">]</span><span> </span><span>s_node</span><span>
</span><span>      </span><span>sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>capacity_const</span><span class="delimiter">]</span><span>
</span><span>      </span><span>sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f''.capacity_const</span><span class="delimiter">]</span><span>
</span><span>      </span><span>sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f''.capacity_const</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cf.sum_outgoing_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f'.capacity_const</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cf.sum_incoming_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f'.capacity_const</span><span class="delimiter">]</span><span>
</span><span>      </span><span>sum_subtractf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>sum.distrib</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span> </span><span>no_parallel_edge</span><span> </span><span>aux1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Augmenting flow›</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network flow›</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Augmenting_Path">
<div class="head"><h1>Theory Augmenting_Path</h1>
<span class="command">theory</span> <span class="name">Augmenting_Path</span><br/>
<span class="keyword">imports</span> <a href="Residual_Graph.html"><span class="name">Residual_Graph</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmenting Paths›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Augmenting_Path</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Residual_Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define the concept of an augmenting path in the residual graph,
  and the residual flow induced by an augmenting path.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We fix a network with a preflow @{term f} on it.›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NPreflow</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An \emph{augmenting path} is a simple path from the source to the sink in the residual graph:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isAugmentingPath</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"path ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ≡ cf.isSimplePath s p t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The \emph{residual capacity} of an augmenting path is the smallest capacity 
  annotated to its edges:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resCap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"path ⇒ 'capacity"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap p ≡ Min {cf e | e. e ∈ set p}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resCap_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap p = Min (cf`set p)"</span></span></span><span>  
</span><span>  </span><span class="comment">― ‹Useful characterization for finiteness arguments›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>Min</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An augmenting path induces an \emph{augmenting flow}, which pushes as 
  much flow as possible along the path:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>augmentingFlow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"path ⇒ 'capacity flow"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augmentingFlow p ≡ λ(u, v).
  if (u, v) ∈ (set p) then
    resCap p
  else
    0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmenting Flow is Valid Flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this section, we show that the augmenting flow induced by an 
  augmenting path is a valid flow in the residual graph.

  We start with some auxiliary lemmas.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The residual capacity of an augmenting path is always positive.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resCap_gzero_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath s p t ⟹ 0&lt;resCap p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set p≠{}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_not_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e∈set p. cf e &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.isPath_edgeset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> </span><span>resE_positive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resCap_gzero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ⟹ 0&lt;resCap p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resCap_gzero_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span> </span><span>cf.isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As all edges of the augmenting flow have the same value, we can factor 
  this out from a summation:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_augmenting_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span>          
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ A. (augmentingFlow p) e) 
        = resCap p * of_nat (card (A∩set p))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ A. (augmentingFlow p) e) = sum (λ_. resCap p) (A∩set p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.inter_restrict</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augmentingFlow_def</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augFlow_resFlow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ⟹ Flow cf s t (augmentingFlow p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cf.intro_Flow</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SPATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isSimplePath s p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath s p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cf.isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first show the capacity constraint›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (augmentingFlow p) e ∧ (augmentingFlow p) e ≤ cf e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap p ≤ cf e"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(augmentingFlow p) e = resCap p"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>augmentingFlow_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e ∈ set p›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; resCap p"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resCap_gzero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∉ set p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(augmentingFlow p) e = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>augmentingFlow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resE_nonNegative</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we show the conservation constraint›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ Graph.V cf - {s, t}"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (Graph.incoming cf v ∩ set p) = card (Graph.outgoing cf v ∩ set p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈set (cf.pathVertices_fwd s p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cf.split_path_at_vertex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>P_FMT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath s p1 v"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath v p2 t"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1'</span><span> </span><span>u1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p1=p1'@[(u1,v)]"</span></span></span><span>    
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_path_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p2'</span><span> </span><span>u2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2=(v,u2)#p2'"</span></span></span><span>    
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> 
</span><span>        </span><span>cf.isSPath_sg_outgoing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SPATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v</span><span> </span><span>u2</span><span class="delimiter">]</span><span>  
</span><span>        </span><span>cf.isSPath_sg_incoming</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SPATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u1</span><span> </span><span>v</span><span class="delimiter">]</span><span>
</span><span>        </span><span>cf.isPath_edgeset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.outgoing v ∩ set p = {(v,u2)}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.incoming v ∩ set p = {(u1,v)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>P_FMT</span><span> </span><span>cf.outgoing_def</span><span> </span><span>cf.incoming_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∉set (cf.pathVertices_fwd s p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. (u,v)∉set p ∧ (v,u)∉set p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cf.pathVertices_edge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.incoming v ∩ set p = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.outgoing v ∩ set p = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.incoming_def</span><span> </span><span>cf.outgoing_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ Graph.incoming cf v. (augmentingFlow p) e) =
      (∑e ∈ Graph.outgoing cf v. (augmentingFlow p) e)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_augmenting_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Value of Augmenting Flow is Residual Capacity›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we show that the value of the augmenting flow is the residual 
  capacity of the augmenting path›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augFlow_val</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ⟹ Flow.val cf s (augmentingFlow p) = resCap p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>augFlow_resFlow</span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>cf</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"augmentingFlow p"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>AUG</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SPATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isSimplePath s p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isPath s p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cf.isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=(s,v)#p'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,v)∈cf.E"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_not_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.outgoing s ∩ set p = {(s,v)}"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.isSPath_sg_outgoing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SPATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>s</span><span> </span><span>v</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.isPath_edgeset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.outgoing_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.incoming s ∩ set p = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SPATH</span><span> </span><span>no_incoming_s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.incoming_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹p=(s,v)#p'›</span></span></span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">=</span><span>p'</span><span class="delimiter">]</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.isSimplePath_append</span><span> </span><span>cf.isSimplePath_cons</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f.val_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_augmenting_alt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with flow›</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Ford_Fulkerson">
<div class="head"><h1>Theory Ford_Fulkerson</h1>
<span class="command">theory</span> <span class="name">Ford_Fulkerson</span><br/>
<span class="keyword">imports</span> <a href="Augmenting_Flow.html"><span class="name">Augmenting_Flow</span></a> <a href="Augmenting_Path.html"><span class="name">Augmenting_Path</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Ford-Fulkerson Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Ford_Fulkerson</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Augmenting_Flow</span><span> </span><span>Augmenting_Path</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this theory, we prove the Ford-Fulkerson theorem, 
  and its well-known corollary, the min-cut max-flow theorem.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We fix a network with a flow and a cut›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NFlowCut</span><span> </span><span class="delimiter">=</span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span> </span><span>NCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>k</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity::linordered_idom graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span>k</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_k</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite k"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cut_ss_V</span><span> </span><span>finite_V</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>V</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Net Flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define the \emph{net flow} to be the amount of flow effectively 
  passed over the cut from the source to the sink:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>netFlow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"netFlow ≡ (∑e ∈ outgoing' k. f e) - (∑e ∈ incoming' k. f e)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We can show that the net flow equals the value of the flow.
  Note: Cormen et al.~\cite{CLRS09} present a whole page full of 
  summation calculations for this proof, and our formal proof also 
  looks quite complicated.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flow_value</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"netFlow = val"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?LCL</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(u, v). u ∈ k ∧ v ∈ k ∧ (u, v) ∈ E}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?AOG</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(u, v). u ∈ k ∧ (u, v) ∈ E}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?AIN</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(v, u) | u v. u ∈ k ∧ (v, u) ∈ E}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SOG</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λu. (∑e ∈ outgoing u. f e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SIN</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λu. (∑e ∈ incoming u. f e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SOG'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ outgoing' k. f e)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?SIN'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ incoming' k. f e)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Some setup to make finiteness reasoning implicit›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>simproc</span><span> </span><span>finite_Collect</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"netFlow = ?SOG' + (∑e ∈ ?LCL. f e) - (?SIN' + (∑e ∈ ?LCL. f e))"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_   =        ?SAOG              -          ?SAIN"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>netFlow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SAOG = (∑y ∈ k - {s}. ?SOG y) + ?SOG s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SAOG = (∑e∈(outgoing' k ∪ ?LCL). f e)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing'_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing' k ∪ ?LCL = (⋃y∈k-{s}. outgoing y) ∪ outgoing s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing_def</span><span> </span><span>outgoing'_def</span><span> </span><span>s_in_cut</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈(⋃(outgoing ` (k - {s})) ∪ outgoing s). f e) 
      = (∑e∈(⋃(outgoing ` (k - {s}))). f e) + (∑e∈outgoing s. f e)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈(⋃(outgoing ` (k - {s}))). f e) 
      = (∑y ∈ k - {s}. ?SOG y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.UNION_disjoint</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SAIN = (∑y ∈ k - {s}. ?SIN y) + ?SIN s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?SAIN = (∑e∈(incoming' k ∪ ?LCL). f e)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming'_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming' k ∪ ?LCL = (⋃y∈k-{s}. incoming y) ∪ incoming s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>incoming'_def</span><span> </span><span>s_in_cut</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈(⋃(incoming ` (k - {s})) ∪ incoming s). f e) 
      = (∑e∈(⋃(incoming ` (k - {s}))). f e) + (∑e∈incoming s. f e)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e∈(⋃(incoming ` (k - {s}))). f e) 
      = (∑y ∈ k - {s}. ?SIN y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.UNION_disjoint</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"netFlow =  
      ((∑y ∈ k - {s}. ?SOG y) + ?SOG s) 
    - ((∑y ∈ k - {s}. ?SIN y) + ?SIN s)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"netFlow = ?R"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R = ?SOG s - ?SIN s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀u. u ∈ k - {s} ⟹ ?SOG u = ?SIN u)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conservation_const</span><span> </span><span>cut_ss_V</span><span> </span><span>t_ni_cut</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The value of any flow is bounded by the capacity of any cut.
  This is intuitively clear, as all flow from the source to the sink has to go
  over the cut.›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>weak_duality</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val ≤ cap"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ outgoing' k. f e) ≤ (∑e ∈ outgoing' k. c e)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ≤ ?R"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ outgoing' k. f e) ≤ cap"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cap_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val ≤ (∑e ∈ outgoing' k. f e)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>netFlow_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>capacity_const</span><span> </span><span>flow_value</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Cut›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ford-Fulkerson Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NFlow</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We prove three auxiliary lemmas first, and the state the theorem as a corollary›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fofu_I_II</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f ⟹ ¬ (∃ p. isAugmentingPath p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMaxFlow_alt</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t f 
    ∧ (∀f'. NFlow c s t f' ⟶ Flow.val c s f' ≤ Flow.val c s f)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ¬ (∃ p. isAugmentingPath p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow cf s t (augmentingFlow p)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt</span><span> </span><span>augFlow_resFlow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow.val cf s (augmentingFlow p) &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt</span><span> </span><span>augFlow_val</span><span>
</span><span>    </span><span>resCap_gzero</span><span> </span><span>isAugmentingPath_def</span><span> </span><span>cf.isSimplePath_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t (augment (augmentingFlow p))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct1</span><span> </span><span>augment_flow_presv</span><span> </span><span>Network_axioms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Flow_def</span><span> </span><span>NFlow_def</span><span> </span><span>NPreflow_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow.val c s (augment (augmentingFlow p)) &gt; val"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct1</span><span> </span><span>fct2</span><span> </span><span>augment_flow_value</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fofu_II_III</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (∃ p. isAugmentingPath p) ⟹ ∃k'. NCut c s t k' ∧ val = NCut.cap c k'"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.reachableNodes s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃ p. isAugmentingPath p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∉?S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isAugmentingPath_def</span><span> </span><span>cf.reachableNodes_def</span><span> </span><span>cf.connected_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cf.isSPath_pathLE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>CUT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NCut c s t ?S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.reachableNodes cf s ⊆ V"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.reachable_ss_V</span><span> </span><span>s_node</span><span> </span><span>resV_netV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ Graph.reachableNodes cf s"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.reachableNodes_def</span><span> </span><span>Graph.connected_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Graph.isPath.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="var">?S</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlowCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="var">?S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(u,v)∈outgoing' ?S. f (u,v) = c (u,v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹Proof by contradiction›</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈outgoing' ?S"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈?S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∉?S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>outgoing'_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (u,v) ≠ c (u,v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (u,v) &lt; c (u,v)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>capacity_const</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>eq_iff</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (u, v) ≠ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,v)∈E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ cf.E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈?S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∈?S›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cf.reachableNodes_append_edge</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∉?S›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ outgoing' ?S. f e) = cap"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(u,v)∈incoming' ?S. f (u,v) = 0"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹Proof by contradiction›</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈incoming' ?S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∉?S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈?S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incoming'_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∉E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_parallel_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (u,v) ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf (v, u) ≠ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,v)∈E›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v,u)∉E›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, u) ∈ cf.E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈?S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈?S›</span></span></span><span> </span><span>cf.reachableNodes_append_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∉?S›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ incoming' ?S. f e) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val = cap"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>flow_value</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>netFlow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fofu_III_I</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃k. NCut c s t k ∧ val = NCut.cap c k ⟹ isMaxFlow f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NCut c s t k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlowCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val = cap"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Flow c s t f'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>fc'</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f'</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>fc'</span><span class="delimiter">:</span><span> </span><span>NFlowCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f'</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fc'.val ≤ cap"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fc'.weak_duality</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹val = cap›</span></span></span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fc'.val ≤ val"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMaxFlow_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we can state the Ford-Fulkerson theorem: ›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ford_fulkerson</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f ⟷ 
  ¬ Ex isAugmentingPath"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Ex isAugmentingPath ⟷ 
  (∃k. NCut c s t k ∧ val = NCut.cap c k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fofu_I_II</span><span> </span><span>fofu_II_III</span><span> </span><span>fofu_III_I</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Corollaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this subsection we present a few corollaries of the 
  flow-cut relation and the Ford-Fulkerson theorem.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The outgoing flow of the source is the same as the incoming flow of 
  the sink. Intuitively, this means that no flow is generated or lost in the 
  network, except at the source and sink.›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>inflow_t_outflow_s</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ incoming t. f e) = (∑e ∈ outgoing s. f e)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We choose a cut between the sink and all other nodes›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"V - {t}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlowCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="var">?K</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_node</span><span> </span><span>s_not_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The cut is chosen such that its outgoing edges are the incoming edges
    to the sink, and its incoming edges are the outgoing edges from the sink.
    Note that the sink has no outgoing edges.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outgoing' ?K = incoming t"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"incoming' ?K = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_self_loop</span><span> </span><span>no_outgoing_t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outgoing'_def</span><span> </span><span>incoming_def</span><span> </span><span>incoming'_def</span><span> </span><span>outgoing_def</span><span> </span><span>V_def</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑e ∈ incoming t. f e) = netFlow"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>netFlow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"netFlow = val"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flow_value</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val = (∑e ∈ outgoing s. f e)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>val_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As an immediate consequence of the Ford-Fulkerson theorem, we get that
  there is no augmenting path if and only if the flow is maximal.›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>noAugPath_iff_maxFlow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄p. isAugmentingPath p) ⟷ isMaxFlow f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ford_fulkerson</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with flow›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The value of the maximum flow equals the capacity of the minimum cut›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network</span><span class="delimiter">)</span><span> </span><span>maxFlow_minCut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦isMaxFlow f; isMinCut c s t k⟧ 
  ⟹ Flow.val c s f = NCut.cap c k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMaxFlow f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isMinCut c s t k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="delimiter">+</span><span> </span><span>NCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMaxFlow_def</span><span> </span><span>isMinCut_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlowCut</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span> 
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ford_fulkerson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isMaxFlow f›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NCut c s t k'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val = NCut.cap c k'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val = cap"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isMinCut c s t k›</span></span></span><span> </span><span>weak_duality</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isMinCut_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Graph_Impl">
<div class="head"><h1>Theory Graph_Impl</h1>
<span class="command">theory</span> <span class="name">Graph_Impl</span><br/>
<span class="keyword">imports</span> <a href="Refine_Add_Fofu.html"><span class="name">Refine_Add_Fofu</span></a> <a href="Graph.html"><span class="name">Graph</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: That's quite specific to the BFS alg. Move to Edka! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Graph_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lib/Refine_Add_Fofu"</span></span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment">― ‹Fixing capacities to integer values›</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>capacity_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>int</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: DUP in Network_Impl. Remove here!*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Impl_Succ</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>absG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ga ⇒ capacity_impl graph"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ifT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ig itself"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>succ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ga ⇒ node ⇒ node list nres"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>isG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ga ⇒ 'gi ⇒ assn"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>succ_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'gi ⇒ node ⇒ node list Heap"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*assumes [constraint_rules]: "precise isG"*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>si_rule</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry succ_impl,(uncurry succ)) ∈ [λ(c,u). u∈Graph.V (absG c)]<span class="hidden">⇩</span><sub>a</sub> isG<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (pure nat_rel)<span class="hidden">⇧</span><sup>k</sup> → list_assn (pure nat_rel)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>this_loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Impl_Succ absG succ isG succ_impl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ig ⇒ node ⇒ node list nres"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Will not work if succ is not a constant! *)</span></span></span></span></span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Network_Impl">
<div class="head"><h1>Theory Network_Impl</h1>
<span class="command">theory</span> <span class="name">Network_Impl</span><br/>
<span class="keyword">imports</span> <a href="Refine_Add_Fofu.html"><span class="name">Refine_Add_Fofu</span></a> <a href="Ford_Fulkerson.html"><span class="name">Ford_Fulkerson</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Flow Networks›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Network_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib/Refine_Add_Fofu"</span></span></span><span>
</span><span>  </span><span>Ford_Fulkerson</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Type Constraints›</span></span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We constrain the types that we use for implementation.›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define capacities to be integer values.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>capacity_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>int</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>flow_impl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl flow"</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a locale that assumes that the nodes are natural numbers in the 
  range @{term "{0..&lt;N}"}.›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Network_Impl</span><span> </span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆{0..&lt;N}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ⊆ {0..&lt;N}×{0..&lt;N}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss_VxV</span><span> </span><span>V_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Operations›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Residual Graph›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Get the residual capacity of an edge.›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cf_get</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_impl ⇒ edge ⇒ capacity_impl nres"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_get cf e ≡ do {
      assert (e∈E ∪ E¯);
      return (cf e)
    }"</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Update the residual capacity of an edge.›</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cf_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_impl ⇒ edge ⇒ capacity_impl ⇒ flow_impl nres"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_set cf e x ≡ do {
      assert (e∈E ∪ E¯);
      return (cf (e:=x))
    }"</span></span></span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Obtain the initial residual graph.›</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cf_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_impl nres"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_init ≡ return (op_mtx_new c)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adjacency Map›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Obtain the list of adjacent nodes for a specified node.›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>am_get</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ node ⇒ node list nres"</span></span></span><span>    
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"am_get am u ≡ do {
      assert (u∈V);
      return (am u)
    }"</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test whether a node identifier is actually a node. 
    As not all numbers in the range @{term ‹{0..&lt;N}›} must identify nodes, 
    this function uses the adjacency map to check whether there are adjacent
    edges. Due to the network constraints, all nodes have adjacent edges.
  ›</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>am_is_in_V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ node ⇒ bool nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"am_is_in_V am u ≡ do {
      return (am u ≠ [])
    }"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_is_in_V_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">,</span><span> </span><span>refine_vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(am,adjacent_nodes) ∈ nat_rel → ⟨nat_rel⟩list_set_rel"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"am_is_in_V am u ≤ (spec x. x ⟷ u∈V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V ⟷ adjacent_nodes u ≠ {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>V_def</span><span> </span><span>adjacent_nodes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ am u ≠ []"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_relD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>am_is_in_V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>refine_vcg</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Registration of Basic Operations to Sepref›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bundles the setup for registration of abstract operations.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>Network_Impl_Sepref_Register</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Automatically rewrite to ‹i_mtx› interface type›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>map_type_eqs</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>map_type_eqI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl flow)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl i_mtx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Bundle›</span><span>
</span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Registration of Abstract Operations›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Network_Impl_Sepref_Register</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>N</span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>cf_get</span><span> </span><span>cf_set</span><span> </span><span>cf_init</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>am_get</span><span> </span><span>am_is_in_V</span><span>    
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Anonymous Context›</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement To Efficient Data Structures›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Functions from Nodes by Arrays›</span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  TODO: Move to own file in IICF
 
  This has more general uses than implementing nodes!
  It can implement functions from any objects represented by an initial
  segment of the natural numbers, a very often recurring pattern.
*)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We provide a template for implementing functions from nodes by arrays.
  Outside the node range, the abstract functions have a default value.

  This template is then used for refinement of various data structures.
›</span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_nf N dflt f a 
  ≡ ∃<span class="hidden">⇩</span><sub>A</sub>l. a↦<span class="hidden">⇩</span><sub>a</sub>l * ↑(length l = N ∧ (∀i&lt;N. l!i = f i) ∧ (∀i≥N. f i = dflt))"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_init_rule</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; Array.new N dflt &lt;is_nf N dflt (λ_. dflt)&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_nf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sep_auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_copy_rule</span><span class="delimiter">[</span><span>sep_heap_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;is_nf N dflt f a&gt; array_copy a &lt;λr. is_nf N dflt f a * is_nf N dflt f r&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_nf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sep_auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_lookup_rule</span><span class="delimiter">[</span><span>sep_heap_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v&lt;N ⟹ &lt;is_nf N dflt f a&gt; Array.nth a v &lt;λr. is_nf N dflt f a *↑(r = f v)&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_nf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sep_auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_update_rule</span><span class="delimiter">[</span><span>sep_heap_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v&lt;N ⟹ &lt;is_nf N dflt f a&gt; Array.upd v x a &lt;is_nf N dflt (f(v:=x))&gt;"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_nf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sep_auto</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Automation Setup for Side-Condition Discharging›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtx_nonzero_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtx_nonzero c = E"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mtx_nonzero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtx_nonzeroN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtx_nonzero c ⊆ {0..&lt;N}×{0..&lt;N}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_mtx_nonzeroN</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v) ∈ mtx_nonzero c ⟹ u&lt;N ∧ v&lt;N"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mtx_nonzeroN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inV_less_N</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V ⟹ v&lt;N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inEIE_lessN</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈E ∨ e∈E¯ ⟹ case e of (u,v) ⇒ u&lt;N ∧ v&lt;N"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>nested_case_prod_simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Network Parameters by Identity›</span></span></span><span>    
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>cap_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl ⇒ _"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cap_assn ≡ id_assn"</span></span></span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge_assn ≡ nat_assn ×<span class="hidden">⇩</span><sub>a</sub> nat_assn"</span></span></span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"node_assn ≡ nat_assn"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refine number of nodes, and source and sink node by themselves›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>  </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>  </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>c_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(uncurry0 (return c),uncurry0 (RETURN c))
    ∈unit_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> pure (nat_rel ×<span class="hidden">⇩</span><sub>r</sub> nat_rel → Id)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sepref_to_hoare</span><span class="delimiter">)</span><span> </span><span>sep_auto</span><span> 
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Residual Graph by Adjacency Matrix›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_assn N ≡ asmtx_assn N cap_assn"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cf_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_assn ≡ Network_Impl.cf_assn N"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>intf_of_assn</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"intf_of_assn (cf_assn) TYPE(capacity_impl i_mtx)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>cf_get_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry (PR_CONST cf_get)"</span></span></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_assn<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> edge_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> cap_assn"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_get_def</span><span> </span><span>cf_assn_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>cf_get_impl</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Network_Impl.cf_get_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry ?f,_)∈_"</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>cf_set_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry2 (PR_CONST cf_set)"</span></span></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_assn<span class="hidden">⇧</span><sup>d</sup> *<span class="hidden">⇩</span><sub>a</sub> edge_assn<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> cap_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> cf_assn"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_set_def</span><span> </span><span>cf_assn_def</span><span> </span><span>PR_CONST_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>cf_set_impl</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Network_Impl.cf_set_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry2 ?f,_)∈_"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>cf_init_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry0 (PR_CONST cf_init)"</span></span></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> cf_assn"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span> </span><span>cf_assn_def</span><span> </span><span>cf_init_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>amtx_fold_custom_new</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span> </span><span>N</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>  
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>cf_init_impl</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Network_Impl.cf_init_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry0 ?f,_)∈_"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>cf_get_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Network_Impl_axioms</span><span class="delimiter">]</span><span> 
</span><span>  </span><span>cf_set_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Network_Impl_axioms</span><span class="delimiter">]</span><span> 
</span><span>  </span><span>cf_init_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Network_Impl_axioms</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adjacency Map by Array›</span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"am_assn N ≡ is_nf N ([]::nat list)"</span></span></span><span>    
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>am_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"am_assn ≡ Network_Impl.am_assn N"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_get_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(uncurry Array.nth, uncurry (PR_CONST am_get)) 
  ∈ am_assn<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> node_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> list_assn id_assn"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>am_assn_def</span><span> </span><span>am_get_def</span><span> </span><span>list_assn_pure_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"am_is_in_V_impl am u ≡ do {
  amu ← Array.nth am u;
  return (¬is_Nil amu)
}"</span></span></span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_is_in_V_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry am_is_in_V_impl, uncurry (am_is_in_V)) 
  ∈ [λ(_,v). v&lt;N]<span class="hidden">⇩</span><sub>a</sub> am_assn<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> node_assn<span class="hidden">⇧</span><sup>k</sup> → bool_assn"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>am_assn_def</span><span> </span><span>am_is_in_V_def</span><span> </span><span>am_is_in_V_impl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Computing the Flow Value›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define an algorithm to compute the value of a flow from 
  the residual graph
›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>RGraph_Impl</span><span> </span><span class="delimiter">=</span><span> </span><span>RGraph</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>cf</span><span> </span><span class="delimiter">+</span><span> </span><span>Network_Impl</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>N</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl flow"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>N</span><span> </span><span>cf</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rgraph_and_network_impl_imp_rgraph_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph c s t cf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Network_Impl c s t N"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph_Impl c s t N cf"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Network_Impl.RGraph_Impl.intro</span><span class="delimiter">)</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>val_by_adj_map</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f.val = (∑v∈set (am s). cf (v,s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (am s) = E``{s}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AM</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_adj_map_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>f.val_by_cf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rg_is_cf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(u, v)∈outgoing s. cf (v, u)) 
          = ((∑v∈set (am s). cf (v,s)))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_outgoing_pointwise</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val_aux am cf ≡ do {
    succs ← am_get am s;
    sum_impl (λv. cf_get cf (v,s)) (set succs)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph_Impl</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_aux_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val_aux am cf ≤ (spec v. v = f.val)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_by_adj_map</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val_aux_def</span><span> </span><span>cf_get_def</span><span> </span><span>am_get_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>sum_impl_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s_node</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_adj_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For technical reasons (poor foreach-support of Sepref tool), 
  we have to add another refinement step: ›</span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val am cf ≡ (do {
  succs ← am_get am s;
  nfoldli succs (λ_. True) (λx a. do {
     b ← cf_get cf (x, s); 
     return (a + b)
   }) 0
})"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph_Impl</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">,</span><span> </span><span>refine_vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val am cf ≤ (spec v. v = f.val)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RELATES (⟨Id⟩list_set_rel)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>compute_flow_val_aux_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val_def</span><span> </span><span>compute_flow_val_aux_def</span><span> </span><span>sum_impl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>LFO_refine</span><span> </span><span>bind_refine'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>am_get_def</span><span> </span><span>is_adj_map_def</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Network_Impl_Sepref_Register</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>compute_flow_val</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>compute_flow_val_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry (PR_CONST compute_flow_val)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"am_assn<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> cf_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> cap_assn"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>  
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_impl</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Network_Impl.compute_flow_val_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry ?f,_)∈_"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>compute_flow_val_impl_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="delimiter">=</span><span> </span><span>compute_flow_val_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Network_Impl_axioms</span><span class="delimiter">]</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also export a correctness theorem on the separation logic level›</span></span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_flow_val_impl_correct</span><span class="delimiter">[</span><span>sep_heap_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph_Impl c s t N cf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.is_adj_map c am"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;cf_assn N cf cfi * am_assn N am ami&gt; 
          compute_flow_val_impl s N ami cfi 
        &lt;λv. cf_assn N cf cfi * am_assn N am ami 
            * ↑( v = Flow.val c s (RPreGraph.f c cf) )&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>RGraph_Impl</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>N</span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hn_refine_ref</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>      </span><span>compute_flow_val_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AM</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>compute_flow_val_impl_hnr</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>autoref_tag_defs</span><span class="delimiter">]</span><span class="delimiter">]</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>pure_def</span><span> </span><span>hn_refine_def</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_post_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sep_auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Computing the Exact Number of Nodes›</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_to_adj_nodes_refine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(am u, adjacent_nodes u) ∈ ⟨nat_rel⟩list_set_rel"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AM</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjacent_nodes_def</span><span> </span><span>is_adj_map_def</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_C am ≡ do {
  let cardV=0;
  nfoldli [0..&lt;N] (λ_. True) (λv cardV. do {
    assert (v&lt;N);
    inV ← am_is_in_V am v;
    if inV then do {
      return (cardV + 1)
    } else
      return cardV
  }) cardV
}"</span></span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_C_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_C am ≤ SPEC (λC. C = card V)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_C_def</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>      </span><span>nfoldli_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λl1 _ C. C = card (V∩set l1)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp_all</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_ss</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>upt_eq_lel_conv</span><span> </span><span>Int_absorb2</span><span> </span><span>am_to_adj_nodes_refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AM</span><span class="delimiter">]</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Network_Impl_Sepref_Register</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>init_C</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>  
</span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>fifo_init_C_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(PR_CONST init_C)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"am_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> nat_assn"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_C_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>fifo_init_C_impl</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Network_Impl.fifo_init_C_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?f,_)∈_"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fifo_init_C_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Network_Impl_axioms</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network Implementation Locale›</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NetCheck">
<div class="head"><h1>Theory NetCheck</h1>
<span class="command">theory</span> <span class="name">NetCheck</span><br/>
<span class="keyword">imports</span> <a href="Network.html"><span class="name">Network</span></a> <a href="Graph_Impl.html"><span class="name">Graph_Impl</span></a> <a href="Reachable_Nodes.html"><span class="name">Reachable_Nodes</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Checking for Valid Network›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NetCheck</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Lib/Refine_Add_Fofu"</span></span></span><span>
</span><span>  </span><span>Network</span><span>
</span><span>  </span><span>Graph_Impl</span><span>
</span><span>  </span><span>DFS_Framework.Reachable_Nodes</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory contains code to read a network from an edge list, 
  and verify that the network is a valid input for the 
  Edmonds Karp Algorithm.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>coercion_delete</span><span> </span><span>int</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>coercion_delete</span><span> </span><span class="string"><span class="delete"><span class="delete">"real::nat⇒real"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graphs as Lists of Edges›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graphs can be represented as lists of edges, each edge being a triple of 
    start node, end node, and capacity. Capacities must be positive, and there
    must not be multiple edges with the same start and end node. ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>edge_list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node × node × capacity_impl) list"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ln_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge_list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ln_invar el ≡ 
      distinct (map (λ(u, v, _). (u,v)) el) 
    ∧ (∀(u,v,c)∈set el. c&gt;0) 
    "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ln_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge_list ⇒ capacity_impl graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ln_α el ≡ λ(u,v). 
      if ∃c. (u, v, c) ∈ set el ∧ c ≠ 0 then 
        SOME c. (u, v, c) ∈ set el ∧ c ≠ 0
      else 0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_rel ≡ br ln_α ln_invar"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ln_equivalence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, c') ∈ ln_rel ⟷ ln_invar el ∧ c' = ln_α el"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ln_N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node×node×_) list ⇒ nat"</span></span></span><span> 
</span><span>    </span><span class="comment">― ‹Maximum node number plus one. I.e. the size of an array to be indexed by nodes.›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_N el ≡ Max ((fst`set el) ∪ ((fst o snd)`set el)) + 1"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ln_α_imp_in_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ln_α el (u,v)≠(0)⟧ ⟹ (u,v,ln_α el (u,v))∈set el"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_α_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ln_N_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V (ln_α el) ⊆ {0..&lt;ln_N el}"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.V_def</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>safe</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ln_α_imp_in_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_N_def</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_ge</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_N_def</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_ge</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pre-Networks›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This data structure is used to convert an edge-list to a network and 
    check validity. It maintains additional information, like a adjacency maps. ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">record</span></span><span> </span><span>pre_network</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>pn_c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>    </span><span>pn_V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat set"</span></span></span><span>
</span><span>    </span><span>pn_succ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list"</span></span></span><span>
</span><span>    </span><span>pn_pred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list"</span></span></span><span>
</span><span>    </span><span>pn_adjmap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list"</span></span></span><span>
</span><span>    </span><span>pn_s_node</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>    </span><span>pn_t_node</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>read</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge_list ⇒ nat ⇒ nat ⇒ pre_network option"</span></span></span><span> 
</span><span>    </span><span class="comment">― ‹Read a pre-network from an edge list, and source/sink node numbers.›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"read [] _ _ = Some ⦇
      pn_c = (λ _. 0), 
      pn_V = {}, 
      pn_succ = (λ _. []),
      pn_pred = (λ _. []),
      pn_adjmap = (λ _. []), 
      pn_s_node = False, 
      pn_t_node = False
    ⦈"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"read ((u, v, c) # es) s t = ((case (read es s t) of 
      Some x ⇒
        (if (pn_c x) (u, v) = 0 ∧ (pn_c x) (v, u) = 0 ∧ c &gt; 0 then
          (if u = v ∨ v = s ∨ u = t then
            None
          else
            Some (x⦇ 
              pn_c := (pn_c x) ((u, v) := c),
              pn_V := insert u (insert v (pn_V x)),
              pn_succ := (pn_succ x) (u := v # ((pn_succ x) u)),
              pn_pred := (pn_pred x) (v := u # ((pn_pred x) v)),
              pn_adjmap := (pn_adjmap x) (
                u := v # (pn_adjmap x) u, 
                v := u # (pn_adjmap x) v),
              pn_s_node := pn_s_node x ∨ u = s,
              pn_t_node := pn_t_node x ∨ v = t
            ⦈))
        else
          None)
    | None ⇒ None))"</span></span></span><span>
</span><span>      
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: These proofs look overly verbose. *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>read_correct1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read es s t = Some ⦇pn_c = c, pn_V = V, pn_succ = succ, 
    pn_pred = pred , pn_adjmap = adjmap, pn_s_node = s_n, pn_t_node = t_n⦈ ⟹ 
    (es, c) ∈ ln_rel ∧ Graph.V c = V ∧ finite V ∧ 
    (s_n ⟶ s ∈ V) ∧ (t_n ⟶ t ∈ V) ∧ (¬s_n ⟶ s ∉ V) ∧ (¬t_n ⟶ t ∉ V) ∧
    (∀u v. c (u,v) ≥ 0) ∧
    (∀u. c(u, u) = 0) ∧ (∀u. c (u, s) = 0) ∧ (∀u. c (t, u) = 0) ∧
    (∀u v. c (u, v) ≠ 0 ⟶ c (v, u) = 0) ∧ 
    (∀u. set (succ u) = Graph.E c``{u} ∧ distinct (succ u)) ∧ 
    (∀u. set (pred u) = (Graph.E c)¯``{u} ∧ distinct (pred u)) ∧ 
    (∀u. set (adjmap u) = Graph.E c``{u} ∪ (Graph.E c)¯``{u} 
      ∧ distinct (adjmap u))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>es</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>succ</span><span> </span><span>pred</span><span> </span><span>adjmap</span><span> </span><span>s_n</span><span> </span><span>t_n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span>Graph.E_def</span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> 
</span><span>            </span><span>ln_α_def</span><span> </span><span>ln_invar_def</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1</span><span> </span><span>v1</span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e = (u1, v1, c1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>prod_cases3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read es s t = Some x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pn_c x) (u1, v1) = 0 ∧ (pn_c x) (v1, u1) = 0 ∧ c1 &gt; 0"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 &gt; 0 ∧ u1 ≠ v1 ∧ v1 ≠ s ∧ u1 ≠ t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span>V'</span><span> </span><span>sc'</span><span> </span><span>ps'</span><span> </span><span>pd'</span><span> </span><span>s_n'</span><span> </span><span>t_n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt3</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c', pn_V = V',
                pn_succ = sc', pn_pred = pd',  pn_adjmap = ps', 
                pn_s_node = s_n', pn_t_node = t_n'⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read es s t = Some ⦇pn_c = c', pn_V = V', 
          pn_succ = sc', pn_pred = pd',
          pn_adjmap = ps', pn_s_node = s_n', pn_t_node = t_n'⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s_n = (s_n' ∨ u1 = s)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t_n = (t_n' ∨ v1 = t)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = c' ((u1, v1) := c1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V = V' ∪ {u1, v1}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ = sc' (u1 := v1 # sc' u1)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pred = pd' (v1 := u1 # pd' v1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjmap = (ps' (u1 := v1 # ps' u1)) (v1 := u1 # ps' v1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct1</span><span> </span><span>Cons.prems</span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        
</span><span>          
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(es, c') ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar es"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' = ln_α es"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar (e # es)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(u, v, c) ∈ set (e # es). c&gt;0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ln_invar es›</span></span></span><span> </span><span>fct0</span><span> </span><span>obt1</span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map (λ(u, v, _). (u,v)) es)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ln_invar es›</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c1'. (u1, v1, c1') ∈ (set es) ∧ c1' ≠ 0"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c1'. (u1, v1, c1') ∉ (set es) ∨ c1' = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map (λ(u, v, _). (u,v)) (e # es))"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar (e # es)"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ ln_invar (e # es)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u1, v1, c1') ∈ (set es) ∧ c1' ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) = (SOME c. (u1, v1, c) ∈ set es ∧ c ≠ 0)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c' = ln_α es›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u1, v1, c1') ∈ (set es) ∧ c1' ≠ 0›</span></span></span><span> </span><span>f1</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map (λ(u, v, _). (u,v)) (e # es))"</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u v. (u, v, 0) ∉ set (e # es)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ln_invar (e # es)›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c a = ln_α (e # es) a"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = (u1, v1)"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c a = c1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ln_α (e # es)) a 
                        = (SOME c. (u1, v1, c) ∈ set (e # es) ∧ c ≠ 0)"</span></span></span><span>
</span><span>                        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>fct0</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R = c1"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">"(u1, v1, c1') ∈ set (e # es) ∧ c1' ≠ 0 ∧ c1' ≠ c1"</span></span></span><span> 
</span><span>                            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">"¬distinct (map (λ(u, v, _). (u,v)) (e # es))"</span></span></span><span> 
</span><span>                            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> 
</span><span>                            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pair_inject</span><span> 
</span><span>                              </span><span>distinct_map_eq</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split_conv</span><span class="delimiter">)</span><span> 
</span><span>                          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = c1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> 
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"∀u1' v1' c1'. u1' ≠ u1 ∨ v1' ≠ v1 
                      ⟶ ((u1', v1', c1') ∈ set (e # es)
                            ⟷ (u1', v1', c1') ∈ set es)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1'</span><span> </span><span>v1'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = (u1', v1')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ln_α (e # es)) (u1', v1') = (ln_α es) (u1', v1')"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> 
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">"∃ c1'. (u1', v1', c1') ∈ set (e # es) ∧ c1' ≠ 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> 
</span><span>                              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>False</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (u1', v1')›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ln_α (e # es)) a = (ln_α es) a"</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (u1', v1')›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c a = c' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>fct4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' a = ln_α es a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c' = ln_α es›</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ln_α (e # es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(e # es, c) ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c = Graph.V c' ∪ {u1, v1}"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>fct4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c' = V'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c = V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s_n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s_n' ∨ u1 = s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ V"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s_n'"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u1 = s"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t_n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t_n' ∨ v1 = t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ V"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t_n'"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 = t"</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬s_n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬s_n' ∧ u1 ≠ s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∉ V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct5</span><span> </span><span>fct1</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬t_n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬t_n' ∧ v1 ≠ t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∉ V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct5</span><span> </span><span>fct1</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u v. (c (u, v) ≥ 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct4</span><span> </span><span>fct1</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. c (u, u) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct4</span><span> </span><span>fct1</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. c (u, s) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct4</span><span> </span><span>fct1</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. c (t, u) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>fct4</span><span> </span><span>fct1</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (a, b) ≠ 0"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀u. c (u, u) = 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (b, a) = 0"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b) = (u1, v1)"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (b, a) = c' (v1, u1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ b›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (v1, u1) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b, a) = (u1, v1)"</span></span></span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (a, b) = c' (v1, u1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ b›</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (v1, u1) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c (a, b) ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (b, a) = c' (b, a)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (a, b) = c' (a, b)"</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(a, b) ≠ (u1, v1)›</span></span></span><span> </span><span>fct4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c (a, b) ≠ 0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>n_fct</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ u1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ a = sc' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (sc' a) = Graph.E c' `` {a} ∧ distinct (sc' a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (succ a) = Graph.E c``{a} ∧ distinct (succ a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ u1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = u1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (succ a) = Graph.E c``{a} ∧ distinct (succ a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (sc' a) = Graph.E c' `` {a} ∧ distinct (sc' a)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ a = v1 # sc' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span>fct6</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c = Graph.E c' ∪ {(u1, v1)}"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∉ set (sc' a)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (a, v1) ≠ 0"</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀u. set (succ u) = Graph.E c `` {u} ∧ distinct (succ u)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ v1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred a = pd' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"set (pd' a) = (Graph.E c')¯ `` {a} ∧ distinct (pd' a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"set (pred a) = (Graph.E c)¯``{a} ∧ distinct (pred a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ v1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = v1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (pred a) = (Graph.E c)¯``{a} ∧ distinct (pred a)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct</span><span class="delimiter">:</span><span> 
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"set (pd' a) = (Graph.E c')¯ `` {a} ∧ distinct (pd' a)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred a = u1 # pd' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span>fct7</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c = Graph.E c' ∪ {(u1, v1)}"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u1 ∉ set (pd' a)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, a) ≠ 0"</span></span></span><span> 
</span><span>                        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀u. set (pred u) = (Graph.E c)¯`` {u} ∧ distinct (pred u)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ u1 ∧ a ≠ v1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjmap a = ps' a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (ps' a) = 
              Graph.E c'``{a} ∪ (Graph.E c')¯``{a} ∧ distinct (ps' a)"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"set (adjmap a) = Graph.E c``{a} ∪ (Graph.E c)¯``{a} 
                ∧ distinct (adjmap a)"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ u1 ∧ a ≠ v1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = u1 ∨ a = v1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"set (adjmap a) = Graph.E c``{a} ∪ (Graph.E c)¯``{a} 
              ∧ distinct (adjmap a)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = u1"</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) = 0 ∧ c' (v1, u1) = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct</span><span class="delimiter">:</span><span> 
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"set (ps' a) = Graph.E c' `` {a} ∪ (Graph.E c')¯ `` {a} 
                      ∧ distinct (ps' a)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                    
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjmap a = v1 # ps' a"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span>fct8</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c = Graph.E c' ∪ {(u1, v1)}"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v1 ∉ set (ps' a)"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (a, v1) ≠ 0 ∨ c' (v1, a) ≠ 0"</span></span></span><span>
</span><span>                          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = u1›</span></span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = v1"</span></span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) = 0 ∧ c' (v1, u1) = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fct</span><span class="delimiter">:</span><span> 
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"set (ps' a) = Graph.E c' `` {a} ∪ (Graph.E c')¯ `` {a} 
                      ∧ distinct (ps' a)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                    
</span><span>                    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjmap a = u1 # ps' a"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span>fct8</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c = Graph.E c' ∪ {(u1, v1)}"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct4</span><span> </span><span>fct0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u1 ∉ set (ps' a)"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ?thesis"</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, a) ≠ 0 ∨ c' (a, u1) ≠ 0"</span></span></span><span>
</span><span>                          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = v1›</span></span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct0</span><span> </span><span>obt3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀u. set (adjmap u) = Graph.E c``{u} ∪ (Graph.E c)¯``{u} 
          ∧ distinct (adjmap u)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>read_correct2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = None ⟹ ¬ln_invar el 
    ∨ (∃u v c. (u,v,c) ∈ set el ∧ ¬(c &gt; 0))
    ∨ (∃u c. (u, u, c) ∈ set el ∧ c ≠ 0) ∨ 
    (∃u c. (u, s, c) ∈ set el ∧ c ≠ 0) ∨ (∃u c. (t, u, c) ∈ set el ∧ c ≠ 0) ∨
    (∃u v c1 c2. (u, v, c1) ∈ set el ∧ (v, u, c2) ∈ set el ∧ c1 ≠ 0 ∧ c2 ≠ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>el</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>el</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = None"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar el"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬distinct (map (λ(u, v, _). (u,v)) (e # el)) ∨ 
                    (∃(u, v, c) ∈ set (e # el). ¬(c&gt;0))"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
                    (∃u v c. (u, v, c) ∈ set (el) ∧ ¬(c &gt; 0)) 
                  ∨ (∃u c. (u, u, c) ∈ set el ∧ c ≠ 0) 
                  ∨ (∃u c. (u, s, c) ∈ set el ∧ c ≠ 0) 
                  ∨ (∃u c. (t, u, c) ∈ set el ∧ c ≠ 0) 
                  ∨ (∃u v c1 c2. (u, v, c1) ∈ set el ∧ (v, u, c2) ∈ set el 
                      ∧ c1 ≠ 0 ∧ c2 ≠ 0)"</span></span></span><span> 
</span><span>                  
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c. (u, v, c) ∈ set el ∧ ¬(c &gt; 0))"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c. (u, v, c) ∈ set (e # el) ∧ ¬(c &gt; 0))"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, u, c) ∈ set el ∧ c ≠ 0)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, u, c) ∈ set (e # el) ∧ c ≠ 0)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, s, c) ∈ set el ∧ c ≠ 0)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, s, c) ∈ set (e # el) ∧ c ≠ 0)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (t, u, c) ∈ set el ∧ c ≠ 0)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (t, u, c) ∈ set (e # el) ∧ c ≠ 0)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c1 c2. 
                      (u, v, c1) ∈ set el ∧ (v, u, c2) ∈ set el 
                        ∧ c1 ≠ 0 ∧ c2 ≠ 0)"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c1 c2. (u, v, c1) ∈ set (e # el) ∧
                      (v, u, c2) ∈ set (e # el) ∧ c1 ≠ 0 ∧ c2 ≠ 0)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1</span><span> </span><span>v1</span><span> </span><span>c1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e = (u1, v1, c1)"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span>V'</span><span> </span><span>sc'</span><span> </span><span>pd'</span><span> </span><span>ps'</span><span> </span><span>s_n'</span><span> </span><span>t_n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = 
              ⦇
                pn_c = c', pn_V = V', pn_succ = sc',
                pn_pred = pd', pn_adjmap = ps',
                pn_s_node = s_n', pn_t_node = t_n'
              ⦈"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, c') ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' = ln_α el"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c' (u1, v1) ≠ 0 ∨ c' (v1, u1) ≠ 0 ∨ c1 ≤ 0) ∨ 
              (c1 &gt; 0 ∧ (u1 = v1 ∨ v1 = s ∨ u1 = t))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt1</span><span> </span><span>obt2</span><span> </span><span>obt3</span><span> </span><span>False</span><span> </span><span>Cons.prems</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 ≤ 0"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ln_invar (e # el)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 &gt; 0 ∧ u1 = v1"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, u, c) ∈ set (e # el) ∧ c &gt; 0)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 &gt; 0 ∧ v1 = s"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, s, c) ∈ set (e # el) ∧ c &gt; 0)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 &gt; 0 ∧ u1 = t"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (t, u, c) ∈ set (e # el) ∧ c &gt; 0)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (u1, v1) ≠ 0"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c1'. (u1, v1, c1') ∈ set el"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c' = ln_α el›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ distinct (map (λ(u, v, _). (u, v)) (e # el))"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar (e # el)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' (v1, u1) ≠ 0"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c1'. (v1, u1, c1') ∈ set el ∧ c1' ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c' = ln_α el›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar (e # el) ∨ (
                ∃u v c1 c2.
                  (u, v, c1) ∈ set (e # el) ∧ (v, u, c2) ∈ set (e # el) 
                  ∧ c1 ≠ 0 ∧ c2 ≠ 0)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c1 ≠ 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃c1'. (v1, u1, c1') ∈ set el  ∧ c1' ≠ 0›</span></span></span><span> </span><span>obt2</span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar (e # el)"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_invar_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Pre-Networks›</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="tfree">'capacity</span><span class="delimiter">::</span><span>linordered_idom</span><span> </span><span>pre_network'</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>pn_c'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat*nat,'capacity) ArrayHashMap.ahm"</span></span></span><span>
</span><span>    </span><span>pn_V'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ahs"</span></span></span><span>
</span><span>    </span><span>pn_succ'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat list) ArrayHashMap.ahm"</span></span></span><span>
</span><span>    </span><span>pn_pred'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat list) ArrayHashMap.ahm"</span></span></span><span>
</span><span>    </span><span>pn_adjmap'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat list) ArrayHashMap.ahm"</span></span></span><span>
</span><span>    </span><span>pn_s_node'</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>    </span><span>pn_t_node'</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pnet_α pn' ≡ ⦇
      pn_c = the_default 0 o (ahm.α (pn_c' pn')), 
      pn_V = ahs_α (pn_V' pn'), 
      pn_succ = the_default [] o (ahm.α (pn_succ' pn')),
      pn_pred = the_default [] o (ahm.α (pn_pred' pn')),
      pn_adjmap = the_default [] o (ahm.α (pn_adjmap' pn')), 
      pn_s_node = pn_s_node' pn', 
      pn_t_node = pn_t_node' pn'
  ⦈"</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pnet_rel ≡ br pnet_α (λ_. True)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ahm_ld a ahm k ≡ the_default a (ahm.lookup k ahm)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cap_lookup ≡ ahm_ld 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ_lookup ≡ ahm_ld []"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>read'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × nat × 'capacity::linordered_idom) list ⇒ nat ⇒ nat ⇒
    'capacity pre_network' option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"read' [] _ _ = Some ⦇
      pn_c' = ahm.empty (), 
      pn_V' = ahs.empty (), 
      pn_succ' = ahm.empty (),
      pn_pred' = ahm.empty (),
      pn_adjmap' = ahm.empty (), 
      pn_s_node' = False, 
      pn_t_node' = False
    ⦈"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"read' ((u, v, c) # es) s t = ((case (read' es s t) of 
      Some x ⇒
        (if 
          cap_lookup (pn_c' x) (u, v) = 0 
          ∧ cap_lookup (pn_c' x) (v, u) = 0 ∧ c &gt; 0 
         then
          (if u = v ∨ v = s ∨ u = t then
            None
          else
            Some (x⦇ 
              pn_c' := ahm.update (u, v) c (pn_c' x),
              pn_V' := ahs.ins u (ahs.ins v (pn_V' x)),
              pn_succ' := 
                ahm.update u (v # (succ_lookup (pn_succ' x) u)) (pn_succ' x),
              pn_pred' := 
                ahm.update v (u # (succ_lookup (pn_pred' x) v)) (pn_pred' x),
              pn_adjmap' := ahm.update 
                u (v # (succ_lookup (pn_adjmap' x) u)) (ahm.update 
                v (u # (succ_lookup (pn_adjmap' x) v)) 
                (pn_adjmap' x)),
              pn_s_node' := pn_s_node' x ∨ u = s,
              pn_t_node' := pn_t_node' x ∨ v = t
            ⦈))
        else
          None)
    | None ⇒ None))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>read'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = map_option pnet_α (read' el s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>read.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pnet_α_def</span><span> </span><span>o_def</span><span> </span><span>ahm.correct</span><span> </span><span>ahs.correct</span><span> </span><span>ahm_ld_def</span><span> 
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Takes long *)</span></span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>read'_correct_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(read' el s t, read el s t) ∈ ⟨pnet_rel⟩option_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option_rel_def</span><span> </span><span>read'_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domIff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>read</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>     
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Usefulness Check›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    We have to check that every node in the network is useful,
    i.e., lays on a path from source to sink.
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_spec c s ≡ RETURN (((Graph.E c)<span class="hidden">⇧</span><sup>*</sup>)``{s}) "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reaching_spec c t ≡ RETURN ((((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup>)``{t})"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet cc s t ≡ do {
    if s = t then
      RETURN None
    else do {
      let rd = read cc s t;
      case rd of 
        None ⇒ RETURN None
      | Some x ⇒ do {                
          if pn_s_node x ∧ pn_t_node x then
            do {
              ASSERT(finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}));
              ASSERT(∀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} 
                ∧ distinct ((pn_succ x) u));
              ASSERT(∀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u}   
                ∧ distinct ((pn_pred x) u));
              
              succ_s ← reachable_spec (pn_c x) s;
              pred_t ← reaching_spec (pn_c x) t;
              if (pn_V x) = succ_s ∧ (pn_V x) = pred_t then
                RETURN (Some (pn_c x, pn_adjmap x))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet_pre_correct1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet el s t ≤ 
    SPEC (λ r. r = Some (c, adjmap) ⟶ (el, c) ∈ ln_rel ∧ Network c s t ∧ 
    (∀u. set (adjmap u) = Graph.E c``{u} ∪ (Graph.E c)¯``{u} 
      ∧ distinct (adjmap u)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checkNet_def</span><span> </span><span>reachable_spec_def</span><span> </span><span>reaching_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>adjmap</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = 
            ⦇
              pn_c = c, pn_V = V,
              pn_succ = sc, pn_pred = pd,  pn_adjmap = adjmap, 
              pn_s_node = True, pn_t_node = True
            ⦈"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm3</span><span> </span><span>asm4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇
            pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
            pn_adjmap = adjmap, pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Graph.V c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c ⊆ (Graph.V c) × (Graph.V c)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Graph.E (pn_c x))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obt</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t})"</span></span></span><span>  
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_rtrancl_Image</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t})"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span> 
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>adjmap</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V,
            pn_succ = sc, pn_pred = pd,  pn_adjmap = adjmap, 
            pn_s_node = True, pn_t_node = True⦈"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span> </span><span>asm6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, 
            pn_succ = sc, pn_pred = pd, pn_adjmap = adjmap, 
            pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_succ x) u) 
            = Graph.E (pn_c x) `` {u} ∧ distinct ((pn_succ x) u)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u} ∧ 
            distinct ((pn_pred x) u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u}"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. distinct ((pn_succ x) u)"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u}"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u.  distinct ((pn_pred x) u)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm5</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} = (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_V x = (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}"</span></span></span><span> 
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = pn_c x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjmap = pn_adjmap x"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V,
            pn_succ = sc, pn_pred = pd,  pn_adjmap = adjmap, 
            pn_s_node = True, pn_t_node = True⦈"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm3</span><span> </span><span>asm4</span><span> </span><span>asm7</span><span> </span><span>asm8</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, 
            pn_succ = sc, pn_pred = pd, pn_adjmap = adjmap, 
            pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} 
            ∧ distinct ((pn_succ x) u)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u} ∧ 
            distinct ((pn_pred x) u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, pn_c x) ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>asm7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c ⊆ ((Graph.E c))<span class="hidden">⇧</span><sup>*</sup> `` {s}"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm6</span><span> </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈(Graph.V c). Graph.isReachable c s v"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.connected_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.rtc_isPath</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c ⊆ ((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span> </span><span>asm6</span><span> </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈(Graph.V c). Graph.isReachable c v t"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.connected_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.rtci_isPath</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"∀v∈(Graph.V c). Graph.isReachable c s v 
                ∧ Graph.isReachable c v t"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Graph.V c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ (Graph.V c)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Graph.reachable_ss_V</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ (Graph.V c)›</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite (Graph.V c)›</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (pn_c x) s t"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm1</span><span> </span><span>fct</span><span> </span><span>asm7</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u.(set (pn_adjmap x u) =
            Graph.E (pn_c x) `` {u} ∪ (Graph.E (pn_c x))¯ `` {u})"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. distinct (pn_adjmap x u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, pn_c x) ∈ ln_rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (pn_c x) s t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"⋀u. set (pn_adjmap x u) 
              = Graph.E (pn_c x) `` {u} ∪ (Graph.E (pn_c x))¯ `` {u}"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. distinct (pn_adjmap x u)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet_pre_correct2_aux</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀u. set (pn_succ x u) = Graph.E (pn_c x) `` {u} ∧ distinct (pn_succ x u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. set (pn_pred x u) = (Graph.E (pn_c x))¯ `` {u} 
      ∧ distinct (pn_pred x u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_V x = (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s} 
      ⟶ (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s} ≠ ((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar el"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (ln_α el) s t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>ps</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V, 
        pn_succ = sc, pn_pred = pd, pn_adjmap = ps, 
        pn_s_node = True, pn_t_node = True⦈"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm3</span><span> </span><span>asm4</span><span> </span><span>asm6</span><span> </span><span>asm7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, 
        pn_succ = sc, pn_pred = pd, pn_adjmap = ps, 
        pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_V x ≠ (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s} 
        ∨ (pn_V x = (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s} 
            ∧ ((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ≠ (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_V x = (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s} ∧ 
            ((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ≠ (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(Graph.V c ⊆ ((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}) 
            ∨ ¬(((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ⊆ Graph.V c)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span>  </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v∈(Graph.V c). ¬Graph.isReachable c v t"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ⊆ Graph.V c)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ∧ x ∉ Graph.V c"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. Graph.isPath c x p t"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.rtci_isPath</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c x p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Graph.V c"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = t"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graph.isPath c x p t›</span></span></span><span> </span><span>Graph.isPath.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = p1 # ps"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c x (p1 # ps) t"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graph.isPath c x p t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst p1 = x ∧ c p1 ≠ 0"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.isPath_head</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>x</span><span> </span><span>p1</span><span> </span><span>ps</span><span> </span><span>t</span><span class="delimiter">]</span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v. c (x, v) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Graph.V c"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(Graph.V c ⊆ ((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t})"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ ((Graph.E c)¯)<span class="hidden">⇧</span><sup>*</sup> `` {t} ∧ x ∈ Graph.V c"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x , t) ∉ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Image_singleton_iff</span><span> </span><span>rtrancl_converseI</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. ¬Graph.isPath c x p t"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬?thesis"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c x p t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.isPath_rtc</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(x , t) ∉ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup>›</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Graph.isReachable c x t"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, c) ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ln_α el"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Network (ln_α el) s t"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_V x ≠ (Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}"</span></span></span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(Graph.V c ⊆ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s}) 
            ∨ ¬((Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s} ⊆ Graph.V c)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span>  </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v∈(Graph.V c). ¬Graph.isReachable c s v"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬((Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s} ⊆ Graph.V c)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ∈ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s} ∧ x ∉ Graph.V c"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. Graph.isPath c s p x"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.rtc_isPath</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c s p x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Graph.V c"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = s"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graph.isPath c s p x›</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.isPath.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = ps @ [p1]"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_butlast_last_id</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c s (ps @ [p1]) x"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graph.isPath c s p x›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd p1 = x ∧ c p1 ≠ 0"</span></span></span><span>
</span><span>                      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.isPath_tail</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>ps</span><span> </span><span>p1</span><span> </span><span>x</span><span class="delimiter">]</span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v. c (v, x) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Graph.V c"</span></span></span><span> 
</span><span>                      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span>Graph.E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(Graph.V c ⊆ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup> `` {s} ∧ x ∈ Graph.V c"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s , x) ∉ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Image_singleton_iff</span><span> </span><span>rtrancl_converseI</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. ¬Graph.isPath c s p x"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬?thesis"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c s p x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.isPath_rtc</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(s, x) ∉ (Graph.E c)<span class="hidden">⇧</span><sup>*</sup>›</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Graph.isReachable c s x"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.connected_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, c) ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ln_α el"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Network (ln_α el) s t"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm9</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet_pre_correct2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"checkNet el s t 
    ≤ SPEC (λr. r = None ⟶ ¬ln_invar el ∨ ¬Network (ln_α el) s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checkNet_def</span><span> </span><span>reachable_spec_def</span><span> </span><span>reaching_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar el"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (ln_α el) t t"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar el"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (ln_α el) s t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>read_correct2</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹read el s t = None›</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar el"</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ln_invar el›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"
              (∃u v c. (u, v, c) ∈ set el ∧ ¬(c &gt; 0)) 
            ∨ (∃u c. (u, u, c) ∈ set el ∧ c≠0) 
            ∨ (∃u c. (u, s, c) ∈ set el ∧ c≠0) 
            ∨ (∃u c. (t, u, c) ∈ set el ∧ c≠0) 
            ∨ (∃u v c1 c2. (u, v, c1) ∈ set el 
                ∧ (v, u, c2) ∈ set el ∧ c1≠0 ∧ c2≠0)"</span></span></span><span>
</span><span>            
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c. (u, v, c) ∈ set el ∧ ¬(c&gt;0))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ln_invar el"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_invar_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ln_invar el›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, u, c) ∈ set el ∧ c≠0)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ u. ln_α el (u, u) ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Network (ln_α el) s t›</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (u, s, c) ∈ set el ∧ c≠0)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ u. ln_α el (u, s) ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Network (ln_α el) s t›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u c. (t, u, c) ∈ set el ∧ c≠0)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ u. ln_α el (t, u) ≠ 0"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Network (ln_α el) s t›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃u v c1 c2. 
                (u, v, c1) ∈ set el ∧ (v, u, c2) ∈ set el ∧ c1≠0 ∧ c2≠0)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                </span><span>o1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v, c1) ∈ set el ∧ (v, u, c2) ∈ set el 
                    ∧ c1≠0 ∧ c2≠0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_α el (u, v) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_α el (v, u) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_α_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o1</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"¬ (∀u v. (ln_α el) (u, v) ≠ 0 ⟶ (ln_α el) (v, u) = 0)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Network (ln_α el) s t›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Network_def</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>adjmap</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V,
          pn_succ = sc, pn_pred = pd,  pn_adjmap = adjmap, 
          pn_s_node = True, pn_t_node = True⦈"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm3</span><span> </span><span>asm4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, 
          pn_succ = sc, pn_pred = pd, pn_adjmap = adjmap, 
          pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Graph.V c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c ⊆ (Graph.V c) × (Graph.V c)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.V_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (Graph.E (pn_c x))"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obt</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t})"</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_rtrancl_Image</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t})"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_t_node x"</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>adjmap</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V,
          pn_succ = sc, pn_pred = pd, pn_adjmap = adjmap, 
          pn_s_node = True, pn_t_node = True⦈"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm5</span><span> </span><span>asm6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, pn_succ = sc, 
          pn_pred = pd, pn_adjmap = adjmap, pn_s_node = True, pn_t_node = True⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} 
          ∧ distinct ((pn_succ x) u)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u} ∧ 
          distinct ((pn_pred x) u)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u}"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. distinct ((pn_succ x) u)"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u}"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u.  distinct ((pn_pred x) u)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ t"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pn_s_node x ⟶ ¬pn_t_node x"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ln_invar el"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network (ln_α el) s t"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>V</span><span> </span><span>sc</span><span> </span><span>pd</span><span> </span><span>ps</span><span> </span><span>s_node</span><span> </span><span>t_node</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>obt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ⦇pn_c = c, pn_V = V, pn_succ = sc, pn_pred = pd, 
          pn_adjmap = ps, pn_s_node = s_node, pn_t_node = t_node⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"read el s t = Some ⦇pn_c = c, pn_V = V, pn_succ = sc, 
          pn_pred = pd, pn_adjmap = ps, pn_s_node = s_node, pn_t_node = t_node⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fct</span><span> </span><span class="delimiter">=</span><span> </span><span>read_correct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(el, c) ∈ ln_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span>obt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ln_α el"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬pn_s_node x ∨ ¬pn_t_node x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬pn_s_node x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬s_node"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∉ Graph.V c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c = ln_α el›</span></span></span><span> </span><span>asm5</span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬pn_t_node x"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬t_node"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obt</span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∉ Graph.V c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c = ln_α el›</span></span></span><span> </span><span>asm5</span><span> </span><span>Network_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>checkNet_pre_correct2_aux</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet_correct'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet el s t ≤ SPEC (λ r. case r of 
      Some (c, adjmap) ⇒
        (el, c) ∈ ln_rel ∧ Network c s t 
        ∧ (∀u. set (adjmap u) = Graph.E c``{u} ∪ (Graph.E c)¯``{u} 
           ∧ distinct (adjmap u))
    | None ⇒ ¬ln_invar el ∨ ¬Network (ln_α el) s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>checkNet_pre_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>checkNet_pre_correct2</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet_correct</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet el s t ≤ SPEC (λr. case r of 
      Some (c, adjmap) ⇒ (el, c) ∈ ln_rel ∧ Network c s t 
        ∧ Graph.is_adj_map c adjmap
    | None ⇒ ¬ln_invar el ∨ ¬Network (ln_α el) s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>checkNet_pre_correct1</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>checkNet_pre_correct2</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.is_adj_map_def</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Usefulness Check›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We use the DFS framework to implement the usefulness check.
    We have to convert between our graph representation and the CAVA automata 
    library's graph representation used by the DFS framework.
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_of pn s ≡ ⦇
    g_V = UNIV,
    g_E = Graph.E (pn_c pn),
    g_V0 = {s}
  ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_graph_of pn s ≡ ⦇
    g_V = UNIV,
    g_E = (Graph.E (pn_c pn))¯,
    g_V0 = {s}
  ⦈"</span></span></span><span>
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet2 cc s t ≡ do {
    if s = t then
      RETURN None
    else do {
      let rd = read cc s t;
      case rd of 
        None ⇒ RETURN None
      | Some x ⇒ do {                
          if pn_s_node x ∧ pn_t_node x then
            do {
              ASSERT(finite ((Graph.E (pn_c x))<span class="hidden">⇧</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c x))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}));
              ASSERT(∀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} 
                ∧ distinct ((pn_succ x) u));
              ASSERT(∀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u} 
                ∧ distinct ((pn_pred x) u));
              
              let succ_s = (op_reachable (graph_of x s));
              let pred_t = (op_reachable (rev_graph_of x t));
              if (pn_V x) = succ_s ∧ (pn_V x) = pred_t then
                RETURN (Some (pn_c x, pn_adjmap x))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet2_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet2 c s t ≤ checkNet c s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checkNet_def</span><span> </span><span>checkNet2_def</span><span> </span><span>graph_of_def</span><span> </span><span>rev_graph_of_def</span><span> 
</span><span>      </span><span>reachable_spec_def</span><span> </span><span>reaching_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_of_impl pn' s ≡ ⦇
    gi_V = λ_. True,
    gi_E = succ_lookup (pn_succ' pn'),
    gi_V0 = [s]
  ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_graph_of_impl pn' t ≡ ⦇
    gi_V = λ_. True,
    gi_E = succ_lookup (pn_pred' pn'),
    gi_V0 = [t]
  ⦈"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_formed_pn x ≡ 
    (∀u. set ((pn_succ x) u) = Graph.E (pn_c x) `` {u} 
      ∧ distinct ((pn_succ x) u))"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_well_formed_pn x ≡ 
    (∀u. set ((pn_pred x) u) = (Graph.E (pn_c x))¯ `` {u} 
      ∧ distinct ((pn_pred x) u))"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_slg_rel_alt_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩slg_rel 
    = { (s,E). ∀u. distinct (s u) ∧ set (s u) = E``{u} }"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>slg_rel_def</span><span> </span><span>br_def</span><span> </span><span>list_set_rel_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_relD</span><span class="delimiter">)</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>graph_of_impl_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"well_formed_pn pn ⟹ (pn', pn) ∈ pnet_rel ⟹
    (graph_of_impl pn' s, graph_of pn s) ∈ ⟨unit_rel,Id⟩g_impl_rel_ext"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>graph_of_impl_def</span><span> </span><span>graph_of_def</span><span>
</span><span>      </span><span>g_impl_rel_ext_def</span><span> </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>list_set_rel_def</span><span> 
</span><span>        </span><span>id_slg_rel_alt_a</span><span> </span><span>ahm_ld_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>well_formed_pn_def</span><span> </span><span>Graph.E_def</span><span> 
</span><span>        </span><span>pnet_α_def</span><span> </span><span>o_def</span><span> </span><span>ahm_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_graph_of_impl_correct</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⟦rev_well_formed_pn pn; (pn',pn)∈pnet_rel⟧ 
    ⟹ 
    (rev_graph_of_impl pn' s, rev_graph_of pn s) ∈ ⟨unit_rel,Id⟩g_impl_rel_ext"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>rev_graph_of_impl_def</span><span> </span><span>rev_graph_of_def</span><span>
</span><span>      </span><span>g_impl_rel_ext_def</span><span> </span><span>gen_g_impl_rel_ext_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>list_set_rel_def</span><span> 
</span><span>        </span><span>id_slg_rel_alt_a</span><span> </span><span>ahm_ld_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rev_well_formed_pn_def</span><span> </span><span>Graph.E_def</span><span> </span><span>pnet_α_def</span><span> 
</span><span>        </span><span>o_def</span><span> </span><span>ahm_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>   
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>reachable_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E G)<span class="hidden">⇧</span><sup>*</sup> `` g_V0 G)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Gi,G)∈⟨unit_rel,nat_rel⟩g_impl_rel_ext"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (?c::?'c) ≤ ⇓?R (RETURN (op_reachable G))"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>autoref_monadic</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>reachable_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>reachable_impl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>reachable_impl.refine</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>sets_eq_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat set"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ai,a) ∈ ⟨nat_rel⟩ahs.rel"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bi,b) ∈ ⟨nat_rel⟩dflt_ahs_rel"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c, (a ::: ⟨nat_rel⟩ahs.rel) = (b ::: ⟨nat_rel⟩dflt_ahs_rel )) 
        ∈ bool_rel"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>sets_eq_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>sets_eq_impl</span><span>  
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"net_α ≡ (λ(ci, adjmapi) . 
    ((the_default 0 o (ahm.α ci)), (the_default [] o (ahm.α adjmapi))))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"net_α (ci, adjmapi) = (
    cap_lookup ci, succ_lookup adjmapi
    )"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>net_α_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ahm.correct</span><span> </span><span>ahm_ld_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet3 cc s t ≡ do {
    if s = t then
      RETURN None
    else do {
      let rd = read' cc s t;
      case rd of 
        None ⇒ RETURN None
      | Some x ⇒ do {                
          if pn_s_node' x ∧ pn_t_node' x then
            do {
              ASSERT(finite ((Graph.E (pn_c (pnet_α x)))<span class="hidden">⇧</span><sup>*</sup> `` {s}));
              ASSERT(finite (((Graph.E (pn_c (pnet_α x)))¯)<span class="hidden">⇧</span><sup>*</sup> `` {t}));
              ASSERT(∀u. set ((pn_succ (pnet_α x)) u) =
                Graph.E (pn_c (pnet_α x)) `` {u} 
                ∧ distinct ((pn_succ (pnet_α x)) u));
              ASSERT(∀u. set ((pn_pred (pnet_α x)) u) = 
                (Graph.E (pn_c (pnet_α x)))¯ `` {u} 
                ∧ distinct ((pn_pred (pnet_α x)) u));
            
              let succ_s = (reachable_impl (graph_of_impl x s));
              let pred_t = (reachable_impl (rev_graph_of_impl x t));
              if (sets_eq_impl (pn_V' x) succ_s) 
                ∧ (sets_eq_impl (pn_V' x) pred_t) 
              then
                RETURN (Some (net_α (pn_c' x, pn_adjmap' x)))
              else
                RETURN None
            }
          else
            RETURN None
        }
      }
    }"</span></span></span><span>     
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x', x) ∈ pnet_rel ⟹ (pn_V' x', pn_V x) ∈ br ahs.α ahs.invar"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span> </span><span>pnet_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph (graph_of pn s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_of_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph (rev_graph_of pn s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rev_graph_of_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sets_eq_impl_correct_aux1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pn', pn) ∈ pnet_rel"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"well_formed_pn pn"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((Graph.E (pn_c (pnet_α pn')))<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sets_eq_impl (pn_V' pn') (reachable_impl (graph_of_impl pn' s))
      ⟷ pn_V pn = (g_E (graph_of pn s))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (graph_of pn s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S1i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pn_V' pn', pn_V pn) ∈ br ahs.α ahs.invar"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span> </span><span>pnet_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>GI</span><span> </span><span class="delimiter">=</span><span> </span><span>graph_of_impl_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>WF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph (graph_of pn s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (graph_of pn s))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (graph_of pn s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>graph_of_def</span><span> </span><span>pnet_α_def</span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S2i</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_impl.refine</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F'</span><span> </span><span>G</span><span> </span><span>GI</span><span class="delimiter">]</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sets_eq_impl.refine</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>S1i</span><span> </span><span>S2i</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sets_eq_impl_correct_aux2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pn', pn) ∈ pnet_rel"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev_well_formed_pn pn"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (((Graph.E (pn_c (pnet_α pn')))¯)<span class="hidden">⇧</span><sup>*</sup> `` {s})"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sets_eq_impl (pn_V' pn') (reachable_impl (rev_graph_of_impl pn' s))
      ⟷ pn_V pn = (g_E (rev_graph_of pn s))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (rev_graph_of pn s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S1i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pn_V' pn', pn_V pn) ∈ br ahs.α ahs.invar"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span> </span><span>pnet_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>GI</span><span> </span><span class="delimiter">=</span><span> </span><span>rev_graph_of_impl_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>WF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph (rev_graph_of pn s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ((g_E (rev_graph_of pn s))<span class="hidden">⇧</span><sup>*</sup> `` g_V0 (rev_graph_of pn s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rev_graph_of_def</span><span> </span><span>pnet_α_def</span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>S2i</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_impl.refine</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F'</span><span> </span><span>G</span><span> </span><span>GI</span><span class="delimiter">]</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sets_eq_impl.refine</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>S1i</span><span> </span><span>S2i</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet3_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"checkNet3 el s t ≤ checkNet2 el s t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checkNet3_def</span><span> </span><span>checkNet2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>introR</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨pnet_rel⟩option_rel"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>read'_correct_alt</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span> </span><span>pnet_α_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>7</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sets_eq_impl_correct_aux1</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>well_formed_pn_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sets_eq_impl_correct_aux2</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rev_well_formed_pn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>net_α_def</span><span> </span><span>o_def</span><span> </span><span>pnet_α_def</span><span> </span><span>pnet_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>checkNet4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?c ≤ checkNet3 el s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checkNet3_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>checkNet4</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>checkNet4</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checkNet4_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"case checkNet4 el s t of 
      Some (c, adjmap) ⇒ (el, c) ∈ ln_rel 
        ∧ Network c s t ∧ Graph.is_adj_map c adjmap
    | None ⇒ ¬ln_invar el ∨ ¬Network (ln_α el) s t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>checkNet4.refine</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>checkNet3_correct</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>checkNet2_correct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>checkNet_correct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Executable Network Checker›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prepareNet</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge_list ⇒ node ⇒ node 
    ⇒ (capacity_impl graph × (node⇒node list) × nat) option"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Read an edge list and a source/sink node, and return a network graph,
      an adjacency map, and the maximum node number plus one. 
      If the edge list or network is invalid, return ‹NONE›.›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prepareNet el s t ≡ do {
      (c,adjmap) ← checkNet4 el s t;
      let N = ln_N el;
      Some (c,adjmap,N)
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>prepareNet</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prepareNet_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"case (prepareNet el s t) of 
      Some (c, adjmap,N) ⇒ (el, c) ∈ ln_rel ∧ Network c s t 
        ∧ Graph.is_adj_map c adjmap ∧ Graph.V c ⊆ {0..&lt;N}
    | None ⇒ ¬ln_invar el ∨ ¬Network (ln_α el) s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>checkNet4_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>ln_N_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prepareNet_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>