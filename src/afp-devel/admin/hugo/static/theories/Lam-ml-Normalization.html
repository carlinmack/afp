<div id="Lam_ml">
<div class="head"><h1>Theory Lam_ml</h1>
<span class="command">theory</span> <span class="name">Lam_ml</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Nominal/Nominal.html"><span class="name">Nominal</span></a> <a href="../../HOL/HOL-Library/LaTeXsugar.html"><span class="name">LaTeXsugar</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introduction›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lam_ml</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Nominal.Nominal"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.LaTeXsugar"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{chap:formal}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This article contains a formalization of the strong normalization
theorem for the $\lambda_{ml}$-calculus. The formalization is based on a proof
by Lindley and Stark \cite{TT-lifting}. An informal description of the
formalization can be found in \cite{Doczkal:09}.

This formalization extends the example proof of strong normalization for the
simply-typed $\lambda$-calculus, which is included in the Isabelle distribution
\cite{SN.thy}. The parts of the original proof which have been left unchanged
are not displayed in this document.

The next section deals with the formalization of syntax, typing, and
substitution. Section~\ref{sec:reduction} contains the formalization of the
reduction relation. Section~\ref{sec:stacks} defines stacks which are used to
define the reducibility relation in Section~\ref{sec:reducibility-formal}. The
following sections contain proofs about the reducibility relation, ending with
the normalization theorem in Section~\ref{sec:FTLR}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Calculus›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:calc}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">atom_decl</span></span><span> </span><span>name</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_datatype</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>Var</span><span> </span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>App</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Lam</span><span> </span><span class="string"><span class="delete"><span class="delete">"«name»trm"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Λ _ . _"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>120</span><span class="delimiter">]</span><span> </span><span>120</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>To</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"«name»trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ to _ in _"</span></span></span><span> </span><span class="delimiter">[</span><span>141</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>140</span><span class="delimiter">]</span><span> </span><span>140</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Ret</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>trm.inject</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>name_swap_bij</span><span> </span><span class="delimiter">=</span><span> </span><span>pt_swap_bij''</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pt_name_inst</span><span> </span><span>at_name_inst</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ex_fresh</span><span> </span><span class="delimiter">=</span><span> </span><span>exists_fresh'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin_supp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alpha''</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y].t = [x].([(y,x)] ∙ t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ♯ [(y, x)] ∙ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fresh_bij</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[(x,y)]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>perm_swap</span><span> </span><span>calc_atm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span> </span><span>perm_swap</span><span> </span><span>name_swap_bij</span><span> </span><span>fresh_bij</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Even though our types do not involve binders, we still need to formalize
them as nominal datatypes to obtain a permutation action. This is required to
establish equivariance of the typing relation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_datatype</span></span><span> </span><span>ty</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>TBase</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>TFun</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ty"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→"</span></span></span><span> </span><span>200</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>T</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Since we cannot use typed variables, we have to formalize typing
contexts. Typing contexts are formalized as lists. A context is \textit{valid}
if no name occurs twice.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>valid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×ty) list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>v1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>v2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦valid Γ;x♯Γ⟧⟹ valid ((x,σ)#Γ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">equivariance</span></span><span> </span><span>valid</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fresh_ty</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>τ</span><span class="delimiter">::</span><span>ty</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>τ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ty.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fresh_context</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>  </span><span>Γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×ty)list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ Γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃ τ . (x,τ)∈set Γ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Γ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_list_cons</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>typing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×ty) list⇒trm⇒ty⇒bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ : _"</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>t1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦valid Γ; (x,τ)∈set Γ⟧ ⟹ Γ ⊢ Var x : τ"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>t2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Γ ⊢ s : τ→σ; Γ ⊢ t : τ⟧ ⟹ Γ ⊢ App s t : σ"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>t3</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦x ♯ Γ; ((x,τ)#Γ) ⊢ t : σ⟧ ⟹ Γ ⊢ Λ x . t : τ→σ"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>t4</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ Γ ⊢ s : σ ⟧ ⟹ Γ ⊢ [s] : T σ"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>t5</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦x ♯ (Γ,s); Γ ⊢ s : T σ ; ((x,σ)#Γ) ⊢ t : T τ ⟧ 
                ⟹ Γ ⊢ s to x in t : T τ"</span></span></span><span> 
</span><span class="keyword1"><span class="command">equivariance</span></span><span> </span><span>typing</span><span>
</span><span class="keyword1"><span class="command">nominal_inductive</span></span><span> </span><span>typing</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_ty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Except for the explicit requirement that contexts be valid in the
variable case and the freshness requirements in \isa{t3} and \isa{t5}, this
typing
relation is a direct translation of the original typing relation in
\cite{TT-lifting} to Curry-style typing.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>lookup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×trm) list ⇒ name ⇒ trm"</span></span></span><span>   
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lookup [] x        = Var x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup ((y,e)#θ) x = (if x=y then e else lookup θ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_eqvt</span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pi</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name prm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>θ</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"(name×trm) list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pi ∙ (lookup θ x) = lookup (pi ∙ θ) (pi ∙ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>θ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvts</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_primrec</span></span><span>
</span><span>  </span><span>psubst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×trm) list ⇒ trm ⇒ trm"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_&lt;_&gt;"</span></span></span><span> </span><span class="delimiter">[</span><span>95</span><span class="delimiter">,</span><span>95</span><span class="delimiter">]</span><span> </span><span>205</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"θ&lt;Var x&gt; = lookup θ x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;App s t&gt; = App (θ&lt;s&gt;) (θ&lt;t&gt;)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ θ ⟹ θ&lt;Λ x .s&gt; = Λ x . (θ&lt;s&gt;)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;[t]&gt; = [θ&lt;t&gt;]"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ x ♯ θ ; x ♯ t ⟧ ⟹ θ&lt;t to x in s&gt; = (θ&lt;t&gt;) to x in (θ&lt;s&gt;)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>finite_guess</span><span class="delimiter">+</span><span> </span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">,</span><span> </span><span>fresh_guess</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psubst_eqvt</span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pi</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name prm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pi ∙ (θ&lt;t&gt;) = (pi ∙ θ)&lt;(pi ∙ t)&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>θ</span><span> </span><span>rule</span><span class="delimiter">:</span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvts</span><span> </span><span>fresh_bij</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span>  </span><span>subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ name ⇒ trm ⇒ trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_[_::=_]"</span></span></span><span> </span><span class="delimiter">[</span><span>200</span><span class="delimiter">,</span><span>100</span><span class="delimiter">,</span><span>100</span><span class="delimiter">]</span><span> </span><span>200</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t[x::=t']  ≡ ([(x,t')])&lt;t&gt;"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Var x)[y::=v] = (if x = y then v else Var x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(App s t)[y::=v] = App (s[y::=v]) (t[y::=v])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ (y,v) ⟹ (Λ x . t)[y::=v] = Λ x .t[y::=v]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ (s,y,v) ⟹ (s to x in t)[y::=v] = s[y::=v] to x in t[y::=v]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([s])[y::=v] = [s[y::=v]]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_list_cons</span><span> </span><span>fresh_list_nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_rename</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ♯ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([(y,x)]∙t)[y::=v] = t[x::=v]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>calc_atm</span><span> </span><span>fresh_atm</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_aux</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>subst_rename'</span><span> </span><span class="delimiter">=</span><span> </span><span>subst_rename</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t ⟹ t[x::=v] = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fresh_fact</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ v"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t[y::=v]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fresh_fact'</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t[x::=v]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_lemma</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x≠y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s[x::=v][y::=u] = s[y::=u][x::=v[y::=u]]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>s</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_fact</span><span> </span><span>forget</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_subs</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t[x::=Var x] = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span>trm.strong_induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In addition to the facts on simple substitution we also need some facts
on parallel substitution. In particular we want to be able to extend a parallel
substitution with a simple one.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>z</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z♯θ"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z♯x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z♯ lookup θ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lookup.induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_list_cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_fresh'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z♯θ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup θ z = Var z"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lookup.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_list_cons</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psubst_fresh_fact</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ θ"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ θ&lt;t&gt;"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>θ</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span>trm.strong_induct</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lookup_fresh</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psubst_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ θ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;t&gt;[x::=s] = ((x,s)#θ)&lt;t&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>θ</span><span> </span><span>x</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_list_cons</span><span> </span><span>fresh_atm</span><span> </span><span>forget</span><span> 
</span><span>      </span><span>lookup_fresh</span><span> </span><span>lookup_fresh'</span><span> </span><span>fresh_prod</span><span> </span><span>psubst_fresh_fact</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Reduction Relation›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:reduction}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹With substitution in place, we can now define the reduction relation on
$\lambda_{ml}$-terms. To derive strong induction and case rules, all the rules
must be vc-compatible (cf. \cite{nominal-techniques}). This requires some
additional freshness conditions. Note that in this particular case the
additional freshness conditions only serve the technical purpose of
automatically deriving strong reasoning principles. To show that the version
with freshness conditions defines the same relation as the one without the
freshness conditions, we also state this version and prove equality of the two
relations. 

This requires quite some effort and is something that is certainly undesirable
in nominal reasoning. Unfortunately, handling the reduction rule \isa{r10} which
rearranges the binding structure, appeared to be impossible without going
through this.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>std_reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ↝ _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>std_r1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ↝ s' ⟹ App s t ↝ App s' t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ↝ t' ⟹ App s t ↝ App s t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r3</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"App (Λ x . t) s ↝ t[x::=s]"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r4</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ↝ t' ⟹ Λ x . t ↝ Λ x . t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r5</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ t ⟹ Λ x . App t (Var x) ↝ t"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r6</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⟦ s ↝ s' ⟧ ⟹ s to x in t ↝ s' to x in t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r7</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⟦ t ↝ t' ⟧ ⟹ s to x in t ↝ s  to x in t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r8</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"[s] to x in t ↝ t[x::=s]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r9</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ s ⟹ s to x in [Var x] ↝ s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r10</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ x ♯ y; x ♯ u⟧ 
                     ⟹ (s to x in t) to y in u ↝ s to x in (t to y in u)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>std_r11</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↝ s' ⟹ [s] ↝ [s']"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ↦ _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>r1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ↦ s' ⟹ App s t ↦ App s' t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ↦ t' ⟹ App s t ↦ App s t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r3</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ s ⟹ App (Λ x . t) s ↦ t[x::=s]"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>r4</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ↦ t' ⟹ Λ x . t ↦ Λ x . t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r5</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ t ⟹ Λ x . App t (Var x) ↦ t"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>r6</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⟦ x ♯ (s,s') ; s ↦ s' ⟧ ⟹ s to x in t ↦ s' to x in t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r7</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⟦ x ♯ s ; t ↦ t' ⟧ ⟹ s to x in t ↦ s  to x in t'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r8</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ s ⟹ [s] to x in t ↦ t[x::=s]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r9</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ s ⟹ s to x in [Var x] ↦ s"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r10</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ x ♯ (y,s,u) ; y ♯ (s,t) ⟧ 
                  ⟹ (s to x in t) to y in u ↦ s to x in (t to y in u)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>r11</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↦ s' ⟹ [s] ↦ [s']"</span></span></span><span> 
</span><span class="keyword1"><span class="command">equivariance</span></span><span> </span><span>reduction</span><span>
</span><span class="keyword1"><span class="command">nominal_inductive</span></span><span> </span><span>reduction</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_fact'</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In order to show adequacy, the extra freshness conditions in the rules
\isa{r3}, \isa{r6}, \isa{r7}, \isa{r8}, \isa{r9}, and \isa{r10} need to be
discharged.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{pg:alpha-begin}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r3'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x . t) s ↦ t[x::=s]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,t)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x . t) s = App (Λ x' . ([(x,x')] ∙ t)) s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↦ ([(x, x')] ∙ t)[x'::=s]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = t[x::=s]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_rename'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>perm_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r3</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r6'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↦ s'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t ↦ s' to x in t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ (s, s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,s',t)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t = s to x' in ([(x,x')] ∙ t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>s</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↦ s' to x' in ([(x, x')] ∙ t)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = s' to x in t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r6</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r7'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t ↦ s to x in t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ s"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,t',s,x)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t = s to x' in ([(x,x')] ∙ t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([(x,x')] ∙ t) ↦ [(x,x')] ∙ t'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x' in ([(x,x')] ∙ t) ↦ s to x' in ([(x,x')] ∙ t')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t' = s to x' in ([(x,x')] ∙ t')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>trm.inject</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r7</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r8'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[s] to x in t ↦ t[x::=s]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,t)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[s] to x in t = [s] to x' in ([(x,x')] ∙ t)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↦ ([(x, x')] ∙ t)[x'::=s]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = t[x::=s]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_rename'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>perm_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r8</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r9'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in [Var x] ↦ s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ s"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,x)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x' in [Var x'] ↦ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x' in ([Var x']) = s to x in ([Var x])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span> </span><span>fresh_atm</span><span> </span><span>swap_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r9</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹While discharging these freshness conditions is easy for rules involving
only one binder it unfortunately becomes quite tedious for the assoc rule
\isa{r10}. This is due to the complex binding structure of this rule which
includes \textit{four} binding occurrences of two different names. Furthermore,
the binding structure changes from the left to the right: On the left hand
side, $x$ is only bound in $t$, whereas on the right hand side the scope of $x$
extends over the whole term @{term "(t to y in u)"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r10'</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ y"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s to x in t) to y in u ↦ s to x in (t to y in u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="comment">― ‹suitably fresh›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y' ♯ s"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"y' ♯ x"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"y' ♯ t"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"y' ♯ u"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,x,t,u,[(x, x')] ∙ t)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ s"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ y'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ y"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x' ♯ t"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ u"</span></span></span><span>   
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"x' ♯ ([(y,y')] ∙ u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,y',y,t,u,([(y,y')] ∙ u))"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yaux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y' ♯ [(x, x')] ∙ t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_left</span><span> </span><span>perm_fresh_fresh</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s to x in t) to y in u = (s to x in t) to y' in ([(y,y')] ∙ u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' ♯ u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (s to x' in ([(x,x')] ∙ t)) to y' in ([(y,y')] ∙ u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x' ♯ t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↦ s to x' in (([(x,x')] ∙ t) to y' in ([(y,y')] ∙ u))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>yaux</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … = s to x' in (([(x,x')] ∙ t) to y in u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y' ♯ u›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fun_eq1</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = s to x in (t to y in u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>trm.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xf</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[(x,x')] ∙ y = y"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"[(x,x')] ∙ u = u "</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_atm</span><span> </span><span>perm_fresh_fresh</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = s ∧ [x'].([(x, x')] ∙ t) to y in u = [x].t to y in u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">[</span><span>of</span><span> </span><span>x'</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>abs_fresh</span><span> </span><span>abs_fun_eq1</span><span> </span><span>swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>r10</span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{pg:alpha-end}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since now all the introduction rules of the vc-compatible reduction
relation exactly match their standard counterparts, both directions of the
adequacy proof are trivial inductions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>adequacy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↦ t = s ↝ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>reduction.induct</span><span> </span><span>std_reduction.induct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we show that the reduction relation preserves freshness and is in
turn preserved under substitution.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduction_fresh</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ t ⟹ x ♯ t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>t'</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reduction.strong_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_fact</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduction_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" t ↦ t' "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t[x::=v] ↦ t'[x::=v]"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>t'</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reduction.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_atm</span><span> </span><span>fresh_fact</span><span> </span><span>subst_lemma</span><span> </span><span>fresh_prod</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*section {* Strong Normalization *}
text_raw {* \label{sec:SN-formal} *} *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Following \cite{SN.thy}, we use an inductive variant of strong
normalization, as it allows for inductive proofs on terms being strongly
normalizing, without establishing that
the reduction relation is finitely branching.›</span></span></span><span>   
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>SN</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>SN_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ t' . t ↦ t' ⟹ SN t') ⟹ SN t"</span></span></span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
text {* It remains to be shown that this definition actually excludes infinite
sequences of reductions. We define a term $t$ to be diverging, written @{term
"DIV t"}, if there is some infinite sequence $S$ of reductions beginning at
$t$. *}

definition DIV :: "trm ⇒ bool"
where
  "DIV t ≡ ∃ (S::nat ⇒ trm) .  t = S 0 ∧ (∀ n . S n ↦ S (n + 1))"

theorem "SN t ⟹ ¬ DIV t"
proof (induct rule:SN.induct)
  case (SN_intro t)
  have ih: "⋀t'. t ↦ t' ⟹ ¬ DIV t'" by fact
  moreover have "DIV t ⟹ ∃ t' . t ↦ t' ∧ DIV t'"
  proof -
    assume "DIV t" from this obtain S::"nat⇒trm" 
      where S: "t = S 0 ∧ (∀ n . S n ↦ S (n + 1))"
      unfolding DIV_def .. 
    let ?t = "S 1" let ?S = "λ n . S (n + 1)"
    from S have " t ↦ ?t" by auto
    moreover { 
      from S have "?t = ?S 0 ∧ (∀ n . ?S n ↦ ?S (n + 1))" by auto
      hence "DIV ?t" unfolding DIV_def by auto}
    ultimately show ?thesis by blast
  qed
  ultimately show "¬ DIV t" using ih by blast
qed


theorem "¬ SN t ⟹ DIV t"
proof -
  fix t assume t: "¬ SN t"
  let ?NSN = "{ t . ¬ SN t }"
  have "∀ t ∈ ?NSN .  ∃ t' . t ↦ t' ∧ ¬ SN t'"
    by (auto intro: SN_intro)
  hence " ∃ f . ∀ t ∈ ?NSN . t ↦ f t ∧ ¬ SN (f t)"
    by (rule bchoice)
  from this obtain f where f: "∀ t ∈ ?NSN . t ↦ f t ∧ ¬ SN (f t)" ..
  let ?S = "λ n . (f^^n) t"
  { fix n from t f have  "?S n ↦ ?S (n + 1) ∧ ¬ SN (?S (n + 1))"
      by (induct n) auto }
  hence "t = ?S 0 ∧ (∀ n . ?S n ↦ ?S (n + 1))" by auto
  thus "DIV t" unfolding DIV_def  by(rule exI[where x="?S"])
qed

text{* For the normalization theorem, we merely need that strong normalization
is preserved under reduction and some lemmas on normal terms. *}
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_preserved</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NORMAL"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NORMAL t ≡ ¬(∃t'. t ↦ t')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NORMAL (Var x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NORMAL_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>reduction.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_implies_sn</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NORMAL s ⟹ SN s"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NORMAL_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SN_intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stacks›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:stacks}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹As explained in \cite{TT-lifting}, the monadic type structure of
the $\lambda_{ml}$-calculus does not lend itself to an easy definition of a
logical relation along the type structure of the calculus. Therefore, we need to
introduce stacks as an auxiliary notion to handle the monadic type constructor
$T$. Stacks can be thought of as lists of term abstractions @{term "[x].t"}. The
notation for stacks is chosen with this resemblance in mind.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_datatype</span></span><span> </span><span>stack</span><span> </span><span class="delimiter">=</span><span> </span><span>Id</span><span> </span><span class="delimiter">|</span><span> </span><span>St</span><span> </span><span class="string"><span class="delete"><span class="delete">"«name»trm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stack"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"[_]_≫_"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stack_exhaust</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::fs_name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = Id ∨ (∃ y n l  . y ♯ l ∧ y ♯ c ∧ k = [y]n≫l)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stack.strong_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_primrec</span></span><span> 
</span><span>  </span><span>length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"stack ⇒ nat"</span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="string"><span class="delete"><span class="delete">"|_|"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"|Id| = 0"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ♯ L ⟹ length ([y]n≫L) = 1 + |L|"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>finite_guess</span><span class="delimiter">+</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_nat</span><span class="delimiter">,</span><span>fresh_guess</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Together with the stack datatype, we introduce the notion of dismantling
a term onto a stack. Unfortunately, the dismantling operation has no easy
primitive recursive formulation. The Nominal package, however, only provides a
recursion combinator for primitive recursion. This means that for dismantling
one has to prove pattern completeness, right uniqueness, and termination
explicitly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span>
</span><span>  </span><span>dismantle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ stack ⇒ trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⋆ _"</span></span></span><span> </span><span class="delimiter">[</span><span>160</span><span class="delimiter">,</span><span>160</span><span class="delimiter">]</span><span> </span><span>160</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ⋆ Id = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ♯ (K,t) ⟹ t ⋆ ([x]s≫K) = (t to x in s) ⋆ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>    </span><span class="comment">― ‹pattern completeness›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>arg</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"trm × stack"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. arg = (t, stack.Id) ⟹ P"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x K t s. ⟦x ♯ (K, t); arg = (t, [x]s≫K)⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd arg = Id"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>id</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst arg"</span></span></span><span class="delimiter">]</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span> </span><span>n</span><span> </span><span>L</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd arg = [y]n≫L"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"y ♯ (L, fst arg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>st</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst arg"</span></span></span><span class="delimiter">]</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stack_exhaust</span><span class="delimiter">[</span><span>of</span><span>   </span><span class="string"><span class="delete"><span class="delete">"snd arg"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"fst arg"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="comment">― ‹right uniqueness›</span><span>
</span><span>    </span><span class="comment">― ‹only the case of the second equation matching both args needs to be
shown.›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>t'</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span>x'</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span>K'</span><span> </span><span class="delimiter">::</span><span> </span><span>stack</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span>dismantle_sumC</span><span> </span><span class="comment">― ‹graph of dismantle›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ (K, t)"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ (K', t')"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(t, [x]s≫K) = (t', [x']s'≫K')"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?g (t to x in s, K) = ?g (t' to x' in s', K')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?g"</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stack.inject</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stack.inject</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹all other cases are trivial›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>dismantle</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ(t,K). |K| )"</span></span></span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Like all our constructions, dismantling is equivariant. Also, freshness
can be pushed over dismantling, and the freshness requirement in the second
defining equation is not needed›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_eqvt</span><span class="delimiter">[</span><span>eqvt</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name × name) list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pi ∙ (t ⋆ K) =  (pi ∙ t) ⋆ (pi ∙ K)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>K</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>pi</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>stack.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eqvts</span><span> </span><span>fresh_bij</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_fresh</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>  </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ♯ (t ⋆ k)) = (x ♯ t ∧ x ♯ k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stack.strong_induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋆ [y]n≫L = (s to y in n) ⋆ L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ s"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ L"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ n"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,L,n)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s to y in n = s to x in ([(y,x)] ∙ n)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]n≫L = [x]([(y,x)] ∙ n)≫L"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stack.inject</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋆ [y]n≫L = s ⋆ [x]([(y,x)] ∙ n)≫L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … = (s to y in n) ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>trm.inject</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also need a notion of reduction on stacks. This reduction relation
allows us to define strong normalization not only for terms but also for stacks
and is needed to prove the properties of the logical relation later on.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stack_reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"stack ⇒ stack ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">" _ ↦ _ "</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"k ↦ k' ≡ ∀ (t::trm) . (t ⋆ k)  ↦ (t ⋆ k')"</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stack_reduction_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>stack</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ↦ k'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ♯ x"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var z ⋆ k ↦ Var z ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span>f'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ Var z ⋆ k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ Var z ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_red</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" m ↦ m'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ⋆ k ↦ m' ⋆ k"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>m</span><span> </span><span>m'</span><span> </span><span>rule</span><span class="delimiter">:</span><span>stack.strong_induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we define a substitution operation for stacks. The main purpose of
this is to distribute substitution over dismantling.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_primrec</span></span><span>
</span><span>  </span><span>ssubst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"name ⇒ trm ⇒ stack ⇒ stack"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ssubst x v Id = Id"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">" y ♯ (k,x,v)  ⟹ ssubst x v ([y]n≫k) = [y](n[x::=v])≫(ssubst x v k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>finite_guess</span><span class="delimiter">+</span><span> </span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">,</span><span> </span><span>fresh_guess</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ssubst_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" y ♯ (x,v,k) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"y ♯ ssubst x v k"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>x</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stack.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_fact</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ssubst_forget</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>name</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ssubst x v k = k"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stack.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_atm</span><span> </span><span>forget</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_dismantle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t ⋆ k)[x ::= v] = (t[x::=v]) ⋆ ssubst x v k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span>v</span><span>  </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stack.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ssubst_fresh</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_fact</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reducibility for Terms and Stacks›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:reducibility-formal}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Following \cite{SN.thy}, we formalize the logical relation as a function
@{term "RED"} of type @{typ "ty ⇒ trm set"} for the term part and accordingly
@{term SRED} of type @{typ "ty ⇒ stack set"} for the stack part of the logical
relation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ty_exhaust</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty = TBase ∨ (∃ σ τ . ty = σ → τ) ∨ (∃ σ . ty = T σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>ty</span><span> </span><span>rule</span><span class="delimiter">:</span><span>ty.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>RED</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ trm set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>SRED</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ stack set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RED (TBase) = {t. SN(t)}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"RED (τ→σ) = {t. ∀ u ∈ RED τ . (App t u) ∈ RED σ }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"RED (T σ) = {t. ∀ k ∈ SRED σ . SN(t ⋆ k) }"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"SRED τ = {k. ∀ t ∈ RED τ . SN ([t] ⋆ k) }"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ty.inject</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sum.exhaust</span><span class="delimiter">,</span><span>insert</span><span> </span><span>ty_exhaust</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is the second non-primitive function in the formalization. Since
types do not involve binders, pattern completeness and right uniqueness are
mostly trivial. The termination argument is not as simple as for the dismantling
function, because the definiton of @{term "SRED τ"} involves a recursive call to
@{term "RED τ"} without reducing the size of @{term "τ"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nominal_primrec</span></span><span>
</span><span>  </span><span>tsize</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"tsize TBase = 1"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tsize (σ→τ) = 1 + tsize σ + tsize τ"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tsize (T τ) = 1 + tsize τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>TrueI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the termination argument below, @{term "Inl τ"} corresponds to the
call @{term "RED τ"}, whereas @{term "Inr τ"}  corresponds to @{term "SRED τ"}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>RED</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure 
    (λ x . case x of Inl τ ⇒ 2 * tsize τ 
                      | Inr τ ⇒ 2 * tsize τ + 1)"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of the Reducibility Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹After defining the logical relations we need to prove that the relation
implies strong normalization, is preserved under reduction, and satisfies the
head expansion property.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>NEUT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NEUT t ≡ (∃a. t = Var a) ∨ (∃t1 t2. t = App t1 t2)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CR1 τ ≡ ∀t. (t∈RED τ ⟶ SN t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CR2 τ ≡ ∀t t'. (t∈RED τ ∧ t ↦ t') ⟶ t'∈RED τ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3_RED"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ ty ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CR3_RED t τ ≡ ∀t'. t ↦ t' ⟶  t'∈RED τ"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CR3 τ ≡ ∀t. (NEUT t ∧ CR3_RED t τ) ⟶ t∈RED τ"</span></span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR4"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ty ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CR4 τ ≡ ∀t. (NEUT t ∧ NORMAL t) ⟶t∈RED τ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CR3_implies_CR4</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 τ ⟹ CR4 τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR3_def</span><span> </span><span>CR3_RED_def</span><span> </span><span>CR4_def</span><span> </span><span>NORMAL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span>sub_induction</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(u)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈RED τ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 τ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>c3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 σ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>c4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3_RED t (τ→σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(App t u)∈RED σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈RED τ"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⋀u'. ⟦u ↦ u'; u' ∈ RED τ⟧ ⟹ App t u' ∈ RED σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (App t u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NEUT_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3_RED (App t u) σ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR3_RED_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App t u ↦ r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t'. t ↦ t' ∧ r = App t' u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = App t' u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t'∈RED (τ→σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c4</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR3_RED_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App t' u∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u'. u ↦ u' ∧ r = App t u'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ↦ u'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = App t u'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∈RED τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>b1</span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR2_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App t u' ∈ RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x t'. t = Λ x .t'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>t'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Λ x .t'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (Λ x .t')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NEUT_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App t u ∈ RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>FST</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm⇒trm⇒bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">" _ » _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>fst</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(App t s) » t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_of_FST_of_App</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (App t s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. (App t s » z) ⟶ SN z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN.induct</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>FST.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SN_intro</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The lemma above is a simplified version of the one used in
\cite{SN.thy}. Since we have generalized our notion of reduction from terms to
stacks, we can also generalize the notion of strong normalization. The new
induction principle will be used to prove the @{term "T"} case of the
properties of the reducibility relation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>  </span><span>SSN</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"stack ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>SSN_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀ k' . k ↦ k' ⟹ SSN k') ⟹ SSN k"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Furthermore, the approach for deriving strong normalization of
subterms from above can be generalized to terms of the form @{term "t ⋆ k"}. In
contrast to the case of applications, @{term "t ⋆ k"} does \textit{not} uniquely
determine @{term t} and @{term k}. Thus, the extraction is a proper relation in
this case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>SND_DIS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ stack ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊳ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>snd_dis</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ⊳ k"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_SSN</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t ⋆ k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" SSN k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. (t ⋆ k ⊳ z) ⟶ SSN z"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN.induct</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SND_DIS.cases</span><span> </span><span>SSN_intro</span><span> </span><span>snd_dis</span><span> </span><span>stack_reduction_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SSN k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹To prove CR1-3, the authors of
\cite{TT-lifting} use a case distinction on the reducts of @{term "t ⋆ k"},
where $t$ is a neutral term and therefore no interaction occurs between $t$ and
$k$.

%auto generated stuff
\begin{isamarkuptext}%
\renewcommand\isacharquery{}
$$\inferrule{
    \isa{{\isacharquery}t\ {\isasymstar}\ {\isacharquery}k\ {\isasymmapsto}\
{\isacharquery}r}\\
    \isa{{\isasymAnd}t{\isacharprime}{\isachardot}\
{\isasymlbrakk}{\isacharquery}t\ {\isasymmapsto}\
t{\isacharprime}{\isacharsemicolon}\ {\isacharquery}r\ {\isacharequal}\
t{\isacharprime}\ {\isasymstar}\ {\isacharquery}k{\isasymrbrakk}\
{\isasymLongrightarrow}\ {\isacharquery}P}\\
    \isa{NEUT\ {\isacharquery}t}\\
    \isa{{\isasymAnd}k{\isacharprime}{\isachardot}\ {\isasymlbrakk}\
{\isacharquery}k\ {\isasymmapsto}\ k{\isacharprime}\ {\isacharsemicolon}\
{\isacharquery}r\ {\isacharequal}\ {\isacharquery}t\ {\isasymstar}\
k{\isacharprime}{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isacharquery}P}\\
    }{
    \isa{{\isacharquery}P}}$$%
\end{isamarkuptext}%›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We strive for a proof of this rule by structural induction on $k$. The
general idea of the case where @{term "k = [y]n≫l"} is to move the first stack
frame into the term $t$ and then apply the induction hypothesis as a case
rule. Unfortunately, this term is no longer neutral, so, for the induction to go
through, we need to generalize the claim to also include the possible
interactions of non-neutral terms and stacks.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ↦ r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t' . ⟦ t ↦ t' ; r = t' ⋆ k ⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k' . ⟦ k ↦ k' ; r = t ⋆ k' ⟧ ⟹ P"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s y n l .⟦ t = [s] ; k = [y]n≫l ; r = (n[y::=s]) ⋆ l ⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ u x v y n l.⟦ x ♯ y; x ♯ n ; t = u to x in v ; 
             k = [y]n≫l ; r = (u to x in (v to y in n)) ⋆ l ⟧ ⟹ P "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>k</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span>stack.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>St</span><span> </span><span>y</span><span> </span><span>n</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span>  </span><span>yfresh</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ♯ t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ♯ r›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ♯ L›</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>St</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>St</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span>St</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span> </span><span class="delimiter">=</span><span> </span><span>St</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span>St</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>IH</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t to y in n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ba</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>r'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t to y in n ↦ r'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" r = r' ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If @{term "m to y in n"} makes a step we reason by case distinction      
on the successors of @{term "m to y in n"}. We want to use the strong inversion
principle for the reduction relation. For this we need that $y$ is fresh for
@{term "t to y in n"} and $r'$.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>yfresh</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ♯  t to y in n"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"y ♯ r'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≠ y"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z ♯ r'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z ♯ t to y in n"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,r',t to y in n)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>red</span><span>  </span><span>r</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>reduction.strong_cases</span><span>
</span><span>        </span><span class="delimiter">[</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xb</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xc</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xd</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xe</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xf</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xg</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r6</span><span> </span><span>s</span><span> </span><span>t'</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹if $t$ makes a step we use assumption T›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"r' = t' to y in n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span class="delimiter">[</span><span>of</span><span> </span><span>t'</span><span class="delimiter">]</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r7</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>n'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ↦ n'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = t to y in n'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since @{term "k = [y]n≫L"}, the reduction @{thm n} occurs within
        the stack $k$. Hence, we need to establish this stack reduction.›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]n≫L ↦ [y]n'≫L"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u to y in n ↦ u to y in n'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u to y in n) ⋆ L ↦ (u to y in n') ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" u ⋆ [y]n≫L ↦ u ⋆ [y]n'≫L"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t ⋆ [y]n'≫L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>r'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r8</span><span> </span><span>s</span><span> </span><span>_</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹the case of a $\beta$-reduction is exactly B›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = [s]"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"r' = n[y::=s]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L"</span></span></span><span class="delimiter">]</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r9</span><span> </span><span>_</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹The case of an $\eta$-reduction is a stack
reduction as well.›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = [Var y]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = t"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u to y in n ↦ u"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u to y in n) ⋆ L ↦ u ⋆ L "</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋆ [y]n≫L ↦ u ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]n≫L ↦ L"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>r'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r10</span><span> </span><span>u</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹The assoc case holds by A.›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"t = (u to z in v)"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"r' = u to z in (v to y in n)"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"z ♯ (y,n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>y</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>  </span><span class="comment">― ‹No other reductions are possible.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we have to solve the case where a reduction occurs deep within
$L$. We get a reduction of the stack $k$ by moving the first stack frame
``[y]n'' back to the right hand side of the dismantling operator.›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>L'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ↦ L'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = (t to y in n) ⋆ L'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(s to y in n) ⋆ L ↦ (s to y in n) ⋆ L'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋆ [y]n≫L ↦ s ⋆ [y]n≫L'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]n≫L ↦ [y]n≫L'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t ⋆ [y]n≫L'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>K</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span>n'</span><span> </span><span>s</span><span> </span><span>v</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹The ``assoc'' case is again a stack reduction›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ z"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ n'"</span></span></span><span> 
</span><span>      </span><span class="comment">― ‹We get the following equalities›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t to y in n = s to x in v"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"L = [z]n'≫K"</span></span></span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"r = (s to x in v to z in n') ⋆ K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>red</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋆ [y]n≫L = ((u to x in v) to z in n') ⋆ K "</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ x . x ⋆ K"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u to x in v) to z in n' ↦ u to x in (v to z in n')"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((u to x in v) to z in n') ⋆ K ↦ (u to x in (v to z in n')) ⋆ K"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋆ [y]n≫L ↦ (u to x in (v to z in n')) ⋆ K"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>del</span><span class="delimiter">:</span><span>dismantle_simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋆ [y]n≫L ↦ u ⋆ [x](v to z in n')≫K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]n≫L ↦  [x](v to z in n')≫ K"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t ⋆ ([x](v to z in n')≫K)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>red</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>St</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now that we have established the general claim, we can restrict $t$ to
neutral terms only and drop the cases dealing with possible interactions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_cases'</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>T</span><span> </span><span>K</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ↦ r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t' . ⟦ t ↦ t' ; r = t' ⋆ k ⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k' . ⟦ k ↦ k' ; r = t ⋆ k' ⟧ ⟹ P"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span>  
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NEUT_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dismantle_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>k</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_Ret</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[s] ↦ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∃ s' . t = [s'] ∧ s  ↦ s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_Ret</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN u ⟹ SN [u]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>SN.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SN.intros</span><span> </span><span>red_Ret</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹All the properties of reducibility are shown simultaneously by induction
on the type. Lindley and Stark \cite{TT-lifting} only spell out the cases
dealing with the monadic type constructor $T$. We do the same by reusing the
proofs from \cite{SN.thy} for the other cases. To shorten the presentation,
these proofs are omitted›</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RED_props</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 τ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 τ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>τ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ty.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>TBase</span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 TBase"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 TBase"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SN_preserved</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR2_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 TBase"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SN_intro</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR3_def</span><span> </span><span>CR3_RED_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TFun</span><span> </span><span>τ1</span><span> </span><span>τ2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR3_τ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR1_τ2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ RED (τ1 → τ2) ⟹ SN t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED (τ1 → τ2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. u ∈ RED τ1 ⟶ App t u ∈ RED τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ih_CR3_τ1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR4 τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR3_implies_CR4</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (Var a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NEUT_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NORMAL (Var a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_var</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Var a)∈ RED τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR4_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App t (Var a) ∈ RED τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (App t (Var a))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih_CR1_τ2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>SN_of_FST_of_App</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 (τ1 → τ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR2_τ2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 (τ1 → τ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR1_τ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR2_τ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 τ1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR3_τ2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 τ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 (τ1 → τ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR3_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ RED τ1"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT t ∧ CR3_RED t (τ1 → τ2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(u)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>ih_CR1_τ1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(App t u)∈RED τ2"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih_CR2_τ1</span><span> </span><span>ih_CR3_τ2</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sub_induction</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>T</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="comment">― ‹follows from the fact that @{term "Id ∈ SRED σ"}›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR1_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED (T σ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ RED σ"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih_CR1_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ([s])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_Ret</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ([s] ⋆ Id)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∈ SRED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t_red</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>SRED.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="comment">― ‹follows since \isa{SN} is preserved under redcution›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>t'</span><span class="delimiter">::</span><span>trm</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED (T σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_t'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ SRED σ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t_red</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(t ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_t'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ↦ t' ⋆ k"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(t' ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_preserved</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ∈ RED (T σ)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>SRED.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 (T σ)"</span></span></span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CR3 σ›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_CR4_σ</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR4 σ"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t'_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t' . t ↦ t' ⟹ t' ∈ RED (T σ)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>neut_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ SRED σ"</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (Var x)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NEUT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x ∈ RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal_var</span><span> </span><span>ih_CR4_σ</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR4_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ([Var x] ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_red</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SSN k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_SSN</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_red</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span>SSN.induct</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SSN_intro</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k'. ⟦ k ↦ k' ; k' ∈ SRED σ ⟧  ⟹ SN (t ⋆ k')"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ SRED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ↦ r"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neut_t</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>dismantle_cases'</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>T</span><span> </span><span>t'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>t_t'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t' ⋆ k"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_t'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ∈ RED (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>t'_red</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_red</span><span> </span><span>r_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>K</span><span> </span><span>k'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k_k'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ↦ k'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ RED σ"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ([s] ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_red</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[s] ⋆ k ↦ [s] ⋆ k'"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_k'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>   
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ([s] ⋆ k')"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k' ∈ SRED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k_k'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3 (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR3_def</span><span> </span><span>CR3_RED_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The last case above shows that, once all the reasoning principles have
been established, some proofs have a formalization which is amazingly close to
the informal version. For a direct comparison, the informal proof is presented
in Figure~\ref{fig:cr3}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\input{figureCR3}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now that we have established the properties of the reducibility
relation, we need to show that reducibility is preserved by the various term
constructors. The only nontrivial cases are abstraction and sequencing.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstraction Preserves Reducibility›</span></span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Once again we could reuse the proofs from \cite{SN.thy}. The proof uses
the \isa{double-SN} rule and the lemma \isa{red-Lam} below. Unfortunately, this
time the proofs are not fully identical to the proofs in \cite{SN.thy} because
we consider $\beta\eta$-reduction rather than $\beta$-reduction only. However,
the differences are only minor.›</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span>double_SN_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x z.
    ⟦⋀y. x ↦ y ⟹ SN y; ⋀y. x ↦ y ⟹ P y z;
     ⋀u. z ↦ u ⟹ SN u; ⋀u. z ↦ u ⟹ P x u⟧ ⟹ P x z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀b. SN b ⟹ P a b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SN_intro</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>SNI'</span><span> </span><span class="delimiter">=</span><span> </span><span>SN_intro</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>SN.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SN_intro</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>SNI'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>SNI'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN.SN_intro</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>SN_intro</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>double_SN</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(x::trm) (z::trm). 
             ⟦⋀y. x ↦ y ⟹ P y z; ⋀u. z ↦ u ⟹ P x u⟧ ⟹ P x z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>double_SN_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_Lam</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Λ x . t ↦ r"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (∃t'. r = Λ x . t' ∧ t ↦ t') ∨ (t = App r (Var x) ∧ x ♯ r ) "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ♯ x"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z ♯ t"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z ♯ r"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,t,r)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ Λ x . t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reduction.strong_cases</span><span>
</span><span>       </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xb</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xc</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>xd</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xe</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xf</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xg</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>alpha</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abs_RED</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED τ. t[x::=s]∈RED σ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Λ x . t ∈RED (τ→σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x∈RED τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR4 τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RED_props</span><span> </span><span>CR3_implies_CR4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (Var x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NEUT_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NORMAL (Var x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_var</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x∈RED τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR4_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t[x::=Var x]∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>id_subs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RED_props</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Λ x .t∈RED (τ→σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈RED τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RED_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x .t) u ∈ RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b1</span><span> </span><span>b3</span><span> </span><span>b2</span><span> </span><span>asm</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>double_SN</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t'.  ⟦t ↦ t'; u∈RED τ; ∀s∈RED τ. t'[x::=s]∈RED σ⟧ ⟹ App (Λ x
.t') u ∈
RED σ"</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ih2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u'.  ⟦u ↦ u'; u'∈RED τ; ∀s∈RED τ. t[x::=s]∈RED σ⟧ ⟹ App (Λ x
.t) u' ∈
RED σ"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ∈ RED τ"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED τ. t[x::=s]∈RED σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR3_RED (App (Λ x. t) u) σ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CR3_RED_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x .t) u ↦ r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t'. t ↦ t' ∧ r = App (Λ x . t') u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = App (Λ x .t') u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span>
</span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x .t') u∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih1</span><span> </span><span>a1</span><span> </span><span>as1</span><span> </span><span>as2</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>meta_spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>meta_mp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 σ"</span></span></span><span class="delimiter">)</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*A*)</span></span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>CR2_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t[x::=s]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t'[x::=s]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reduction_subst</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*A*)</span></span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RED_props</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rt</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u'. u ↦ u' ∧ r = App (Λ x . t) u'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ↦ u'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = App (Λ x .t) u'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span>
</span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x .t) u'∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih2</span><span> </span><span>b1</span><span> </span><span>as1</span><span> </span><span>as2</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"u'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>meta_spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>meta_mp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"CR2 τ"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>CR2_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"u'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RED_props</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ru</span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = t[x::=u]"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r∈RED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ RED σ"</span></span></span><span> 
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* one wants to use the strong elimination principle; for this one 
             has to know that x♯u *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>red_Lam</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span> </span><span>subst_rename'</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"App s' u = t[x::=u]"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>forget</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NEUT (App (Λ x . t) u)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NEUT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (Λ x . t) u ∈ RED σ"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RED_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>
</span><span>CR3_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sequencing Preserves Reducibility›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This section corresponds to the main part of the paper being formalized
and as such deserves special attention. In the lambda case one has to formalize
doing induction on $\max(s) + max(t)$ for two strongly normalizing terms $s$ and
$t$ (cf. \cite[Section 6.3]{proofs+types}). Above, this was done through a
\isa{double-SN}
rule. The central Lemma 7 of Lindley and Stark's paper uses an even more
complicated induction scheme. They assume terms $p$ and $n$ as well as a stack
$K$ such that @{term "SN(p)"} and @{term "SN(n[x::=p] ⋆ K)"}. The induction is
then done on $|K| + max(n \star K) + max(p)$. See Figure~\ref{fig:lemma7} in
for details.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\input{figureLemma7}›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since we have settled for a different characterization of strong
normalization, we have to derive an induction principle similar in spirit to the
\isa{double-SN} rule. 

Furthermore, it turns out that it is not necessary to formalize the fact that
stack reductions do not increase the length of the stack.\footnote{This
possibility was only discovered \textit{after} having formalized $ K \mapsto K'
\Rightarrow |K| \geq |K'|$. The proof of this seemingly simple fact
was about 90 lines of Isar code.} Doing induction on the sum above, this is
necessary to handle the case of a reduction occurring in $K$. We differ
from \cite{TT-lifting} and establish an induction principle which to some extent
resembles the lexicographic order on $$(\SN,\mapsto) \times (\SN,\mapsto) \times
(\N,&gt;)\,.$$›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>triple_induct</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ (p::trm) (q::trm) (k::stack) . 
  ⟦ ⋀ p' . p ↦ p' ⟹ P p' q k ; 
    ⋀ q' k . q ↦ q' ⟹ P p q' k; 
    ⋀ k' .  |k'| &lt; |k| ⟹ P p q k' ⟧ ⟹ P p q k "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P p q k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀q K . SN q ⟹ P p q K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SN_intro</span><span> </span><span>p</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sn1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ p' q K . ⟦p ↦ p'; SN q⟧ ⟹ P p' q K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sn_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P p q K"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>K</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SN_intro</span><span> </span><span>q</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sn2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ q' K . ⟦q ↦ q'; SN q'⟧ ⟹ P p q' K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P p q K"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>K</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>measure_induct_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"length"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k' . |k'| &lt; |k| ⟹ P p q k'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ↦ p'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P p' q k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>q'</span><span> </span><span>K</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ↦ q'"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_preserved</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P p q' K"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we strengthen the case rule for terms of the form @{term "t ⋆ k ↦
r"}. The freshness requirements on $x$,$y$, and $z$
correspond to those for the rule \isa{reduction.strong-cases}, the strong
inversion principle for the reduction relation.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dismantle_strong_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>trm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋆ k ↦ r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ♯ (t,k,r)"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ (z,t,k,r)"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"z ♯ (t,k,r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t' . ⟦ t ↦ t' ; r = t' ⋆ k ⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ k' . ⟦ k ↦ k' ; r = t ⋆ k' ⟧ ⟹ P"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ s n l . ⟦ t = [s] ; 
                       k = [y]n≫l ; r = (n[y::=s]) ⋆ l ⟧ ⟹ P "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ u v n l . 
           ⟦ x ♯ (z,n); t = u to x in v ; k = [z]n≫l ; 
             r = (u to x in (v to z in n)) ⋆ l ⟧ ⟹ P "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>dismantle_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>k</span><span> </span><span>r</span><span> </span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>s</span><span> </span><span>y'</span><span> </span><span>n</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ch</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t = [s]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"k = [y']n≫L"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r = n[y'::=s] ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The equations we get look almost like those we need to instantiate the
hypothesis \isa{B}. The only difference is that \isa{B} only applies to $y$, and
since we want $y$ to become an instantiation variable of the strengthened rule,
we only know that $y$ satisfies \isa{f} and nothing else. But the condition
\isa{f} is just strong enough to rename $y'$ to $y$ and apply \isa{B}.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = y' ∨ y ♯ n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n[y'::=s] = ([(y,y')] ∙ n)[y::=s]"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y']n≫L = [y]([(y,y')] ∙ n)≫L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>name_swap_bij</span><span> </span><span>subst_rename'</span><span> </span><span>stack.inject</span><span> </span><span>alpha'</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = [s]"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"k = [y]([(y,y')] ∙ n)≫L"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r = ([(y,y')] ∙ n)[y::=s] ⋆ L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>u</span><span> </span><span>x'</span><span> </span><span>v</span><span> </span><span>z'</span><span> </span><span>n</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ch</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x' ♯ z'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x' ♯ n"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t = u to x' in v"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"k = [z']n≫L"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r = (u to x' in v to z' in n) ⋆ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We want to do the same trick as above but at this point we have to take
care of the possibility that $x$ might coincide with $x'$ or $z'$. Similarly,
$z$
might coincide with $z'$.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x' ∨ x ♯ v to z' in n"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = z' ∨ z ♯ n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ n"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">" x' ♯ z'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xz'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = z' ∨ x ♯ n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>name_swap_bij</span><span> </span><span>alpha</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ [z'].n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xz'</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">" x ♯ (z , ([(z, z')] ∙ n))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_atm</span><span> </span><span>fresh_bij</span><span> </span><span>name_swap_bij</span><span> 
</span><span>          </span><span>fresh_prod</span><span> </span><span>abs_fresh</span><span> </span><span>calc_atm</span><span> </span><span>fresh_aux</span><span> </span><span>fresh_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = u to x in ([(x,x')] ∙ v)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>name_swap_bij</span><span> </span><span>alpha'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>z</span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = [z]([(z,z')] ∙ n)≫L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>name_swap_bij</span><span> </span><span>stack.inject</span><span> </span><span>alpha'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The first two $\alpha$-renamings are simple, but here we have to handle
the nested binding structure of the assoc rule. Since $x$ scopes over the whole
term @{term "(v to z' in n)" }, we have to push the swapping over $z'$›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"u to x' in (v to z' in n) = u to x in ([(x,x')] ∙ (v to z' in n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>name_swap_bij</span><span> </span><span>alpha'</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>trm.perm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xz'</span><span> </span><span>x'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = u to x in (([(x,x')] ∙ v) to z' in n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fun_eq1</span><span> </span><span>swap_simps</span><span> </span><span>alpha''</span><span class="delimiter">)</span><span> 
</span><span>           </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alpha''</span><span> </span><span>fresh_atm</span><span> </span><span>perm_fresh_fresh</span><span> </span><span>swap_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … = u to x in (([(x,x')] ∙ v) to z in ([(z,z')] ∙ n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fun_eq1</span><span> </span><span>alpha'</span><span> </span><span>name_swap_bij</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r =  (u to x in (([(x, x')] ∙ v) to z in ([(z, z')] ∙ n))) ⋆ L"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>trm.inject</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>A</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[(z, z')] ∙ n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"([(x, x')] ∙ v)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>r</span><span> </span><span>T</span><span> </span><span>K</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The lemma in Figure~\ref{fig:lemma7} assumes @{term "SN(n[x::=p] ⋆ K)"}
but the actual induction in done on @{term "SN(n ⋆ K)"}. The stronger
assumption @{term "SN (n[x::=p] ⋆ K)"} is needed to handle the $\beta$ and
$\eta$ cases.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sn_forget</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(t[x::=v])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q = t[x::=v]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>q_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>q</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SN_intro</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ t'. ⟦t[x::=v] ↦ t'[x::=v]⟧ ⟹ SN t'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦ t'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t[x::=v] ↦ t'[x::=v]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction_subst</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN t"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sn_forget'</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t[x::=p] ⋆ k)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (t ⋆ k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t[x::=p] ⋆ k = (t ⋆ k)[x::=p]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ssubst_forget</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN( (t ⋆ k)[x::=p] )"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sn_forget</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>redrtrans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"trm ⇒ trm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">" _ ↦<span class="hidden">⇧</span><sup>*</sup> _ "</span></span></span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"redrtrans ≡ reduction^**"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹To be able to handle the case where $p$ makes a step, we need to
establish @{term "p ↦ p' ⟹ (m[x::=p]) ↦<span class="hidden">⇧</span><sup>*</sup> (m[x::=p'])"} as well as the
fact that strong normalization is preserved for an arbitrary number of reduction
steps. The first claim involves a number of simple transitivity lemmas. Here we
can benefit from having removed the freshness conditions from the reduction
relation as this allows all the cases to be proven automatically. Similarly, in
the \isa{red-subst} lemma, only those cases where substitution is pushed to two
subterms needs to be proven explicitly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_trans</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>r1_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" s ↦<span class="hidden">⇧</span><sup>*</sup> s' ⟹ App s t ↦<span class="hidden">⇧</span><sup>*</sup> App s' t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r2_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" t ↦<span class="hidden">⇧</span><sup>*</sup> t' ⟹ App s t ↦<span class="hidden">⇧</span><sup>*</sup> App s t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r4_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↦<span class="hidden">⇧</span><sup>*</sup> t' ⟹ Λ x . t ↦<span class="hidden">⇧</span><sup>*</sup> Λ x . t' "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r6_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" s ↦<span class="hidden">⇧</span><sup>*</sup> s'  ⟹ s to x in t ↦<span class="hidden">⇧</span><sup>*</sup> s' to x in t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r7_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ t ↦<span class="hidden">⇧</span><sup>*</sup> t'  ⟧ ⟹ s to x in t ↦<span class="hidden">⇧</span><sup>*</sup> s  to x in t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r11_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↦<span class="hidden">⇧</span><sup>*</sup> s' ⟹ [s] ↦<span class="hidden">⇧</span><sup>*</sup> ([s'])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span> </span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>
</span><span>transitive_closurep_trans'</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>red_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ↦ p' ⟹ (m[x::=p]) ↦<span class="hidden">⇧</span><sup>*</sup> (m[x::=p'])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>m</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>p</span><span> </span><span>p'</span><span> </span><span>rule</span><span class="delimiter">:</span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>App</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"App (s[x::=p]) (t[x::=p]) ↦<span class="hidden">⇧</span><sup>*</sup> App (s[x::=p']) (t[x::=p])"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>r1_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>App</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↦<span class="hidden">⇧</span><sup>*</sup> App (s[x::=p']) ( t[x::=p'])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>r2_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>To</span><span> </span><span>s</span><span> </span><span>y</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(s[x::=p]) to y in (n[x::=p]) ↦<span class="hidden">⇧</span><sup>*</sup> (s[x::=p']) to y in (n[x::=p])"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>r6_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>To</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … ↦<span class="hidden">⇧</span><sup>*</sup> (s[x::=p']) to y in (n[x::=p']) "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>r7_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>To</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>red_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SN_trans</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦  p ↦<span class="hidden">⇧</span><sup>*</sup> p' ; SN p ⟧ ⟹ SN p' "</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>SN_preserved</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Central lemma›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:central}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now we have everything in place we need to tackle the central ``Lemma
7'' of \cite{TT-lifting} (cf. Figure~\ref{fig:lemma7}). The proof is quite long,
but for the most part, the reasoning is that of \cite{TT-lifting}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_RED_aux</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ p"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>npk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" SN (n[x::=p] ⋆ k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (([p] to x in n) ⋆ k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>q</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN q"</span></span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀ m . ⟦ q = m ⋆ k ; SN(m[x::=p] ⋆ k) ⟧ 
               ⟹ SN (([p] to x in m) ⋆ k)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span>triple_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"k"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹We obtain an induction hypothesis for $p$, $q$, and
$k$.›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_p</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀ p' m . ⟦p ↦ p'; q = m ⋆ k; SN (m[x::=p'] ⋆ k); x ♯ p'; x ♯ k⟧
            ⟹ SN (([p'] to x in m) ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_q</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀ q' m k . ⟦q ↦ q'; q' = m ⋆ k; SN (m[x::=p] ⋆ k); x ♯ p; x ♯ k⟧
            ⟹ SN (([p] to x in m) ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih_k</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"⋀ k' m . ⟦ |k'| &lt; |k|; q = m ⋆ k'; SN (m[x::=p] ⋆ k'); x ♯ p; x ♯ k'⟧
            ⟹ SN (([p] to x in m) ⋆ k')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q = m ⋆ k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (m[x::=p] ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Once again we want to reason via case distinction on the successors of a
term including a dismantling operator. Since this time we also need to handle
the cases where interactions occur, we want to use the strengthened case
rule. We already require $x$ to be suitably fresh. To instantiate the rule, we
need another fresh name.›</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"([p] to x in m) ⋆ k ↦ r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xp</span><span> </span><span>xk</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ ([p] to x in m) ⋆ k "</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>red</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ♯ (x,p,m,k,r)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,p,m,k,r)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>dismantle_strong_cases</span><span>
</span><span>            </span><span class="delimiter">[</span><span>of</span><span>   </span><span class="string"><span class="delete"><span class="delete">"[p] to x in m"</span></span></span><span>   </span><span>k</span><span> </span><span>r</span><span> </span><span>x</span><span> </span><span>x</span><span> </span><span>z</span><span> </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>r'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = r' ⋆ k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[p] to x in m ↦ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹To handle the case of a reduction occurring somewhere in @{term
"[p] to x in m" }, we need to contract the freshness conditions to this subterm.
This allows the use of the strong inversion rule for the reduction relation.›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>r</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(x ♯ [p] to x in m)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xr</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ♯ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ♯ ([p] to x in m)"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ≠ z"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_fresh</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ♯ r'"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment">― ‹handle all reductions of @{term "[p] to x in m"}›</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>reduction.strong_cases</span><span>
</span><span>              </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xb</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xc</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xd</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> 
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xe</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xf</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xg</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The case where @{term "p ↦ p'"} is interesting, because it requires
reasioning about the reflexive transitive closure of the reduction relation.›</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r6</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>t</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[p] ↦ s'"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"r' = s' to x in m"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xl</span><span> </span><span>xr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = [p']"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>p</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ↦ p'"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span>red_Ret</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((m⋆k)[x::=p]) ↦<span class="hidden">⇧</span><sup>*</sup> ((m⋆k)[x::=p'])"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>red_subst</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xk</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((m[x::=p]) ⋆ k) ↦<span class="hidden">⇧</span><sup>*</sup> ((m[x::=p']) ⋆ k)"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ssubst_forget</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ((m[x::=p']) ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SN_trans</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>xp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp'</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ch</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = [p'] to x in m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>q</span><span>  </span><span>sn</span><span> </span><span>xp'</span><span> </span><span>xk</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span>rr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih_p</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>r7</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>m'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = [p] to x in m'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ↦ m'"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xl</span><span> </span><span>xr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = [p] to x in m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ↦ m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"q ↦ m' ⋆ k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dismantle_red</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' ⋆ k = m' ⋆ k"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> </span><span class="comment">― ‹a triviality›</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ↦ m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(m[x::=p]) ⋆ k ↦ (m'[x::=p]) ⋆ k"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dismantle_red</span><span> </span><span>reduction_subst</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(m'[x::=p] ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xp</span><span> </span><span>xk</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span>rr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih_q</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>              
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r8</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹the $\beta$-case is handled by assumption›</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = m[x::=p]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xl</span><span> </span><span>xr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r9</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹the $\eta$-case is handled by assumption as well›</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = [Var x]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = [p]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xl</span><span> </span><span>xr</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = m[x::=p]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>xr</span><span> </span><span>xl</span><span> </span><span>zl</span><span> </span><span>zr</span><span> </span><span>abs_fresh</span><span> </span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment">― ‹There are no other possible reductions of @{term "[p] to x in
m"}.›</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>6</span><span> </span><span>k'</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ↦ k'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = ([p] to x in m) ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ↦ m ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ⋆ k' = m ⋆ k'"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (m[x::=p] ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(m[x::=p]) ⋆ k ↦ (m[x::=p]) ⋆ k'"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stack_reduction_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (m[x::=p] ⋆ k')"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>xp</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>k</span><span> </span><span>xk</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ k'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>stack_reduction_fresh</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih_q</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The case of an assoc interaction between @{term "[p] to x in m" } and
@{term "k"} is easily handled by the induction hypothesis, since @{term
"(m[x::=p]) ⋆ k"} remains fixed under assoc.›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>8</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k = [z]u≫L"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r = ([p] to x in (m to z in u)) ⋆ L"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ u"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?k</span><span> </span><span class="delimiter">=</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?m</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"m to z in u"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>k</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|?k| &lt; |k|"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q =  ?m ⋆ ?k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>k</span><span> </span><span>u</span><span> </span><span>z</span><span> </span><span>xp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?m[x::=p] ⋆ ?k) = (m[x::=p]) ⋆ k"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>forget</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (?m[x::=p] ⋆ ?k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xp</span><span> </span><span>xk</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ ?k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih_k</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>red</span><span> </span><span>z</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>xp</span><span> </span><span>xk</span><span> </span><span class="delimiter">,</span><span>
</span><span>            </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>fresh_atm</span><span> </span><span>abs_fresh</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (([p] to x in m) ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ((n[x::=p]) ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (n ⋆ k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ♯ k›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sn_forget'</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Having established the claim above, we use it show that
\textsf{to}-bindings preserve reducibility.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_RED</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ RED (T σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀ p ∈ RED σ . t[x::=p] ∈ RED (T τ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t ∈ RED (T τ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∈ SRED τ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ RED σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>snp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN p"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RED_props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span class="delimiter">::</span><span>name</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ♯ (t, p, K)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t,p,K)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>t</span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN((t[x::=p]) ⋆ K)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN ((([(x',x)] ∙ t )[x'::=p]) ⋆ K)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_prod</span><span> </span><span>subst_rename</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>snp</span><span> </span><span>x</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snx'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN (([p] to x' in ([(x',x)] ∙ t )) ⋆ K)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>to_RED_aux</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[p] to x' in ([(x',x)] ∙ t ) = [p] to x in t"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alpha'</span><span> </span><span>fresh_prod</span><span> </span><span>name_swap_bij</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([p] to x in t) ⋆ K  = [p] ⋆ [x]t≫K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"SN([p] ⋆ [x]t≫K)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snx'</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>trm.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x]t≫K ∈ SRED σ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN((s to x in t) ⋆ K)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>SRED.simps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s to x in t ∈ RED (T τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Fundamental Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:FTLR}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The remainder of this section follows \cite{SN.thy} very closely.  We
first establish that all well typed terms are reducible if we substitute
reducible terms for the free variables.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span> </span><span>mapsto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×trm) list ⇒ name ⇒ trm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ maps _ to _"</span></span></span><span> </span><span class="delimiter">[</span><span>55</span><span class="delimiter">,</span><span>55</span><span class="delimiter">,</span><span>55</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ maps x to e ≡ (lookup θ x) = e"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span>  </span><span>closes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×trm) list ⇒ (name×ty) list ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ closes _"</span></span></span><span> </span><span class="delimiter">[</span><span>55</span><span class="delimiter">,</span><span>55</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"θ closes Γ ≡ ∀x τ. ((x,τ) ∈ set Γ ⟶ (∃t. θ maps x to t ∧ t ∈ RED τ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fundamental_theorem</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ ⊢ t : τ"</span></span></span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ closes Γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;t&gt; ∈ RED τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>nominal_induct</span><span>  </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>θ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>typing.strong_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>t3</span><span> </span><span>a</span><span> </span><span>Γ</span><span> </span><span>σ</span><span> </span><span>t</span><span> </span><span>τ</span><span> </span><span>θ</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹lambda case›</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="delimiter">%</span><span>invisible</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀θ. θ closes ((a,σ)#Γ) ⟹ θ&lt;t&gt; ∈ RED τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>θ_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ closes Γ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a♯Γ"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"a♯θ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED σ. ((a,s)#θ)&lt;t&gt; ∈ RED τ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span>θ_cond</span><span> </span><span>fresh_context</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED σ. θ&lt;t&gt;[a::=s] ∈ RED τ"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>psubst_subst</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Λ a . (θ&lt;t&gt;) ∈ RED (σ → τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>abs_RED</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;(Λ a . t)&gt; ∈ RED (σ → τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>t5</span><span> </span><span>x</span><span> </span><span>Γ</span><span> </span><span>s</span><span> </span><span>σ</span><span> </span><span>t</span><span> </span><span>τ</span><span> </span><span>θ</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹to case›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ihs</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ θ . θ closes Γ ⟹ θ&lt;s&gt; ∈ RED (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iht</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ θ . θ closes ((x, σ) # Γ) ⟹ θ&lt;t&gt; ∈ RED (T τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>θ_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"θ closes Γ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ θ"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ♯ Γ"</span></span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ♯ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ihs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;s&gt; ∈ RED (T σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>θ_cond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>iht</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED σ. ((x,s)#θ)&lt;t&gt; ∈ RED (T τ)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span>θ_cond</span><span> </span><span>fresh_context</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈RED σ. θ&lt;t&gt;[x::=s] ∈ RED (T τ)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>psubst_subst</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(θ&lt;s&gt;) to x in (θ&lt;t&gt;) ∈ RED (T τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>to_RED</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ&lt;s to x in t&gt; ∈ RED (T τ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fresh</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span> </span><span class="comment">― ‹all other cases are trivial›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The final result then follows using the identity substitution, which is
$\Gamma$-closing since all variables are reducible at any type.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"id"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(name×ty) list ⇒ (name×trm) list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"id []    = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"id ((x,τ)#Γ) = (x,Var x)#(id Γ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_maps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ) maps a to (Var a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Γ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ Γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ♯ (id Γ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Γ</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fresh_list_nil</span><span> </span><span>fresh_list_cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_apply</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ)&lt;t&gt; = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>nominal_induct</span><span> </span><span>t</span><span> </span><span>avoiding</span><span class="delimiter">:</span><span> </span><span>Γ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trm.strong_induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>id_maps</span><span> </span><span>id_fresh</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_closes</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ) closes Γ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>τ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,τ) ∈ set Γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR4 τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RED_props</span><span> </span><span>CR3_implies_CR4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var x ∈ RED τ"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NEUT_def</span><span> </span><span>normal_var</span><span> </span><span>CR4_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ) maps x to Var x ∧ Var x ∈ RED τ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>id_maps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strong normalization theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typing_implies_RED</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ ⊢ t : τ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ)&lt;t&gt;∈RED τ"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(id Γ) closes Γ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>id_closes</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fundamental_theorem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span class="string"><span class="delete"><span class="delete">"t ∈ RED τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>strong_normalization</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ ⊢ t : τ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ RED τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>typing_implies_RED</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CR1 τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RED_props</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SN(t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CR1_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This finishes our formalization effort. This article is generated
from the Isabelle theory file, which consists of roughly 1500 lines of proof
code. The reader is invited to replay some of the more technical proofs using
the theory file provided.›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword2"><span class="keyword">end</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div>