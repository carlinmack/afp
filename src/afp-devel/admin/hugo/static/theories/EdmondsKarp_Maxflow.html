<div id="FordFulkerson_Algo">
<div class="head"><h1>Theory FordFulkerson_Algo</h1>
<span class="command">theory</span> <span class="name">FordFulkerson_Algo</span><br/>
<span class="keyword">imports</span> <a href="../Flow_Networks/Ford_Fulkerson.html"><span class="name">Ford_Fulkerson</span></a> <a href="../Flow_Networks/Refine_Add_Fofu.html"><span class="name">Refine_Add_Fofu</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Ford-Fulkerson Method›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FordFulkerson_Algo</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Flow_Networks.Ford_Fulkerson</span><span>
</span><span>  </span><span>Flow_Networks.Refine_Add_Fofu</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this theory, we formalize the abstract Ford-Fulkerson
  method, which is independent of how an augmenting path is chosen›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We abstractly specify the procedure for finding an augmenting path:
  Assuming a valid flow, the procedure must return an augmenting path 
  iff there exists one.
  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"find_augmenting_spec f ≡ do {
    assert (NFlow c s t f);
    select p. NPreflow.isAugmentingPath c s t f p
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Moreover, we specify augmentation of a flow along a path›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_with_path p ≡ augment (augmentingFlow p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We also specify the loop invariant, and annotate it to the loop.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fofu_invar ≡ λ(f,brk). 
        NFlow c s t f 
      ∧ (brk ⟶ (∀p. ¬NPreflow.isAugmentingPath c s t f p))
    "</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we obtain the Ford-Fulkerson algorithm.
  Note that we annotate some assertions to ease later refinement›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fofu ≡ do {
  let f<span class="hidden">⇩</span><sub>0</sub> = (λ_. 0);

  (f,_) ← while<span class="hidden">⇗</span><sup>fofu_invar<span class="hidden">⇖</span></sup>
    (λ(f,brk). ¬brk) 
    (λ(f,_). do {
      p ← find_augmenting_spec f;
      case p of 
        None ⇒ return (f,True)
      | Some p ⇒ do {
          assert (p≠[]);
          assert (NPreflow.isAugmentingPath c s t f p);
          let f = NFlow.augment_with_path c f p;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f<span class="hidden">⇩</span><sub>0</sub>,False);
  assert (NFlow c s t f);
  return f 
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Partial Correctness›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness of the algorithm is a consequence from the 
  Ford-Fulkerson theorem. We need a few straightforward 
  auxiliary lemmas, though:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The zero flow is a valid flow›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t (λ_. 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s_node</span><span> </span><span>t_node</span><span> </span><span>cap_non_negative</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmentation preserves the flow property›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>augment_pres_nflow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t (augment (augmentingFlow p))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>augment_flow_presv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>augFlow_resFlow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f'</span><span class="delimiter">:</span><span> </span><span>Flow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"augment (augmentingFlow p)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmenting paths cannot be empty›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>augmenting_path_not_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬isAugmentingPath []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isAugmentingPath_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_not_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we can use the verification condition generator to
  show correctness›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fofu_partial_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fofu ≤ (spec f. isMaxFlow f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fofu_def</span><span> </span><span>find_augmenting_spec_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> 
</span><span>    </span><span>zero_flow</span><span> 
</span><span>    </span><span>NFlow.augment_pres_nflow</span><span> 
</span><span>    </span><span>NFlow.augmenting_path_not_empty</span><span>
</span><span>    </span><span>NFlow.noAugPath_iff_maxFlow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>NFlow.augment_with_path_def</span><span>
</span><span>  </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm without Assertions›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For presentation purposes, we extract a version of the algorithm
  without assertions, and using a bit more concise notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"augment 
  ≡ NFlow.augment_with_path"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_augmenting_path f p 
  ≡ NPreflow.isAugmentingPath c s t f p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ {} ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\DefineSnippet{ford_fulkerson_algo}{›</span></span></span><span>       
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ford_fulkerson_method ≡ do {
  let f<span class="hidden">⇩</span><sub>0</sub> = (λ(u,v). 0);

  (f,brk) ← while (λ(f,brk). ¬brk) 
    (λ(f,brk). do {
      p ← select p. is_augmenting_path f p;
      case p of 
        None ⇒ return (f,True)
      | Some p ⇒ return (augment c f p, False)
    })
    (f<span class="hidden">⇩</span><sub>0</sub>,False);
  return f 
}"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹}%EndSnippet›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ {} ›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Anonymous context›</span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network›</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ {} ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\DefineSnippet{ford_fulkerson_correct}{›</span></span></span><span>       
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ford_fulkerson_method ≤ (spec f. isMaxFlow f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹}%EndSnippet›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ {} ›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ(u,v). 0) = (λ_. 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ford_fulkerson_method ≤ fofu"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ford_fulkerson_method_def</span><span> </span><span>fofu_def</span><span> </span><span>Let_def</span><span> </span><span>find_augmenting_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NFlow.augment_with_path_def</span><span> </span><span>solve</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fofu_partial_correct</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="EdmondsKarp_Termination_Abstract">
<div class="head"><h1>Theory EdmondsKarp_Termination_Abstract</h1>
<span class="command">theory</span> <span class="name">EdmondsKarp_Termination_Abstract</span><br/>
<span class="keyword">imports</span> <a href="../Flow_Networks/Ford_Fulkerson.html"><span class="name">Ford_Fulkerson</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Edmonds-Karp Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>EdmondsKarp_Termination_Abstract</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Flow_Networks.Ford_Fulkerson</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mlex_fst_decrI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span>b</span><span> </span><span>b'</span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a&lt;a'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b&lt;N"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b'&lt;N"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a*N + b &lt; a'*N + b'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a*N + b + 1 ≤ a*N + N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b&lt;N›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ a'*N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a&lt;a'›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_leI</span><span> </span><span>ab_semigroup_add_class.add.commute</span><span> 
</span><span>      </span><span>ab_semigroup_mult_class.mult.commute</span><span> </span><span>mult_Suc_right</span><span> </span><span>mult_le_mono2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ a'*N + b'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>augmenting_path_imp_shortest</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ⟹ ∃p. Graph.isShortestPath cf s p t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.obtain_shortest_path</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isAugmentingPath_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.isSimplePath_def</span><span> </span><span>Graph.connected_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>shortest_is_augmenting</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Graph.isShortestPath cf s p t ⟹ isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isAugmentingPath_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Graph.shortestPath_is_simple</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Complexity and Termination Analysis›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we show that the loop iterations of the Edmonds-Karp algorithm
  are bounded by $O(VE)$.

  The basic idea of the proof is, that a path that
  takes an edge reverse to an edge on some shortest path 
  cannot be a shortest path itself.

  As augmentation flips at least one edge, this yields a termination argument:
    After augmentation, either the minimum distance between source and target
    increases, or it remains the same, but the number of edges that lay on a
    shortest path decreases. As the minimum distance is bounded by $V$, 
    we get termination within $O(VE)$ loop iterations.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The basic idea is expressed in the following lemma, which, however, 
  is not general enough to be applied for the correctness proof, where
  we flip more than one edge simultaneously.
  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_flip_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p' t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∈set p'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p' ≥ length p + 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isShortestPath s p t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = length p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>     </span><span>DV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (pathVertices s p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_alt</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,v)∈set p›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@(u,v)#p2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P</span><span> </span><span>DV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u≠v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>pathVertices_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>DISTS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist s (length p1) u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u 1 v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist v (length p2) t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>dist_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[(u,v)]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MIN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MIN'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = length p1 + 1 + length p2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>MIN'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>MDSV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s v = length p1 + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dist_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DISTS</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>MIN'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>MDUT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist u t = 1 + length p2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(v,u)∈set p'›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1'</span><span> </span><span>p2'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p'=p1'@(v,u)#p2'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_decomp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath s p' t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>DISTS'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist s (length p1') v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist u (length p2') t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DISTS'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>min_dist_minD</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>MDSV</span><span> </span><span>MDUT</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"length p + 2 ≤ length p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  To be used for the analysis of augmentation, we have to generalize the 
  lemma to simultaneous flipping of edges:
  ›</span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isShortestPath_flip_edges</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c' ⊇ E - edges"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.E c' ⊆ E ∪ (prod.swap`edges)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EDGES_SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edges ⊆ set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isPath c' s p' t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p' ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + 2 ≤ length p'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>g'</span><span class="delimiter">:</span><span> </span><span>Graph</span><span> </span><span>c'</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: The proof still contains some redundancy: A first flipped edge
    is searched in both, the induction, and the initialization *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>p1</span><span> </span><span>p2'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈edges"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1 v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath u p2' t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t &lt; length p1 + length p2'"</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p2'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>p1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>p2'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"1.IH"</span></span></span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>P1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹isPath s p1 v›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>P2'</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'.isPath u p2' t›</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p1 &gt; min_dist s u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p1 ≥ min_dist s v"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_minD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,v)∈edges›</span></span></span><span> </span><span>EDGES_SS</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s v = Suc (min_dist s u)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isShortestPath_level_edge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SP</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isShortestPath_level_edge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SP</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,v)∈edges›</span></span></span><span> </span><span>EDGES_SS</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"min_dist s t = min_dist s u + min_dist u t"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"connected s u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p2' = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment">― ‹We proceed by a case distinction whether the suffix path contains swapped edges›</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g'.transfer_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P2'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'.E ⊆ E ∪ prod.swap ` edges›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p2' t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p2' ≥ min_dist u t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_minD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length p1 &gt; min_dist s u›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹min_dist s t = min_dist s u + min_dist u t›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="comment">― ‹Obtain first swapped edge on suffix path›</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p21'</span><span> </span><span>e'</span><span> </span><span>p22'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2'=p21'@e'#p22'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>           </span><span>E_IN_EDGES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e'∈prod.swap`edges"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>P1_NO_EDGES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p21' = {}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_list_first_propE</span><span class="delimiter">[</span><span>of</span><span> </span><span>p2'</span><span> </span><span class="string"><span class="delete"><span class="delete">"λe. e∈prod.swap`edges"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹prod.swap ` edges ∩ set p2' ≠ {}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u'</span><span> </span><span>v'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e'=(v',u')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e'</span><span class="delimiter">)</span><span>      
</span><span>  
</span><span>        </span><span class="comment">― ‹Split the suffix path accordingly›</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P2'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P21'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath u p21' v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P22'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath u' p22' t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g'.isPath_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment">― ‹As we chose the first edge, the prefix of the suffix path is also a path in the original graph›</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> 
</span><span>          </span><span>g'.transfer_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P21'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹g'.E ⊆ E ∪ prod.swap ` edges›</span></span></span><span> 
</span><span>          </span><span>P1_NO_EDGES</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P21</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath u p21' v'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min_dist_is_dist</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹connected s u›</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>psu</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>              </span><span>PSU</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s psu u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>LEN_PSU</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length psu = min_dist s u"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PSU</span><span> </span><span>P21</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s (psu@p21') v'"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isPath_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>P1n</span><span> </span><span>P22'</span><span class="delimiter">]</span><span> </span><span>E_IN_EDGES</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"min_dist s t &lt; length psu + length p21' + length p22'"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length p1 &gt; min_dist s u›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LEN_PSU</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>aux</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This step is analogous to what we do in the False-case of the induction.
    Can we somehow remove the redundancy? *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment">― ‹Obtain first swapped edge on path›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1'</span><span> </span><span>e</span><span> </span><span>p2'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p'=p1'@e#p2'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>E_IN_EDGES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈prod.swap`edges"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>P1_NO_EDGES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p1' = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_list_first_propE</span><span class="delimiter">[</span><span>of</span><span> </span><span>p'</span><span> </span><span class="string"><span class="delete"><span class="delete">"λe. e∈prod.swap`edges"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹prod.swap ` edges ∩ set p' ≠ {}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=(v,u)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span>      
</span><span>
</span><span>  </span><span class="comment">― ‹Split the new path accordingly›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'.isPath s p' t›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>P1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath s p1' v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>P2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath u p2' t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g'.isPath_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹As we chose the first edge, the prefix of the path is also a path in the original graph›</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> 
</span><span>    </span><span>g'.transfer_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P1'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>c</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹g'.E ⊆ E ∪ prod.swap ` edges›</span></span></span><span> 
</span><span>    </span><span>P1_NO_EDGES</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isPath s p1' v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P1</span><span> </span><span>P2'</span><span class="delimiter">]</span><span> </span><span>E_IN_EDGES</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t &lt; length p1' + length p2'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SP</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_min_dist_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Graph›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We outsource the more specific lemmas to their own locale, 
  to prevent name space pollution›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ek_analysis_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ek_analysis</span><span> </span><span class="delimiter">=</span><span> </span><span>ek_analysis_defs</span><span> </span><span class="delimiter">+</span><span> </span><span>Finite_Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ek_analysis_defs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"spEdges ≡ {e. ∃p. e∈set p ∧ isShortestPath s p t}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spEdges_ss_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"spEdges ⊆ E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isPath_edgeset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spEdges_def</span><span> </span><span>isShortestPath_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_spEdges</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (spEdges)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spEdges_ss_E</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ek_analysis_defs</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"uE ≡ E ∪ E¯"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_uE</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite uE"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_ss_uE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E⊆uE"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_spEdges_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card spEdges ≤ card uE"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spEdges_ss_E</span><span> </span><span>E_ss_uE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_spEdges_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card spEdges &lt; card uE + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_spEdges_le</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ek_analysis_defs</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ekMeasure ≡ 
  if (connected s t) then
    (card V - min_dist s t) * (card uE + 1) + (card (spEdges))
  else 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>measure_decr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s∈V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP_EDGES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edges⊆set p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Ebounds</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Graph.E c' ⊇ E - edges ∪ prod.swap`edges"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Graph.E c' ⊆ E ∪ prod.swap`edges"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ek_analysis_defs.ekMeasure c' s t ≤ ekMeasure"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges - Graph.E c' ≠ {} 
         ⟹ ek_analysis_defs.ekMeasure c' s t &lt; ekMeasure"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>g'</span><span class="delimiter">:</span><span> </span><span>ek_analysis_defs</span><span> </span><span>c'</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>g'</span><span class="delimiter">:</span><span> </span><span>ek_analysis</span><span> </span><span>c'</span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>g'.Finite_Graph_EI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Ebounds</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SP_EDGES</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SP_EDGES</span><span> </span><span>SP</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges ⊆ E"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>spEdges_def</span><span> </span><span>isShortestPath_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>isPath_edgeset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Ebounds</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Veq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c' = V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.V_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Ebounds</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹edges ⊆ E›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uE_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.uE = uE"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ek_analysis_defs.uE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SP</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LENP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p = min_dist s t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_min_dist_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SP</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CONN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected s t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isShortestPath_def</span><span> </span><span>connected_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NCONN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬g'.connected s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s≠t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CONN</span><span> </span><span>NCONN2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.ekMeasure &lt; ekMeasure"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g'.ekMeasure_def</span><span> </span><span>ekMeasure_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_dist_less_V</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SV</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>SHORTER</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.min_dist s t &lt; min_dist s t"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CONN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.connected s t"</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment">― ‹Obtain a shorter path in $g'$›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g'.min_dist_is_dist</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CONN2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath s p' t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LENP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p' = g'.min_dist s t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g'.dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="comment">― ‹Case: It does not use @{term "prod.swap`edges"}. 
        Then it is also a path in $g$, which is shorter than 
        the shortest path in $g$, yielding a contradiction.›</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p' = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g'.transfer_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>P'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>Ebounds</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dist s (length p') t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dist_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LENP'</span><span> </span><span>SHORTER</span><span> </span><span>min_dist_minD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="comment">― ‹So assume the path uses the edge @{term "prod.swap e"}.›</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p' ≠ {}"</span></span></span><span>
</span><span>      </span><span class="comment">― ‹Due to auxiliary lemma, those path must be longer›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isShortestPath_flip_edges</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>SP</span><span> </span><span>SP_EDGES</span><span> </span><span>P'</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>Ebounds</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p' &gt; length p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SHORTER</span><span> </span><span>LENP</span><span> </span><span>LENP'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>LONGER</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.min_dist s t &gt; min_dist s t"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CONN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.connected s t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.ekMeasure &lt; ekMeasure"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g'.ekMeasure_def</span><span> </span><span>ekMeasure_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Veq</span><span> </span><span>uE_eq</span><span> </span><span>CONN</span><span> </span><span>CONN2</span><span> </span><span>if_True</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mlex_fst_decrI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_spEdges_less</span><span> </span><span>g'.card_spEdges_less</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g'.min_dist_less_V</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>CONN2</span><span class="delimiter">]</span><span> </span><span>SV</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LONGER</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.min_dist s t = min_dist s t"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CONN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.connected s t"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isShortestPath s p' t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p' = {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>EIP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod.swap`edges ∩ set p' ≠ {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>             </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.isPath s p' t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>LENP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length p' = g'.min_dist s t"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g'.isShortestPath_min_dist_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isShortestPath_flip_edges</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>SP</span><span> </span><span>SP_EDGES</span><span> </span><span>P'</span><span> </span><span>EIP'</span><span class="delimiter">]</span><span> </span><span>Ebounds</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length p + 2 ≤ length p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>LENP</span><span> </span><span>LENP'</span><span> </span><span>EQ</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g'.transfer_path</span><span class="delimiter">[</span><span>of</span><span> </span><span>p'</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>P'</span><span> </span><span>Ebounds</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isShortestPath s p' t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.isShortestPath_min_dist_def</span><span> </span><span>EQ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.spEdges ⊆ spEdges"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g'.spEdges_def</span><span> </span><span>spEdges_def</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges - Graph.E c' ≠ {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g'.spEdges_ss_E</span><span> </span><span>SS</span><span> </span><span>SP</span><span> </span><span>SP_EDGES</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.spEdges ⊂ spEdges"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g'.spEdges_def</span><span> </span><span>spEdges_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.ekMeasure &lt; ekMeasure"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g'.ekMeasure_def</span><span> </span><span>ekMeasure_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Veq</span><span> </span><span>uE_eq</span><span> </span><span>EQ</span><span> </span><span>CONN</span><span> </span><span>CONN2</span><span> </span><span>if_True</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_strict_left_mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubset_card_mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>G1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.ekMeasure ≤ ekMeasure"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g'.ekMeasure_def</span><span> </span><span>ekMeasure_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Veq</span><span> </span><span>uE_eq</span><span> </span><span>CONN</span><span> </span><span>CONN2</span><span> </span><span>if_True</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mult_right_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EQ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>G1</span><span> </span><span>G2</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"g'.ekMeasure ≤ ekMeasure"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"edges - Graph.E c' ≠ {} ⟹ g'.ekMeasure &lt; ekMeasure"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_linear</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'.min_dist s t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist s t"</span></span></span><span class="delimiter">]</span><span>   
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Analysis locale›</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As a first step to the analysis setup, we characterize
  the effect of augmentation on the residual graph
  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf edges cap ≡ λe. 
  if e∈edges then c e - cap 
  else if prod.swap e∈edges then c e + cap
  else c e"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf {} cap = c"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_cf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦edges ⊆ E⟧ ⟹ Graph.V (augment_cf edges cap) ⊆ V"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span> </span><span>Graph.V_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>augment_cf_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_saturate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>edges</span><span> </span><span>e</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ≡ augment_cf edges (c e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>EIE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈edges"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e∉Graph.E c'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EIE</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c'_def</span><span> </span><span>augment_cf_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_split</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges1 ∩ edges2 = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges1¯ ∩ edges2 = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.augment_cf c (edges1 ∪ edges2) cap 
    = Graph.augment_cf (Graph.augment_cf c edges1 cap) edges2 cap"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.augment_cf_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Graph›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>NFlow</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augmenting_edge_no_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p ⟹ set p ∩ (set p)¯ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.isSPath_nt_parallel_pf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aug_flows_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite {cf e |e. e ∈ set p}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"cf`set p"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aug_flows_finite'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"finite {cf (u,v) |u v. (u,v) ∈ set p}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"cf`set p"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' ≡ augment (augmentingFlow p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf' ≡ residualGraph c f'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf' = Graph.augment_cf cf (set p) (resCap p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈set p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap p ≤ cf (u,v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Min_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>bn_smallerI</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈set p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈cf.E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AUG</span><span> </span><span>cf.isPath_edgeset</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span> </span><span>cf.isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E ∨ (v,u)∈E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfE_ss_invE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edge_or_swap</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> 
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf.augment_cf_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augmenting_edge_no_swap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>augment_def</span><span> </span><span>augmentingFlow_def</span><span> </span><span>cf'_def</span><span> </span><span>f'_def</span><span> </span><span>residualGraph_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>edge_or_swap</span><span> 
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augmenting_path_contains_resCap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈set p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e = resCap p"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p≠[]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isAugmentingPath_def</span><span> </span><span>s_not_t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{cf e | e. e ∈ set p} ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Min_in</span><span class="delimiter">[</span><span>OF</span><span> </span><span>aug_flows_finite</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>resCap_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈set p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e = resCap p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>        
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we show the main theorem used for termination and complexity 
  analysis: Augmentation with a shortest path decreases the measure function.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>shortest_path_decr_ek_measure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isShortestPath cf s p t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' ≡ augment (augmentingFlow p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf' ≡ residualGraph c f'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ek_analysis_defs.ekMeasure cf' s t &lt; ek_analysis_defs.ekMeasure cf s t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span>ek_analysis</span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cf'</span><span class="delimiter">:</span><span> </span><span>ek_analysis_defs</span><span> </span><span>cf'</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SP</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isAugmentingPath_def</span><span> </span><span>cf.isShortestPath_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>BNGZ</span><span> </span><span class="delimiter">=</span><span> </span><span>resCap_gzero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cf'_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf' = cf.augment_cf (set p) (resCap p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf'_def</span><span> </span><span>f'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>EIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈set p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EBN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e = resCap p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>augmenting_path_contains_resCap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ENIE'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e∉cf'.E"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.augment_saturate</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EIP</span><span class="delimiter">]</span><span> </span><span>EBN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cf'_alt</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e + resCap p ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resE_nonNegative</span><span class="delimiter">[</span><span>of</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span>BNGZ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e∈set p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ cf.E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.shortestPath_is_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SP</span><span class="delimiter">]</span><span> </span><span>cf.isPath_edgeset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf e &gt; 0 ∧ cf e ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resE_positive</span><span class="delimiter">[</span><span>of</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cf.measure_decr</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf'_alt</span><span> </span><span>cf.augment_cf_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augmenting_edge_no_swap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf'_alt</span><span> </span><span>cf.augment_cf_def</span><span> </span><span>Graph.E_def</span><span> 
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cf.zero_cap_simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>Graph.E_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf'_alt</span><span> </span><span>cf.augment_cf_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EIP</span><span> </span><span>ENIE'</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network with flow›</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="EdmondsKarp_Algo">
<div class="head"><h1>Theory EdmondsKarp_Algo</h1>
<span class="command">theory</span> <span class="name">EdmondsKarp_Algo</span><br/>
<span class="keyword">imports</span> <a href="EdmondsKarp_Termination_Abstract.html"><span class="name">EdmondsKarp_Termination_Abstract</span></a> <a href="FordFulkerson_Algo.html"><span class="name">FordFulkerson_Algo</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>EdmondsKarp_Algo</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>EdmondsKarp_Termination_Abstract</span><span> </span><span>FordFulkerson_Algo</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we formalize an abstract version of
  Edmonds-Karp algorithm, which we obtain by refining the 
  Ford-Fulkerson algorithm to always use shortest augmenting paths.

  Then, we show that the algorithm always terminates within $O(VE)$ iterations.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First, we specify the refined procedure for finding augmenting paths›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"find_shortest_augmenting_spec f ≡ assert (NFlow c s t f) ⪢ 
  (select p. Graph.isShortestPath (residualGraph c f) s p t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We show that our refined procedure is actually a refinement›</span></span></span><span>  
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>SELECT_refine</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_shortest_augmenting_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(f',f)∈Id ⟹ find_shortest_augmenting_spec f' ≤ ⇓(⟨Id⟩option_rel) (find_augmenting_spec f)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_shortest_augmenting_spec_def</span><span> </span><span>find_augmenting_spec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NFlow.shortest_is_augmenting</span><span> </span><span>RELATESI</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NFlow.augmenting_path_imp_shortest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we specify the Edmonds-Karp algorithm. 
  Our first specification still uses partial correctness, 
  termination will be proved afterwards. ›</span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_partial ≡ do {
  let f = (λ_. 0);

  (f,_) ← while<span class="hidden">⇗</span><sup>fofu_invar<span class="hidden">⇖</span></sup>
    (λ(f,brk). ¬brk) 
    (λ(f,_). do {
      p ← find_shortest_augmenting_spec f;
      case p of 
        None ⇒ return (f,True)
      | Some p ⇒ do {
          assert (p≠[]);
          assert (NPreflow.isAugmentingPath c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f = NFlow.augment_with_path c f p;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka_partial_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_partial ≤ ⇓Id fofu"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka_partial_def</span><span> </span><span>fofu_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>bind_refine'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_shortest_augmenting_spec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Total Correctness›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We specify the total correct version of Edmonds-Karp algorithm.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka ≡ do {
  let f = (λ_. 0);

  (f,_) ← while<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup>fofu_invar<span class="hidden">⇖</span></sup>
    (λ(f,brk). ¬brk) 
    (λ(f,_). do {
      p ← find_shortest_augmenting_spec f;
      case p of 
        None ⇒ return (f,True)
      | Some p ⇒ do {
          assert (p≠[]);
          assert (NPreflow.isAugmentingPath c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f = NFlow.augment_with_path c f p;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Based on the measure function, it is easy to obtain a well-founded 
  relation that proves termination of the loop in the Edmonds-Karp algorithm:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_wf_rel ≡ inv_image 
  (less_than_bool &lt;*lex*&gt; measure (λcf. ek_analysis_defs.ekMeasure cf s t))
  (λ(f,brk). (¬brk,residualGraph c f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka_wf_rel_wf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf edka_wf_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka_wf_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following theorem states that the total correct 
  version of Edmonds-Karp algorithm refines the partial correct one.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>edka_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka ≤ ⇓Id edka_partial"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka_def</span><span> </span><span>edka_partial_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>bind_refine'</span><span> 
</span><span>    </span><span>WHILEIT_refine_WHILEI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>edka_wf_rel</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unfortunately, the verification condition for introducing 
      the variant requires a bit of manual massaging to be solved:›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>bind_sim_select_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NFlow.augment_with_path_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assert_bind_spec_conv</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_shortest_augmenting_spec_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>edka_wf_rel_def</span><span> </span><span>NFlow.shortest_path_decr_ek_measure</span><span>
</span><span>    </span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The other VCs are straightforward›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Complexity Analysis›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For the complexity analysis, we additionally show that the measure
  function is bounded by $O(VE)$. Note that our absolute bound is not as 
  precise as possible, but clearly $O(VE)$.›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: #edgesSp even bound by |E|, as either e or swap e lays on shortest path! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ekMeasure_upper_bound</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ek_analysis_defs.ekMeasure (residualGraph c (λ_. 0)) s t 
   &lt; 2 * card V * card E + card V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ_. 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s_node</span><span> </span><span>t_node</span><span> </span><span>cap_non_negative</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ek</span><span class="delimiter">:</span><span> </span><span>ek_analysis</span><span> </span><span>cf</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cardV_positive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card V &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cardE_positive</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card E &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_0_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_V</span><span class="delimiter">]</span><span> </span><span>V_not_empty</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_0_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_E</span><span class="delimiter">]</span><span> </span><span>E_not_empty</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.connected s t"</span></span></span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ek.ekMeasure = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ek.ekMeasure_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cardV_positive</span><span> </span><span>cardE_positive</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.min_dist s t &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.min_dist_z_iff</span><span> </span><span>True</span><span> </span><span>s_not_t</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf = c"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span>E_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ek.uE = E∪E¯"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ek.uE_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ek.ekMeasure 
      = (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + (card (ek.spEdges))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ek.ekMeasure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> 
</span><span>      </span><span>mlex_bound</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"card cf.V - cf.min_dist s t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card V"</span></span></span><span class="delimiter">,</span><span> 
</span><span>                 </span><span>OF</span><span> </span><span>_</span><span> </span><span>ek.card_spEdges_less</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… &lt; card V * (card ek.uE+1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf.min_dist s t &gt; 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹card V &gt; 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>resV_netV</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ek.uE ≤ 2*card E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ek.uE = E∪E¯›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_Un_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we present a version of the Edmonds-Karp algorithm 
  which is instrumented with a loop counter, and asserts that
  there are less than $2|V||E|+|V| = O(|V||E|)$ iterations.

  Note that we only count the non-breaking loop iterations.
  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The refinement is achieved by a refinement relation, coupling the 
  instrumented loop state with the uninstrumented one›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edkac_rel ≡ {((f,brk,itc), (f,brk)) | f brk itc.
    itc + ek_analysis_defs.ekMeasure (residualGraph c f) s t 
  &lt; 2 * card V * card E + card V
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_complexity ≡ do {
  let f = (λ_. 0);

  (f,_,itc) ← while<span class="hidden">⇩</span><sub>T</sub> 
    (λ(f,brk,_). ¬brk) 
    (λ(f,_,itc). do {
      p ← find_shortest_augmenting_spec f;
      case p of 
        None ⇒ return (f,True,itc)
      | Some p ⇒ do {
          let f = NFlow.augment_with_path c f p;
          return (f, False,itc + 1)
        }  
    })
    (f,False,0);
  assert (itc &lt; 2 * card V * card E + card V);
  return f 
}"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka_complexity_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_complexity ≤ ⇓Id edka"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"RELATES edkac_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka_complexity_def</span><span> </span><span>edka_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>edkac_rel_def</span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow.augment_with_path_def"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ekMeasure_upper_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NFlow.shortest_path_decr_ek_measure</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We show that this algorithm never fails, and computes a maximum flow.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_complexity ≤ (spec f. isMaxFlow f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka_complexity_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka_partial_refine</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fofu_partial_correct</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Network›</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹Theory›</span><span>
</span></pre>
</div>
</div><div id="Augmenting_Path_BFS">
<div class="head"><h1>Theory Augmenting_Path_BFS</h1>
<span class="command">theory</span> <span class="name">Augmenting_Path_BFS</span><br/>
<span class="keyword">imports</span> <a href="../Flow_Networks/Graph_Impl.html"><span class="name">Graph_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Breadth First Search›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Augmenting_Path_BFS</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Flow_Networks.Refine_Add_Fofu</span><span>
</span><span>  </span><span>Flow_Networks.Graph_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    In this theory, we present a verified breadth-first search
    with an efficient imperative implementation.
    It is parametric in the successor function.
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algorithm›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pre_bfs_invar</span><span> </span><span class="delimiter">=</span><span> </span><span>Graph</span><span> </span><span class="delimiter">+</span><span>    
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>src</span><span> </span><span>dst</span><span> </span><span class="delimiter">::</span><span> </span><span>node</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ndist v ≡ min_dist src v"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Vd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ node set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀d. Vd d ≡ {v. connected src v ∧ ndist v = d}"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vd_disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀d d'. d≠d' ⟹ Vd d ∩ Vd d' = {}"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Vd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>src_Vd0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vd 0 = {src}"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Vd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_Vd_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈Vd d ⟷ connected src v ∧ ndist v = d"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Vd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vd_succ</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈Vd d"</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∈E"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i≤d. v∉Vd i"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈Vd (Suc d)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>connected_append_edge</span><span> </span><span>in_Vd_conv</span><span> </span><span>le_SucE</span><span> </span><span>min_dist_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>valid_PRED</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_bfs_invar</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>PRED</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇀ node"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SRC_IN_V</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"src∈V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FIN_V</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PRED_src</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PRED src = Some src"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PRED_dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦v≠src; PRED v = Some u⟧ ⟹ ndist v = Suc (ndist u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PRED_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦v≠src; PRED v = Some u⟧ ⟹ (u,v)∈E"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PRED_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ PRED v = Some u ⟧ ⟹ u∈dom PRED"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FIN_E</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss_VxV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FIN_succ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E``{u})"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_Image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>nf_invar'</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_PRED</span><span> </span><span>c</span><span> </span><span>src</span><span> </span><span>dst</span><span> </span><span>PRED</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span>src</span><span> </span><span>dst</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PRED</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇀ node"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> 
</span><span>    </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VIS_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dom PRED = N ∪ {u. ∃i≤d. u∈Vd i}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⊆ Vd d"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>N_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N = Vd (d+1) ∩ E``(Vd d - C)"</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dst_ne_VIS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∉ dom PRED"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>nf_invar</span><span> </span><span class="delimiter">=</span><span> </span><span>nf_invar'</span><span> </span><span class="delimiter">+</span><span>   
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>empty_assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C={} ⟹ N={}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>f_invar</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_PRED</span><span> </span><span>c</span><span> </span><span>src</span><span> </span><span>dst</span><span> </span><span>PRED</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span>src</span><span> </span><span>dst</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PRED</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇀ node"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>   
</span><span>    </span><span class="delimiter">+</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dst_found</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∈ dom PRED ∩ Vd d"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_loop_invar src dst ≡ λ(f,PRED,C,N,d). 
      (f ⟶ f_invar c src dst PRED d) ∧
      (¬f ⟶ nf_invar c src dst PRED C N d)

      "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"assn1 src dst ≡ λ(f,PRED,C,N,d). 
      ¬f ∧ nf_invar' c src dst PRED C N d"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_succ_spec dst succ v PRED N ≡ ASSERT (N ⊆ dom PRED) ⪢ 
    SPEC (λ(f,PRED',N').
      case f of
        False ⇒ dst ∉ succ - dom PRED 
          ∧ PRED' = map_mmupd PRED (succ - dom PRED) v 
          ∧ N' = N ∪ (succ - dom PRED)
      | True ⇒ dst ∈ succ - dom PRED 
        ∧ PRED ⊆<span class="hidden">⇩</span><sub>m</sub> PRED' 
        ∧ PRED' ⊆<span class="hidden">⇩</span><sub>m</sub> map_mmupd PRED (succ - dom PRED) v 
        ∧ dst∈dom PRED'
  )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pre_bfs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node ⇒ (nat × (node⇀node)) option nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_bfs src dst ≡ do {
    (f,PRED,_,_,d) ← WHILEIT (outer_loop_invar src dst) 
      (λ(f,PRED,C,N,d). f=False ∧ C≠{})
      (λ(f,PRED,C,N,d). do {
        v ← SPEC (λv. v∈C); let C = C-{v};
        ASSERT (v∈V);
        let succ = (E``{v});
        ASSERT (finite succ);
        (f,PRED,N) ← add_succ_spec dst succ v PRED N;
        if f then
          RETURN (f,PRED,C,N,d+1)
        else do {
          ASSERT (assn1 src dst (f,PRED,C,N,d));
          if (C={}) then do {
            let C=N; 
            let N={}; 
            let d=d+1;
            RETURN (f,PRED,C,N,d)
          } else RETURN (f,PRED,C,N,d)
        }  
      })
      (False,[src↦src],{src},{},0::nat);
    if f then RETURN (Some (d, PRED)) else RETURN None
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness Proof"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar'</span><span class="delimiter">)</span><span> </span><span>ndist_C</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦v∈C⟧ ⟹ ndist v = d"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Vd_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>CVdI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦u∈C⟧ ⟹ u∈Vd d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>inPREDD</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦PRED v = Some u⟧ ⟹ v∈N ∨ (∃i≤d. v∈Vd i)"</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar'</span><span class="delimiter">)</span><span> </span><span>C_ss_VIS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦v∈C⟧ ⟹ v∈dom PRED"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss</span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_succ_step</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∉ E``{v} - dom PRED"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nf_invar' c src dst 
      (map_mmupd PRED (E``{v} - dom PRED) v) 
      (C-{v}) 
      (N ∪ (E``{v} - dom PRED)) 
      d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>C_ss_VIS</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈C›</span></span></span><span class="delimiter">]</span><span> </span><span>dst_ne_VIS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠dst"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈C›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v≠dst›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_mmupd_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>map_mmupdE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_dist</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>VIS_eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CVdI</span><span> </span><span>Vd_succ</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_E</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_mmupdE</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>   
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_closed</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_mmupdE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>C_ss_VIS</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> 
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>N_eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>CVdI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Vd_succ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>inPREDD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>N_eq</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dst_ne_VIS</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦src≠dst; src∈V; finite V⟧ 
    ⟹ nf_invar c src dst [src ↦ src] {src} {} 0"</span></span></span><span>            
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pre_bfs_invar.Vd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_exit</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dst∈C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f_invar c src dst PRED d"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>VIS_eq</span><span> </span><span>C_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_C_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈C ⟹ u∈V"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>CVdI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_Vd_conv</span><span> </span><span>connected_inV_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_N_ss_Vis</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈N ⟹ ∃v. PRED u = Some v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>pre_bfs_invar</span><span class="delimiter">)</span><span> </span><span>Vdsucinter_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Vd (Suc d) ∩ E `` Vd d = Vd (Suc d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Image_iff</span><span> </span><span>in_Vd_conv</span><span> </span><span>min_dist_suc</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar'</span><span class="delimiter">)</span><span> </span><span>invar_shift</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C={}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nf_invar c src dst PRED N {} (Suc d)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span>N_eq</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_Suc_eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_eq</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dst_ne_VIS</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar'</span><span class="delimiter">)</span><span> </span><span>invar_restore</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C≠{}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nf_invar c src dst PRED C N d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_spec src dst r ≡ (
    case r of None ⇒ ¬ connected src dst
            | Some (d,PRED) ⇒ connected src dst 
                ∧ min_dist src dst = d 
                ∧ valid_PRED c src PRED 
                ∧ dst∈dom PRED)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>f_invar</span><span class="delimiter">)</span><span> </span><span>invar_found</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_spec src dst (Some (d,PRED))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dst_found</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_not_found</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C={}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_spec src dst None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N={}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"connected src dst"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>dstd'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∈ Vd d'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We make a case-distinction whether ‹d'≤d›:›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d'≤d ∨ Suc d ≤ d'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d'≤d"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>VIS_eq</span><span> </span><span>dstd'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∈ dom PRED"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>dst_ne_VIS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc d ≤ d'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the case ‹d+1 ≤ d'›, we also obtain a node
        that has a shortest path of length ‹d+1›:›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>min_dist_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>dstd'</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v' ∈ Vd (Suc d)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹However, the invariant states that such nodes are either in
        ‹N› or are successors of ‹C›. As ‹N› 
        and ‹C› are both empty, we again get a contradiction.›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N_eq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_le_mp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m⊆<span class="hidden">⇩</span><sub>m</sub>m'; m k = Some v⟧ ⟹ m' k = Some v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_le_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>dst_notin_Vdd</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i≤d ⟹ dst∉Vd i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span>dst_ne_VIS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>invar_exit'</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,dst) ∈ E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dst ∈ dom PRED'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SS1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PRED ⊆<span class="hidden">⇩</span><sub>m</sub> PRED'"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SS2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PRED' ⊆<span class="hidden">⇩</span><sub>m</sub> map_mmupd PRED (E``{u} - dom PRED) u"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f_invar c src dst PRED' (Suc d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_le_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS1</span><span> </span><span>PRED_src</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>map_le_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>map_mmupdE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_dist</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>VIS_eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∈C›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CVdI</span><span> </span><span>Vd_succ</span><span> </span><span>in_Vd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>map_le_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_E</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_mmupdE</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>   
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>map_le_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>map_mmupdE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_le_implies_dom_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PRED_closed</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss_VIS</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∈C›</span></span></span><span class="delimiter">]</span><span> </span><span>map_le_implies_dom_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SS1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹dst ∈ dom PRED'›</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∈C›</span></span></span><span> </span><span>CVdI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u∈C›</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(u,dst)∈E›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Vd_succ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>VIS_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_dist src ≡ Max (min_dist src`V)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"outer_loop_rel src ≡ 
    inv_image (
        less_than_bool 
        &lt;*lex*&gt; greater_bounded (max_dist src + 1) 
        &lt;*lex*&gt; finite_psubset) 
      (λ(f,PRED,C,N,d). (¬f,d,C))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outer_loop_rel_wf</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (outer_loop_rel src)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>outer_loop_rel_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>C_ne_max_dist</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C≠{}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≤ max_dist src"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C_ss</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈Vd d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"min_dist src u = d"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_Vd_conv</span><span> </span><span>connected_inV_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d≤max_dist src"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_dist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>Vd_ss_V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vd d ⊆ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Vd_def</span><span> </span><span>connected_inV_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>finite_C</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_ss</span><span> </span><span>FIN_V</span><span> </span><span>Vd_ss_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>nf_invar</span><span class="delimiter">)</span><span> </span><span>finite_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (E``{u})"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>pre_bfs_correct</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"src∈V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src≠dst"</span></span></span><span>       
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_bfs src dst ≤ SPEC (bfs_spec src dst)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_bfs_def</span><span> </span><span>add_succ_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>outer_loop_rel_wf</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>src</span><span class="delimiter">=</span><span>src</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span>
</span><span>      </span><span>invar_init</span><span> 
</span><span>      </span><span>nf_invar.invar_exit'</span><span> 
</span><span>      </span><span>nf_invar.invar_C_ss_V</span><span> 
</span><span>      </span><span>nf_invar.invar_succ_step</span><span>
</span><span>      </span><span>nf_invar'.invar_shift</span><span>
</span><span>      </span><span>nf_invar'.invar_restore</span><span>        
</span><span>      </span><span>f_invar.invar_found</span><span>
</span><span>      </span><span>nf_invar.invar_not_found</span><span>
</span><span>      </span><span>nf_invar.invar_N_ss_Vis</span><span>
</span><span>      </span><span>nf_invar.finite_succ</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_subset</span><span> </span><span>outer_loop_rel_def</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nf_invar.C_ne_max_dist</span><span> </span><span>nf_invar.finite_C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Presentation for Paper *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bfs_core</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node ⇒ (nat × (node⇀node)) option nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_core src dst ≡ do {
    (f,P,_,_,d) ← while<span class="hidden">⇩</span><sub>T</sub> (λ(f,P,C,N,d). f=False ∧ C≠{})
      (λ(f,P,C,N,d). do {
        v ← spec v. v∈C; let C = C-{v};
        let succ = (E``{v});
        (f,P,N) ← add_succ_spec dst succ v P N;
        if f then
          return (f,P,C,N,d+1)
        else do {
          if (C={}) then do {
            let C=N; let N={}; let d=d+1;
            return (f,P,C,N,d)
          } else return (f,P,C,N,d)
        }  
      })
      (False,[src↦src],{src},{},0::nat);
    if f then return (Some (d, P)) else return None
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src∈V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src≠dst"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_core src dst ≤ (spec p. bfs_spec src dst p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>pre_bfs_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_core_def</span><span> </span><span>pre_bfs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extraction of Result Path›</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_rpath src dst PRED ≡ do {
      (_,p) ← WHILEIT
        (λ(v,p). 
          v∈dom PRED 
        ∧ isPath v p dst
        ∧ distinct (pathVertices v p)
        ∧ (∀v'∈set (pathVertices v p). 
            pre_bfs_invar.ndist c src v ≤ pre_bfs_invar.ndist c src v')
        ∧ pre_bfs_invar.ndist c src v + length p 
          = pre_bfs_invar.ndist c src dst)
        (λ(v,p). v≠src) (λ(v,p). do {
        ASSERT (v∈dom PRED);
        let u=the (PRED v);
        let p = (u,v)#p;
        let v=u;
        RETURN (v,p)
      }) (dst,[]);
      RETURN p
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>valid_PRED</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extract_rpath_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dst∈dom PRED"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_rpath src dst PRED 
        ≤ SPEC (λp. isSimplePath src p dst ∧ length p = ndist dst)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_rpath_def</span><span> </span><span>isSimplePath_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>wf_measure</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(d,_). ndist d"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PRED_closed</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>domD</span><span class="delimiter">]</span><span> </span><span>PRED_E</span><span> </span><span>PRED_dist</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs src dst ≡ do {
      if src=dst then RETURN (Some [])
      else do {
        br ← pre_bfs src dst;
        case br of
          None ⇒ RETURN None
        | Some (d,PRED) ⇒ do {
            p ← extract_rpath src dst PRED;
            RETURN (Some p)
          }  
      }    
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bfs_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src∈V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs src dst 
        ≤ SPEC (λ
          None ⇒ ¬connected src dst 
        | Some p ⇒ isShortestPath src p dst)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>        </span><span>pre_bfs_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>valid_PRED.extract_rpath_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bfs_spec_def</span><span> </span><span>isShortestPath_min_dist_def</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Snippet for paper *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Finite_Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>Refine_Monadic_Syntax</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">theorem</span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src∈V"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs src dst ≤ (spec p. case p of 
          None ⇒ ¬connected src dst 
        | Some p ⇒ isShortestPath src p dst)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>        </span><span>pre_bfs_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>valid_PRED.extract_rpath_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bfs_spec_def</span><span> </span><span>isShortestPath_min_dist_def</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>      
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inserting inner Loop and Successor Function›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_loop dst succ u PRED N ≡ FOREACHci
    (λit (f,PRED',N'). 
        PRED' = map_mmupd PRED ((succ - it) - dom PRED) u 
      ∧ N' = N ∪ ((succ - it) - dom PRED)
      ∧ f = (dst∈(succ - it) - dom PRED)
    )
    (succ)
    (λ(f,PRED,N). ¬f)
    (λv (f,PRED,N). do {
      if v∈dom PRED then RETURN (f,PRED,N)
      else do {
        let PRED = PRED(v ↦ u);
        ASSERT (v∉N);
        let N = insert v N;
        RETURN (v=dst,PRED,N)
      }
    }) 
    (False,PRED,N)"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inner_loop_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*assumes NSS: "N ⊆ dom PRED"*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite succ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(succi,succ)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ui,u)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(PREDi,PRED)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Ni,N)∈Id"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_loop dst succi ui PREDi Ni 
      ≤ ⇓Id (add_succ_spec dst succ u PRED N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inner_loop_def</span><span> </span><span>add_succ_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span> </span><span>fun_neq_ext_iff</span><span> </span><span>map_mmupd_def</span><span> 
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>it_step_insert_iff</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>map_mmupd_update_less</span><span> 
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_loop2 dst succl u PRED N ≡ nfoldli
    (succl) (λ(f,_,_). ¬f) (λv (f,PRED,N). do {
    if PRED v ≠ None then RETURN (f,PRED,N)
    else do {
      let PRED = PRED(v ↦ u);
      ASSERT (v∉N);
      let N = insert v N;
      RETURN ((v=dst),PRED,N)
    }
  }) (False,PRED,N)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inner_loop2_refine</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(succl,succ)∈⟨Id⟩list_set_rel"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_loop2 dst succl u PRED N ≤ ⇓Id (inner_loop dst succ u PRED N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inner_loop2_def</span><span> </span><span>inner_loop_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>LFOci_refine</span><span> </span><span>SR</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>conc_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inner_loop2_refine</span><span> </span><span>inner_loop_refine</span><span class="delimiter">,</span><span> </span><span>no_vars</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inner_loop2_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(succl, succ) ∈ ⟨Id⟩list_set_rel"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*assumes "N ⊆ dom PRED"*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(dsti,dst)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ui, u) ∈ Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(PREDi, PRED) ∈ Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Ni, N) ∈ Id"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_loop2 dsti succl ui PREDi Ni 
      ≤ ⇓ Id (add_succ_spec dst succ u PRED N)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conc_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inner_loop2_refine</span><span> </span><span>inner_loop_refine</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bfs_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool × (node ⇀ node) × node set × node set × nat"</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>succ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ bfs_state nres"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"init_state src ≡ RETURN (False,[src↦src],{src},{},0::nat)"</span></span></span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pre_bfs2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node ⇒ (nat × (node⇀node)) option nres"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_bfs2 src dst ≡ do {
        s ← init_state src;
        (f,PRED,_,_,d) ← WHILET (λ(f,PRED,C,N,d). f=False ∧ C≠{})
          (λ(f,PRED,C,N,d). do {
            ASSERT (C≠{});
            v ← op_set_pick C; let C = C-{v};
            ASSERT (v∈V);
            sl ← succ v;
            (f,PRED,N) ← inner_loop2 dst sl v PRED N;
            if f then
              RETURN (f,PRED,C,N,d+1)
            else do {
              ASSERT (assn1 src dst (f,PRED,C,N,d));
              if (C={}) then do {
                let C=N; 
                let N={}; 
                let d=d+1;
                RETURN (f,PRED,C,N,d)
              } else RETURN (f,PRED,C,N,d)
            }  
          })
          s;
        if f then RETURN (Some (d, PRED)) else RETURN None
        }"</span></span></span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pre_bfs2_refine</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>succ_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ui u. ⟦(ui,u)∈Id; u∈V⟧ 
          ⟹ succ ui ≤ SPEC (λl. (l,E``{u}) ∈ ⟨Id⟩list_set_rel)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_bfs2 src dst ≤⇓Id (pre_bfs src dst)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pre_bfs_def</span><span> </span><span>pre_bfs2_def</span><span> </span><span>init_state_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>nres_monad1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>inner_loop2_correct</span><span> </span><span>succ_impl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Takes some time *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs2 succ src dst ≡ do {
      if src=dst then 
        RETURN (Some [])
      else do {  
        br ← pre_bfs2 succ src dst;
        case br of
          None ⇒ RETURN None
        | Some (d,PRED) ⇒ do {
            p ← extract_rpath src dst PRED;
            RETURN (Some p)
          }  
      }    
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bfs2_refine</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>succ_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ui u. ⟦(ui,u)∈Id; u∈V⟧ 
        ⟹ succ ui ≤ SPEC (λl. (l,E``{u}) ∈ ⟨Id⟩list_set_rel)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs2 succ src dst ≤ ⇓Id (bfs src dst)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs_def</span><span> </span><span>bfs2_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>pre_bfs2_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>      
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bfs2_refine_succ</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ui u. ⟦(ui,u)∈Id; u∈Graph.V c⟧ 
      ⟹ succi ui ≤ ⇓Id (succ u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(si,s)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ti,t)∈Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ci,c)∈Id"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.bfs2 ci succi si ti ≤ ⇓Id (Graph.bfs2 c succ s t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.bfs2_def</span><span> </span><span>Graph.pre_bfs2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> 
</span><span>      </span><span>param_nfoldli</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span> </span><span>nres_relI</span><span> </span><span>fun_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative Implementation›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Impl_Succ</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>op_bfs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ga ⇒ node ⇒ node ⇒ path option nres"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"op_bfs c s t ≡ Graph.bfs2 (absG c) (succ c) s t"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pat_op_dfs</span><span class="delimiter">[</span><span>pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Graph.bfs2$(absG$c)$(succ$c)$s$t ≡ UNPROTECT op_bfs$c$s$t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST op_bfs"</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ig ⇒ node ⇒ node ⇒ path option nres"</span></span></span><span>  
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ibfs_state</span><span> 
</span><span>      </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool × (node,node) i_map × node set × node set × nat"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>Graph.init_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ ibfs_state nres"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>init_state_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>src</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>src</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(nat)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine (hn_val nat_rel src srci) 
        (?c::?'c Heap) ?Γ' ?R (Graph.init_state src)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.init_state_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[src↦src]"</span></span></span><span> </span><span>iam.fold_custom_empty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ls.fold_custom_empty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ls.fold_custom_empty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert src _"</span></span></span><span> </span><span>fold_set_insert_dj</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_(⌑↦src)"</span></span></span><span> </span><span>fold_COPY</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>init_state_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Impl_Succ.init_state_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">,</span><span>to_hfref</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>bfs_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*notes [sepref_opt_simps del] = imp_nfoldli_def 
          -- ‹Prevent the foreach-loop to be unfolded to a fixed-point, 
              to produce more readable code for presentation purposes.›*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>heap_WHILET_def</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(nat)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(nat)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE('ig)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="comment">― ‹Declare parameters to operation identification›</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine (
        hn_ctxt (isG) c ci 
      * hn_val nat_rel s si 
      * hn_val nat_rel t ti) (?c::?'c Heap) ?Γ' ?R (PR_CONST op_bfs c s t)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_bfs_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.bfs2_def</span><span> </span><span>Graph.pre_bfs2_def</span><span> 
</span><span>        </span><span>Graph.inner_loop2_def</span><span> </span><span>Graph.extract_rpath_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nres_monad_laws</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nfoldli _ _ ⌑ _"</span></span></span><span> </span><span>fold_set_insert_dj</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>HOL_list.fold_custom_empty</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"let N={} in _"</span></span></span><span> </span><span>ls.fold_custom_empty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>bfs_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Impl_Succ.bfs_impl</span><span>
</span><span>      </span><span class="comment">― ‹Extract generated implementation into constant›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>bfs_impl_def</span><span>
</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bfs_impl_fr_rule</span><span> </span><span class="delimiter">=</span><span> </span><span>bfs_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">,</span><span>to_hfref</span><span class="delimiter">]</span><span>  
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>bfs_impl</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML_imp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="EdmondsKarp_Impl">
<div class="head"><h1>Theory EdmondsKarp_Impl</h1>
<span class="command">theory</span> <span class="name">EdmondsKarp_Impl</span><br/>
<span class="keyword">imports</span> <a href="EdmondsKarp_Algo.html"><span class="name">EdmondsKarp_Algo</span></a> <a href="Augmenting_Path_BFS.html"><span class="name">Augmenting_Path_BFS</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of the Edmonds-Karp Algorithm›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>EdmondsKarp_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>EdmondsKarp_Algo</span><span>
</span><span>  </span><span>Augmenting_Path_BFS</span><span>
</span><span>  </span><span>Refine_Imperative_HOL.IICF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now implement the Edmonds-Karp algorithm.
    Note that, during the implementation, we explicitly write down the 
    whole refined algorithm several times. As refinement is modular, most 
    of these copies could be avoided--- we inserted them deliberately for
    documentation purposes.
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement to Residual Graph›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As a first step towards implementation, we refine the algorithm
      to work directly on residual graphs. For this, we first have to 
      establish a relation between flows in a network and residual graphs.
      ›</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement of Operations›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define the relation between residual graphs and flows›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfi_rel ≡ br flow_of_cf (RGraph c s t)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It can also be characterized the other way round, i.e., 
      mapping flows to residual graphs:›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cfi_rel_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfi_rel = {(cf,f). cf = residualGraph c f ∧ NFlow c s t f}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NFlow.is_RGraph</span><span> </span><span>RGraph.is_NFlow</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RPreGraph.rg_fo_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RGraph.this_loc_rpg</span><span class="delimiter">]</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NPreflow.fo_rg_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NFlow.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Initially, the residual graph for the zero flow equals the original network›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>residualGraph_zero_flow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"residualGraph c (λ_. 0) = c"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>residualGraph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flow_of_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"flow_of_cf c = (λ_. 0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flow_of_cf_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The residual capacity is naturally defined on residual graphs›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap_cf cf p ≡ Min {cf e | e. e∈set p}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>resCap_cf_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap_cf cf p = resCap p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_cf_def</span><span> </span><span>resCap_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Augmentation can be done by @{const Graph.augment_cf}.›</span></span></span><span> 
</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>NFlow</span><span class="delimiter">)</span><span> </span><span>augment_cf_refine_aux</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For snippet *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isAugmentingPath p"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"residualGraph c (augment (augmentingFlow p)) (u,v) = (
        if (u,v)∈set p then (residualGraph c f (u,v) - resCap p)
        else if (v,u)∈set p then (residualGraph c f (u,v) + resCap p)
        else residualGraph c f (u,v))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Graph.augment_cf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_refine</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cf,f)∈cfi_rel"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"NPreflow.isAugmentingPath c s t f p"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Graph.augment_cf cf (set p) (resCap_cf cf p), 
          NFlow.augment_with_path c f p) ∈ cfi_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf = residualGraph c f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NFlow c s t f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_alt</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span>NFlow</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f.augment_with_path_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cfi_rel_alt</span><span class="delimiter">;</span><span> </span><span>safe</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.augment_cf f.cf (set p) (resCap_cf f.cf p) (u,v) 
              = residualGraph c (f.augment (f.augmentingFlow p)) (u,v)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f.augment_cf_refine_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f.cf.augment_cf_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f.resCap_cf_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f.augment_pres_nflow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AUG</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We rephrase the specification of shortest augmenting path to
      take a residual graph as parameter›</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This actually rephrases the spec to make it look more similar to 
      what BFS does later. This rephrasing does not belong here, but where we 
      implement it with BFS. *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"find_shortest_augmenting_spec_cf cf ≡ 
      assert (RGraph c s t cf) ⪢
      SPEC (λ
        None ⇒ ¬Graph.connected cf s t 
      | Some p ⇒ Graph.isShortestPath cf s p t)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>find_shortest_augmenting_spec_cf_refine</span><span class="delimiter">:</span><span> 
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"find_shortest_augmenting_spec_cf cf 
      ≤ find_shortest_augmenting_spec (flow_of_cf cf)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_shortest_augmenting_spec_cf_def</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>find_shortest_augmenting_spec_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>this_loc</span><span> </span><span>rg_is_cf</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f.isAugmentingPath_def</span><span> </span><span>Graph.connected_def</span><span> </span><span>Graph.isSimplePath_def</span><span> 
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cf.shortestPath_is_path</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This leads to the following refined algorithm›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka2 ≡ do {
      let cf = c;

      (cf,_) ← while<span class="hidden">⇩</span><sub>T</sub> 
        (λ(cf,brk). ¬brk) 
        (λ(cf,_). do {
          assert (RGraph c s t cf);
          p ← find_shortest_augmenting_spec_cf cf;
          case p of 
            None ⇒ return (cf,True)
          | Some p ⇒ do {
              assert (p≠[]);
              assert (Graph.isShortestPath cf s p t);
              let cf = Graph.augment_cf cf (set p) (resCap_cf cf p);
              assert (RGraph c s t cf);
              return (cf, False)
            }  
        })
        (cf,False);
      assert (RGraph c s t cf);
      let f = flow_of_cf cf;  
      return f
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka2_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka2 ≤ ⇓Id edka"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RELATES cfi_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka2_def</span><span> </span><span>edka_def</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rewrite in "let f' = NFlow.augmentingFlow c _ _ in _" Let_def)
        apply (rewrite in "let f = flow_of_cf _ in _" Let_def)*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>
</span><span>        </span><span class="comment">― ‹Solve some left-over verification conditions one by one›</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>NFlow.is_RGraph</span><span class="delimiter">;</span><span> 
</span><span>            </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span> </span><span>residualGraph_zero_flow</span><span> </span><span>flow_of_c</span><span class="delimiter">;</span><span> 
</span><span>            </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RGraph.find_shortest_augmenting_spec_cf_refine</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RPreGraph.rg_fo_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RGraph.this_loc_rpg</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>augment_cf_refine</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>augment_cf_refine</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cfi_rel_def</span><span> </span><span>br_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Bottleneck Computation and Augmentation›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We will access the capacities in the residual graph
      only by a get-operation, which asserts that the edges are valid›</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>valid_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"edge ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"valid_edge ≡ λ(u,v). u∈V ∧ v∈V"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cf_get</span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph ⇒ edge ⇒ 'capacity nres"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_get cf e ≡ ASSERT (valid_edge e) ⪢ RETURN (cf e)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cf_set</span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph ⇒ edge ⇒ 'capacity ⇒ 'capacity graph nres"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_set cf e cap ≡ ASSERT (valid_edge e) ⪢ RETURN (cf(e:=cap))"</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resCap_cf_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph ⇒ path ⇒ 'capacity nres"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap_cf_impl cf p ≡ 
      case p of
        [] ⇒ RETURN (0::'capacity)
      | (e#p) ⇒ do {
          cap ← cf_get cf e;
          ASSERT (distinct p);
          nfoldli 
            p (λ_. True)
            (λe cap. do {
              cape ← cf_get cf e;
              RETURN (min cape cap)
            }) 
            cap
        }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>resCap_cf_impl_refine</span><span class="delimiter">:</span><span>   
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AUG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf.isSimplePath s p t"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resCap_cf_impl cf p ≤ SPEC (λr. r = resCap_cf cf p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Can we exploit Min.set_eq_fold *)</span></span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Min_insert</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Min_insert</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AUG</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cf.isSPath_distinct</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct p"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AUG</span><span> </span><span>cf.isPath_edgeset</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set p ⊆ cf.E"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.isSimplePath_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set p ⊆ Collect valid_edge"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf.E_ss_VxV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AUG</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p≠[]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s_not_t</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=e#p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_cf_impl_def</span><span> </span><span>resCap_cf_def</span><span> </span><span>cf_get_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>list.case</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>nfoldli_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span>I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λl l' cap. 
              cap = Min (cf`insert e (set l)) 
            ∧ set (l@l') ⊆ Collect valid_edge"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>Min</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"augment_edge e cap ≡ (c(
                  e := c e - cap, 
        prod.swap e := c (prod.swap e) + cap))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This would be much simpler to prove if we had a characterization 
      of simple-path only depending on p. *)</span></span></span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Graph</span><span class="delimiter">)</span><span> </span><span>augment_cf_inductive</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>e</span><span> </span><span>cap</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ≡ augment_edge e cap"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isSimplePath s (e#p) t"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'. Graph.isSimplePath c' s' p t"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=(u,v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isSPath_no_selfloop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀u. (u,u)∉set p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u≠v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isSPath_nt_parallel</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,u)∉set p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isSPath_distinct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v)∉set p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.augment_cf_def</span><span> </span><span>c'_def</span><span> </span><span>Graph.augment_edge_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isSimplePath c' v p t"</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.isSimplePath_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>transfer_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>c'_def</span><span> </span><span>Graph.augment_edge_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isSimplePath_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'. Graph.isSimplePath c' s' p t"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_edge_impl cf e cap ≡ do {
      v ← cf_get cf e; cf ← cf_set cf e (v-cap);
      let e = prod.swap e;
      v ← cf_get cf e; cf ← cf_set cf e (v+cap);
      RETURN cf
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_edge_impl_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge e"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. e≠(u,u)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_edge_impl cf e cap 
          ≤ (spec r. r = Graph.augment_edge cf e cap)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>augment_edge_impl_def</span><span> </span><span>Graph.augment_edge_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_get_def</span><span> </span><span>cf_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>augment_cf_impl</span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph ⇒ path ⇒ 'capacity ⇒ 'capacity graph nres"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"augment_cf_impl cf p x ≡ do {
        (rec<span class="hidden">⇩</span><sub>T</sub> D. λ
          ([],cf) ⇒ return cf
        | (e#p,cf) ⇒ do {
            cf ← augment_edge_impl cf e x;
            D (p,cf)
          }  
        ) (p,cf)
      }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deriving the corresponding recursion equations›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_impl_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"augment_cf_impl cf [] x = return cf"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"augment_cf_impl cf (e#p) x = do { 
        cf ← augment_edge_impl cf e x; 
        augment_cf_impl cf p x}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>augment_cf_impl_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>augment_cf_impl_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>      
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_cf_impl_aux</span><span class="delimiter">:</span><span>    
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e∈set p. valid_edge e"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s. Graph.isSimplePath cf s p t"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf_impl cf p x ≤ RETURN (Graph.augment_cf cf (set p) x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>cf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Graph.augment_cf_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Graph.augment_cf_inductive</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>augment_edge_impl_refine</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Graph.isSPath_no_selfloop</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">,</span><span> </span><span>rprems</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Graph.augment_cf_inductive</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cap</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>augment_cf_impl_refine</span><span class="delimiter">:</span><span>     
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.isSimplePath cf s p t"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"augment_cf_impl cf p x ≤ RETURN (Graph.augment_cf cf (set p) x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>augment_cf_impl_aux</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cf.E_ss_VxV</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cf.isSimplePath_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cf.isPath_edgeset</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we arrive at the algorithm where augmentation is 
      implemented algorithmically: ›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka3 ≡ do {
      let cf = c;

      (cf,_) ← while<span class="hidden">⇩</span><sub>T</sub> 
        (λ(cf,brk). ¬brk) 
        (λ(cf,_). do {
          assert (RGraph c s t cf);
          p ← find_shortest_augmenting_spec_cf cf;
          case p of 
            None ⇒ return (cf,True)
          | Some p ⇒ do {
              assert (p≠[]);
              assert (Graph.isShortestPath cf s p t);
              bn ← resCap_cf_impl cf p;
              cf ← augment_cf_impl cf p bn;
              assert (RGraph c s t cf);
              return (cf, False)
            }  
        })
        (cf,False);
      assert (RGraph c s t cf);
      let f = flow_of_cf cf;  
      return f
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka3_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka3 ≤ ⇓Id edka2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka3_def</span><span> </span><span>edka2_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"let cf = Graph.augment_cf _ _ _ in _"</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Graph.shortestPath_is_simple</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>RGraph.resCap_cf_impl_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>RGraph.augment_cf_impl_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement to use BFS›</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We refine the Edmonds-Karp algorithm to use breadth first search (BFS)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka4 ≡ do {
      let cf = c;

      (cf,_) ← while<span class="hidden">⇩</span><sub>T</sub> 
        (λ(cf,brk). ¬brk) 
        (λ(cf,_). do {
          assert (RGraph c s t cf);
          p ← Graph.bfs cf s t;
          case p of 
            None ⇒ return (cf,True)
          | Some p ⇒ do {
              assert (p≠[]);
              assert (Graph.isShortestPath cf s p t);
              bn ← resCap_cf_impl cf p;
              cf ← augment_cf_impl cf p bn;
              assert (RGraph c s t cf);
              return (cf, False)
            }  
        })
        (cf,False);
      assert (RGraph c s t cf);
      let f = flow_of_cf cf;  
      return f
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A shortest path can be obtained by BFS›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bfs_refines_shortest_augmenting_spec</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Graph.bfs cf s t ≤ find_shortest_augmenting_spec_cf cf"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_shortest_augmenting_spec_cf_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_ASSERTI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Graph.bfs_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RPreGraph.resV_netV</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RGraph.this_loc_rpg</span><span class="delimiter">]</span><span> </span><span>s_node</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RPreGraph.resV_netV</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RGraph.this_loc_rpg</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka4_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka4 ≤ ⇓Id edka3"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka4_def</span><span> </span><span>edka3_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bfs_refines_shortest_augmenting_spec</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementing the Successor Function for BFS›</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We implement the successor function in two steps.
      The first step shows how to obtain the successor function by
      filtering the list of adjacent nodes. This step contains the idea   
      of the implementation. The second step is purely technical, and makes 
      explicit the recursion of the filter function as a recursion combinator
      in the monad. This is required for the Sepref tool.
      ›</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note: We use @{term filter_rev} here, as it is tail-recursive, 
      and we are not interested in the order of successors.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rg_succ am cf u ≡  
      filter_rev (λv. cf (u,v) &gt; 0) (am u)"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>rg_succ_ref1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_adj_map am⟧ 
      ⟹ (rg_succ am cf u, Graph.E cf``{u}) ∈ ⟨Id⟩list_set_rel"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Graph.E_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>rg_succ_def</span><span> </span><span>filter_rev_alt</span><span class="delimiter">;</span><span> 
</span><span>        </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfE_ss_invE</span><span> </span><span>resE_nonNegative</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_adj_map_def</span><span> </span><span>less_le</span><span> </span><span>Graph.E_def</span><span> 
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>cf.zero_cap_simp</span><span> </span><span>zero_cap_simp</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_adj_map_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ps_get_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ node ⇒ node list nres"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ps_get_op am u ≡ assert (u∈V) ⪢ return (am u)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>monadic_filter_rev_aux</span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a ⇒ bool nres) ⇒ 'a list ⇒ 'a list nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"monadic_filter_rev_aux a P l ≡ (rec<span class="hidden">⇩</span><sub>T</sub> D. (λ(l,a). case l of
        [] ⇒ return a 
      | (v#l) ⇒ do {
          c ← P v;
          let a = (if c then v#a else a);
          D (l,a)
        }
      )) (l,a)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_filter_rev_aux_rule</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x∈set l ⟹ P x ≤ SPEC (λr. r=Q x)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monadic_filter_rev_aux a P l ≤ SPEC (λr. r=filter_rev_aux a Q l)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>monadic_filter_rev_aux_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>monadic_filter_rev_aux_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>monadic_filter_rev_aux_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>monadic_filter_rev_aux_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monadic_filter_rev = monadic_filter_rev_aux []"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_filter_rev_rule</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x∈set l ⟹ P x ≤ (spec r. r=Q x)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monadic_filter_rev P l ≤ (spec r. r=filter_rev Q l)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monadic_filter_rev_aux_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>monadic_filter_rev_def</span><span> </span><span>filter_rev_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rg_succ2 am cf u ≡ do {
      l ← ps_get_op am u;
      monadic_filter_rev (λv. do {
        x ← cf_get cf (u,v);
        return (x&gt;0)
      }) l
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>rg_succ_ref2</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rg_succ2 am cf u ≤ return (rg_succ am cf u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈set (am u). valid_edge (u,v)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PS</span><span> </span><span>V</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_adj_map_def</span><span> </span><span>Graph.V_def</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rg_succ2_def</span><span> </span><span>rg_succ_def</span><span> </span><span>ps_get_op_def</span><span> </span><span>cf_get_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>monadic_filter_rev_rule</span><span class="delimiter">[</span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(λv. 0 &lt; cf (u, v))"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>rg_succ_ref</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rg_succ2 am cf u ≤ SPEC (λl. (l,cf.E``{u}) ∈ ⟨Id⟩list_set_rel)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rg_succ_ref1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span>rg_succ_ref2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adding Tabulation of Input›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
      Next, we add functions that will be refined to tabulate the input of 
      the algorithm, i.e., the network's capacity matrix and adjacency map,
      into efficient representations. 
      The capacity matrix is tabulated to give the initial residual graph,
      and the adjacency map is tabulated for faster access.

      Note, on the abstract level, the tabulation functions are just identity,
      and merely serve as marker constants for implementation.
      ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph nres"</span></span></span><span> 
</span><span>      </span><span class="comment">― ‹Initialization of residual graph from network›</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_cf ≡ RETURN c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_ps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ _"</span></span></span><span> 
</span><span>      </span><span class="comment">― ‹Initialization of adjacency map›</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_ps am ≡ ASSERT (is_adj_map am) ⪢ RETURN am"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compute_rflow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'capacity graph ⇒ 'capacity flow nres"</span></span></span><span> 
</span><span>      </span><span class="comment">― ‹Extraction of result flow from residual graph›</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"compute_rflow cf ≡ ASSERT (RGraph c s t cf) ⪢ RETURN (flow_of_cf cf)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs2_op am cf ≡ Graph.bfs2 cf (rg_succ2 am cf) s t"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We split the algorithm into a tabulation function, and the 
      running of the actual algorithm:›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka5_tabulate am ≡ do {
      cf ← init_cf;
      am ← init_ps am;
      return (cf,am)
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka5_run cf am ≡ do {
      (cf,_) ← while<span class="hidden">⇩</span><sub>T</sub> 
        (λ(cf,brk). ¬brk) 
        (λ(cf,_). do {
          assert (RGraph c s t cf);
          p ← bfs2_op am cf;
          case p of 
            None ⇒ return (cf,True)
          | Some p ⇒ do {
              assert (p≠[]);
              assert (Graph.isShortestPath cf s p t);
              bn ← resCap_cf_impl cf p;
              cf ← augment_cf_impl cf p bn;
              assert (RGraph c s t cf);
              return (cf, False)
            }  
        })
        (cf,False);
      f ← compute_rflow cf;  
      return f
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka5 am ≡ do {
      (cf,am) ← edka5_tabulate am;
      edka5_run cf am
    }"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka5_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_adj_map am⟧ ⟹ edka5 am ≤ ⇓Id edka4"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka5_def</span><span> </span><span>edka5_tabulate_def</span><span> </span><span>edka5_run_def</span><span>
</span><span>        </span><span>edka4_def</span><span> </span><span>init_cf_def</span><span> </span><span>compute_rflow_def</span><span>
</span><span>        </span><span>init_ps_def</span><span> </span><span>Let_def</span><span> </span><span>nres_monad_laws</span><span> </span><span>bfs2_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Graph.bfs2_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RPreGraph.resV_netV</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RGraph.this_loc_rpg</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RGraph.rg_succ_ref</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Imperative Implementation›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this section we provide an efficient imperative implementation,
    using the Sepref tool. It is mostly technical, setting up the mappings
    from abstract to concrete data structures, and then refining the algorithm,
    function by function.  
    ›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    This is also the point where we have to choose the implementation of 
    capacities. Up to here, they have been a polymorphic type with a
    typeclass constraint of being a linearly ordered integral domain.
    Here, we switch to @{typ [source] capacity_impl} (@{typ capacity_impl}).
    ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Network_Impl</span><span> </span><span class="delimiter">=</span><span> </span><span>Network</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Moreover, we assume that the nodes are natural numbers less 
    than some number @{term N}, which will become an additional parameter 
    of our algorithm. ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Edka_Impl</span><span> </span><span class="delimiter">=</span><span> </span><span>Network_Impl</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V⊆{0..&lt;N}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>this_loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Edka_Impl c s t N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ⊆ {0..&lt;N}×{0..&lt;N}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss_VxV</span><span> </span><span>V_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtx_nonzero_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtx_nonzero c = E"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mtx_nonzero_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtx_nonzeroN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtx_nonzero c ⊆ {0..&lt;N}×{0..&lt;N}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V ⟹ v&lt;N"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Declare some variables to Sepref. ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>N</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(nat)"</span></span></span><span class="delimiter">]</span><span>  
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node)"</span></span></span><span class="delimiter">]</span><span>  
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node)"</span></span></span><span class="delimiter">]</span><span>  
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl graph)"</span></span></span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instruct Sepref to not refine these parameters. This is expressed
      by using identity as refinement relation.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>      </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>      </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span>      </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*IdI[of c]*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry0 (return c),uncurry0 (return c))∈unit_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> pure (nat_rel×<span class="hidden">⇩</span><sub>r</sub>nat_rel → int_rel)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sep_auto</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Adjacency Map by Array›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_am am psi 
      ≡ ∃<span class="hidden">⇩</span><sub>A</sub>l. psi ↦<span class="hidden">⇩</span><sub>a</sub> l 
          * ↑(length l = N ∧ (∀i&lt;N. l!i = am i) 
              ∧ (∀i≥N. am i = []))"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_am_precise</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"precise (is_am)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_am_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>l</span><span> </span><span>l'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>prec_extract_eqs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;length l'"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_decl_intf</span></span><span> </span><span>i_ps</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps_get_imp psi u ≡ Array.nth psi u"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.ps_get_op$c ≡ UNPROTECT ps_get_op"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST ps_get_op"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i_ps ⇒ node ⇒ node list nres"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ps_get_op_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry ps_get_imp, uncurry (PR_CONST ps_get_op)) 
        ∈ is_am<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> list_assn (pure Id)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_assn_pure_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_ss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> 
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_am_def</span><span> </span><span>pure_def</span><span> </span><span>ps_get_imp_def</span><span> 
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ps_get_op_def</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_pred_succ_no_node</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_adj_map a; u∉V⟧ ⟹ a u = []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_adj_map_def</span><span> </span><span>V_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Array.make N, PR_CONST init_ps) 
      ∈ (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> is_am"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_ss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_ps_def</span><span> </span><span>refine_pw_simps</span><span> </span><span>is_am_def</span><span> </span><span>pure_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>is_pred_succ_no_node</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.init_ps$c ≡ UNPROTECT init_ps"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST init_ps"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ i_ps nres"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Capacity Matrix by Array›</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.cf_get$c ≡ UNPROTECT cf_get"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.cf_set$c ≡ UNPROTECT cf_set"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"PR_CONST cf_get"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ edge ⇒ capacity_impl nres"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"PR_CONST cf_set"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ edge ⇒ capacity_impl 
        ⇒ capacity_impl i_mtx nres"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We have to link the matrix implementation, which encodes the bound, 
      to the abstract assertion of the bound›</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>cf_get_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry (PR_CONST cf_get)"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (prod_assn id_assn id_assn)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> id_assn"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span> </span><span>cf_get_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cf_get_impl.refine</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cf_get_impl_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>cf_set_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry2 (PR_CONST cf_set)"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>d</sup> *<span class="hidden">⇩</span><sub>a</sub> (prod_assn id_assn id_assn)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> id_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> asmtx_assn N id_assn"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span> </span><span>cf_set_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cf_set_impl.refine</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cf_set_impl_def</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>init_cf_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry0 (PR_CONST init_cf)"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit_assn<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> asmtx_assn N id_assn"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span> </span><span>init_cf_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_ss</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>op_mtx_new_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>amtx_fold_custom_new</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span> </span><span>N</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>init_cf_impl</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.init_cf_impl.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry0 ?f,_)∈_"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>init_cf_impl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>init_cf_impl.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span>  
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Use sepref to synthesize the get-operations! *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>amtx_cnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"amtx_assn N M id_assn = IICF_Array_Matrix.is_amtx N M"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>amtx_assn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*

    lemma init_cf_imp_refine[sepref_fr_rules]: 
      "(uncurry0 (mtx_new N c), uncurry0 (PR_CONST init_cf)) 
        ∈ (pure unit_rel)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> (asmtx_assn N id_assn)"
      unfolding asmtx_cnv
      apply sepref_to_hoare
      using E_ss
      by (sep_auto simp: init_cf_def)
    *)</span></span></span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.init_cf$c ≡ UNPROTECT init_cf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST init_cf"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx nres"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representing Result Flow as Residual Graph›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network_Impl</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rflow N f cfi 
      ≡ ∃<span class="hidden">⇩</span><sub>A</sub>cf. asmtx_assn N id_assn cf cfi * ↑(RGraph c s t cf ∧ f = flow_of_cf cf)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_rflow_precise</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"precise (is_rflow N)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_rflow_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>amtx_assn_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>prec_extract_eqs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_decl_intf</span></span><span> </span><span>i_rflow</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat×nat ⇒ int"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(λcfi. return cfi, PR_CONST compute_rflow) ∈ (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>d</sup> →<span class="hidden">⇩</span><sub>a</sub> is_rflow N"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>amtx_cnv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>amtx_cnv</span><span> </span><span>compute_rflow_def</span><span> </span><span>is_rflow_def</span><span> </span><span>refine_pw_simps</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Network.compute_rflow$c$s$t ≡ UNPROTECT compute_rflow"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"PR_CONST compute_rflow"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ i_rflow nres"</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Functions›</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>rg_succ2_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>am</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(i_ps)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>cf</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl i_mtx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>HOL_list_empty_hnr</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_val nat_rel u ui) (?c::?'c Heap) ?Γ ?R (rg_succ2 am cf u)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rg_succ2_def</span><span> </span><span>APP_def</span><span> </span><span>monadic_filter_rev_def</span><span> </span><span>monadic_filter_rev_aux_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Make setting up combinators for sepref simpler, then we do not need to unfold! *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>succ_imp</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.rg_succ2_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>succ_imp_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_imp_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry2 (succ_imp N), uncurry2 (PR_CONST rg_succ2)) 
        ∈ is_am<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> list_assn (pure Id)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_imp.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span>            
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>mult_ac</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.rg_succ2$c ≡ UNPROTECT rg_succ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"PR_CONST rg_succ2"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i_ps ⇒ capacity_impl i_mtx ⇒ node ⇒ node list nres"</span></span></span><span>
</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(min,min)∈Id→Id→Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path ≡ list_assn (prod_assn (pure Id) (pure Id))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>resCap_imp_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span> </span><span>pi</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(edge list)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>cf</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl i_mtx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine 
        (hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_ctxt is_path p pi) 
        (?c::?'c Heap) ?Γ ?R 
        (resCap_cf_impl cf p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resCap_cf_impl_def</span><span> </span><span>APP_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>resCap_imp</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.resCap_imp_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>resCap_imp_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resCap_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry (resCap_imp N), uncurry (PR_CONST resCap_cf_impl)) 
        ∈ (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (is_path)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> (pure Id)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hnr</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_preI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uncurry_def</span><span> </span><span>list_assn_pure_conv</span><span> </span><span>hn_ctxt_def</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>resCap_imp.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span> </span><span>_</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_assn_pure_conv</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>pure_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enttI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Network.resCap_cf_impl$c ≡ UNPROTECT resCap_cf_impl"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST resCap_cf_impl"</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ path ⇒ capacity_impl nres"</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_thm</span></span><span> </span><span>augment_imp</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry2 (PR_CONST augment_cf_impl)"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>d</sup> *<span class="hidden">⇩</span><sub>a</sub> (is_path)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> asmtx_assn N id_assn)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>augment_cf_impl_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>augment_edge_impl_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>augment_imp</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.augment_imp.refine_raw</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(uncurry2 ?f,_)∈_"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>augment_imp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl)) 
        ∈ (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>d</sup> *<span class="hidden">⇩</span><sub>a</sub> (is_path)<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> asmtx_assn N id_assn"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>augment_imp.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Network.augment_cf_impl$c ≡ UNPROTECT augment_cf_impl"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST augment_cf_impl"</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ path ⇒ capacity_impl ⇒ capacity_impl i_mtx nres"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>bfs</span><span class="delimiter">:</span><span> </span><span>Impl_Succ</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"snd"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"TYPE(i_ps × capacity_impl i_mtx)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"PR_CONST (λ(am,cf). rg_succ2 am cf)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"prod_assn is_am (asmtx_assn N id_assn)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λ(am,cf). succ_imp N am cf"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>APP_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fold_partial_uncurry</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>succ_imp_refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"bfsi' N s t psi cfi 
      ≡ bfs_impl (λ(am, cf). succ_imp N am cf) (psi,cfi) s t"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry (bfsi' N s t),uncurry (PR_CONST bfs2_op)) 
        ∈ is_am<span class="hidden">⇧</span><sup>k</sup> *<span class="hidden">⇩</span><sub>a</sub> (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> option_assn is_path"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfsi'_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>bfs2_op_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bfs.bfs_impl_fr_rule</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bfs.op_bfs_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfref_def</span><span> </span><span>all_to_meta</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rprems</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enttI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network.bfs2_op$c$s$t ≡ UNPROTECT bfs2_op"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST bfs2_op"</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i_ps ⇒ capacity_impl i_mtx ⇒ path option nres"</span></span></span><span>  
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>edka_imp_tabulate_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>heap_WHILET_def</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>am</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node ⇒ node list)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>am</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine (emp) (?c::?'c Heap) ?Γ ?R (edka5_tabulate am)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka5_tabulate_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp_tabulate</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.edka_imp_tabulate_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp_tabulate_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka_imp_tabulate_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(edka_imp_tabulate c N, PR_CONST edka5_tabulate) 
      ∈ (pure Id)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> prod_assn (asmtx_assn N id_assn) is_am"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_preI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uncurry_def</span><span> </span><span>list_assn_pure_conv</span><span> </span><span>hn_ctxt_def</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>edka_imp_tabulate.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Network.edka5_tabulate$c ≡ UNPROTECT edka5_tabulate"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST edka5_tabulate"</span></span></span><span>
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ (capacity_impl i_mtx × i_ps) nres"</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>edka_imp_run_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>heap_WHILET_def</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>cf</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl i_mtx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>am</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(i_ps)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine 
        (hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_ctxt is_am am psi) 
        (?c::?'c Heap) ?Γ ?R  
        (edka5_run cf am)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka5_run_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp_run</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.edka_imp_run_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp_run_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>edka_imp_run_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edka_imp_run_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(uncurry (edka_imp_run s t N), uncurry (PR_CONST edka5_run)) 
        ∈ (asmtx_assn N id_assn)<span class="hidden">⇧</span><sup>d</sup> *<span class="hidden">⇩</span><sub>a</sub> (is_am)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> is_rflow N"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uncurry_def</span><span> </span><span>list_assn_pure_conv</span><span> </span><span>hn_ctxt_def</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>edka_imp_run.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span> </span><span>_</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Network.edka5_run$c$s$t ≡ UNPROTECT edka5_run"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PR_CONST edka5_run"</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl i_mtx ⇒ i_ps ⇒ i_rflow nres"</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>edka_imp_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_opt_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>heap_WHILET_def</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>am</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node ⇒ node list)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>am</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine (emp) (?c::?'c Heap) ?Γ ?R (edka5 am)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edka5_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.edka_imp_impl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>edka_imp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>edka_imp_refine</span><span> </span><span class="delimiter">=</span><span> </span><span>edka_imp.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this_loc</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>pat_rules</span><span> </span><span>TrueI</span><span> </span><span>def_pat_rules</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>edka_imp</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML_imp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness Theorem for Implementation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We combine all refinement steps to derive a correctness 
    theorem for the implementation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>edka_imp_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c ⊆ {0..&lt;N}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ABS_PS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
        &lt;emp&gt; 
          edka_imp c s t N am 
        &lt;λfi. ∃<span class="hidden">⇩</span><sub>A</sub>f. is_rflow N f fi * ↑(isMaxFlow f)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Edka_Impl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>fact</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka5_refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ABS_PS</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka4_refine</span><span>                 
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka3_refine</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka2_refine</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka_refine</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>edka_partial_refine</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fofu_partial_correct</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edka5 am ≤ SPEC isMaxFlow"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hn_refine_ref</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>edka_imp_refine</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_refine_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Edka_Checked_Impl">
<div class="head"><h1>Theory Edka_Checked_Impl</h1>
<span class="command">theory</span> <span class="name">Edka_Checked_Impl</span><br/>
<span class="keyword">imports</span> <a href="../Flow_Networks/NetCheck.html"><span class="name">NetCheck</span></a> <a href="EdmondsKarp_Impl.html"><span class="name">EdmondsKarp_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combination with Network Checker›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Edka_Checked_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Flow_Networks.NetCheck</span><span> </span><span>EdmondsKarp_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we combine the Edmonds-Karp implementation with the 
  network checker.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adding Statistic Counters›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first add some statistic counters, that we use for profiling›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stat_outer_c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stat_outer_c = return ()"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_stat_outer_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = stat_outer_c ⪢ m"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stat_outer_c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stat_inner_c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit Heap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stat_inner_c = return ()"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_stat_inner_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = stat_inner_c ⪢ m"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stat_inner_c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>stat</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    structure stat = struct
      val outer_c = ref 0;
      fun outer_c_incr () = (outer_c := !outer_c + 1; ())
      val inner_c = ref 0;
      fun inner_c_incr () = (inner_c := !inner_c + 1; ())
    end
    ›</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>stat_outer_c</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"stat.outer'_c'_incr"</span></span></span><span>  
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>stat_inner_c</span><span> </span><span class="delimiter">⇀</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"stat.inner'_c'_incr"</span></span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edka_imp_run_0 s t N f brk = ?foo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>edka_imp_run.code</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌑"</span></span></span><span> </span><span>insert_stat_outer_c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>bfs_impl.code</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bfs_impl_0 succ_impl ci ti x = ?foo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bfs_impl.code</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"imp_nfoldli _ _ ⌑ _"</span></span></span><span> </span><span>insert_stat_inner_c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combined Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edmonds_karp el s t ≡ do {
  case prepareNet el s t of
    None ⇒ return None
  | Some (c,am,N) ⇒ do {
      f ← edka_imp c s t N am ;
      return (Some (c,am,N,f))
  }
}"</span></span></span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>edmonds_karp</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>network_is_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Network c s t ⟹ Network_Impl c s t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>edmonds_karp_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; edmonds_karp el s t &lt;λ
      None ⇒ ↑(¬ln_invar el ∨ ¬Network (ln_α el) s t)
    | Some (c,am,N,fi) ⇒ 
      ∃<span class="hidden">⇩</span><sub>A</sub>f. Network_Impl.is_rflow c s t N f fi 
      * ↑(ln_α el = c ∧ Graph.is_adj_map c am
        ∧ Network.isMaxFlow c s t f
        ∧ ln_invar el ∧ Network c s t ∧ Graph.V c ⊆ {0..&lt;N})
  &gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edmonds_karp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prepareNet_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> 
</span><span>    </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> 
</span><span>    </span><span>heap</span><span class="delimiter">:</span><span> </span><span>Network_Impl.edka_imp_correct</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ln_rel_def</span><span> </span><span>br_def</span><span> </span><span>network_is_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_rflow ≡ Network_Impl.is_rflow"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\DefineSnippet{edmonds_karp_correct}{›</span></span></span><span>       
</span><span class="keyword1"><span class="command">theorem</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>el</span><span> </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≡ ln_α el"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; 
      edmonds_karp el s t 
    &lt;λ None ⇒ ↑(¬ln_invar el ∨ ¬Network c s t)
     | Some (_,_,N,cf) ⇒ 
         ↑(ln_invar el ∧ Network c s t ∧ Graph.V c ⊆ {0..&lt;N})
       * (∃<span class="hidden">⇩</span><sub>A</sub>f. is_rflow c s t N f cf * ↑(Network.isMaxFlow c s t f))
    &gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹}%EndSnippet›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span>is_rflow_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>heap</span><span class="delimiter">:</span><span> </span><span>edmonds_karp_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>el</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Usage Example: Computing Maxflow Value ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We implement a function to compute the value of the maximum flow.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Network</span><span class="delimiter">)</span><span> </span><span>am_s_is_incoming</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E``{s} = set (am s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>no_incoming_s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_adj_map_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>RGraph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_by_adj_map</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f.val = (∑v∈set (am s). c (s,v) - cf (s,v))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f.val = (∑v∈E``{s}. c (s,v) - cf (s,v))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f.val_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_outgoing_pointwise</span><span> </span><span>f_def</span><span> </span><span>flow_of_cf_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑v∈set (am s). c (s,v) - cf (s,v))"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>am_s_is_incoming</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_cap e ≡ c e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>get_am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(node ⇒ node list) ⇒ node ⇒ node list"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_am am v ≡ am v"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val am cf ≡ do {
      let succs = get_am am s;
      sum_impl 
      (λv. do {
        let csv = get_cap (s,v);
        cfsv ← cf_get cf (s,v);
        return (csv - cfsv)
      }) (set succs)
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val am cf ≤ (spec v. v = f.val)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>val_by_adj_map</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val_def</span><span> </span><span>cf_get_def</span><span> </span><span>get_cap_def</span><span> </span><span>get_am_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>sum_impl_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vc_solve</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>am_s_is_incoming</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>V_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For technical reasons (poor foreach-support of Sepref tool), 
    we have to add another refinement step: ›</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val2 am cf ≡ (do {
    let succs = get_am am s;
    nfoldli succs (λ_. True)
     (λx a. do {
           b ← do {
               let csv = get_cap (s, x);
               cfsv ← cf_get cf (s, x);
               return (csv - cfsv)
             };
           return (a + b)
         })
     0
  })"</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>RGraph</span><span class="delimiter">)</span><span> </span><span>compute_flow_val2_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compute_flow_val2 am cf ≤ (spec v. v = f.val)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RELATES (⟨Id⟩list_set_rel)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>compute_flow_val_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val2_def</span><span> </span><span>compute_flow_val_def</span><span> </span><span>sum_impl_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>LFO_refine</span><span> </span><span>bind_refine'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vc_solve</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_set_rel_def</span><span> </span><span>br_def</span><span> </span><span>get_am_def</span><span> </span><span>is_adj_map_def</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Edka_Impl</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>is_am</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c,PR_CONST get_cap) ∈ Id×<span class="hidden">⇩</span><sub>r</sub>Id → Id"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_cap_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Network.get_cap$c ≡ UNPROTECT get_cap"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"PR_CONST get_cap"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node×node ⇒ capacity_impl"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(get_am,get_am) ∈ Id → Id → ⟨Id⟩list_rel"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_am_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>compute_flow_val_imp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>am</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"node ⇒ node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"capacity_impl graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>am</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(node ⇒ node list)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>itypeI</span><span class="delimiter">[</span><span>Pure.of</span><span> </span><span>cf</span><span> </span><span class="string"><span class="delete"><span class="delete">"TYPE(capacity_impl i_mtx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span> </span><span>IdI</span><span class="delimiter">[</span><span>of</span><span> </span><span>am</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hn_refine 
      (hn_ctxt (asmtx_assn N id_assn) cf cfi)
      (?c::?'d Heap) ?Γ ?R (compute_flow_val2 am cf)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compute_flow_val2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>id_debug</span><span class="delimiter">,</span><span> </span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_imp</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>N</span><span> </span><span>am</span><span> </span><span>cfi</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>Edka_Impl.compute_flow_val_imp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">prepare_code_thms</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>compute_flow_val_imp_def</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Network_Impl</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_flow_val_imp_correct_aux</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c ⊆ {0..&lt;N}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ABS_PS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_adj_map am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>RG</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RGraph c s t cf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
    &lt;asmtx_assn N id_assn cf cfi&gt; 
      compute_flow_val_imp c s N am cfi
    &lt;λv. asmtx_assn N id_assn cf cfi * ↑(v = Flow.val c s (flow_of_cf cf))&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>rg</span><span class="delimiter">:</span><span> </span><span>RGraph</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Edka_Impl c s t N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hn_refine_ref</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>      </span><span>rg.compute_flow_val2_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ABS_PS</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>compute_flow_val_imp.refine</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EI</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>cfi</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>pure_def</span><span> </span><span>hn_refine_def</span><span> </span><span>rg.f_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>cons_post_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sep_auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_flow_val_imp_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.V c ⊆ {0..&lt;N}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ABS_PS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.is_adj_map c am"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
    &lt;is_rflow N f cfi&gt; 
      compute_flow_val_imp c s N am cfi
    &lt;λv. is_rflow N f cfi * ↑(v = Flow.val c s f)&gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoare_triple_preI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_rflow_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>compute_flow_val_imp_correct_aux</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfi</span><span class="delimiter">=</span><span>cfi</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VN</span><span> </span><span>ABS_PS</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edmonds_karp_val el s t ≡ do {
  r ← edmonds_karp el s t;
  case r of
    None ⇒ return None
  | Some (c,am,N,cfi) ⇒ do {
      v ← compute_flow_val_imp c s N am cfi;
      return (Some v)
    } 
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>edmonds_karp_val_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;emp&gt; edmonds_karp_val el s t &lt;λ
    None ⇒ ↑(¬ln_invar el ∨ ¬Network (ln_α el) s t)
  | Some v ⇒ ↑(∃f N. 
          ln_invar el ∧ Network (ln_α el) s t 
        ∧ Graph.V (ln_α el) ⊆ {0..&lt;N}
        ∧ Network.isMaxFlow (ln_α el) s t f
        ∧ v = Flow.val (ln_α el) s f)  
        &gt;<span class="hidden">⇩</span><sub>t</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edmonds_karp_val_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> 
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>network_is_impl</span><span>
</span><span>    </span><span>heap</span><span class="delimiter">:</span><span> </span><span>edmonds_karp_correct</span><span> </span><span>Network_Impl.compute_flow_val_imp_correct</span><span class="delimiter">)</span><span>      
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Edka_Benchmark_Export">
<div class="head"><h1>Theory Edka_Benchmark_Export</h1>
<span class="command">theory</span> <span class="name">Edka_Benchmark_Export</span><br/>
<span class="keyword">imports</span> <a href="Edka_Checked_Impl.html"><span class="name">Edka_Checked_Impl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Exporting Code›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Edka_Benchmark_Export</span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Edka_Checked_Impl</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Moved to own theory, as code-export makes theory unusable for inclusion from
other AFP entries. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>nat_of_integer</span><span> </span><span>integer_of_nat</span><span> </span><span>int_of_integer</span><span> </span><span>integer_of_int</span><span>
</span><span>  </span><span>edmonds_karp</span><span> </span><span>edka_imp</span><span> </span><span>edka_imp_tabulate</span><span> </span><span>edka_imp_run</span><span> </span><span>prepareNet</span><span>
</span><span>  </span><span>compute_flow_val_imp</span><span> </span><span>edmonds_karp_val</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML_imp</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>Fofu</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹evaluation/fofu-SML/Fofu_Export.sml›</span></span></span><span>  
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>