<div id="FordFulkerson_Algo">
<div class="head">
<h1>Theory FordFulkerson_Algo</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Ford-Fulkerson Method›</span></span>
<span class="keyword1"><span class="command">theory</span></span> FordFulkerson_Algo
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Flow_Networks/Ford_Fulkerson.html">Flow_Networks.Ford_Fulkerson</a>
  <a href="../Flow_Networks/Refine_Add_Fofu.html">Flow_Networks.Refine_Add_Fofu</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this theory, we formalize the abstract Ford-Fulkerson
  method, which is independent of how an augmenting path is chosen›</span></span>

<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We abstractly specify the procedure for finding an augmenting path:
  Assuming a valid flow, the procedure must return an augmenting path 
  iff there exists one.
  ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_augmenting_spec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">select</span> <span class="bound">p</span><span class="main">.</span> NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">p</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Moreover, we specify augmentation of a flow along a path›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">augment_with_path</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> augment <span class="main">(</span>augmentingFlow <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We also specify the loop invariant, and annotate it to the loop.
›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">fofu_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> 
        NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> 
      <span class="main">∧</span> <span class="main">(</span><span class="bound">brk</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="main">¬</span>NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span>
    "</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we obtain the Ford-Fulkerson algorithm.
  Note that we annotate some assertions to ease later refinement›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fofu</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> while<span class="hidden">⇗</span><sup>fofu_invar</sup><span class="hidden">⇖</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">p</span> <span class="main">←</span> find_augmenting_spec <span class="bound">f</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span>True<span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> NFlow.augment_with_path <span class="free">c</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> False<span class="main">)</span>
        <span class="main">}</span>  
    <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="bound">f<span class="hidden">⇩</span><sub>0</sub></span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span> 
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Partial Correctness›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Correctness of the algorithm is a consequence from the 
  Ford-Fulkerson theorem. We need a few straightforward 
  auxiliary lemmas, though:
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The zero flow is a valid flow›</span></span>
<span class="keyword1" id="FordFulkerson_Algo-zero_flow"><span class="command">lemma</span></span> zero_flow<span class="main">:</span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s_node t_node cap_non_negative<span class="main">)</span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Augmentation preserves the flow property›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> augment_pres_nflow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">(</span>augment <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> augment_flow_presv<span class="main">[</span><span class="operator">OF</span> augFlow_resFlow<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AUG<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">interpret</span></span> f'<span class="main">:</span> Flow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"augment <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Augmenting paths cannot be empty›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> augmenting_path_not_empty<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span>isAugmentingPath <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def <span class="keyword1"><span class="command">using</span></span> s_not_t <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we can use the verification condition generator to
  show correctness›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> fofu_partial_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"fofu <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">f</span><span class="main">.</span> isMaxFlow <span class="bound">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fofu_def find_augmenting_spec_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> 
    zero_flow 
    NFlow.augment_pres_nflow 
    NFlow.augmenting_path_not_empty
    NFlow.noAugPath_iff_maxFlow<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
    NFlow.augment_with_path_def
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm without Assertions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For presentation purposes, we extract a version of the algorithm
  without assertions, and using a bit more concise notation›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">augment</span> 
  <span class="main">≡</span> NFlow.augment_with_path"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">is_augmenting_path</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> 
  <span class="main">≡</span> NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ {} ›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\DefineSnippet{ford_fulkerson_algo}{›</span></span>       
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ford_fulkerson_method</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">p</span> <span class="main">←</span> <span class="keyword1">select</span> <span class="bound">p</span><span class="main">.</span> is_augmenting_path <span class="bound">f</span> <span class="bound">p</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span>True<span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span>augment <span class="free">c</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">,</span> False<span class="main">)</span>
    <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="bound">f<span class="hidden">⇩</span><sub>0</sub></span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span> 
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹}%EndSnippet›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ {} ›</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Anonymous context›</span> 
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ {} ›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\DefineSnippet{ford_fulkerson_correct}{›</span></span>       
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> <span class="quoted"><span class="quoted">"ford_fulkerson_method <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">f</span><span class="main">.</span> isMaxFlow <span class="bound">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹}%EndSnippet›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ {} ›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ford_fulkerson_method <span class="main">≤</span> fofu"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ford_fulkerson_method_def fofu_def Let_def find_augmenting_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFlow.augment_with_path_def <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> exI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fofu_partial_correct  
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="EdmondsKarp_Termination_Abstract">
<div class="head">
<h1>Theory EdmondsKarp_Termination_Abstract</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Edmonds-Karp Algorithm›</span></span>

<span class="keyword1"><span class="command">theory</span></span> EdmondsKarp_Termination_Abstract <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../Flow_Networks/Ford_Fulkerson.html">Flow_Networks.Ford_Fulkerson</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-mlex_fst_decrI"><span class="command">lemma</span></span> mlex_fst_decrI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">a'</span> <span class="free">b</span> <span class="free">b'</span> <span class="free">N</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">&lt;</span><span class="free">a'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span><span class="main">&lt;</span><span class="free">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b'</span><span class="main">&lt;</span><span class="free">N</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">*</span><span class="free">N</span> <span class="main">+</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="free">a'</span><span class="main">*</span><span class="free">N</span> <span class="main">+</span> <span class="free">b'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">*</span><span class="free">N</span> <span class="main">+</span> <span class="free">b</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">a</span><span class="main">*</span><span class="free">N</span> <span class="main">+</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">b</span><span class="main">&lt;</span><span class="free">N</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">a'</span><span class="main">*</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">a</span><span class="main">&lt;</span><span class="free">a'</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_leI ab_semigroup_add_class.add.commute 
      ab_semigroup_mult_class.mult.commute mult_Suc_right mult_le_mono2<span class="main">)</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">a'</span><span class="main">*</span><span class="free">N</span> <span class="main">+</span> <span class="free">b'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> augmenting_path_imp_shortest<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> Graph.isShortestPath cf <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Graph.obtain_shortest_path <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.isSimplePath_def Graph.connected_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> shortest_is_augmenting<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Graph.isShortestPath cf <span class="free">s</span> <span class="free">p</span> <span class="free">t</span> <span class="main">⟹</span> isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def <span class="keyword1"><span class="command">using</span></span> Graph.shortestPath_is_simple
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complexity and Termination Analysis›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we show that the loop iterations of the Edmonds-Karp algorithm
  are bounded by $O(VE)$.

  The basic idea of the proof is, that a path that
  takes an edge reverse to an edge on some shortest path 
  cannot be a shortest path itself.

  As augmentation flips at least one edge, this yields a termination argument:
    After augmentation, either the minimum distance between source and target
    increases, or it remains the same, but the number of edges that lay on a
    shortest path decreases. As the minimum distance is bounded by $V$, 
    we get termination within $O(VE)$ loop iterations.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The basic idea is expressed in the following lemma, which, however, 
  is not general enough to be applied for the correctness proof, where
  we flip more than one edge simultaneously.
  ›</span></span>
<span class="keyword1" id="EdmondsKarp_Termination_Abstract-isShortestPath_flip_edge"><span class="command">lemma</span></span> isShortestPath_flip_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p'</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p'</span> <span class="main">≥</span> length <span class="free">p</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
    MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      P<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
     DV<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>pathVertices <span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_alt isSimplePath_def<span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> P DV <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p2</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isPath_append pathVertices_append<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> DISTS<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">s</span> <span class="main">(</span>length <span class="skolem">p1</span><span class="main">)</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">1</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">v</span> <span class="main">(</span>length <span class="skolem">p2</span><span class="main">)</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append dist_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> MIN <span class="keyword1"><span class="command">have</span></span> MIN'<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> length <span class="skolem">p1</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> length <span class="skolem">p2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> min_dist_split<span class="main">[</span><span class="operator">OF</span> dist_trans<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> DISTS<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">,</span></span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span> DISTS<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span> MIN'<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
    MDSV<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">v</span> <span class="main">=</span> length <span class="skolem">p1</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
  <span class="keyword1"><span class="command">from</span></span> min_dist_split<span class="main">[</span><span class="operator">OF</span> DISTS<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span> dist_trans<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> DISTS<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">,</span></span></span></span></span>3<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span> MIN' <span class="keyword1"><span class="command">have</span></span>
    MDUT<span class="main">:</span> <span class="quoted"><span class="quoted">"min_dist <span class="free">u</span> <span class="free">t</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> length <span class="skolem">p2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p'</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1'</span></span> <span class="skolem"><span class="skolem">p2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span><span class="main">=</span><span class="skolem">p1'</span><span class="main">@</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹isPath <span class="free">s</span> <span class="free">p'</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
    DISTS'<span class="main">:</span> <span class="quoted"><span class="quoted">"dist <span class="free">s</span> <span class="main">(</span>length <span class="skolem">p1'</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">u</span> <span class="main">(</span>length <span class="skolem">p2'</span><span class="main">)</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append dist_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> DISTS'<span class="main">[</span><span class="operator">THEN</span> min_dist_minD<span class="main">,</span> <span class="operator">unfolded</span> MDSV MDUT<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span>
    <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="free">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>    


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To be used for the analysis of augmentation, we have to generalize the 
  lemma to simultaneous flipping of edges:
  ›</span></span> 
<span class="keyword1" id="EdmondsKarp_Termination_Abstract-isShortestPath_flip_edges"><span class="command">lemma</span></span> isShortestPath_flip_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="free">c'</span> <span class="main">⊇</span> E <span class="main">-</span> <span class="free">edges</span>"</span></span> <span class="quoted"><span class="quoted">"Graph.E <span class="free">c'</span> <span class="main">⊆</span> E <span class="main">∪</span> <span class="main">(</span>prod.swap<span class="main">`</span><span class="free">edges</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> EDGES_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">⊆</span> set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P'<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.isPath <span class="free">c'</span> <span class="free">s</span> <span class="free">p'</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="free">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="free">p'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> g'<span class="main">:</span> Graph <span class="quoted"><span class="free">c'</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="comment1">(* TODO: The proof still contains some redundancy: A first flipped edge
    is searched in both, the induction, and the initialization *)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">p1</span> <span class="skolem">p2'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="free">edges</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"g'.isPath <span class="skolem">u</span> <span class="skolem">p2'</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> length <span class="skolem">p1</span> <span class="main">+</span> length <span class="skolem">p2'</span>"</span></span>   
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p2'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">u</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">p1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">p2'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> <span class="quoted">"1.IH"</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span>
      <span class="keyword1"><span class="command">note</span></span> P1 <span class="main">=</span> <span class="quoted"><span class="quoted">‹isPath <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">v</span>›</span></span>
      <span class="keyword1"><span class="command">note</span></span> P2' <span class="main">=</span> <span class="quoted"><span class="quoted">‹g'.isPath <span class="skolem">u</span> <span class="skolem">p2'</span> <span class="free">t</span>›</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p1</span> <span class="main">&gt;</span> min_dist <span class="free">s</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> P1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p1</span> <span class="main">≥</span> min_dist <span class="free">s</span> <span class="skolem">v</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> min_dist_minD <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="free">edges</span>›</span></span> EDGES_SS 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="skolem">v</span> <span class="main">=</span> Suc <span class="main">(</span>min_dist <span class="free">s</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> isShortestPath_level_edge<span class="main">[</span><span class="operator">OF</span> SP<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>  

      <span class="keyword1"><span class="command">from</span></span> isShortestPath_level_edge<span class="main">[</span><span class="operator">OF</span> SP<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="free">edges</span>›</span></span> EDGES_SS 
      <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="skolem">u</span> <span class="main">+</span> min_dist <span class="skolem">u</span> <span class="free">t</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">s</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p2'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="comment1">― ‹We proceed by a case distinction whether the suffix path contains swapped edges›</span>
        <span class="keyword3"><span class="command">case</span></span> True 
        <span class="keyword1"><span class="command">with</span></span> g'.transfer_path<span class="main">[</span><span class="operator">OF</span> _ P2'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">c</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹g'.E <span class="main">⊆</span> E <span class="main">∪</span> prod.swap <span class="main">`</span> <span class="free">edges</span>›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p2'</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p2'</span> <span class="main">≥</span> min_dist <span class="skolem">u</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> min_dist_minD
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹length <span class="skolem">p1</span> <span class="main">&gt;</span> min_dist <span class="free">s</span> <span class="skolem">u</span>›</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="skolem">u</span> <span class="main">+</span> min_dist <span class="skolem">u</span> <span class="free">t</span>›</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="comment1">― ‹Obtain first swapped edge on suffix path›</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p21'</span></span> <span class="skolem"><span class="skolem">e'</span></span> <span class="skolem"><span class="skolem">p22'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p2'</span><span class="main">=</span><span class="skolem">p21'</span><span class="main">@</span><span class="skolem">e'</span><span class="main">#</span><span class="skolem">p22'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
           E_IN_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">∈</span>prod.swap<span class="main">`</span><span class="free">edges</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
          P1_NO_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p21'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> split_list_first_propE<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p2'</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">e</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span><span class="main"><span class="main">∈</span></span>prod.swap<span class="main"><span class="main">`</span></span><span class="free"><span class="free">edges</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹prod.swap <span class="main">`</span> <span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p2'</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span><span class="main">=</span><span class="main">(</span><span class="skolem">v'</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e'</span></span><span class="main">)</span>      
  
        <span class="comment1">― ‹Split the suffix path accordingly›</span>
        <span class="keyword1"><span class="command">from</span></span> P2' <span class="keyword1"><span class="command">have</span></span> P21'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="skolem">u</span> <span class="skolem">p21'</span> <span class="skolem">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P22'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="skolem">u'</span> <span class="skolem">p22'</span> <span class="free">t</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> g'.isPath_append<span class="main">)</span>
        <span class="comment1">― ‹As we chose the first edge, the prefix of the suffix path is also a path in the original graph›</span>  
        <span class="keyword1"><span class="command">from</span></span> 
          g'.transfer_path<span class="main">[</span><span class="operator">OF</span> _ P21'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">c</span></span><span class="main">]</span> 
          <span class="quoted"><span class="quoted">‹g'.E <span class="main">⊆</span> E <span class="main">∪</span> prod.swap <span class="main">`</span> <span class="free">edges</span>›</span></span> 
          P1_NO_EDGES
        <span class="keyword1"><span class="command">have</span></span> P21<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="skolem">u</span> <span class="skolem">p21'</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> min_dist_is_dist<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹connected <span class="free">s</span> <span class="skolem">u</span>›</span></span><span class="main">]</span> 
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">psu</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
              PSU<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">psu</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
          LEN_PSU<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">psu</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="skolem">u</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> PSU P21 <span class="keyword1"><span class="command">have</span></span> P1n<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="main">(</span><span class="skolem">psu</span><span class="main">@</span><span class="skolem">p21'</span><span class="main">)</span> <span class="skolem">v'</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isPath_append<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> IH<span class="main">[</span><span class="operator">OF</span> _ _ P1n P22'<span class="main">]</span> E_IN_EDGES <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> length <span class="skolem">psu</span> <span class="main">+</span> length <span class="skolem">p21'</span> <span class="main">+</span> length <span class="skolem">p22'</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹length <span class="skolem">p1</span> <span class="main">&gt;</span> min_dist <span class="free">s</span> <span class="skolem">u</span>›</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> LEN_PSU<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>  
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux<span class="main">=</span>this

  <span class="comment1">(* TODO: This step is analogous to what we do in the False-case of the induction.
    Can we somehow remove the redundancy? *)</span>
  <span class="comment1">― ‹Obtain first swapped edge on path›</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1'</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="skolem"><span class="skolem">p2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span><span class="main">=</span><span class="skolem">p1'</span><span class="main">@</span><span class="skolem">e</span><span class="main">#</span><span class="skolem">p2'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    E_IN_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>prod.swap<span class="main">`</span><span class="free">edges</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    P1_NO_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p1'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> split_list_first_propE<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p'</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">e</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span><span class="main"><span class="main">∈</span></span>prod.swap<span class="main"><span class="main">`</span></span><span class="free"><span class="free">edges</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹prod.swap <span class="main">`</span> <span class="free">edges</span> <span class="main">∩</span> set <span class="free">p'</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">)</span>      

  <span class="comment1">― ‹Split the new path accordingly›</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹g'.isPath <span class="free">s</span> <span class="free">p'</span> <span class="free">t</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
    P1'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="free">s</span> <span class="skolem">p1'</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    P2'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="skolem">u</span> <span class="skolem">p2'</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> g'.isPath_append<span class="main">)</span>
  <span class="comment1">― ‹As we chose the first edge, the prefix of the path is also a path in the original graph›</span>  
  <span class="keyword1"><span class="command">from</span></span> 
    g'.transfer_path<span class="main">[</span><span class="operator">OF</span> _ P1'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">c</span></span><span class="main">]</span> 
    <span class="quoted"><span class="quoted">‹g'.E <span class="main">⊆</span> E <span class="main">∪</span> prod.swap <span class="main">`</span> <span class="free">edges</span>›</span></span> 
    P1_NO_EDGES
  <span class="keyword1"><span class="command">have</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"isPath <span class="free">s</span> <span class="skolem">p1'</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> aux<span class="main">[</span><span class="operator">OF</span> _ P1 P2'<span class="main">]</span> E_IN_EDGES 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> length <span class="skolem">p1'</span> <span class="main">+</span> length <span class="skolem">p2'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> SP 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_min_dist_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Graph›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We outsource the more specific lemmas to their own locale, 
  to prevent name space pollution›</span></span>
<span class="keyword1"><span class="command">locale</span></span> ek_analysis_defs <span class="main">=</span> Graph <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">node</span>

<span class="keyword1"><span class="command">locale</span></span> ek_analysis <span class="main">=</span> ek_analysis_defs <span class="main">+</span> Finite_Graph
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ek_analysis_defs<span class="main">)</span> 
  <span class="quoted"><span class="quoted">"<span class="free">spEdges</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">e</span><span class="main">.</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="bound">e</span><span class="main">∈</span>set <span class="bound">p</span> <span class="main">∧</span> isShortestPath <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-spEdges_ss_E"><span class="command">lemma</span></span> spEdges_ss_E<span class="main">:</span> <span class="quoted"><span class="quoted">"spEdges <span class="main">⊆</span> E"</span></span>
  <span class="keyword1"><span class="command">using</span></span> isPath_edgeset <span class="keyword1"><span class="command">unfolding</span></span> spEdges_def isShortestPath_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-finite_spEdges"><span class="command">lemma</span></span> finite_spEdges<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>spEdges<span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> spEdges_ss_E<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ek_analysis_defs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">uE</span> <span class="main">≡</span> E <span class="main">∪</span> E<span class="main">¯</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-finite_uE"><span class="command">lemma</span></span> finite_uE<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite uE"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uE_def<span class="main">)</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-E_ss_uE"><span class="command">lemma</span></span> E_ss_uE<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">⊆</span>uE"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uE_def<span class="main">)</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-card_spEdges_le"><span class="command">lemma</span></span> card_spEdges_le<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card spEdges <span class="main">≤</span> card uE"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spEdges_ss_E E_ss_uE<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-card_spEdges_less"><span class="command">lemma</span></span> card_spEdges_less<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card spEdges <span class="main">&lt;</span> card uE <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> card_spEdges_le 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ek_analysis_defs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">ekMeasure</span> <span class="main">≡</span> 
  <span class="keyword1">if</span> <span class="main">(</span>connected <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="keyword1">then</span>
    <span class="main">(</span>card V <span class="main">-</span> min_dist <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>card uE <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>card <span class="main">(</span>spEdges<span class="main">)</span><span class="main">)</span>
  <span class="keyword1">else</span> <span class="main">0</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-measure_decr"><span class="command">lemma</span></span> measure_decr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>V"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SP_EDGES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">edges</span><span class="main">⊆</span>set <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Ebounds<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"Graph.E <span class="free">c'</span> <span class="main">⊇</span> E <span class="main">-</span> <span class="free">edges</span> <span class="main">∪</span> prod.swap<span class="main">`</span><span class="free">edges</span>"</span></span> 
    <span class="quoted"><span class="quoted">"Graph.E <span class="free">c'</span> <span class="main">⊆</span> E <span class="main">∪</span> prod.swap<span class="main">`</span><span class="free">edges</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ek_analysis_defs.ekMeasure <span class="free">c'</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> ekMeasure"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">-</span> Graph.E <span class="free">c'</span> <span class="main">≠</span> <span class="main">{}</span> 
         <span class="main">⟹</span> ek_analysis_defs.ekMeasure <span class="free">c'</span> <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> ekMeasure"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> g'<span class="main">:</span> ek_analysis_defs <span class="quoted"><span class="free">c'</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> g'<span class="main">:</span> ek_analysis <span class="quoted"><span class="free">c'</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> g'.Finite_Graph_EI<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> Ebounds<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> finite_subset<span class="main">[</span><span class="operator">OF</span> SP_EDGES<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> SP_EDGES SP <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">⊆</span> E"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spEdges_def isShortestPath_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> isPath_edgeset<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Ebounds <span class="keyword1"><span class="command">have</span></span> Veq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c'</span> <span class="main">=</span> V"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.V_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> Ebounds <span class="quoted"><span class="quoted">‹<span class="free">edges</span> <span class="main">⊆</span> E›</span></span> <span class="keyword1"><span class="command">have</span></span> uE_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"g'.uE <span class="main">=</span> uE"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ek_analysis_defs.uE_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> SP <span class="keyword1"><span class="command">have</span></span> LENP<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_min_dist_def<span class="main">)</span> 

  <span class="keyword1"><span class="command">from</span></span> SP <span class="keyword1"><span class="command">have</span></span> CONN<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">s</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isShortestPath_def connected_def<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> NCONN2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>g'.connected <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">≠</span><span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> CONN NCONN2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g'.ekMeasure <span class="main">&lt;</span> ekMeasure"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> g'.ekMeasure_def ekMeasure_def
      <span class="keyword1"><span class="command">using</span></span> min_dist_less_V<span class="main">[</span><span class="operator">OF</span> SV<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> SHORTER<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> min_dist <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> CONN2<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.connected <span class="free">s</span> <span class="free">t</span>"</span></span>

    <span class="comment1">― ‹Obtain a shorter path in $g'$›</span>
    <span class="keyword1"><span class="command">from</span></span> g'.min_dist_is_dist<span class="main">[</span><span class="operator">OF</span> CONN2<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      P'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="free">s</span> <span class="skolem">p'</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> LENP'<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">=</span> g'.min_dist <span class="free">s</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> g'.dist_def<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span> <span class="comment1">― ‹Case: It does not use <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span>"</span><span class="antiquote">}</span></span>. 
        Then it is also a path in $g$, which is shorter than 
        the shortest path in $g$, yielding a contradiction.›</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> g'.transfer_path<span class="main">[</span><span class="operator">OF</span> _ P'<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">c</span></span><span class="main">]</span> Ebounds <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dist <span class="free">s</span> <span class="main">(</span>length <span class="skolem">p'</span><span class="main">)</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dist_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> LENP' SHORTER min_dist_minD<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="comment1">― ‹So assume the path uses the edge <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"prod.swap <span class="free">e</span>"</span><span class="antiquote">}</span></span>.›</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="comment1">― ‹Due to auxiliary lemma, those path must be longer›</span>
      <span class="keyword1"><span class="command">from</span></span> isShortestPath_flip_edges<span class="main">[</span><span class="operator">OF</span> _ _ SP SP_EDGES P' this<span class="main">]</span> Ebounds
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">&gt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> SHORTER LENP LENP' <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> LONGER<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&gt;</span> min_dist <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> CONN2<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.connected <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g'.ekMeasure <span class="main">&lt;</span> ekMeasure"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> g'.ekMeasure_def ekMeasure_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Veq uE_eq CONN CONN2 if_True<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mlex_fst_decrI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> card_spEdges_less g'.card_spEdges_less 
        <span class="keyword2"><span class="keyword">and</span></span> g'.min_dist_less_V<span class="main">[</span><span class="operator">OF</span> _ CONN2<span class="main">]</span> SV
        <span class="keyword2"><span class="keyword">and</span></span> LONGER
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> min_dist <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> CONN2<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.connected <span class="free">s</span> <span class="free">t</span>"</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p'</span>
      <span class="keyword3"><span class="command">assume</span></span> P'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isShortestPath <span class="free">s</span> <span class="skolem">p'</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span> 
        <span class="keyword3"><span class="command">assume</span></span> EIP'<span class="main">:</span> <span class="quoted"><span class="quoted">"prod.swap<span class="main">`</span><span class="free">edges</span> <span class="main">∩</span> set <span class="skolem">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> P' <span class="keyword1"><span class="command">have</span></span> 
             P'<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.isPath <span class="free">s</span> <span class="skolem">p'</span> <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
          LENP'<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">=</span> g'.min_dist <span class="free">s</span> <span class="free">t</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> g'.isShortestPath_min_dist_def<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> isShortestPath_flip_edges<span class="main">[</span><span class="operator">OF</span> _ _ SP SP_EDGES P' EIP'<span class="main">]</span> Ebounds 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> LENP LENP' EQ <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>  
      <span class="keyword1"><span class="command">with</span></span> g'.transfer_path<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p'</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> P' Ebounds <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isShortestPath <span class="free">s</span> <span class="skolem">p'</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.isShortestPath_min_dist_def EQ<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">hence</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.spEdges <span class="main">⊆</span> spEdges"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> g'.spEdges_def spEdges_def<span class="main">)</span>
        
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">-</span> Graph.E <span class="free">c'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> g'.spEdges_ss_E SS SP SP_EDGES <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g'.spEdges <span class="main">⊂</span> spEdges"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> g'.spEdges_def spEdges_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"g'.ekMeasure <span class="main">&lt;</span> ekMeasure"</span></span>  
        <span class="keyword1"><span class="command">unfolding</span></span> g'.ekMeasure_def ekMeasure_def 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Veq uE_eq EQ CONN CONN2 if_True<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> add_strict_left_mono<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> psubset_card_mono<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> G1 <span class="main">=</span> this

    <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="quoted"><span class="quoted">"g'.ekMeasure <span class="main">≤</span> ekMeasure"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> g'.ekMeasure_def ekMeasure_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Veq uE_eq CONN CONN2 if_True<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> add_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mult_right_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> EQ<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">note</span></span> G1 G2  
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> 
    <span class="quoted"><span class="quoted">"g'.ekMeasure <span class="main">≤</span> ekMeasure"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">-</span> Graph.E <span class="free">c'</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> g'.ekMeasure <span class="main">&lt;</span> ekMeasure"</span></span>
    <span class="keyword1"><span class="command">using</span></span> less_linear<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"g'.min_dist <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">s</span> <span class="free">t</span>"</span></span><span class="main">]</span>   
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Analysis locale›</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a first step to the analysis setup, we characterize
  the effect of augmentation on the residual graph
  ›</span></span>
<span class="keyword1"><span class="command">context</span></span> Graph
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">augment_cf</span> <span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">e</span><span class="main">.</span> 
  <span class="keyword1">if</span> <span class="bound">e</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="keyword1">then</span> <span class="free">c</span> <span class="bound">e</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> 
  <span class="keyword1">else</span> <span class="keyword1">if</span> prod.swap <span class="bound">e</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">edges</span></span></span> <span class="keyword1">then</span> <span class="free">c</span> <span class="bound">e</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span>
  <span class="keyword1">else</span> <span class="free">c</span> <span class="bound">e</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augment_cf_empty"><span class="command">lemma</span></span> augment_cf_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"augment_cf <span class="main">{}</span> <span class="free">cap</span> <span class="main">=</span> <span class="free">c</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_cf_def<span class="main">)</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augment_cf_ss_V"><span class="command">lemma</span></span> augment_cf_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">edges</span> <span class="main">⊆</span> E<span class="main">⟧</span> <span class="main">⟹</span> Graph.V <span class="main">(</span>augment_cf <span class="free">edges</span> <span class="free">cap</span><span class="main">)</span> <span class="main">⊆</span> V"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def Graph.V_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_cf_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augment_saturate"><span class="command">lemma</span></span> augment_saturate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">edges</span> <span class="free">e</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">c'</span> <span class="main">≡</span> augment_cf <span class="free">edges</span> <span class="main">(</span><span class="free">c</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> EIE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span><span class="free">edges</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∉</span>Graph.E <span class="free">c'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> EIE <span class="keyword1"><span class="command">unfolding</span></span> c'_def augment_cf_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.E_def<span class="main">)</span>
  

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augment_cf_split"><span class="command">lemma</span></span> augment_cf_split<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges1</span> <span class="main">∩</span> <span class="free">edges2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges1</span><span class="main">¯</span> <span class="main">∩</span> <span class="free">edges2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Graph.augment_cf <span class="free">c</span> <span class="main">(</span><span class="free">edges1</span> <span class="main">∪</span> <span class="free">edges2</span><span class="main">)</span> <span class="free">cap</span> 
    <span class="main">=</span> Graph.augment_cf <span class="main">(</span>Graph.augment_cf <span class="free">c</span> <span class="free">edges1</span> <span class="free">cap</span><span class="main">)</span> <span class="free">edges2</span> <span class="free">cap</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.augment_cf_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
      
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Graph›</span>

<span class="keyword1"><span class="command">context</span></span> NFlow <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augmenting_edge_no_swap"><span class="command">lemma</span></span> augmenting_edge_no_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span> <span class="main">⟹</span> set <span class="free">p</span> <span class="main">∩</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cf.isSPath_nt_parallel_pf
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def<span class="main">)</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-aug_flows_finite"><span class="command">lemma</span></span> aug_flows_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span>cf <span class="bound">e</span> <span class="main">|</span><span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"cf<span class="main"><span class="main">`</span></span>set <span class="free"><span class="free">p</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-aug_flows_finite'"><span class="command">lemma</span></span> aug_flows_finite'<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="main">{</span>cf <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">|</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"cf<span class="main"><span class="main">`</span></span>set <span class="free"><span class="free">p</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augment_alt"><span class="command">lemma</span></span> augment_alt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">≡</span> augment <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf'</span> <span class="main">≡</span> residualGraph <span class="free">c</span> <span class="free">f'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf'</span> <span class="main">=</span> Graph.augment_cf cf <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">(</span>resCap <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"resCap <span class="free">p</span> <span class="main">≤</span> cf <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> resCap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_le<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> bn_smallerI <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>cf.E"</span></span> <span class="keyword1"><span class="command">using</span></span> AUG cf.isPath_edgeset
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def cf.isSimplePath_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E <span class="main">∨</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> edge_or_swap <span class="main">=</span> this 

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cf.augment_cf_def
    <span class="keyword1"><span class="command">using</span></span> augmenting_edge_no_swap<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> augment_def augmentingFlow_def cf'_def f'_def residualGraph_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits
      <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edge_or_swap 
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>    


<span class="keyword1" id="EdmondsKarp_Termination_Abstract-augmenting_path_contains_resCap"><span class="command">lemma</span></span> augmenting_path_contains_resCap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">e</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"cf <span class="free">e</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isAugmentingPath_def s_not_t<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>cf <span class="bound">e</span> <span class="main">|</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> set <span class="free">p</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> Min_in<span class="main">[</span><span class="operator">OF</span> aug_flows_finite this<span class="main">,</span> <span class="operator">folded</span> resCap_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"cf <span class="skolem">e</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
        
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we show the main theorem used for termination and complexity 
  analysis: Augmentation with a shortest path decreases the measure function.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> shortest_path_decr_ek_measure<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> SP<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.isShortestPath cf <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">≡</span> augment <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf'</span> <span class="main">≡</span> residualGraph <span class="free">c</span> <span class="free">f'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ek_analysis_defs.ekMeasure <span class="free">cf'</span> <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span> ek_analysis_defs.ekMeasure cf <span class="free">s</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> cf<span class="main">:</span> ek_analysis <span class="quoted">cf</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">interpret</span></span> cf'<span class="main">:</span> ek_analysis_defs <span class="quoted"><span class="free">cf'</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> SP <span class="keyword1"><span class="command">have</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> isAugmentingPath_def cf.isShortestPath_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">note</span></span> BNGZ <span class="main">=</span> resCap_gzero<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span>  

  <span class="keyword1"><span class="command">have</span></span> cf'_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf'</span> <span class="main">=</span> cf.augment_cf <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">(</span>resCap <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> augment_alt<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> cf'_def f'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    EIP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> EBN<span class="main">:</span> <span class="quoted"><span class="quoted">"cf <span class="skolem">e</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> augmenting_path_contains_resCap<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AUG<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> ENIE'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∉</span>cf'.E"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cf.augment_saturate<span class="main">[</span><span class="operator">OF</span> EIP<span class="main">]</span> EBN <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cf'_alt<span class="main">)</span>
  
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span>  
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="skolem">e</span> <span class="main">+</span> resCap <span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> resE_nonNegative<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">]</span> BNGZ <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this  
  
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> cf.E"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cf.shortestPath_is_path<span class="main">[</span><span class="operator">OF</span> SP<span class="main">]</span> cf.isPath_edgeset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cf <span class="skolem">e</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> cf <span class="skolem">e</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> resE_positive<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cf.measure_decr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s_node<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> SP<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_refl<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Graph.E_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf'_alt cf.augment_cf_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> augmenting_edge_no_swap<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf'_alt cf.augment_cf_def Graph.E_def 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> cf.zero_cap_simp<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Graph.E_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf'_alt cf.augment_cf_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> EIP ENIE' <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network with flow›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="EdmondsKarp_Algo">
<div class="head">
<h1>Theory EdmondsKarp_Algo</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> EdmondsKarp_Algo
<span class="keyword2"><span class="keyword">imports</span></span> <a href="EdmondsKarp_Termination_Abstract.html">EdmondsKarp_Termination_Abstract</a> <a href="FordFulkerson_Algo.html">FordFulkerson_Algo</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we formalize an abstract version of
  Edmonds-Karp algorithm, which we obtain by refining the 
  Ford-Fulkerson algorithm to always use shortest augmenting paths.

  Then, we show that the algorithm always terminates within $O(VE)$ iterations.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, we specify the refined procedure for finding augmenting paths›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_shortest_augmenting_spec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">⪢</span> 
  <span class="main">(</span><span class="keyword1">select</span> <span class="bound">p</span><span class="main">.</span> Graph.isShortestPath <span class="main">(</span>residualGraph <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that our refined procedure is actually a refinement›</span></span>  
<span class="keyword1"><span class="command">thm</span></span> SELECT_refine  
<span class="keyword1" id="EdmondsKarp_Algo-find_shortest_augmenting_refine"><span class="command">lemma</span></span> find_shortest_augmenting_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f'</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>Id <span class="main">⟹</span> find_shortest_augmenting_spec <span class="free">f'</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span>Id<span class="main">⟩</span>option_rel<span class="main">)</span> <span class="main">(</span>find_augmenting_spec <span class="free">f</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> find_shortest_augmenting_spec_def find_augmenting_spec_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFlow.shortest_is_augmenting RELATESI
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NFlow.augmenting_path_imp_shortest<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we specify the Edmonds-Karp algorithm. 
  Our first specification still uses partial correctness, 
  termination will be proved afterwards. ›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka_partial</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> while<span class="hidden">⇗</span><sup>fofu_invar</sup><span class="hidden">⇖</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">p</span> <span class="main">←</span> find_shortest_augmenting_spec <span class="bound">f</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span>True<span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="main">(</span>residualGraph <span class="free">c</span> <span class="bound">f</span><span class="main">)</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> NFlow.augment_with_path <span class="free">c</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> False<span class="main">)</span>
        <span class="main">}</span>  
    <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span> 
<span class="main">}</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Algo-edka_partial_refine"><span class="command">lemma</span></span> edka_partial_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edka_partial <span class="main">≤</span> <span class="main">⇓</span>Id fofu"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edka_partial_def fofu_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_shortest_augmenting_spec_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Total Correctness›</span></span>
<span class="keyword1"><span class="command">context</span></span> Network <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We specify the total correct version of Edmonds-Karp algorithm.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> while<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup>fofu_invar</sup><span class="hidden">⇖</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">p</span> <span class="main">←</span> find_shortest_augmenting_spec <span class="bound">f</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span>True<span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="main">(</span>residualGraph <span class="free">c</span> <span class="bound">f</span><span class="main">)</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> NFlow.augment_with_path <span class="free">c</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">;</span>
          <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> False<span class="main">)</span>
        <span class="main">}</span>  
    <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span>NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span> 
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Based on the measure function, it is easy to obtain a well-founded 
  relation that proves termination of the loop in the Edmonds-Karp algorithm:›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka_wf_rel</span> <span class="main">≡</span> inv_image 
  <span class="main">(</span>less_than_bool <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">cf</span><span class="main">.</span> ek_analysis_defs.ekMeasure <span class="bound">cf</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span><span class="bound">brk</span><span class="main">,</span>residualGraph <span class="free">c</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="EdmondsKarp_Algo-edka_wf_rel_wf"><span class="command">lemma</span></span> edka_wf_rel_wf<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf edka_wf_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edka_wf_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following theorem states that the total correct 
  version of Edmonds-Karp algorithm refines the partial correct one.›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> edka_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edka <span class="main">≤</span> <span class="main">⇓</span>Id edka_partial"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edka_def edka_partial_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> bind_refine' 
    WHILEIT_refine_WHILEI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> V<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">edka_wf_rel</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Unfortunately, the verification condition for introducing 
      the variant requires a bit of manual massaging to be solved:›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> bind_sim_select_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFlow.augment_with_path_def
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assert_bind_spec_conv Let_def
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> find_shortest_augmenting_spec_def
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edka_wf_rel_def NFlow.shortest_path_decr_ek_measure
    <span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The other VCs are straightforward›</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Complexity Analysis›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the complexity analysis, we additionally show that the measure
  function is bounded by $O(VE)$. Note that our absolute bound is not as 
  precise as possible, but clearly $O(VE)$.›</span></span>
  <span class="comment1">(* TODO: #edgesSp even bound by |E|, as either e or swap e lays on shortest path! *)</span>
<span class="keyword1" id="EdmondsKarp_Algo-ekMeasure_upper_bound"><span class="command">lemma</span></span> ekMeasure_upper_bound<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ek_analysis_defs.ekMeasure <span class="main">(</span>residualGraph <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span> 
   <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> card E <span class="main">+</span> card V"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">interpret</span></span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s_node t_node cap_non_negative<span class="main">)</span>

  <span class="keyword1"><span class="command">interpret</span></span> ek<span class="main">:</span> ek_analysis <span class="quoted">cf</span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> cardV_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"card V <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> cardE_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"card E <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> card_0_eq<span class="main">[</span><span class="operator">OF</span> finite_V<span class="main">]</span> V_not_empty <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">using</span></span> card_0_eq<span class="main">[</span><span class="operator">OF</span> finite_E<span class="main">]</span> E_not_empty <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"cf.connected <span class="free">s</span> <span class="free">t</span>"</span></span><span class="main">)</span>  
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ek.ekMeasure <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ek.ekMeasure_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> cardV_positive cardE_positive <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True 

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf.min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.min_dist_z_iff True s_not_t<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cf <span class="main">=</span> <span class="free">c</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def E_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ek.uE <span class="main">=</span> E<span class="main">∪</span>E<span class="main">¯</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ek.uE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ek.ekMeasure 
      <span class="main">=</span> <span class="main">(</span>card cf.V <span class="main">-</span> cf.min_dist <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>card ek.uE <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>card <span class="main">(</span>ek.spEdges<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ek.ekMeasure_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> 
      mlex_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"card cf.V <span class="main">-</span> cf.min_dist <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"card V"</span></span><span class="main">,</span> 
                 <span class="operator">OF</span> _ ek.card_spEdges_less<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">&lt;</span> card V <span class="main">*</span> <span class="main">(</span>card ek.uE<span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cf.min_dist <span class="free">s</span> <span class="free">t</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹card V <span class="main">&gt;</span> <span class="main">0</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> resV_netV<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card ek.uE <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span>card E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹ek.uE <span class="main">=</span> E<span class="main">∪</span>E<span class="main">¯</span>›</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> card_Un_le<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>  
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we present a version of the Edmonds-Karp algorithm 
  which is instrumented with a loop counter, and asserts that
  there are less than $2|V||E|+|V| = O(|V||E|)$ iterations.

  Note that we only count the non-breaking loop iterations.
  ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refinement is achieved by a refinement relation, coupling the 
  instrumented loop state with the uninstrumented one›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edkac_rel</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">,</span><span class="bound">itc</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span> <span class="bound">brk</span> <span class="bound">itc</span><span class="main">.</span>
    <span class="bound">itc</span> <span class="main">+</span> ek_analysis_defs.ekMeasure <span class="main">(</span>residualGraph <span class="free">c</span> <span class="bound">f</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span> 
  <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> card E <span class="main">+</span> card V
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka_complexity</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>

  <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">itc</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">brk</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">itc</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">p</span> <span class="main">←</span> find_shortest_augmenting_spec <span class="bound">f</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span>True<span class="main">,</span><span class="bound">itc</span><span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> NFlow.augment_with_path <span class="free">c</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">;</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span> False<span class="main">,</span><span class="bound">itc</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
        <span class="main">}</span>  
    <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span>False<span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">itc</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> card V <span class="main">*</span> card E <span class="main">+</span> card V<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">return</span> <span class="bound">f</span> 
<span class="main">}</span>"</span></span>
  
<span class="keyword1" id="EdmondsKarp_Algo-edka_complexity_refine"><span class="command">lemma</span></span> edka_complexity_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"edka_complexity <span class="main">≤</span> <span class="main">⇓</span>Id edka"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"RELATES edkac_rel"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> edka_complexity_def edka_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edkac_rel_def <span class="quoted">"NFlow.augment_with_path_def"</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> ekMeasure_upper_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> NFlow.shortest_path_decr_ek_measure<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that this algorithm never fails, and computes a maximum flow.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"edka_complexity <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">f</span><span class="main">.</span> isMaxFlow <span class="bound">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">note</span></span> edka_complexity_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka_partial_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fofu_partial_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>  


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Network›</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Augmenting_Path_BFS">
<div class="head">
<h1>Theory Augmenting_Path_BFS</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Breadth First Search›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Augmenting_Path_BFS
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Flow_Networks/Refine_Add_Fofu.html">Flow_Networks.Refine_Add_Fofu</a>
  <a href="../Flow_Networks/Graph_Impl.html">Flow_Networks.Graph_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    In this theory, we present a verified breadth-first search
    with an efficient imperative implementation.
    It is parametric in the successor function.
    ›</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algorithm›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> pre_bfs_invar <span class="main">=</span> Graph <span class="main">+</span>    
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">src</span> <span class="free">dst</span> <span class="main">::</span> <span class="quoted">node</span>
  <span class="keyword2"><span class="keyword">begin</span></span>  

    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ndist</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> min_dist <span class="free">src</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Vd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> node set"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">Vd</span> <span class="bound">d</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> connected <span class="free">src</span> <span class="bound">v</span> <span class="main">∧</span> ndist <span class="bound">v</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>

    <span class="keyword1" id="Augmenting_Path_BFS-Vd_disj"><span class="command">lemma</span></span> Vd_disj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">d</span> <span class="bound">d'</span><span class="main">.</span> <span class="bound">d</span><span class="main">≠</span><span class="bound">d'</span> <span class="main">⟹</span> Vd <span class="bound">d</span> <span class="main">∩</span> Vd <span class="bound">d'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Vd_def<span class="main">)</span>

    <span class="keyword1" id="Augmenting_Path_BFS-src_Vd0"><span class="command">lemma</span></span> src_Vd0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Vd <span class="main">0</span> <span class="main">=</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Vd_def<span class="main">)</span>

    <span class="keyword1" id="Augmenting_Path_BFS-in_Vd_conv"><span class="command">lemma</span></span> in_Vd_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>Vd <span class="free">d</span> <span class="main">⟷</span> connected <span class="free">src</span> <span class="free">v</span> <span class="main">∧</span> ndist <span class="free">v</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Vd_def<span class="main">)</span>

    <span class="keyword1" id="Augmenting_Path_BFS-Vd_succ"><span class="command">lemma</span></span> Vd_succ<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>Vd <span class="free">d</span>"</span></span>  
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">≤</span><span class="free">d</span><span class="main">.</span> <span class="free">v</span><span class="main">∉</span>Vd <span class="bound">i</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>Vd <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> connected_append_edge in_Vd_conv le_SucE min_dist_succ<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> valid_PRED <span class="main">=</span> pre_bfs_invar <span class="main">+</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">PRED</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇀</span> node"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SRC_IN_V<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">∈</span>V"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> FIN_V<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRED_src<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">PRED</span> <span class="free">src</span> <span class="main">=</span> Some <span class="free">src</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRED_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span><span class="main">≠</span><span class="free">src</span><span class="main">;</span> <span class="free">PRED</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">u</span><span class="main">⟧</span> <span class="main">⟹</span> ndist <span class="free">v</span> <span class="main">=</span> Suc <span class="main">(</span>ndist <span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRED_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span><span class="main">≠</span><span class="free">src</span><span class="main">;</span> <span class="free">PRED</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">u</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRED_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">PRED</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">u</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">u</span><span class="main">∈</span>dom <span class="free">PRED</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="Augmenting_Path_BFS-FIN_E"><span class="command">lemma</span></span> FIN_E<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite E"</span></span> <span class="keyword1"><span class="command">using</span></span> E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1" id="Augmenting_Path_BFS-FIN_succ"><span class="command">lemma</span></span> FIN_succ<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Image<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>  
    
  <span class="keyword1"><span class="command">locale</span></span> nf_invar' <span class="main">=</span> valid_PRED <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">src</span></span> <span class="quoted"><span class="free">dst</span></span> <span class="quoted"><span class="free">PRED</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">PRED</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇀</span> node"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">C</span> <span class="free">N</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">d</span> <span class="main">::</span> <span class="quoted">nat</span> 
    <span class="main">+</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VIS_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="free">PRED</span> <span class="main">=</span> <span class="free">N</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> <span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">≤</span><span class="free">d</span><span class="main">.</span> <span class="bound">u</span><span class="main">∈</span>Vd <span class="bound">i</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> C_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> Vd <span class="free">d</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> N_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">=</span> Vd <span class="main">(</span><span class="free">d</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">∩</span> E<span class="main">``</span><span class="main">(</span>Vd <span class="free">d</span> <span class="main">-</span> <span class="free">C</span><span class="main">)</span>"</span></span>
      
    <span class="keyword2"><span class="keyword">assumes</span></span> dst_ne_VIS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∉</span> dom <span class="free">PRED</span>"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> nf_invar <span class="main">=</span> nf_invar' <span class="main">+</span>   
    <span class="keyword2"><span class="keyword">assumes</span></span> empty_assm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">=</span><span class="main">{}</span> <span class="main">⟹</span> <span class="free">N</span><span class="main">=</span><span class="main">{}</span>"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> f_invar <span class="main">=</span> valid_PRED <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">src</span></span> <span class="quoted"><span class="free">dst</span></span> <span class="quoted"><span class="free">PRED</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">PRED</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇀</span> node"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">d</span> <span class="main">::</span> <span class="quoted">nat</span>   
    <span class="main">+</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> dst_found<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∈</span> dom <span class="free">PRED</span> <span class="main">∩</span> Vd <span class="free">d</span>"</span></span>

  <span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">outer_loop_invar</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> 
      <span class="main">(</span><span class="bound">f</span> <span class="main">⟶</span> f_invar <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">PRED</span> <span class="bound">d</span><span class="main">)</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">¬</span><span class="bound">f</span> <span class="main">⟶</span> nf_invar <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">PRED</span> <span class="bound">C</span> <span class="bound">N</span> <span class="bound">d</span><span class="main">)</span>

      "</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">assn1</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> 
      <span class="main">¬</span><span class="bound">f</span> <span class="main">∧</span> nf_invar' <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">PRED</span> <span class="bound">C</span> <span class="bound">N</span> <span class="bound">d</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">add_succ_spec</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> ASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">⊆</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span> <span class="main">⪢</span> 
    SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED'</span><span class="main">,</span><span class="bound">N'</span><span class="main">)</span><span class="main">.</span>
      <span class="keyword1">case</span> <span class="bound">f</span> <span class="keyword1">of</span>
        False <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> 
          <span class="main">∧</span> <span class="bound">PRED'</span> <span class="main">=</span> map_mmupd <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
          <span class="main">∧</span> <span class="bound">N'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∪</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span>
      <span class="main">|</span> True <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="bound">PRED'</span> 
        <span class="main">∧</span> <span class="bound">PRED'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_mmupd <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
        <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">∈</span>dom <span class="bound">PRED'</span>
  <span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_bfs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span>node<span class="main">⇀</span>node<span class="main">)</span><span class="main">)</span> option nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_bfs</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> WHILEIT <span class="main">(</span>outer_loop_invar <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span><span class="main">=</span>False <span class="main">∧</span> <span class="bound">C</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">v</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">C</span><span class="main">)</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">C</span> <span class="main">=</span> <span class="bound">C</span><span class="main">-</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">;</span>
        ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">succ</span> <span class="main">=</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
        ASSERT <span class="main">(</span>finite <span class="bound">succ</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">←</span> add_succ_spec <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">succ</span> <span class="bound">v</span> <span class="bound">PRED</span> <span class="bound">N</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span>
          RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          ASSERT <span class="main">(</span>assn1 <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">if</span> <span class="main">(</span><span class="bound">C</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">let</span> <span class="bound">C</span><span class="main">=</span><span class="bound">N</span><span class="main">;</span> 
            <span class="keyword1">let</span> <span class="bound">N</span><span class="main">=</span><span class="main">{}</span><span class="main">;</span> 
            <span class="keyword1">let</span> <span class="bound">d</span><span class="main">=</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">;</span>
            RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
          <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
        <span class="main">}</span>  
      <span class="main">}</span><span class="main">)</span>
      <span class="main">(</span>False<span class="main">,</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">]</span><span class="main">,</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">}</span><span class="main">,</span><span class="main">{}</span><span class="main">,</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span> <span class="bound">PRED</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> RETURN None
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Correctness Proof"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar'<span class="main">)</span> ndist_C<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span><span class="main">∈</span><span class="free">C</span><span class="main">⟧</span> <span class="main">⟹</span> ndist <span class="free">v</span> <span class="main">=</span> <span class="free">d</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> C_ss <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Vd_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> CVdI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span><span class="main">∈</span><span class="free">C</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">u</span><span class="main">∈</span>Vd <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> C_ss <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> inPREDD<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">PRED</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">u</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span><span class="free">N</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">≤</span><span class="free">d</span><span class="main">.</span> <span class="free">v</span><span class="main">∈</span>Vd <span class="bound">i</span><span class="main">)</span>"</span></span>   
    <span class="keyword1"><span class="command">using</span></span> VIS_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar'<span class="main">)</span> C_ss_VIS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span><span class="main">∈</span><span class="free">C</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>dom <span class="free">PRED</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> C_ss VIS_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_succ_step<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">C</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∉</span> E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">-</span> dom <span class="free">PRED</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nf_invar' <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> 
      <span class="main">(</span>map_mmupd <span class="free">PRED</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">-</span> dom <span class="free">PRED</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span> 
      <span class="main">(</span><span class="free">C</span><span class="main">-</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> 
      <span class="main">(</span><span class="free">N</span> <span class="main">∪</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">-</span> dom <span class="free">PRED</span><span class="main">)</span><span class="main">)</span> 
      <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> C_ss_VIS<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">C</span>›</span></span><span class="main">]</span> dst_ne_VIS <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="free">dst</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">≠</span><span class="free">dst</span>›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_mmupd_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> map_mmupdE<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> PRED_dist <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> VIS_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> CVdI Vd_succ in_Vd_conv<span class="main">)</span>
  
      <span class="keyword1"><span class="command">using</span></span> PRED_E <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_mmupdE<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>   
      <span class="keyword1"><span class="command">using</span></span> PRED_closed <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_mmupdE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> C_ss_VIS<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 
  
      <span class="keyword1"><span class="command">using</span></span> VIS_eq <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> C_ss <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> N_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> CVdI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Vd_succ<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> VIS_eq <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inPREDD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N_eq in_Vd_conv<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
      <span class="keyword1"><span class="command">using</span></span> dst_ne_VIS assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>  

  <span class="keyword1" id="Augmenting_Path_BFS-invar_init"><span class="command">lemma</span></span> invar_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">src</span><span class="main">≠</span><span class="free">dst</span><span class="main">;</span> <span class="free">src</span><span class="main">∈</span>V<span class="main">;</span> finite V<span class="main">⟧</span> 
    <span class="main">⟹</span> nf_invar <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> <span class="main">[</span><span class="free">src</span> <span class="main">↦</span> <span class="free">src</span><span class="main">]</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">{}</span> <span class="main">0</span>"</span></span>            
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pre_bfs_invar.Vd_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_exit<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">dst</span><span class="main">∈</span><span class="free">C</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_invar <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> <span class="free">PRED</span> <span class="free">d</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> assms VIS_eq C_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_C_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">C</span> <span class="main">⟹</span> <span class="free">u</span><span class="main">∈</span>V"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> CVdI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_Vd_conv connected_inV_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_N_ss_Vis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">N</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free">PRED</span> <span class="free">u</span> <span class="main">=</span> Some <span class="bound">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> VIS_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> pre_bfs_invar<span class="main">)</span> Vdsucinter_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"Vd <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span> <span class="main">∩</span> E <span class="main">``</span> Vd <span class="free">d</span> <span class="main">=</span> Vd <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Image_iff in_Vd_conv min_dist_suc<span class="main">)</span>  

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar'<span class="main">)</span> invar_shift<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">=</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nf_invar <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> <span class="free">PRED</span> <span class="free">N</span> <span class="main">{}</span> <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
    <span class="keyword1"><span class="command">using</span></span> VIS_eq N_eq<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Suc_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> N_eq <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> N_eq<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> dst_ne_VIS <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar'<span class="main">)</span> invar_restore<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nf_invar <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> <span class="free">PRED</span> <span class="free">C</span> <span class="free">N</span> <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bfs_spec</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">(</span>
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">¬</span> connected <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span>
            <span class="main">|</span> Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">PRED</span><span class="main">)</span> <span class="main">⇒</span> connected <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> 
                <span class="main">∧</span> min_dist <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">=</span> <span class="bound">d</span> 
                <span class="main">∧</span> valid_PRED <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="bound">PRED</span> 
                <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">∈</span>dom <span class="bound">PRED</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> f_invar<span class="main">)</span> invar_found<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs_spec <span class="free">src</span> <span class="free">dst</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">d</span><span class="main">,</span><span class="free">PRED</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bfs_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">using</span></span> dst_found 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_Vd_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_not_found<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">=</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs_spec <span class="free">src</span> <span class="free">dst</span> None"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bfs_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">N</span><span class="main">=</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> empty_assm <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">src</span> <span class="free">dst</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d'</span></span> <span class="keyword2"><span class="keyword">where</span></span> dstd'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∈</span> Vd <span class="skolem">d'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_Vd_conv<span class="main">)</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We make a case-distinction whether <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d'≤d›</span></span></span></span>:›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d'</span><span class="main">≤</span><span class="free">d</span> <span class="main">∨</span> Suc <span class="free">d</span> <span class="main">≤</span> <span class="skolem">d'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d'</span><span class="main">≤</span><span class="free">d</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> VIS_eq dstd' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∈</span> dom <span class="free">PRED</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> dst_ne_VIS <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">d</span> <span class="main">≤</span> <span class="skolem">d'</span>"</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹In the case <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d+1 ≤ d'›</span></span></span></span>, we also obtain a node
        that has a shortest path of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d+1›</span></span></span></span>:›</span></span>
      <span class="keyword1"><span class="command">with</span></span> min_dist_le<span class="main">[</span><span class="operator">OF</span> C<span class="main">]</span> dstd' <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> Vd <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_Vd_conv<span class="main">)</span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹However, the invariant states that such nodes are either in
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span> or are successors of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>C›</span></span></span></span>. As <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>N›</span></span></span></span> 
        and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>C›</span></span></span></span> are both empty, we again get a contradiction.›</span></span>
      <span class="keyword1"><span class="command">with</span></span> N_eq <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Augmenting_Path_BFS-map_le_mp"><span class="command">lemma</span></span> map_le_mp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span><span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span><span class="free">m'</span><span class="main">;</span> <span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m'</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_le_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> dst_notin_Vdd<span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="free">d</span> <span class="main">⟹</span> <span class="free">dst</span><span class="main">∉</span>Vd <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> VIS_eq dst_ne_VIS <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> invar_exit'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">dst</span><span class="main">)</span> <span class="main">∈</span> E"</span></span> <span class="quoted"><span class="quoted">"<span class="free">dst</span> <span class="main">∈</span> dom <span class="free">PRED'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SS1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">PRED</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">PRED'</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> SS2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">PRED'</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> map_mmupd <span class="free">PRED</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">-</span> dom <span class="free">PRED</span><span class="main">)</span> <span class="free">u</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f_invar <span class="free">c</span> <span class="free">src</span> <span class="free">dst</span> <span class="free">PRED'</span> <span class="main">(</span>Suc <span class="free">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">using</span></span> map_le_mp<span class="main">[</span><span class="operator">OF</span> SS1 PRED_src<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> map_le_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> map_mmupdE<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> PRED_dist <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> VIS_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">C</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> CVdI Vd_succ in_Vd_conv<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> map_le_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> PRED_E <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_mmupdE<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>   
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> map_le_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> map_mmupdE<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> map_le_implies_dom_le<span class="main">[</span><span class="operator">OF</span> SS1<span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> PRED_closed <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> C_ss_VIS<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">C</span>›</span></span><span class="main">]</span> map_le_implies_dom_le<span class="main">[</span><span class="operator">OF</span> SS1<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">dst</span> <span class="main">∈</span> dom <span class="free">PRED'</span>›</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">C</span>›</span></span> CVdI<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">C</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">dst</span><span class="main">)</span><span class="main">∈</span>E›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Vd_succ<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> VIS_eq <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">max_dist</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">≡</span> Max <span class="main">(</span>min_dist <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">`</span>V<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">outer_loop_rel</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">≡</span> 
    inv_image <span class="main">(</span>
        less_than_bool 
        <span class="keyword1">&lt;*lex*&gt;</span> greater_bounded <span class="main">(</span>max_dist <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> 
        <span class="keyword1">&lt;*lex*&gt;</span> finite_psubset<span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span><span class="bound">f</span><span class="main">,</span><span class="bound">d</span><span class="main">,</span><span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1" id="Augmenting_Path_BFS-outer_loop_rel_wf"><span class="command">lemma</span></span> outer_loop_rel_wf<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite V"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>outer_loop_rel <span class="free">src</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> outer_loop_rel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> C_ne_max_dist<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≤</span> max_dist <span class="free">src</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> C_ss <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>Vd <span class="free">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"min_dist <span class="free">src</span> <span class="skolem">u</span> <span class="main">=</span> <span class="free">d</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_Vd_conv connected_inV_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span><span class="main">≤</span>max_dist <span class="free">src</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> max_dist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> Vd_ss_V<span class="main">:</span> <span class="quoted"><span class="quoted">"Vd <span class="free">d</span> <span class="main">⊆</span> V"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Vd_def connected_inV_iff<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> finite_C<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> C_ss FIN_V Vd_ss_V <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> nf_invar<span class="main">)</span> finite_succ<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">theorem</span></span> pre_bfs_correct<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">≠</span><span class="free">dst</span>"</span></span>       
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pre_bfs <span class="free">src</span> <span class="free">dst</span> <span class="main">≤</span> SPEC <span class="main">(</span>bfs_spec <span class="free">src</span> <span class="free">dst</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pre_bfs_def add_succ_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> outer_loop_rel_wf<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> src<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">src</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
      invar_init 
      nf_invar.invar_exit' 
      nf_invar.invar_C_ss_V 
      nf_invar.invar_succ_step
      nf_invar'.invar_shift
      nf_invar'.invar_restore        
      f_invar.invar_found
      nf_invar.invar_not_found
      nf_invar.invar_N_ss_Vis
      nf_invar.finite_succ
      <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_subset outer_loop_rel_def 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nf_invar.C_ne_max_dist nf_invar.finite_C<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



  <span class="comment1">(* Presentation for Paper *)</span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">bfs_core</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span>node<span class="main">⇀</span>node<span class="main">)</span><span class="main">)</span> option nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bfs_core</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span><span class="main">=</span>False <span class="main">∧</span> <span class="bound">C</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">v</span> <span class="main">←</span> <span class="keyword1">spec</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">C</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">C</span> <span class="main">=</span> <span class="bound">C</span><span class="main">-</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">succ</span> <span class="main">=</span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">←</span> add_succ_spec <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">succ</span> <span class="bound">v</span> <span class="bound">P</span> <span class="bound">N</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span>
          <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> <span class="main">(</span><span class="bound">C</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">let</span> <span class="bound">C</span><span class="main">=</span><span class="bound">N</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">N</span><span class="main">=</span><span class="main">{}</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">d</span><span class="main">=</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">;</span>
            <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
          <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">P</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
        <span class="main">}</span>  
      <span class="main">}</span><span class="main">)</span>
      <span class="main">(</span>False<span class="main">,</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">]</span><span class="main">,</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">}</span><span class="main">,</span><span class="main">{}</span><span class="main">,</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span> <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span> <span class="bound">P</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">return</span> None
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">≠</span><span class="free">dst</span>"</span></span> <span class="quoted"><span class="quoted">"finite V"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs_core <span class="free">src</span> <span class="free">dst</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">p</span><span class="main">.</span> bfs_spec <span class="free">src</span> <span class="free">dst</span> <span class="bound">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ pre_bfs_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> bfs_core_def pre_bfs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


      
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Extraction of Result Path›</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">extract_rpath</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">←</span> WHILEIT
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> 
          <span class="bound">v</span><span class="main">∈</span>dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> 
        <span class="main">∧</span> isPath <span class="bound">v</span> <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span>
        <span class="main">∧</span> distinct <span class="main">(</span>pathVertices <span class="bound">v</span> <span class="bound">p</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>set <span class="main">(</span>pathVertices <span class="bound">v</span> <span class="bound">p</span><span class="main">)</span><span class="main">.</span> 
            pre_bfs_invar.ndist <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="bound">v</span> <span class="main">≤</span> pre_bfs_invar.ndist <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="bound">v'</span><span class="main">)</span>
        <span class="main">∧</span> pre_bfs_invar.ndist <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="bound">v</span> <span class="main">+</span> length <span class="bound">p</span> 
          <span class="main">=</span> pre_bfs_invar.ndist <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">)</span>
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span><span class="main">≠</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">u</span><span class="main">=</span>the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">#</span><span class="bound">p</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">v</span><span class="main">=</span><span class="bound">u</span><span class="main">;</span>
        RETURN <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">,</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="bound">p</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword2"><span class="keyword">end</span></span>  

  <span class="keyword1"><span class="command">context</span></span> valid_PRED <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="Augmenting_Path_BFS-extract_rpath_correct"><span class="command">lemma</span></span> extract_rpath_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">dst</span><span class="main">∈</span>dom <span class="free">PRED</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extract_rpath <span class="free">src</span> <span class="free">dst</span> <span class="free">PRED</span> 
        <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> isSimplePath <span class="free">src</span> <span class="bound">p</span> <span class="free">dst</span> <span class="main">∧</span> length <span class="bound">p</span> <span class="main">=</span> ndist <span class="free">dst</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> extract_rpath_def isSimplePath_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> wf_measure<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> ndist <span class="bound">d</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> PRED_closed<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> domD<span class="main"><span class="main">]</span></span> PRED_E PRED_dist<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bfs</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="keyword1">then</span> RETURN <span class="main">(</span>Some <span class="main">[]</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">br</span> <span class="main">←</span> pre_bfs <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">;</span>
        <span class="keyword1">case</span> <span class="bound">br</span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> RETURN None
        <span class="main">|</span> Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">PRED</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="bound">p</span> <span class="main">←</span> extract_rpath <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">PRED</span><span class="main">;</span>
            RETURN <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span>
          <span class="main">}</span>  
      <span class="main">}</span>    
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="Augmenting_Path_BFS-bfs_correct"><span class="command">lemma</span></span> bfs_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"finite V"</span></span> 
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs <span class="free">src</span> <span class="free">dst</span> 
        <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span>
          None <span class="main">⇒</span> <span class="main">¬</span>connected <span class="free">src</span> <span class="free">dst</span> 
        <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> isShortestPath <span class="free">src</span> <span class="bound">p</span> <span class="free">dst</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bfs_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span>
        pre_bfs_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span>
        valid_PRED.extract_rpath_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span>
        <span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bfs_spec_def isShortestPath_min_dist_def isSimplePath_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="comment1">(* Snippet for paper *)</span>  
  <span class="keyword1"><span class="command">context</span></span> Finite_Graph <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">interpretation</span></span> Refine_Monadic_Syntax <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">theorem</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span><span class="main">∈</span>V"</span></span> 
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs <span class="free">src</span> <span class="free">dst</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">p</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
          None <span class="main">⇒</span> <span class="main">¬</span>connected <span class="free">src</span> <span class="free">dst</span> 
        <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> isShortestPath <span class="free">src</span> <span class="bound">p</span> <span class="free">dst</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bfs_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span>
        pre_bfs_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span>
        valid_PRED.extract_rpath_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span>
        <span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bfs_spec_def isShortestPath_min_dist_def isSimplePath_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

  <span class="keyword2"><span class="keyword">end</span></span>  

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Inserting inner Loop and Successor Function›</span></span>
  <span class="keyword1"><span class="command">context</span></span> Graph <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">inner_loop</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> FOREACHci
    <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED'</span><span class="main">,</span><span class="bound">N'</span><span class="main">)</span><span class="main">.</span> 
        <span class="bound">PRED'</span> <span class="main">=</span> map_mmupd <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> <span class="bound">it</span><span class="main">)</span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> 
      <span class="main">∧</span> <span class="bound">N'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> <span class="bound">it</span><span class="main">)</span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span>
      <span class="main">∧</span> <span class="bound">f</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">∈</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">-</span> <span class="bound">it</span><span class="main">)</span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">)</span>
    <span class="main">)</span>
    <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">f</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span>dom <span class="bound">PRED</span> <span class="keyword1">then</span> RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">let</span> <span class="bound">PRED</span> <span class="main">=</span> <span class="bound">PRED</span><span class="main">(</span><span class="bound">v</span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">;</span>
        ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∉</span><span class="bound">N</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">N</span> <span class="main">=</span> insert <span class="bound">v</span> <span class="bound">N</span><span class="main">;</span>
        RETURN <span class="main">(</span><span class="bound">v</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">)</span>"</span></span>


  <span class="keyword1" id="Augmenting_Path_BFS-inner_loop_refine"><span class="command">lemma</span></span> inner_loop_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
    <span class="comment1">(*assumes NSS: "N ⊆ dom PRED"*)</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">succ</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">succi</span><span class="main">,</span><span class="free">succ</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">PREDi</span><span class="main">,</span><span class="free">PRED</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ni</span><span class="main">,</span><span class="free">N</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inner_loop <span class="free">dst</span> <span class="free">succi</span> <span class="free">ui</span> <span class="free">PREDi</span> <span class="free">Ni</span> 
      <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>add_succ_spec <span class="free">dst</span> <span class="free">succ</span> <span class="free">u</span> <span class="free">PRED</span> <span class="free">N</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inner_loop_def add_succ_spec_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span> <span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff fun_neq_ext_iff map_mmupd_def 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> it_step_insert_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_mmupd_update_less 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">inner_loop2</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">succl</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">PRED</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> nfoldli
    <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succl</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="bound">PRED</span> <span class="bound">v</span> <span class="main">≠</span> None <span class="keyword1">then</span> RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">PRED</span> <span class="main">=</span> <span class="bound">PRED</span><span class="main">(</span><span class="bound">v</span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∉</span><span class="bound">N</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">N</span> <span class="main">=</span> insert <span class="bound">v</span> <span class="bound">N</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">)</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span>False<span class="main">,</span><span class="free"><span class="bound"><span class="entity">PRED</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Augmenting_Path_BFS-inner_loop2_refine"><span class="command">lemma</span></span> inner_loop2_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">succl</span><span class="main">,</span><span class="free">succ</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inner_loop2 <span class="free">dst</span> <span class="free">succl</span> <span class="free">u</span> <span class="free">PRED</span> <span class="free">N</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>inner_loop <span class="free">dst</span> <span class="free">succ</span> <span class="free">u</span> <span class="free">PRED</span> <span class="free">N</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> inner_loop2_def inner_loop_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> LFOci_refine SR<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">thm</span></span> conc_trans<span class="main">[</span><span class="operator">OF</span> inner_loop2_refine inner_loop_refine<span class="main">,</span> <span class="operator">no_vars</span><span class="main">]</span>

  <span class="keyword1" id="Augmenting_Path_BFS-inner_loop2_correct"><span class="command">lemma</span></span> inner_loop2_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">succl</span><span class="main">,</span> <span class="free">succ</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel"</span></span>
    <span class="comment1">(*assumes "N ⊆ dom PRED"*)</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">dsti</span><span class="main">,</span><span class="free">dst</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ui</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">PREDi</span><span class="main">,</span> <span class="free">PRED</span><span class="main">)</span> <span class="main">∈</span> Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Ni</span><span class="main">,</span> <span class="free">N</span><span class="main">)</span> <span class="main">∈</span> Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inner_loop2 <span class="free">dsti</span> <span class="free">succl</span> <span class="free">ui</span> <span class="free">PREDi</span> <span class="free">Ni</span> 
      <span class="main">≤</span> <span class="main">⇓</span> Id <span class="main">(</span>add_succ_spec <span class="free">dst</span> <span class="free">succ</span> <span class="free">u</span> <span class="free">PRED</span> <span class="free">N</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conc_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inner_loop2_refine inner_loop_refine<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1-2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">type_synonym</span></span> bfs_state <span class="main">=</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="main">(</span>node <span class="main">⇀</span> node<span class="main">)</span> <span class="main">×</span> node set <span class="main">×</span> node set <span class="main">×</span> nat"</span></span>  

    <span class="keyword1"><span class="command">context</span></span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list nres"</span></span>
    <span class="keyword2"><span class="keyword">begin</span></span>
      <span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> bfs_state nres"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> 
        <span class="quoted"><span class="quoted">"<span class="free">init_state</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span>False<span class="main">,</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">]</span><span class="main">,</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">}</span><span class="main">,</span><span class="main">{}</span><span class="main">,</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
  
      <span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_bfs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span>node<span class="main">⇀</span>node<span class="main">)</span><span class="main">)</span> option nres"</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pre_bfs2</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">s</span> <span class="main">←</span> init_state <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">;</span>
        <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> WHILET <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span><span class="main">=</span>False <span class="main">∧</span> <span class="bound">C</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span>
          <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
            ASSERT <span class="main">(</span><span class="bound">C</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">v</span> <span class="main">←</span> op_set_pick <span class="bound">C</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">C</span> <span class="main">=</span> <span class="bound">C</span><span class="main">-</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">;</span>
            ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">)</span><span class="main">;</span>
            <span class="bound">sl</span> <span class="main">←</span> <span class="free">succ</span> <span class="bound">v</span><span class="main">;</span>
            <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">←</span> inner_loop2 <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">sl</span> <span class="bound">v</span> <span class="bound">PRED</span> <span class="bound">N</span><span class="main">;</span>
            <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span>
              RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>
            <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
              ASSERT <span class="main">(</span>assn1 <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="main">(</span><span class="bound">C</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">let</span> <span class="bound">C</span><span class="main">=</span><span class="bound">N</span><span class="main">;</span> 
                <span class="keyword1">let</span> <span class="bound">N</span><span class="main">=</span><span class="main">{}</span><span class="main">;</span> 
                <span class="keyword1">let</span> <span class="bound">d</span><span class="main">=</span><span class="bound">d</span><span class="main">+</span><span class="main">1</span><span class="main">;</span>
                RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
              <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">PRED</span><span class="main">,</span><span class="bound">C</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span>
            <span class="main">}</span>  
          <span class="main">}</span><span class="main">)</span>
          <span class="bound">s</span><span class="main">;</span>
        <span class="keyword1">if</span> <span class="bound">f</span> <span class="keyword1">then</span> RETURN <span class="main">(</span>Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span> <span class="bound">PRED</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> RETURN None
        <span class="main">}</span>"</span></span>
    
      <span class="keyword1" id="Augmenting_Path_BFS-pre_bfs2_refine"><span class="command">lemma</span></span> pre_bfs2_refine<span class="main">:</span> 
        <span class="keyword2"><span class="keyword">assumes</span></span> succ_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ui</span> <span class="bound">u</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">ui</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="bound">u</span><span class="main">∈</span>V<span class="main">⟧</span> 
          <span class="main">⟹</span> <span class="free">succ</span> <span class="bound">ui</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel<span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pre_bfs2 <span class="free">src</span> <span class="free">dst</span> <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>pre_bfs <span class="free">src</span> <span class="free">dst</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pre_bfs_def pre_bfs2_def init_state_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> nres_monad1<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> inner_loop2_correct succ_impl<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span> <span class="comment1">(* Takes some time *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
    <span class="keyword2"><span class="keyword">end</span></span>    
  
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bfs2</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="keyword1">then</span> 
        RETURN <span class="main">(</span>Some <span class="main">[]</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>  
        <span class="bound">br</span> <span class="main">←</span> pre_bfs2 <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">;</span>
        <span class="keyword1">case</span> <span class="bound">br</span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> RETURN None
        <span class="main">|</span> Some <span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">PRED</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="bound">p</span> <span class="main">←</span> extract_rpath <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="bound">PRED</span><span class="main">;</span>
            RETURN <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span>
          <span class="main">}</span>  
      <span class="main">}</span>    
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="Augmenting_Path_BFS-bfs2_refine"><span class="command">lemma</span></span> bfs2_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> succ_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ui</span> <span class="bound">u</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">ui</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="bound">u</span><span class="main">∈</span>V<span class="main">⟧</span> 
        <span class="main">⟹</span> <span class="free">succ</span> <span class="bound">ui</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>E<span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel<span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bfs2 <span class="free">succ</span> <span class="free">src</span> <span class="free">dst</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>bfs <span class="free">src</span> <span class="free">dst</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bfs_def bfs2_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> pre_bfs2_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

  <span class="keyword2"><span class="keyword">end</span></span>  

  
  <span class="keyword1" id="Augmenting_Path_BFS-bfs2_refine_succ"><span class="command">lemma</span></span> bfs2_refine_succ<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ui</span> <span class="bound">u</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">ui</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="bound">u</span><span class="main">∈</span>Graph.V <span class="free">c</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="free">succi</span> <span class="bound">ui</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span><span class="free">succ</span> <span class="bound">u</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ti</span><span class="main">,</span><span class="free">t</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ci</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Graph.bfs2 <span class="free">ci</span> <span class="free">succi</span> <span class="free">si</span> <span class="free">ti</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>Graph.bfs2 <span class="free">c</span> <span class="free">succ</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Graph.bfs2_def Graph.pre_bfs2_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
      param_nfoldli<span class="main"><span class="main">[</span></span><span class="operator">param_fo</span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> nres_relD<span class="main"><span class="main">]</span></span> nres_relI fun_relI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Implementation›</span></span>

  <span class="keyword1"><span class="command">context</span></span> Impl_Succ <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">op_bfs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ga</span> <span class="main">⇒</span> node <span class="main">⇒</span> node <span class="main">⇒</span> path option nres"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">op_bfs</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> Graph.bfs2 <span class="main">(</span><span class="free">absG</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">succ</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>
  
    <span class="keyword1" id="Augmenting_Path_BFS-pat_op_dfs"><span class="command">lemma</span></span> pat_op_dfs<span class="main">[</span><span class="operator">pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Graph.bfs2<span class="main">$</span><span class="main">(</span><span class="free">absG</span><span class="main">$</span><span class="free">c</span><span class="main">)</span><span class="main">$</span><span class="main">(</span><span class="free">succ</span><span class="main">$</span><span class="free">c</span><span class="main">)</span><span class="main">$</span><span class="free">s</span><span class="main">$</span><span class="free">t</span> <span class="main">≡</span> UNPROTECT op_bfs<span class="main">$</span><span class="free">c</span><span class="main">$</span><span class="free">s</span><span class="main">$</span><span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST op_bfs"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ig</span> <span class="main">⇒</span> node <span class="main">⇒</span> node <span class="main">⇒</span> path option nres"</span></span>  
  
    <span class="keyword1"><span class="command">type_synonym</span></span> ibfs_state 
      <span class="main">=</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="main">(</span>node<span class="main">,</span>node<span class="main">)</span> i_map <span class="main">×</span> node set <span class="main">×</span> node set <span class="main">×</span> nat"</span></span>

    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted">Graph.init_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> ibfs_state nres"</span></span>
    <span class="keyword1"><span class="command">schematic_goal</span></span> init_state_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">src</span> <span class="main">::</span> <span class="quoted">nat</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">src</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>nat<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine <span class="main">(</span>hn_val nat_rel <span class="free">src</span> <span class="free">srci</span><span class="main">)</span> 
        <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ'</span> <span class="var">?R</span> <span class="main">(</span>Graph.init_state <span class="free">src</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Graph.init_state_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">[</span></span><span class="free"><span class="free">src</span></span><span class="main"><span class="main">↦</span></span><span class="free"><span class="free">src</span></span><span class="main"><span class="main">]</span></span>"</span></span></span> iam.fold_custom_empty<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ls.fold_custom_empty<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ls.fold_custom_empty<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"insert <span class="free"><span class="free">src</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> fold_set_insert_dj<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">↦</span></span><span class="free"><span class="free">src</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> fold_COPY<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">init_state_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> Impl_Succ.init_state_impl
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> init_state_impl.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">,</span><span class="operator">to_hfref</span><span class="main">]</span>

    <span class="keyword1"><span class="command">schematic_goal</span></span> bfs_impl<span class="main">:</span>
      <span class="comment1">(*notes [sepref_opt_simps del] = imp_nfoldli_def 
          -- ‹Prevent the foreach-loop to be unfolded to a fixed-point, 
              to produce more readable code for presentation purposes.›*)</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> heap_WHILET_def
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="free">t</span> <span class="main">::</span> <span class="quoted">nat</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>nat<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>nat<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'ig</span><span class="main">)</span>"</span></span><span class="main">]</span>
        <span class="comment1">― ‹Declare parameters to operation identification›</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine <span class="main">(</span>
        hn_ctxt <span class="main">(</span><span class="free">isG</span><span class="main">)</span> <span class="free">c</span> <span class="free">ci</span> 
      <span class="main">*</span> hn_val nat_rel <span class="free">s</span> <span class="free">si</span> 
      <span class="main">*</span> hn_val nat_rel <span class="free">t</span> <span class="free">ti</span><span class="main">)</span> <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ'</span> <span class="var">?R</span> <span class="main">(</span>PR_CONST op_bfs <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> op_bfs_def PR_CONST_def
      <span class="keyword1"><span class="command">unfolding</span></span> Graph.bfs2_def Graph.pre_bfs2_def 
        Graph.inner_loop2_def Graph.extract_rpath_def
      <span class="keyword1"><span class="command">unfolding</span></span> nres_monad_laws  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"nfoldli <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> fold_set_insert_dj<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> HOL_list.fold_custom_empty<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">let</span></span> <span class="bound"><span class="bound">N</span></span><span class="main"><span class="main">=</span></span><span class="main"><span class="main">{}</span></span> <span class="keyword1"><span class="keyword1">in</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> ls.fold_custom_empty<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">bfs_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> Impl_Succ.bfs_impl
      <span class="comment1">― ‹Extract generated implementation into constant›</span>
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> bfs_impl_def
   
    <span class="keyword1"><span class="command">lemmas</span></span> bfs_impl_fr_rule <span class="main">=</span> bfs_impl.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">,</span><span class="operator">to_hfref</span><span class="main">]</span>  
  
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">bfs_impl</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="EdmondsKarp_Impl">
<div class="head">
<h1>Theory EdmondsKarp_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of the Edmonds-Karp Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> EdmondsKarp_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="EdmondsKarp_Algo.html">EdmondsKarp_Algo</a>
  <a href="Augmenting_Path_BFS.html">Augmenting_Path_BFS</a>
  <a href="../Refine_Imperative_HOL/IICF.html">Refine_Imperative_HOL.IICF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now implement the Edmonds-Karp algorithm.
    Note that, during the implementation, we explicitly write down the 
    whole refined algorithm several times. As refinement is modular, most 
    of these copies could be avoided--- we inserted them deliberately for
    documentation purposes.
    ›</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Residual Graph›</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a first step towards implementation, we refine the algorithm
      to work directly on residual graphs. For this, we first have to 
      establish a relation between flows in a network and residual graphs.
      ›</span></span>
    
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Operations›</span></span>
  <span class="keyword1"><span class="command">context</span></span> Network 
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the relation between residual graphs and flows›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cfi_rel</span> <span class="main">≡</span> br flow_of_cf <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It can also be characterized the other way round, i.e., 
      mapping flows to residual graphs:›</span></span>
    <span class="keyword1" id="EdmondsKarp_Impl-cfi_rel_alt"><span class="command">lemma</span></span> cfi_rel_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"cfi_rel <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="bound">f</span> <span class="main">∧</span> NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cfi_rel_def br_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NFlow.is_RGraph RGraph.is_NFlow 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RPreGraph.rg_fo_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RGraph.this_loc_rpg<span class="main"><span class="main">]</span></span>
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NPreflow.fo_rg_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NFlow.axioms<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initially, the residual graph for the zero flow equals the original network›</span></span>
    <span class="keyword1" id="EdmondsKarp_Impl-residualGraph_zero_flow"><span class="command">lemma</span></span> residualGraph_zero_flow<span class="main">:</span> <span class="quoted"><span class="quoted">"residualGraph <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> residualGraph_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
    <span class="keyword1" id="EdmondsKarp_Impl-flow_of_c"><span class="command">lemma</span></span> flow_of_c<span class="main">:</span> <span class="quoted"><span class="quoted">"flow_of_cf <span class="free">c</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> flow_of_cf_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The residual capacity is naturally defined on residual graphs›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">resCap_cf</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> Min <span class="main">{</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="bound">e</span> <span class="main">|</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">e</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> resCap_cf_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"resCap_cf cf <span class="free">p</span> <span class="main">=</span> resCap <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> resCap_cf_def resCap_def <span class="keyword1"><span class="command">..</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Augmentation can be done by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Graph.augment_cf<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span> 

    
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> NFlow<span class="main">)</span> augment_cf_refine_aux<span class="main">:</span> <span class="comment1">(* For snippet *)</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"isAugmentingPath <span class="free">p</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"residualGraph <span class="free">c</span> <span class="main">(</span>augment <span class="main">(</span>augmentingFlow <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span> <span class="keyword1">then</span> <span class="main">(</span>residualGraph <span class="free">c</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">-</span> resCap <span class="free">p</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span> <span class="keyword1">then</span> <span class="main">(</span>residualGraph <span class="free">c</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">+</span> resCap <span class="free">p</span><span class="main">)</span>
        <span class="keyword1">else</span> residualGraph <span class="free">c</span> <span class="free">f</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> augment_alt<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Graph.augment_cf_def<span class="main">)</span>

    <span class="keyword1" id="EdmondsKarp_Impl-augment_cf_refine"><span class="command">lemma</span></span> augment_cf_refine<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">cf</span><span class="main">,</span><span class="free">f</span><span class="main">)</span><span class="main">∈</span>cfi_rel"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"NPreflow.isAugmentingPath <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span> <span class="free">p</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Graph.augment_cf <span class="free">cf</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">(</span>resCap_cf <span class="free">cf</span> <span class="free">p</span><span class="main">)</span><span class="main">,</span> 
          NFlow.augment_with_path <span class="free">c</span> <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="main">∈</span> cfi_rel"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
      <span class="keyword1"><span class="command">from</span></span> R <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cf</span> <span class="main">=</span> residualGraph <span class="free">c</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"NFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">f</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_alt br_def<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> f<span class="main">:</span> NFlow <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">f</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> f.augment_with_path_def
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfi_rel_alt<span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Graph.augment_cf f.cf <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">(</span>resCap_cf f.cf <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> 
              <span class="main">=</span> residualGraph <span class="free">c</span> <span class="main">(</span>f.augment <span class="main">(</span>f.augmentingFlow <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> f.augment_cf_refine_aux<span class="main">[</span><span class="operator">OF</span> AUG<span class="main">]</span>
          <span class="keyword1"><span class="command">unfolding</span></span> f.cf.augment_cf_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f.resCap_cf_refine<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> f.augment_pres_nflow<span class="main"><span class="main">[</span></span><span class="operator">OF</span> AUG<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>  

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We rephrase the specification of shortest augmenting path to
      take a residual graph as parameter›</span></span>
    <span class="comment1">(* TODO: This actually rephrases the spec to make it look more similar to 
      what BFS does later. This rephrasing does not belong here, but where we 
      implement it with BFS. *)</span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_shortest_augmenting_spec_cf</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span> <span class="main">⪢</span>
      SPEC <span class="main">(</span><span class="main">λ</span>
        None <span class="main">⇒</span> <span class="main">¬</span>Graph.connected <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free">s</span> <span class="free">t</span> 
      <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> Graph.isShortestPath <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> find_shortest_augmenting_spec_cf_refine<span class="main">:</span> 
       <span class="quoted"><span class="quoted">"find_shortest_augmenting_spec_cf <span class="free">cf</span> 
      <span class="main">≤</span> find_shortest_augmenting_spec <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> f_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> find_shortest_augmenting_spec_cf_def 
        <span class="keyword2"><span class="keyword">and</span></span> find_shortest_augmenting_spec_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> this_loc rg_is_cf
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f.isAugmentingPath_def Graph.connected_def Graph.isSimplePath_def 
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> cf.shortestPath_is_path
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
      
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This leads to the following refined algorithm›</span></span>  
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka2</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">cf</span> <span class="main">=</span> <span class="free">c</span><span class="main">;</span>

      <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">p</span> <span class="main">←</span> find_shortest_augmenting_spec_cf <span class="bound">cf</span><span class="main">;</span>
          <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
            None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>True<span class="main">)</span>
          <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="bound">cf</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">let</span> <span class="bound">cf</span> <span class="main">=</span> Graph.augment_cf <span class="bound">cf</span> <span class="main">(</span>set <span class="bound">p</span><span class="main">)</span> <span class="main">(</span>resCap_cf <span class="bound">cf</span> <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span> False<span class="main">)</span>
            <span class="main">}</span>  
        <span class="main">}</span><span class="main">)</span>
        <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> flow_of_cf <span class="bound">cf</span><span class="main">;</span>  
      <span class="keyword1">return</span> <span class="bound">f</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-edka2_refine"><span class="command">lemma</span></span> edka2_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"edka2 <span class="main">≤</span> <span class="main">⇓</span>Id edka"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES cfi_rel"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> edka2_def edka_def
        <span class="comment1">(*apply (rewrite in "let f' = NFlow.augmentingFlow c _ _ in _" Let_def)
        apply (rewrite in "let f = flow_of_cf _ in _" Let_def)*)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>

        <span class="comment1">― ‹Solve some left-over verification conditions one by one›</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> NFlow.is_RGraph<span class="main"><span class="keyword3">;</span></span> 
            <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def residualGraph_zero_flow flow_of_c<span class="main"><span class="keyword3">;</span></span> 
            <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> RGraph.find_shortest_augmenting_spec_cf_refine
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> RPreGraph.rg_fo_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RGraph.this_loc_rpg<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> augment_cf_refine<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_cf_refine<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfi_rel_def br_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">qed</span></span>    

    <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Bottleneck Computation and Augmentation›</span></span>  
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We will access the capacities in the residual graph
      only by a get-operation, which asserts that the edges are valid›</span></span>
    
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">valid_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"edge <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">valid_edge</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">u</span><span class="main">∈</span>V <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span>V"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cf_get</span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph <span class="main">⇒</span> edge <span class="main">⇒</span> <span class="tfree">'capacity</span> nres"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_get</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> ASSERT <span class="main">(</span>valid_edge <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">⪢</span> RETURN <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cf_set</span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph <span class="main">⇒</span> edge <span class="main">⇒</span> <span class="tfree">'capacity</span> <span class="main">⇒</span> <span class="tfree">'capacity</span> graph nres"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cf_set</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≡</span> ASSERT <span class="main">(</span>valid_edge <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">⪢</span> RETURN <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">:=</span><span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>  

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">resCap_cf_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph <span class="main">⇒</span> path <span class="main">⇒</span> <span class="tfree">'capacity</span> nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">resCap_cf_impl</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span>
        <span class="main">[]</span> <span class="main">⇒</span> RETURN <span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="tfree">'capacity</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span><span class="bound">e</span><span class="main">#</span><span class="bound">p</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">cap</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="bound">e</span><span class="main">;</span>
          ASSERT <span class="main">(</span>distinct <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
          nfoldli 
            <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">cap</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="bound">cape</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="bound">e</span><span class="main">;</span>
              RETURN <span class="main">(</span>min <span class="bound">cape</span> <span class="bound">cap</span><span class="main">)</span>
            <span class="main">}</span><span class="main">)</span> 
            <span class="bound">cap</span>
        <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> resCap_cf_impl_refine<span class="main">:</span>   
      <span class="keyword2"><span class="keyword">assumes</span></span> AUG<span class="main">:</span> <span class="quoted"><span class="quoted">"cf.isSimplePath <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resCap_cf_impl <span class="free">cf</span> <span class="free">p</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> resCap_cf <span class="free">cf</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="comment1">(* TODO: Can we exploit Min.set_eq_fold *)</span>

      <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> Min_insert
      <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Min_insert<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">from</span></span> AUG<span class="main">[</span><span class="operator">THEN</span> cf.isSPath_distinct<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> AUG cf.isPath_edgeset <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">p</span> <span class="main">⊆</span> cf.E"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.isSimplePath_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="free">p</span> <span class="main">⊆</span> Collect valid_edge"</span></span>  
        <span class="keyword1"><span class="command">using</span></span> cf.E_ss_VxV <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> AUG <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s_not_t<span class="main">)</span> 
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">e</span><span class="main">#</span><span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
        <span class="keyword1"><span class="command">unfolding</span></span> resCap_cf_impl_def resCap_cf_def cf_get_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> list.case<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
            I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l</span> <span class="bound">l'</span> <span class="bound">cap</span><span class="main">.</span> 
              <span class="bound">cap</span> <span class="main">=</span> Min <span class="main">(</span><span class="free">cf</span><span class="main">`</span>insert <span class="skolem">e</span> <span class="main">(</span>set <span class="bound">l</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">∧</span> set <span class="main">(</span><span class="bound">l</span><span class="main">@</span><span class="bound">l'</span><span class="main">)</span> <span class="main">⊆</span> Collect valid_edge"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Min</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>    

    <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> 
      <span class="quoted"><span class="quoted">"<span class="free">augment_edge</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free">c</span><span class="main">(</span>
                  <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">:=</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">,</span> 
        prod.swap <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">:=</span> <span class="free">c</span> <span class="main">(</span>prod.swap <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="comment1">(* TODO: This would be much simpler to prove if we had a characterization 
      of simple-path only depending on p. *)</span>    
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Graph<span class="main">)</span> augment_cf_inductive<span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">e</span> <span class="free">cap</span>
      <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">c'</span> <span class="main">≡</span> augment_edge <span class="free">e</span> <span class="free">cap</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"isSimplePath <span class="free">s</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">t</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"augment_cf <span class="main">(</span>insert <span class="free">e</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="free">cap</span> <span class="main">=</span> Graph.augment_cf <span class="free">c'</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="free">cap</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> Graph.isSimplePath <span class="free">c'</span> <span class="bound">s'</span> <span class="free">p</span> <span class="free">t</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> isSPath_no_selfloop<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> isSPath_nt_parallel<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> isSPath_distinct<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>set <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"augment_cf <span class="main">(</span>insert <span class="free">e</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="free">cap</span> <span class="main">=</span> Graph.augment_cf <span class="free">c'</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="free">cap</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>  
        <span class="keyword1"><span class="command">unfolding</span></span> Graph.augment_cf_def c'_def Graph.augment_edge_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Graph.isSimplePath <span class="free">c'</span> <span class="skolem">v</span> <span class="free">p</span> <span class="free">t</span>"</span></span>  
        <span class="keyword1"><span class="command">unfolding</span></span> Graph.isSimplePath_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> transfer_path<span class="main">)</span>
        <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> c'_def Graph.augment_edge_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> P <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> P <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> isSimplePath_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> Graph.isSimplePath <span class="free">c'</span> <span class="bound">s'</span> <span class="free">p</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">..</span></span> 

    <span class="keyword1"><span class="command">qed</span></span>    
        
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">augment_edge_impl</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">cap</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span> <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">e</span> <span class="main">=</span> prod.swap <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
      <span class="bound">v</span> <span class="main">←</span> cf_get <span class="bound">cf</span> <span class="bound">e</span><span class="main">;</span> <span class="bound">cf</span> <span class="main">←</span> cf_set <span class="bound">cf</span> <span class="bound">e</span> <span class="main">(</span><span class="bound">v</span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">cap</span></span></span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="bound">cf</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-augment_edge_impl_refine"><span class="command">lemma</span></span> augment_edge_impl_refine<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_edge <span class="free">e</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="free">e</span><span class="main">≠</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"augment_edge_impl <span class="free">cf</span> <span class="free">e</span> <span class="free">cap</span> 
          <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Graph.augment_edge <span class="free">cf</span> <span class="free">e</span> <span class="free">cap</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">unfolding</span></span> augment_edge_impl_def Graph.augment_edge_def 
      <span class="keyword1"><span class="command">unfolding</span></span> cf_get_def cf_set_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">augment_cf_impl</span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph <span class="main">⇒</span> path <span class="main">⇒</span> <span class="tfree">'capacity</span> <span class="main">⇒</span> <span class="tfree">'capacity</span> graph nres"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">augment_cf_impl</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="keyword1">rec<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">D</span><span class="main">.</span> <span class="main">λ</span>
          <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">return</span> <span class="bound">cf</span>
        <span class="main">|</span> <span class="main">(</span><span class="bound">e</span><span class="main">#</span><span class="bound">p</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="bound">cf</span> <span class="main">←</span> augment_edge_impl <span class="bound">cf</span> <span class="bound">e</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span>
            <span class="bound">D</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span>
          <span class="main">}</span>  
        <span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span>
      <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Deriving the corresponding recursion equations›</span></span>  
    <span class="keyword1" id="EdmondsKarp_Impl-augment_cf_impl_simps"><span class="command">lemma</span></span> augment_cf_impl_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"augment_cf_impl <span class="free">cf</span> <span class="main">[]</span> <span class="free">x</span> <span class="main">=</span> <span class="keyword1">return</span> <span class="free">cf</span>"</span></span>
      <span class="quoted"><span class="quoted">"augment_cf_impl <span class="free">cf</span> <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
        <span class="bound">cf</span> <span class="main">←</span> augment_edge_impl <span class="free">cf</span> <span class="free">e</span> <span class="free">x</span><span class="main">;</span> 
        augment_cf_impl <span class="bound">cf</span> <span class="free">p</span> <span class="free">x</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_cf_impl_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RECT_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_mono</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> augment_cf_impl_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RECT_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_mono</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      

    <span class="keyword1" id="EdmondsKarp_Impl-augment_cf_impl_aux"><span class="command">lemma</span></span> augment_cf_impl_aux<span class="main">:</span>    
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>set <span class="free">p</span><span class="main">.</span> valid_edge <span class="bound">e</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s</span><span class="main">.</span> Graph.isSimplePath <span class="free">cf</span> <span class="bound">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"augment_cf_impl <span class="free">cf</span> <span class="free">p</span> <span class="free">x</span> <span class="main">≤</span> RETURN <span class="main">(</span>Graph.augment_cf <span class="free">cf</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">cf</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Graph.augment_cf_empty<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Graph.augment_cf_inductive<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> augment_edge_impl_refine<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Graph.isSPath_no_selfloop<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">rprems</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Graph.augment_cf_inductive<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cap<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
      
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> augment_cf_impl_refine<span class="main">:</span>     
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Graph.isSimplePath <span class="free">cf</span> <span class="free">s</span> <span class="free">p</span> <span class="free">t</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"augment_cf_impl <span class="free">cf</span> <span class="free">p</span> <span class="free">x</span> <span class="main">≤</span> RETURN <span class="main">(</span>Graph.augment_cf <span class="free">cf</span> <span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> augment_cf_impl_aux<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms cf.E_ss_VxV <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cf.isSimplePath_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cf.isPath_edgeset<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we arrive at the algorithm where augmentation is 
      implemented algorithmically: ›</span></span>  
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka3</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">cf</span> <span class="main">=</span> <span class="free">c</span><span class="main">;</span>

      <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">p</span> <span class="main">←</span> find_shortest_augmenting_spec_cf <span class="bound">cf</span><span class="main">;</span>
          <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
            None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>True<span class="main">)</span>
          <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="bound">cf</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">bn</span> <span class="main">←</span> resCap_cf_impl <span class="bound">cf</span> <span class="bound">p</span><span class="main">;</span>
              <span class="bound">cf</span> <span class="main">←</span> augment_cf_impl <span class="bound">cf</span> <span class="bound">p</span> <span class="bound">bn</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span> False<span class="main">)</span>
            <span class="main">}</span>  
        <span class="main">}</span><span class="main">)</span>
        <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> flow_of_cf <span class="bound">cf</span><span class="main">;</span>  
      <span class="keyword1">return</span> <span class="bound">f</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-edka3_refine"><span class="command">lemma</span></span> edka3_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"edka3 <span class="main">≤</span> <span class="main">⇓</span>Id edka2"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka3_def edka2_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">let</span></span> <span class="bound"><span class="bound">cf</span></span> <span class="main"><span class="main">=</span></span> Graph.augment_cf <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="keyword1"><span class="keyword1">in</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Graph.shortestPath_is_simple<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> RGraph.resCap_cf_impl_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> RGraph.augment_cf_impl_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
    
    <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to use BFS›</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refine the Edmonds-Karp algorithm to use breadth first search (BFS)›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka4</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">cf</span> <span class="main">=</span> <span class="free">c</span><span class="main">;</span>

      <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">p</span> <span class="main">←</span> Graph.bfs <span class="bound">cf</span> <span class="free">s</span> <span class="free">t</span><span class="main">;</span>
          <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
            None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>True<span class="main">)</span>
          <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="bound">cf</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">bn</span> <span class="main">←</span> resCap_cf_impl <span class="bound">cf</span> <span class="bound">p</span><span class="main">;</span>
              <span class="bound">cf</span> <span class="main">←</span> augment_cf_impl <span class="bound">cf</span> <span class="bound">p</span> <span class="bound">bn</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span> False<span class="main">)</span>
            <span class="main">}</span>  
        <span class="main">}</span><span class="main">)</span>
        <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">f</span> <span class="main">=</span> flow_of_cf <span class="bound">cf</span><span class="main">;</span>  
      <span class="keyword1">return</span> <span class="bound">f</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A shortest path can be obtained by BFS›</span></span>  
    <span class="keyword1" id="EdmondsKarp_Impl-bfs_refines_shortest_augmenting_spec"><span class="command">lemma</span></span> bfs_refines_shortest_augmenting_spec<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Graph.bfs <span class="free">cf</span> <span class="free">s</span> <span class="free">t</span> <span class="main">≤</span> find_shortest_augmenting_spec_cf <span class="free">cf</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> find_shortest_augmenting_spec_cf_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> le_ASSERTI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Graph.bfs_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RPreGraph.resV_netV<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RGraph.this_loc_rpg<span class="main"><span class="main">]</span></span> s_node<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RPreGraph.resV_netV<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RGraph.this_loc_rpg<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-edka4_refine"><span class="command">lemma</span></span> edka4_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"edka4 <span class="main">≤</span> <span class="main">⇓</span>Id edka3"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka4_def edka3_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bfs_refines_shortest_augmenting_spec<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing the Successor Function for BFS›</span></span>  

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We implement the successor function in two steps.
      The first step shows how to obtain the successor function by
      filtering the list of adjacent nodes. This step contains the idea   
      of the implementation. The second step is purely technical, and makes 
      explicit the recursion of the filter function as a recursion combinator
      in the monad. This is required for the Sepref tool.
      ›</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note: We use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">filter_rev</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> here, as it is tail-recursive, 
      and we are not interested in the order of successors.›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rg_succ</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span>  
      filter_rev <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>"</span></span>
  
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> rg_succ_ref1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_adj_map <span class="free">am</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="main">(</span>rg_succ <span class="free">am</span> <span class="free">cf</span> <span class="free">u</span><span class="main">,</span> Graph.E <span class="free">cf</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Graph.E_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def br_def rg_succ_def filter_rev_alt<span class="main"><span class="keyword3">;</span></span> 
        <span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> cfE_ss_invE resE_nonNegative 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_adj_map_def less_le Graph.E_def 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> cf.zero_cap_simp zero_cap_simp<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_adj_map_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ps_get_op</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ps_get_op</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">assert</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span>V<span class="main">)</span> <span class="main">⪢</span> <span class="keyword1">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">monadic_filter_rev_aux</span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool nres<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">monadic_filter_rev_aux</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">rec<span class="hidden">⇩</span><sub>T</sub></span> <span class="bound">D</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">l</span> <span class="keyword1">of</span>
        <span class="main">[]</span> <span class="main">⇒</span> <span class="keyword1">return</span> <span class="bound">a</span> 
      <span class="main">|</span> <span class="main">(</span><span class="bound">v</span><span class="main">#</span><span class="bound">l</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">c</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="bound">v</span><span class="main">#</span><span class="bound">a</span> <span class="keyword1">else</span> <span class="bound">a</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">D</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-monadic_filter_rev_aux_rule"><span class="command">lemma</span></span> monadic_filter_rev_aux_rule<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span><span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monadic_filter_rev_aux <span class="free">a</span> <span class="free">P</span> <span class="free">l</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>filter_rev_aux <span class="free">a</span> <span class="free">Q</span> <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> monadic_filter_rev_aux_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RECT_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_mono</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> monadic_filter_rev_aux_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> monadic_filter_rev_aux_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RECT_unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_mono</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> monadic_filter_rev_aux_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">monadic_filter_rev</span> <span class="main">=</span> monadic_filter_rev_aux <span class="main">[]</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-monadic_filter_rev_rule"><span class="command">lemma</span></span> monadic_filter_rev_rule<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span><span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monadic_filter_rev <span class="free">P</span> <span class="free">l</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>filter_rev <span class="free">Q</span> <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> monadic_filter_rev_aux_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">]</span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> monadic_filter_rev_def filter_rev_def<span class="main">)</span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rg_succ2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span> <span class="main">←</span> ps_get_op <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">;</span>
      monadic_filter_rev <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">x</span><span class="main">&gt;</span><span class="main">0</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">l</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> rg_succ_ref2<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> PS<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rg_succ2 <span class="free">am</span> <span class="free">cf</span> <span class="free">u</span> <span class="main">≤</span> <span class="keyword1">return</span> <span class="main">(</span>rg_succ <span class="free">am</span> <span class="free">cf</span> <span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free">am</span> <span class="free">u</span><span class="main">)</span><span class="main">.</span> valid_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> PS V
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_adj_map_def Graph.V_def<span class="main">)</span>
      
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
        <span class="keyword1"><span class="command">unfolding</span></span> rg_succ2_def rg_succ_def ps_get_op_def cf_get_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> monadic_filter_rev_rule<span class="main"><span class="main">[</span></span>
            <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free">cf</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>    

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> rg_succ_ref<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>V"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rg_succ2 <span class="free">am</span> <span class="free">cf</span> <span class="free">u</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>cf.E<span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> rg_succ_ref1<span class="main">[</span><span class="operator">OF</span> A<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> rg_succ_ref2<span class="main">[</span><span class="operator">OF</span> A B<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>


    <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Adding Tabulation of Input›</span></span>  
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
      Next, we add functions that will be refined to tabulate the input of 
      the algorithm, i.e., the network's capacity matrix and adjacency map,
      into efficient representations. 
      The capacity matrix is tabulated to give the initial residual graph,
      and the adjacency map is tabulated for faster access.

      Note, on the abstract level, the tabulation functions are just identity,
      and merely serve as marker constants for implementation.
      ›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph nres"</span></span> 
      <span class="comment1">― ‹Initialization of residual graph from network›</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_cf</span> <span class="main">≡</span> RETURN <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_ps</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
      <span class="comment1">― ‹Initialization of adjacency map›</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_ps</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> ASSERT <span class="main">(</span>is_adj_map <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">)</span> <span class="main">⪢</span> RETURN <span class="free"><span class="bound"><span class="entity">am</span></span></span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">compute_rflow</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'capacity</span> graph <span class="main">⇒</span> <span class="tfree">'capacity</span> flow nres"</span></span> 
      <span class="comment1">― ‹Extraction of result flow from residual graph›</span>
      <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">compute_rflow</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> ASSERT <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span> <span class="main">⪢</span> RETURN <span class="main">(</span>flow_of_cf <span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bfs2_op</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> Graph.bfs2 <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span>rg_succ2 <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span>"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We split the algorithm into a tabulation function, and the 
      running of the actual algorithm:›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka5_tabulate</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">cf</span> <span class="main">←</span> init_cf<span class="main">;</span>
      <span class="bound">am</span> <span class="main">←</span> init_ps <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">am</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka5_run</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">while<span class="hidden">⇩</span><sub>T</sub></span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">p</span> <span class="main">←</span> bfs2_op <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">cf</span><span class="main">;</span>
          <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
            None <span class="main">⇒</span> <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span>True<span class="main">)</span>
          <span class="main">|</span> Some <span class="bound">p</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
              <span class="keyword1">assert</span> <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>Graph.isShortestPath <span class="bound">cf</span> <span class="free">s</span> <span class="bound">p</span> <span class="free">t</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">bn</span> <span class="main">←</span> resCap_cf_impl <span class="bound">cf</span> <span class="bound">p</span><span class="main">;</span>
              <span class="bound">cf</span> <span class="main">←</span> augment_cf_impl <span class="bound">cf</span> <span class="bound">p</span> <span class="bound">bn</span><span class="main">;</span>
              <span class="keyword1">assert</span> <span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">return</span> <span class="main">(</span><span class="bound">cf</span><span class="main">,</span> False<span class="main">)</span>
            <span class="main">}</span>  
        <span class="main">}</span><span class="main">)</span>
        <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cf</span></span></span><span class="main">,</span>False<span class="main">)</span><span class="main">;</span>
      <span class="bound">f</span> <span class="main">←</span> compute_rflow <span class="bound">cf</span><span class="main">;</span>  
      <span class="keyword1">return</span> <span class="bound">f</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edka5</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">cf</span><span class="main">,</span><span class="bound">am</span><span class="main">)</span> <span class="main">←</span> edka5_tabulate <span class="free"><span class="bound"><span class="entity">am</span></span></span><span class="main">;</span>
      edka5_run <span class="bound">cf</span> <span class="bound">am</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-edka5_refine"><span class="command">lemma</span></span> edka5_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_adj_map <span class="free">am</span><span class="main">⟧</span> <span class="main">⟹</span> edka5 <span class="free">am</span> <span class="main">≤</span> <span class="main">⇓</span>Id edka4"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka5_def edka5_tabulate_def edka5_run_def
        edka4_def init_cf_def compute_rflow_def
        init_ps_def Let_def nres_monad_laws bfs2_op_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Graph.bfs2_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RPreGraph.resV_netV<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RGraph.this_loc_rpg<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RGraph.rg_succ_ref<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword2"><span class="keyword">end</span></span>    

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Imperative Implementation›</span></span>  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section we provide an efficient imperative implementation,
    using the Sepref tool. It is mostly technical, setting up the mappings
    from abstract to concrete data structures, and then refining the algorithm,
    function by function.  
    ›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    This is also the point where we have to choose the implementation of 
    capacities. Up to here, they have been a polymorphic type with a
    typeclass constraint of being a linearly ordered integral domain.
    Here, we switch to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> [source] <span class="quoted"><span class="quoted">capacity_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">capacity_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).
    ›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> Network_Impl <span class="main">=</span> Network <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="free">t</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Moreover, we assume that the nodes are natural numbers less 
    than some number <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which will become an additional parameter 
    of our algorithm. ›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> Edka_Impl <span class="main">=</span> Network_Impl <span class="main">+</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">N</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> V_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"V<span class="main">⊆</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>  
    <span class="keyword1" id="EdmondsKarp_Impl-this_loc"><span class="command">lemma</span></span> this_loc<span class="main">:</span> <span class="quoted"><span class="quoted">"Edka_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

    <span class="keyword1" id="EdmondsKarp_Impl-E_ss"><span class="command">lemma</span></span> E_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span><span class="main">×</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> E_ss_VxV V_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1" id="EdmondsKarp_Impl-mtx_nonzero_iff"><span class="command">lemma</span></span> mtx_nonzero_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mtx_nonzero <span class="free">c</span> <span class="main">=</span> E"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mtx_nonzero_def<span class="main">)</span>

    <span class="keyword1" id="EdmondsKarp_Impl-mtx_nonzeroN"><span class="command">lemma</span></span> mtx_nonzeroN<span class="main">:</span> <span class="quoted"><span class="quoted">"mtx_nonzero <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span><span class="main">×</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> E_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>V <span class="main">⟹</span> <span class="free">v</span><span class="main">&lt;</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> V_ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Declare some variables to Sepref. ›</span></span>
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">N</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>nat<span class="main">)</span>"</span></span><span class="main">]</span>  
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node<span class="main">)</span>"</span></span><span class="main">]</span>  
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node<span class="main">)</span>"</span></span><span class="main">]</span>  
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl graph<span class="main">)</span>"</span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instruct Sepref to not refine these parameters. This is expressed
      by using identity as refinement relation.›</span></span>
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> 
      IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">N</span></span><span class="main">]</span>
      IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span><span class="main">]</span>
      IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
      <span class="comment1">(*IdI[of c]*)</span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="main">(</span><span class="keyword1">return</span> <span class="free">c</span><span class="main">)</span><span class="main">,</span>uncurry0 <span class="main">(</span><span class="keyword1">return</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> pure <span class="main">(</span>nat_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>nat_rel <span class="main">→</span> int_rel<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">sep_auto</span>


    <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Adjacency Map by Array›</span></span>  
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_am</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">psi</span></span></span> 
      <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">psi</span></span></span> <span class="keyword1">↦<span class="hidden">⇩</span><sub>a</sub></span> <span class="bound">l</span> 
          <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>length <span class="bound">l</span> <span class="main">=</span> <span class="free">N</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free">N</span><span class="main">.</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">i</span><span class="main">)</span> 
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">≥</span><span class="free">N</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="bound">i</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
  
    <span class="keyword1" id="EdmondsKarp_Impl-is_am_precise"><span class="command">lemma</span></span> is_am_precise<span class="main">[</span><span class="operator">safe_constraint_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="main">(</span>is_am<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_am_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> l l'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">prec_extract_eqs</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">i</span><span class="main">&lt;</span>length <span class="improper">l'</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">sepref_decl_intf</span></span> i_ps <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list"</span></span> 

    <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">ps_get_imp</span> <span class="free"><span class="bound"><span class="entity">psi</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> Array.nth <span class="free"><span class="bound"><span class="entity">psi</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.ps_get_op<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT ps_get_op"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST ps_get_op"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"i_ps <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span>

    <span class="keyword1" id="EdmondsKarp_Impl-ps_get_op_refine"><span class="command">lemma</span></span> ps_get_op_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry ps_get_imp<span class="main">,</span> uncurry <span class="main">(</span>PR_CONST ps_get_op<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> is_am<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> list_assn <span class="main">(</span>pure Id<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> list_assn_pure_conv
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
      <span class="keyword1"><span class="command">using</span></span> V_ss
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_am_def pure_def ps_get_imp_def 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ps_get_op_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

    <span class="keyword1" id="EdmondsKarp_Impl-is_pred_succ_no_node"><span class="command">lemma</span></span> is_pred_succ_no_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>is_adj_map <span class="free">a</span><span class="main">;</span> <span class="free">u</span><span class="main">∉</span>V<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">a</span> <span class="free">u</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def V_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Array.make <span class="free">N</span><span class="main">,</span> PR_CONST init_ps<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> is_am"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
      <span class="keyword1"><span class="command">using</span></span> V_ss
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> init_ps_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> is_am_def pure_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_pred_succ_no_node<span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.init_ps<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT init_ps"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST init_ps"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> i_ps nres"</span></span>

    <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Capacity Matrix by Array›</span></span>  
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.cf_get<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT cf_get"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.cf_set<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT cf_set"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">sepref_register</span></span> 
      <span class="quoted"><span class="quoted">"PR_CONST cf_get"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> edge <span class="main">⇒</span> capacity_impl nres"</span></span>
    <span class="keyword1"><span class="command">sepref_register</span></span> 
      <span class="quoted"><span class="quoted">"PR_CONST cf_set"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> edge <span class="main">⇒</span> capacity_impl 
        <span class="main">⇒</span> capacity_impl i_mtx nres"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We have to link the matrix implementation, which encodes the bound, 
      to the abstract assertion of the bound›</span></span>

    <span class="keyword1"><span class="command">sepref_definition</span></span> <span class="entity">cf_get_impl</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry <span class="main">(</span>PR_CONST cf_get<span class="main">)</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>prod_assn id_assn id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> id_assn"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> PR_CONST_def cf_get_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> cf_get_impl.refine
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> cf_get_impl_def

    <span class="keyword1"><span class="command">sepref_definition</span></span> <span class="entity">cf_set_impl</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST cf_set<span class="main">)</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>prod_assn id_assn id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> id_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> asmtx_assn <span class="free">N</span> id_assn"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> PR_CONST_def cf_set_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> cf_set_impl.refine
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> cf_set_impl_def


    <span class="keyword1"><span class="command">sepref_thm</span></span> init_cf_impl <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry0 <span class="main">(</span>PR_CONST init_cf<span class="main">)</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> asmtx_assn <span class="free">N</span> id_assn"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> PR_CONST_def init_cf_def 
      <span class="keyword1"><span class="command">using</span></span> E_ss
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> op_mtx_new_def<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">c</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> amtx_fold_custom_new<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">N</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>

    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">init_cf_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.init_cf_impl.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry0 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span> 
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> init_cf_impl_def
    <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> init_cf_impl.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">]</span>  

    <span class="comment1">(* TODO: Use sepref to synthesize the get-operations! *)</span>
    <span class="keyword1" id="EdmondsKarp_Impl-amtx_cnv"><span class="command">lemma</span></span> amtx_cnv<span class="main">:</span> <span class="quoted"><span class="quoted">"amtx_assn <span class="free">N</span> <span class="free">M</span> id_assn <span class="main">=</span> IICF_Array_Matrix.is_amtx <span class="free">N</span> <span class="free">M</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> amtx_assn_def<span class="main">)</span>

    <span class="comment1">(*

    lemma init_cf_imp_refine[sepref_fr_rules]: 
      "(uncurry0 (mtx_new N c), uncurry0 (PR_CONST init_cf)) 
        ∈ (pure unit_rel)<span class="hidden">⇧</span><sup>k</sup> →<span class="hidden">⇩</span><sub>a</sub> (asmtx_assn N id_assn)"
      unfolding asmtx_cnv
      apply sepref_to_hoare
      using E_ss
      by (sep_auto simp: init_cf_def)
    *)</span>  

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.init_cf<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT init_cf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST init_cf"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx nres"</span></span>

    <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Representing Result Flow as Residual Graph›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network_Impl<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">is_rflow</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">cfi</span></span></span> 
      <span class="main">≡</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">cf</span><span class="main">.</span> asmtx_assn <span class="free"><span class="bound"><span class="entity">N</span></span></span> id_assn <span class="bound">cf</span> <span class="free"><span class="bound"><span class="entity">cfi</span></span></span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">cf</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> flow_of_cf <span class="bound">cf</span><span class="main">)</span>"</span></span>
    <span class="keyword1" id="EdmondsKarp_Impl-is_rflow_precise"><span class="command">lemma</span></span> is_rflow_precise<span class="main">[</span><span class="operator">safe_constraint_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"precise <span class="main">(</span>is_rflow <span class="free">N</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_rflow_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> amtx_assn_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">prec_extract_eqs</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">sepref_decl_intf</span></span> i_rflow <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"nat<span class="main">×</span>nat <span class="main">⇒</span> int"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">cfi</span><span class="main">.</span> <span class="keyword1">return</span> <span class="bound">cfi</span><span class="main">,</span> PR_CONST compute_rflow<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> is_rflow <span class="free">N</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> amtx_cnv
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> amtx_cnv compute_rflow_def is_rflow_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> hn_ctxt_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Network.compute_rflow<span class="main">$</span><span class="free">c</span><span class="main">$</span><span class="free">s</span><span class="main">$</span><span class="free">t</span> <span class="main">≡</span> UNPROTECT compute_rflow"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> 
      <span class="quoted"><span class="quoted">"PR_CONST compute_rflow"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> i_rflow nres"</span></span>


    <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Functions›</span></span>  

    <span class="keyword1"><span class="command">schematic_goal</span></span> rg_succ2_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">am</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>i_ps<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">cf</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">N</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> HOL_list_empty_hnr
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine <span class="main">(</span>hn_ctxt is_am <span class="free">am</span> <span class="free">psi</span> <span class="main">*</span> hn_ctxt <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span> <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> hn_val nat_rel <span class="free">u</span> <span class="free">ui</span><span class="main">)</span> <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span> <span class="main">(</span>rg_succ2 <span class="free">am</span> <span class="free">cf</span> <span class="free">u</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rg_succ2_def APP_def monadic_filter_rev_def monadic_filter_rev_aux_def
      <span class="comment1">(* TODO: Make setting up combinators for sepref simpler, then we do not need to unfold! *)</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">succ_imp</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.rg_succ2_impl
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> succ_imp_def

    <span class="keyword1" id="EdmondsKarp_Impl-succ_imp_refine"><span class="command">lemma</span></span> succ_imp_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="main">(</span>succ_imp <span class="free">N</span><span class="main">)</span><span class="main">,</span> uncurry2 <span class="main">(</span>PR_CONST rg_succ2<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> is_am<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> list_assn <span class="main">(</span>pure Id<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command">using</span></span> succ_imp.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">]</span>            
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hn_ctxt_def mult_ac <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.rg_succ2<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT rg_succ2"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> 
      <span class="quoted"><span class="quoted">"PR_CONST rg_succ2"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"i_ps <span class="main">⇒</span> capacity_impl i_mtx <span class="main">⇒</span> node <span class="main">⇒</span> node list nres"</span></span>

    
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>min<span class="main">,</span>min<span class="main">)</span><span class="main">∈</span>Id<span class="main">→</span>Id<span class="main">→</span>Id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_path</span> <span class="main">≡</span> list_assn <span class="main">(</span>prod_assn <span class="main">(</span>pure Id<span class="main">)</span> <span class="main">(</span>pure Id<span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">schematic_goal</span></span> resCap_imp_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">p</span> <span class="free">pi</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>edge list<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">cf</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">N</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine 
        <span class="main">(</span>hn_ctxt <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span> <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> hn_ctxt is_path <span class="free">p</span> <span class="free">pi</span><span class="main">)</span> 
        <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span> 
        <span class="main">(</span>resCap_cf_impl <span class="free">cf</span> <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> resCap_cf_impl_def APP_def
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">resCap_imp</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.resCap_imp_impl
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> resCap_imp_def

    <span class="keyword1" id="EdmondsKarp_Impl-resCap_impl_refine"><span class="command">lemma</span></span> resCap_impl_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="main">(</span>resCap_imp <span class="free">N</span><span class="main">)</span><span class="main">,</span> uncurry <span class="main">(</span>PR_CONST resCap_cf_impl<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>is_path<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure Id<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hnr</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_preI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uncurry_def list_assn_pure_conv hn_ctxt_def 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pure_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ resCap_imp.refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> this_loc<span class="main"><span class="main">]</span></span> _<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_assn_pure_conv hn_ctxt_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hn_ctxt_def pure_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> enttI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Network.resCap_cf_impl<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT resCap_cf_impl"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST resCap_cf_impl"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> path <span class="main">⇒</span> capacity_impl nres"</span></span>
    
    <span class="keyword1"><span class="command">sepref_thm</span></span> augment_imp <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 <span class="main">(</span>PR_CONST augment_cf_impl<span class="main">)</span>"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>is_path<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> augment_cf_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> augment_edge_impl_def PR_CONST_def
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span> 
    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">augment_imp</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.augment_imp.refine_raw <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="var">?f</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">∈</span><span class="main">_</span>"</span></span>
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> augment_imp_def
    <span class="keyword1" id="EdmondsKarp_Impl-augment_impl_refine"><span class="command">lemma</span></span> augment_impl_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 <span class="main">(</span>augment_imp <span class="free">N</span><span class="main">)</span><span class="main">,</span> uncurry2 <span class="main">(</span>PR_CONST augment_cf_impl<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>is_path<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> asmtx_assn <span class="free">N</span> id_assn"</span></span>
      <span class="keyword1"><span class="command">using</span></span> augment_imp.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Network.augment_cf_impl<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT augment_cf_impl"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST augment_cf_impl"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> path <span class="main">⇒</span> capacity_impl <span class="main">⇒</span> capacity_impl i_mtx nres"</span></span>

    <span class="keyword1"><span class="command">sublocale</span></span> bfs<span class="main">:</span> Impl_Succ 
      <span class="quoted"><span class="quoted">"snd"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>i_ps <span class="main">×</span> capacity_impl i_mtx<span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"PR_CONST <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">am</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> rg_succ2 <span class="bound">am</span> <span class="bound">cf</span><span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"prod_assn is_am <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">am</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span><span class="main">.</span> succ_imp <span class="free">N</span> <span class="bound">am</span> <span class="bound">cf</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> APP_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_partial_uncurry<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hfref_cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> succ_imp_refine<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> PR_CONST_def<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">bfsi'</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">psi</span></span></span> <span class="free"><span class="bound"><span class="entity">cfi</span></span></span> 
      <span class="main">≡</span> bfs_impl <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">am</span><span class="main">,</span> <span class="bound">cf</span><span class="main">)</span><span class="main">.</span> succ_imp <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="bound">am</span> <span class="bound">cf</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">psi</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cfi</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="main">(</span>bfsi' <span class="free">N</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">,</span>uncurry <span class="main">(</span>PR_CONST bfs2_op<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> is_am<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> option_assn is_path"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bfsi'_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> bfs2_op_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
      <span class="keyword1"><span class="command">using</span></span> bfs.bfs_impl_fr_rule <span class="keyword1"><span class="command">unfolding</span></span> bfs.op_bfs_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hfref_def all_to_meta<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_cons<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rprems</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pure_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> enttI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pure_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pure_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Network.bfs2_op<span class="main">$</span><span class="free">c</span><span class="main">$</span><span class="free">s</span><span class="main">$</span><span class="free">t</span> <span class="main">≡</span> UNPROTECT bfs2_op"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST bfs2_op"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"i_ps <span class="main">⇒</span> capacity_impl i_mtx <span class="main">⇒</span> path option nres"</span></span>  


    <span class="keyword1"><span class="command">schematic_goal</span></span> edka_imp_tabulate_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> heap_WHILET_def
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">am</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">am</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine <span class="main">(</span><span class="keyword1">emp</span><span class="main">)</span> <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span> <span class="main">(</span>edka5_tabulate <span class="free">am</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka5_tabulate_def
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>

    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">edka_imp_tabulate</span> 
      <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.edka_imp_tabulate_impl
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> edka_imp_tabulate_def

    <span class="keyword1" id="EdmondsKarp_Impl-edka_imp_tabulate_refine"><span class="command">lemma</span></span> edka_imp_tabulate_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>edka_imp_tabulate <span class="free">c</span> <span class="free">N</span><span class="main">,</span> PR_CONST edka5_tabulate<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">(</span>pure Id<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> prod_assn <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span> is_am"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_preI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uncurry_def list_assn_pure_conv hn_ctxt_def 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ edka_imp_tabulate.refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> this_loc<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hn_ctxt_def pure_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Network.edka5_tabulate<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT edka5_tabulate"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST edka5_tabulate"</span></span>
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>capacity_impl i_mtx <span class="main">×</span> i_ps<span class="main">)</span> nres"</span></span>


    <span class="keyword1"><span class="command">schematic_goal</span></span> edka_imp_run_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> heap_WHILET_def
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">cf</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span><span class="main">]</span>
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">am</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>i_ps<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine 
        <span class="main">(</span>hn_ctxt <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span> <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> hn_ctxt is_am <span class="free">am</span> <span class="free">psi</span><span class="main">)</span> 
        <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span>  
        <span class="main">(</span>edka5_run <span class="free">cf</span> <span class="free">am</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka5_run_def
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>

    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">edka_imp_run</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.edka_imp_run_impl
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> edka_imp_run_def

    <span class="keyword1"><span class="command">thm</span></span> edka_imp_run_def
    <span class="keyword1" id="EdmondsKarp_Impl-edka_imp_run_refine"><span class="command">lemma</span></span> edka_imp_run_refine<span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry <span class="main">(</span>edka_imp_run <span class="free">s</span> <span class="free">t</span> <span class="free">N</span><span class="main">)</span><span class="main">,</span> uncurry <span class="main">(</span>PR_CONST edka5_run<span class="main">)</span><span class="main">)</span> 
        <span class="main">∈</span> <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>is_am<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> is_rflow <span class="free">N</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uncurry_def list_assn_pure_conv hn_ctxt_def 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hn_refine_cons<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ edka_imp_run.refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> this_loc<span class="main"><span class="main">]</span></span> _<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hn_ctxt_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"Network.edka5_run<span class="main">$</span><span class="free">c</span><span class="main">$</span><span class="free">s</span><span class="main">$</span><span class="free">t</span> <span class="main">≡</span> UNPROTECT edka5_run"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">sepref_register</span></span> <span class="quoted"><span class="quoted">"PR_CONST edka5_run"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl i_mtx <span class="main">⇒</span> i_ps <span class="main">⇒</span> i_rflow nres"</span></span>


    <span class="keyword1"><span class="command">schematic_goal</span></span> edka_imp_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_opt_simps</span><span class="main">]</span> <span class="main">=</span> heap_WHILET_def
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
        itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">am</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span>"</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">am</span></span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine <span class="main">(</span><span class="keyword1">emp</span><span class="main">)</span> <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span> <span class="main">(</span>edka5 <span class="free">am</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edka5_def
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>

    <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">edka_imp</span> <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.edka_imp_impl
    <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> edka_imp_def
    <span class="keyword1"><span class="command">lemmas</span></span> edka_imp_refine <span class="main">=</span> edka_imp.refine<span class="main">[</span><span class="operator">OF</span> this_loc<span class="main">]</span>

    <span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">pat_rules</span></span> TrueI <span class="dynamic"><span class="dynamic">def_pat_rules</span></span>
    

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">edka_imp</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML_imp

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Theorem for Implementation›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We combine all refinement steps to derive a correctness 
    theorem for the implementation›</span></span>
  <span class="keyword1"><span class="command">context</span></span> Network_Impl <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">theorem</span></span> edka_imp_correct<span class="main">:</span> 
      <span class="keyword2"><span class="keyword">assumes</span></span> VN<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> ABS_PS<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
        <span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
          edka_imp <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">am</span> 
        <span class="main">&lt;</span><span class="main">λ</span><span class="bound">fi</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">f</span><span class="main">.</span> is_rflow <span class="free">N</span> <span class="bound">f</span> <span class="bound">fi</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>isMaxFlow <span class="bound">f</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">interpret</span></span> Edka_Impl <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>

      <span class="keyword1"><span class="command">note</span></span> edka5_refine<span class="main">[</span><span class="operator">OF</span> ABS_PS<span class="main">]</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka4_refine                 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka3_refine    
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka2_refine 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka_refine
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> edka_partial_refine
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> fofu_partial_correct
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edka5 <span class="free">am</span> <span class="main">≤</span> SPEC isMaxFlow"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">from</span></span> hn_refine_ref<span class="main">[</span><span class="operator">OF</span> this edka_imp_refine<span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hn_refine_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>    
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Edka_Checked_Impl">
<div class="head">
<h1>Theory Edka_Checked_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Combination with Network Checker›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Edka_Checked_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../Flow_Networks/NetCheck.html">Flow_Networks.NetCheck</a> <a href="EdmondsKarp_Impl.html">EdmondsKarp_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we combine the Edmonds-Karp implementation with the 
  network checker.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Adding Statistic Counters›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first add some statistic counters, that we use for profiling›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stat_outer_c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stat_outer_c</span> <span class="main">=</span> <span class="keyword1">return</span> <span class="main">()</span>"</span></span>
<span class="keyword1" id="Edka_Checked_Impl-insert_stat_outer_c"><span class="command">lemma</span></span> insert_stat_outer_c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> stat_outer_c <span class="main">⪢</span> <span class="free">m</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> stat_outer_c_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stat_inner_c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit Heap"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">stat_inner_c</span> <span class="main">=</span> <span class="keyword1">return</span> <span class="main">()</span>"</span></span>
<span class="keyword1" id="Edka_Checked_Impl-insert_stat_inner_c"><span class="command">lemma</span></span> insert_stat_inner_c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> stat_inner_c <span class="main">⪢</span> <span class="free">m</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> stat_inner_c_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> stat <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‹
    structure stat = struct
      val outer_c = ref 0;
      fun outer_c_incr () = (outer_c := !outer_c + 1; ())
      val inner_c = ref 0;
      fun inner_c_incr () = (inner_c := !inner_c + 1; ())
    end
    ›</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stat_outer_c</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"stat.outer'_c'_incr"</span>  
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stat_inner_c</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"stat.inner'_c'_incr"</span>  


<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edka_imp_run_0 <span class="free">s</span> <span class="free">t</span> <span class="free">N</span> <span class="free">f</span> <span class="free">brk</span> <span class="main">=</span> <span class="var">?foo</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> edka_imp_run.code<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">⌑</span></span>"</span></span></span> insert_stat_outer_c<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
  
<span class="keyword1"><span class="command">thm</span></span> bfs_impl.code
<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bfs_impl_0 <span class="free">succ_impl</span> <span class="free">ci</span> <span class="free">ti</span> <span class="free">x</span> <span class="main">=</span> <span class="var">?foo</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> bfs_impl.code<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"imp_nfoldli <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> insert_stat_inner_c<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combined Algorithm›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edmonds_karp</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">case</span> prepareNet <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">f</span> <span class="main">←</span> edka_imp <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">N</span> <span class="bound">am</span> <span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">edmonds_karp</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1" id="Edka_Checked_Impl-network_is_impl"><span class="command">lemma</span></span> network_is_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">⟹</span> Network_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_locales</span>

<span class="keyword1"><span class="command">theorem</span></span> edmonds_karp_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> edmonds_karp <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span><span class="main">λ</span>
      None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">fi</span><span class="main">)</span> <span class="main">⇒</span> 
      <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">f</span><span class="main">.</span> Network_Impl.is_rflow <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">N</span> <span class="bound">f</span> <span class="bound">fi</span> 
      <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>ln_α <span class="free">el</span> <span class="main">=</span> <span class="bound">c</span> <span class="main">∧</span> Graph.is_adj_map <span class="bound">c</span> <span class="bound">am</span>
        <span class="main">∧</span> Network.isMaxFlow <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span>
        <span class="main">∧</span> ln_invar <span class="free">el</span> <span class="main">∧</span> Network <span class="bound">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">∧</span> Graph.V <span class="bound">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="bound">N</span><span class="main">}</span><span class="main">)</span>
  <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edmonds_karp_def
  <span class="keyword1"><span class="command">using</span></span> prepareNet_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits 
    <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> Network_Impl.edka_imp_correct 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_rel_def br_def network_is_impl<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_rflow</span> <span class="main">≡</span> Network_Impl.is_rflow"</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\DefineSnippet{edmonds_karp_correct}{›</span></span>       
<span class="keyword1"><span class="command">theorem</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">el</span> <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≡</span> ln_α <span class="free">el</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> 
      edmonds_karp <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> 
    <span class="main">&lt;</span><span class="main">λ</span> None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
     <span class="main">|</span> Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cf</span><span class="main">)</span> <span class="main">⇒</span> 
         <span class="main">↑</span><span class="main">(</span>ln_invar <span class="free">el</span> <span class="main">∧</span> Network <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="main">∧</span> Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="bound">N</span><span class="main">}</span><span class="main">)</span>
       <span class="main">*</span> <span class="main">(</span><span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">f</span><span class="main">.</span> is_rflow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">N</span> <span class="bound">f</span> <span class="bound">cf</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>Network.isMaxFlow <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹}%EndSnippet›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> c_def is_rflow_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> edmonds_karp_correct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">el</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Usage Example: Computing Maxflow Value ›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We implement a function to compute the value of the maximum flow.›</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Network<span class="main">)</span> am_s_is_incoming<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">{</span><span class="free">s</span><span class="main">}</span> <span class="main">=</span> set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms no_incoming_s
  <span class="keyword1"><span class="command">unfolding</span></span> is_adj_map_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">context</span></span> RGraph <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Edka_Checked_Impl-val_by_adj_map"><span class="command">lemma</span></span> val_by_adj_map<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"f.val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"f.val <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>E<span class="main">``</span><span class="main">{</span><span class="free">s</span><span class="main">}</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> f.val_alt
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_outgoing_pointwise f_def flow_of_cf_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free">am</span> <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">c</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">-</span> <span class="free">cf</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> am_s_is_incoming<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span> 
  <span class="keyword1"><span class="command">qed</span></span>  
      
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> Network 
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_cap</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="free">c</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">get_am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span> <span class="main">⇒</span> node <span class="main">⇒</span> node list"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_am</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_flow_val</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">succs</span> <span class="main">=</span> get_am <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
      sum_impl 
      <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">let</span> <span class="bound">csv</span> <span class="main">=</span> get_cap <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">cfsv</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">return</span> <span class="main">(</span><span class="bound">csv</span> <span class="main">-</span> <span class="bound">cfsv</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="main">(</span>set <span class="bound">succs</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> compute_flow_val_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"compute_flow_val <span class="free">am</span> <span class="free">cf</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> f.val<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> val_by_adj_map<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val_def cf_get_def get_cap_def get_am_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> sum_impl_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s_node<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> am_s_is_incoming<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">OF</span> assms<span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> V_def<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For technical reasons (poor foreach-support of Sepref tool), 
    we have to add another refinement step: ›</span></span>  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_flow_val2</span> <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">succs</span> <span class="main">=</span> get_am <span class="free"><span class="bound"><span class="entity">am</span></span></span> <span class="free">s</span><span class="main">;</span>
    nfoldli <span class="bound">succs</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">a</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
           <span class="bound">b</span> <span class="main">←</span> <span class="keyword1">do</span> <span class="main">{</span>
               <span class="keyword1">let</span> <span class="bound">csv</span> <span class="main">=</span> get_cap <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
               <span class="bound">cfsv</span> <span class="main">←</span> cf_get <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
               <span class="keyword1">return</span> <span class="main">(</span><span class="bound">csv</span> <span class="main">-</span> <span class="bound">cfsv</span><span class="main">)</span>
             <span class="main">}</span><span class="main">;</span>
           <span class="keyword1">return</span> <span class="main">(</span><span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span>
         <span class="main">}</span><span class="main">)</span>
     <span class="main">0</span>
  <span class="main">}</span><span class="main">)</span>"</span></span>  

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> RGraph<span class="main">)</span> compute_flow_val2_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"compute_flow_val2 <span class="free">am</span> <span class="free">cf</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">spec</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">=</span> f.val<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES <span class="main">(</span><span class="main">⟨</span>Id<span class="main">⟩</span>list_set_rel<span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ compute_flow_val_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val2_def compute_flow_val_def sum_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refine_IdD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> LFO_refine bind_refine'<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vc_solve</span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_set_rel_def br_def get_am_def is_adj_map_def 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>    
    


<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Edka_Impl <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">is_am</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">c</span><span class="main">,</span>PR_CONST get_cap<span class="main">)</span> <span class="main">∈</span> Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id <span class="main">→</span> Id"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> get_cap_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">def_pat_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"Network.get_cap<span class="main">$</span><span class="free">c</span> <span class="main">≡</span> UNPROTECT get_cap"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">sepref_register</span></span> 
    <span class="quoted"><span class="quoted">"PR_CONST get_cap"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node<span class="main">×</span>node <span class="main">⇒</span> capacity_impl"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>get_am<span class="main">,</span>get_am<span class="main">)</span> <span class="main">∈</span> Id <span class="main">→</span> Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_rel"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> get_am_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> compute_flow_val_imp<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">am</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"node <span class="main">⇒</span> node list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"capacity_impl graph"</span></span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">id_rules</span><span class="main">]</span> <span class="main">=</span> 
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">am</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>node <span class="main">⇒</span> node list<span class="main">)</span>"</span></span><span class="main">]</span>
      itypeI<span class="main">[</span><span class="operator">Pure.of</span> <span class="quoted"><span class="free">cf</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span>capacity_impl i_mtx<span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">sepref_import_param</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">N</span></span><span class="main">]</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">am</span></span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hn_refine 
      <span class="main">(</span>hn_ctxt <span class="main">(</span>asmtx_assn <span class="free">N</span> id_assn<span class="main">)</span> <span class="free">cf</span> <span class="free">cfi</span><span class="main">)</span>
      <span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'d</span> Heap<span class="main">)</span> <span class="var">?Γ</span> <span class="var">?R</span> <span class="main">(</span>compute_flow_val2 <span class="free">am</span> <span class="free">cf</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_flow_val2_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">id_debug</span><span class="main">,</span> <span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">compute_flow_val_imp</span> <span class="keyword2"><span class="keyword">for</span></span> c s N am cfi
    <span class="keyword2"><span class="keyword">uses</span></span> Edka_Impl.compute_flow_val_imp
  <span class="keyword1"><span class="command">prepare_code_thms</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> compute_flow_val_imp_def
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Network_Impl <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Edka_Checked_Impl-compute_flow_val_imp_correct_aux"><span class="command">lemma</span></span> compute_flow_val_imp_correct_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> VN<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ABS_PS<span class="main">:</span> <span class="quoted"><span class="quoted">"is_adj_map <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RG<span class="main">:</span> <span class="quoted"><span class="quoted">"RGraph <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">cf</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span>asmtx_assn <span class="free">N</span> id_assn <span class="free">cf</span> <span class="free">cfi</span><span class="main">&gt;</span> 
      compute_flow_val_imp <span class="free">c</span> <span class="free">s</span> <span class="free">N</span> <span class="free">am</span> <span class="free">cfi</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> asmtx_assn <span class="free">N</span> id_assn <span class="free">cf</span> <span class="free">cfi</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">v</span> <span class="main">=</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="main">(</span>flow_of_cf <span class="free">cf</span><span class="main">)</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> rg<span class="main">:</span> RGraph <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">cf</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">have</span></span> EI<span class="main">:</span> <span class="quoted"><span class="quoted">"Edka_Impl <span class="free">c</span> <span class="free">s</span> <span class="free">t</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">from</span></span> hn_refine_ref<span class="main">[</span><span class="operator">OF</span> 
      rg.compute_flow_val2_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ABS_PS<span class="main"><span class="main">]</span></span> 
      compute_flow_val_imp.refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> EI<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">cfi</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hn_ctxt_def pure_def hn_refine_def rg.f_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> cons_post_rule<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sep_auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Edka_Checked_Impl-compute_flow_val_imp_correct"><span class="command">lemma</span></span> compute_flow_val_imp_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> VN<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.V <span class="free">c</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">N</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ABS_PS<span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.is_adj_map <span class="free">c</span> <span class="free">am</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    <span class="main">&lt;</span>is_rflow <span class="free">N</span> <span class="free">f</span> <span class="free">cfi</span><span class="main">&gt;</span> 
      compute_flow_val_imp <span class="free">c</span> <span class="free">s</span> <span class="free">N</span> <span class="free">am</span> <span class="free">cfi</span>
    <span class="main">&lt;</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> is_rflow <span class="free">N</span> <span class="free">f</span> <span class="free">cfi</span> <span class="main">*</span> <span class="main">↑</span><span class="main">(</span><span class="bound">v</span> <span class="main">=</span> Flow.val <span class="free">c</span> <span class="free">s</span> <span class="free">f</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> hoare_triple_preI<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_rflow_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ compute_flow_val_imp_correct_aux<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cfi<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free">cfi</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> VN ABS_PS<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edmonds_karp_val</span> <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">r</span> <span class="main">←</span> edmonds_karp <span class="free"><span class="bound"><span class="entity">el</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">;</span>
  <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="keyword1">return</span> None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">am</span><span class="main">,</span><span class="bound">N</span><span class="main">,</span><span class="bound">cfi</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">v</span> <span class="main">←</span> compute_flow_val_imp <span class="bound">c</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">N</span> <span class="bound">am</span> <span class="bound">cfi</span><span class="main">;</span>
      <span class="keyword1">return</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">)</span>
    <span class="main">}</span> 
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> edmonds_karp_val_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">&lt;</span><span class="keyword1">emp</span><span class="main">&gt;</span> edmonds_karp_val <span class="free">el</span> <span class="free">s</span> <span class="free">t</span> <span class="main">&lt;</span><span class="main">λ</span>
    None <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">¬</span>ln_invar <span class="free">el</span> <span class="main">∨</span> <span class="main">¬</span>Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span><span class="main">)</span>
  <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="main">↑</span><span class="main">(</span><span class="main">∃</span><span class="bound">f</span> <span class="bound">N</span><span class="main">.</span> 
          ln_invar <span class="free">el</span> <span class="main">∧</span> Network <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span> 
        <span class="main">∧</span> Graph.V <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="bound">N</span><span class="main">}</span>
        <span class="main">∧</span> Network.isMaxFlow <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="free">t</span> <span class="bound">f</span>
        <span class="main">∧</span> <span class="bound">v</span> <span class="main">=</span> Flow.val <span class="main">(</span>ln_α <span class="free">el</span><span class="main">)</span> <span class="free">s</span> <span class="bound">f</span><span class="main">)</span>  
        <span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edmonds_karp_val_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">sep_auto</span> 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> network_is_impl
    <span class="quasi_keyword">heap</span><span class="main"><span class="main">:</span></span> edmonds_karp_correct Network_Impl.compute_flow_val_imp_correct<span class="main">)</span>      


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Edka_Benchmark_Export">
<div class="head">
<h1>Theory Edka_Benchmark_Export</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Exporting Code›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Edka_Benchmark_Export 
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Edka_Checked_Impl.html">Edka_Checked_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Moved to own theory, as code-export makes theory unusable for inclusion from
other AFP entries. ›</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">nat_of_integer</span></span> <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">int_of_integer</span></span> <span class="quoted"><span class="quoted">integer_of_int</span></span>
  <span class="quoted"><span class="quoted">edmonds_karp</span></span> <span class="quoted"><span class="quoted">edka_imp</span></span> <span class="quoted"><span class="quoted">edka_imp_tabulate</span></span> <span class="quoted"><span class="quoted">edka_imp_run</span></span> <span class="quoted"><span class="quoted">prepareNet</span></span>
  <span class="quoted"><span class="quoted">compute_flow_val_imp</span></span> <span class="quoted"><span class="quoted">edmonds_karp_val</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> SML_imp 
  <span class="keyword2"><span class="keyword">module_name</span></span> Fofu 
  <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">‹evaluation/fofu-SML/Fofu_Export.sml›</span>  


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>