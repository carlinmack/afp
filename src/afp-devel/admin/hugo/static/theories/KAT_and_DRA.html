<div id="Test_Dioid">
<div class="head"><h1>Theory Test_Dioid</h1>
<span class="command">theory</span> <span class="name">Test_Dioid</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/Dioid.html"><span class="name">Dioid</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Dioids›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Test_Dioid</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.Dioid</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Tests are embedded in a weak dioid, a dioid without the right annihilation and left distributivity axioms, using an 
  operator $t$ defined by a complementation operator. This allows us to use tests in weak settings, such as Probabilistic Kleene Algebra and Demonic Refinement Algebra.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Monoids›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>n_op</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>n_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"n _"</span></span></span><span> </span><span class="delimiter">[</span><span>90</span><span class="delimiter">]</span><span> </span><span>91</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>monoid_mult</span><span> </span><span class="delimiter">+</span><span> </span><span>n_op</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>tm1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n n 1 = 1"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n n x = n 1"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tm3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n (n n z ⋅ n n y) = n (n (n x ⋅ n y) ⋅ n (n x ⋅ n z))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*no_notation zero_class.zero ("0")*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>a_zero</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"o"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"o ≡ n 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ≡ n n x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>n_add_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊕"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ⊕ y ≡ n (n x ⋅ n y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n 1 ⋅ x = n 1"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick*)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n 1 = n 1"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick*)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n 1 ⋅ x = n 1 ⟹ n x ⋅ y ⋅ t z = n 1 ⟹ n x ⋅ y = n x ⋅ y ⋅ n z  "</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick*)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_t_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t (n x) = n x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. n x ⋅ n (t (n x) ⋅ t y) = t (n x ⋅ n y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.tm3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>local.tm2</span><span> </span><span>local.tm3</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_t_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t (n x ⋅ n y) = n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>local.tm2</span><span> </span><span>local.tm3</span><span> </span><span>n_t_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_comm_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⋅ n y) = n (n y ⋅ n x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.mult_1_left</span><span> </span><span>local.tm1</span><span> </span><span>local.tm3</span><span> </span><span>n_t_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y = n y ⋅ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_t_closed</span><span> </span><span>n_comm_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>huntington1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n (n n x ⋅ n y) ⋅ n (n n x ⋅ n n y)) = n n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>local.tm2</span><span> </span><span>local.tm3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>huntington2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⊕ n n y) ⊕ n (n x ⊕ n y) = n n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ (n y ⊕ n z) = (n x ⊕ n y) ⊕ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_mult_closure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x = x ⟹ t y = y ⟹ t (x ⋅ y) = x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_t_compl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ t x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>local.tm1</span><span> </span><span>local.tm2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_least1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"o ⊕ n x = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_zero_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_least2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"o ⋅ n x = o"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_zero_def</span><span> </span><span>local.tm2</span><span> </span><span>local.tm3</span><span> </span><span>mult_assoc</span><span> </span><span>mult_t_closed</span><span> </span><span>zero_least1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_least3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ o  = o"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_zero_def</span><span> </span><span>n_comm</span><span> </span><span>zero_least2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_greatest1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⊕ n x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>a_zero_def</span><span> </span><span>local.tm1</span><span> </span><span>n_add_op_def</span><span> </span><span>n_comm_var</span><span> </span><span>zero_least3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_greatest2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ 1 = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_add_op_def</span><span> </span><span>n_comm_var</span><span> </span><span>one_greatest1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ n x = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>huntington1</span><span> </span><span>local.mult_1_right</span><span> </span><span>n_t_closed</span><span> </span><span>n_t_compl</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n x = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_add_idem</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_preserve</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ⋅ n x = n y ⋅ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>n_comm</span><span> </span><span>n_mult_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_preserve2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ⋅ t x = o"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_zero_def</span><span> </span><span>local.tm2</span><span> </span><span>mult_assoc</span><span> </span><span>n_comm</span><span> </span><span>zero_least3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⋅ n y) = t x ⊕ t y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan4</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (t x ⊕ t y) = n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>mult_t_closed</span><span> </span><span>n_t_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_absorb1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ n x ⋅ n y = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>local.tm3</span><span> </span><span>one_greatest2</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_absorb2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n x ⊕ n y) = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_absorb1</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n y ⊕ n z) = (n x ⋅ n y) ⊕ (n x ⋅ n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.tm3</span><span> </span><span>n_comm_var</span><span>  </span><span>n_add_op_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib1_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⊕ n y) ⋅ n z  = (n x ⋅ n z) ⊕ (n y ⋅ n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>n_comm</span><span> </span><span>n_distrib1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ n y ⋅ n z = (n x ⊕ n y) ⋅ (n x ⊕ n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_distrib1</span><span> </span><span>n_mult_idem</span><span>  </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib2_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ⊕ n z = (n x ⊕ n z) ⋅ (n y ⊕ n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>de_morgan1</span><span> </span><span>mult_t_closed</span><span> </span><span>n_distrib1_opp</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ts_ord</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊑"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ⊑ y = (n x ⋅ n y = n y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟷ n x ⊕ n y = n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_t_closed</span><span> </span><span>ts_ord_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ts_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n y ⊑ n z ⟹ n x ⊑ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>ts_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_antisym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n y ⊑ n x ⟹ n x = n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_add_idem</span><span> </span><span>n_comm</span><span> </span><span>ts_ord_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_mult_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n z ⋅ n x ⊑ n z ⋅ n y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n (n z ⋅ n x) ⋅ n (n z ⋅ n y)) = n z ⋅ n y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_add_idem</span><span> </span><span>n_distrib1</span><span> </span><span>ts_ord_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>ts_ord_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_mult_isor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n x ⋅ n z ⊑ n y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_comm</span><span> </span><span>ts_ord_mult_isol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_add_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n z ⊕ n x ⊑ n z ⊕ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>mult_t_closed</span><span> </span><span>n_mult_idem</span><span> </span><span>ts_ord_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_add_isor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ n x ⊕ n z ⊑ n y ⊕ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>n_comm</span><span> </span><span>ts_ord_add_isol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_anti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟹ t y ⊑ t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_absorb2</span><span> </span><span>n_add_idem</span><span> </span><span>n_comm</span><span> </span><span>ts_ord_def</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ts_ord_anti_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⟷ t y ⊑ t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts_ord_anti</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_ts_ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"o ⊑ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_zero_def</span><span> </span><span>ts_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_subid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_zero_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ts_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_lb1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ⊑ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>n_comm</span><span> </span><span>n_subid</span><span> </span><span>ts_ord_mult_isor</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_lb2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ⊑ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_comm</span><span> </span><span>n_mult_lb1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_glbI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⊑ n x ⟹  n z ⊑ n y ⟹ n z ⊑ n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_t_closed</span><span> </span><span>ts_ord_anti_iff</span><span> </span><span>ts_ord_def</span><span> </span><span>ts_ord_mult_isol</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_glb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⊑ n x ∧ n z ⊑ n y ⟷ n z ⊑ n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_mult_glbI</span><span> </span><span>n_mult_lb1</span><span> </span><span>n_mult_lb2</span><span> </span><span>ts_ord_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_ub1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n x ⊕ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>n_absorb2</span><span> </span><span>n_mult_lb2</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_ub2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n y ⊑ n x ⊕ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_add_ub1</span><span> </span><span>n_comm_var</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_lubI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n z ⟹ n y ⊑ n z ⟹ n x ⊕ n y ⊑ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ts_ord_add_isol</span><span> </span><span>ts_ord_alt</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_lub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n z ∧ n y ⊑ n z ⟷ n x ⊕ n y ⊑ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_add_lubI</span><span> </span><span>n_add_op_def</span><span> </span><span>n_add_ub1</span><span> </span><span>n_add_ub2</span><span> </span><span>ts_ord_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_galois1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⊕ n z ⟷ n x ⋅ t y ⊑ n z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⊕ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ t y ⊑ (n y ⊕ n z ) ⋅ t y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_add_op_def</span><span> </span><span>ts_ord_mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n y ⋅ t y ⊕ n z ⋅ t y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>local.tm3</span><span> </span><span>n_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n z ⋅ t y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_zero_def</span><span> </span><span>local.tm2</span><span> </span><span>n_distrib2</span><span> </span><span>zero_least1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ t y ⊑ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_t_closed</span><span> </span><span>n_mult_glb</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ t y ⊑ n z"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x = t (n x ⋅ (n y ⊕ t y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.mult_1_right</span><span> </span><span>n_t_closed</span><span> </span><span>n_t_compl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = t (n x ⋅ n y ⊕ n x ⋅ t y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_distrib1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"...  ⊑ t (n y ⊕ n x ⋅ t y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>calculation</span><span> </span><span>local.mult_1_right</span><span> </span><span>mult_t_closed</span><span> </span><span>n_add_op_def</span><span> </span><span>n_add_ub2</span><span> </span><span>n_distrib2</span><span> </span><span>n_t_compl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ n y ⊕ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>mult_t_closed</span><span> </span><span>ts_ord_add_isol</span><span> </span><span>ts_ord_trans</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_galois2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊑ t y ⊕ n z ⟷ n x ⋅ n y ⊑ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_galois1</span><span> </span><span>n_t_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n z = n y ⋅ n z ⟹ n x ⊕ n z = n y ⊕ n z ⟹ n x = n y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n z = n y ⋅ n z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⊕ n z = n y ⊕ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x = n x ⊕ n x ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_absorb1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n x ⊕ n y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (n x ⊕ n y) ⋅ (n x ⊕ n z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_distrib2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (n y ⊕ n x) ⋅ (n y ⊕ n z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>b</span><span> </span><span>n_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n y ⋅ (n x ⊕ n z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>n_distrib1</span><span> </span><span>n_distrib2</span><span> </span><span>n_mult_idem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n y ⋅ (n y ⊕ n z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x = n y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_absorb2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_dist_var1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⊕ n y) ⋅ (t x ⊕ n z) = t x ⋅ n y ⊕ n x ⋅ n z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⊕ n y) ⋅ (t x ⊕ n z) = n x ⋅ t x ⊕ n y ⋅ t x ⊕ (n x ⋅ n z ⊕ n y ⋅ n z)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>n_distrib1</span><span> </span><span>n_distrib1_opp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = t x ⋅ n y ⊕ (n x ⋅ n z ⊕ (n x ⊕ t x) ⋅ t (n y ⋅ n z))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_op_def</span><span> </span><span>local.mult_1_left</span><span> </span><span>local.tm1</span><span> </span><span>local.tm2</span><span> </span><span>n_comm</span><span> </span><span>n_t_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = t x ⋅ n y ⊕ (n x ⋅ n z ⊕ (n x ⋅ n y ⋅ n z ⊕ t x ⋅ n y ⋅ n z))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>mult_t_closed</span><span> </span><span>n_distrib1_opp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (t x ⋅ n y ⊕ t x ⋅ n y ⋅ n z) ⊕ (n x ⋅ n z ⊕ n x ⋅ n y ⋅ n z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a aa ab. n n (n (a::'a) ⋅ (n aa ⋅ n ab)) = n a ⋅ (n aa ⋅ n ab)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>mult_t_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a aa ab. n (a::'a) ⋅ (n aa ⋅ n ab) = n aa ⋅ (n ab ⋅ n a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>n_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n (n y ⋅ n n x) ⋅ n n (n (n x ⋅ n z) ⋅ (n (n x ⋅ n y ⋅ n z) ⋅ n (n y ⋅ n n x ⋅ n z)))) = n (n (n y ⋅ n n x) ⋅ n (n y ⋅ n n x ⋅ n z) ⋅ (n (n x ⋅ n z) ⋅ n (n x ⋅ n y ⋅ n z)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_t_closed</span><span> </span><span>n_add_op_def</span><span> </span><span>n_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (t x ⋅ n y ⊕ t (t x ⋅ n y) ⋅ n z) ⊕ (n x ⋅ n z ⊕ t (n x ⋅ n z) ⋅ n y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_assoc</span><span> </span><span>mult_t_closed</span><span> </span><span>n_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (t x ⋅ n y ⋅ (1 ⊕ n z)) ⊕ (n x ⋅ n z ⋅ (1 ⊕ n y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_zero_def</span><span> </span><span>n_add_op_def</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.tm1</span><span> </span><span>mult_t_closed</span><span> </span><span>n_absorb1</span><span> </span><span>zero_least2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_dist_var2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⋅ n y ⊕ t x ⋅ n z) = n x ⋅ t y ⊕ t x ⋅ t z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>n_add_op_def</span><span> </span><span>n_dist_var1</span><span> </span><span>n_t_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Near-Semirings›</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_near_semiring_zerol</span><span> </span><span class="delimiter">=</span><span> </span><span>ab_near_semiring_one_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>n_op</span><span> </span><span class="delimiter">+</span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>test_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n n 1 = 1"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_mult</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n n (n x ⋅ n y) = n x ⋅ n y"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_mult_comp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n n x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_de_morgan</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n n x ⋅ n n y) = n x + n y"</span></span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n 0 = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n 0 = n (n 1 ⋅ n n 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.test_mult_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (n 1 ⋅ 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n 1 = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n 1 = n 1 ⋅ 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n 1 ⋅ n n 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>test_mult_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + 1 = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + 1 = n n 1 + n n 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (n n n 1 ⋅ n n n 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.test_de_morgan</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (0 ⋅ n n n 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>near_dioid_one_zerol</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = (1 + 1) ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.distrib_right'</span><span> </span><span>local.mult_onel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = 1 ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_n_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n n (n x) = n x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n n (n x) = n (n n x ⋅ 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (n n x ⋅ n n 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n x + n 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.test_de_morgan</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n x + 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_de_morgan_var1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⋅ n y) = n n x + n n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_de_morgan</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y = n y ⋅ n x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y = n n (n x ⋅ n y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (n n x + n n y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n (n n y + n n x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n n (n y ⋅ n x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tm3'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n (n n z ⋅ n n y) = n (n (n x ⋅ n y) ⋅ n (n x ⋅ n z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n (n n z ⋅ n n y) = n (n n y ⋅ n n z) ⋅ n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_mult_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (n y + n z) ⋅ n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n y ⋅ n x + n z ⋅ n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n n (n x ⋅ n y) + n n (n x ⋅ n z)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_mult</span><span> </span><span>n_mult_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>t_de_morgan_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>test_monoid</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n n 1 = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. n x ⋅ n n x = n 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ⋀x z y. n x ⋅ n (n n z ⋅ n n y) = n (n (n x ⋅ n y) ⋅ n (n x ⋅ n z))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tm3'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_transl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y ⟷ n x ⊑ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.join.sup.absorb_iff2</span><span> </span><span>local.n_add_op_def</span><span> </span><span>local.ts_ord_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_transl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x + n y = n x ⊕ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = o"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.a_zero_def</span><span> </span><span>n_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"test p ≡ t p = p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>n_op</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"!_"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x. test x ⟶ P x) ⟷ (∀x. P (t x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>test_def</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_propI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test x ⟹ P x ⟹ P (t x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_propE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test x ⟹ P (t x) ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test (!p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_double_comp_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p = !(!p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test (p ⋅ q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_mult</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_add_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t (n x + n y) = n x + n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_de_morgan</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_add_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test (p + q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>t_add_closed</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_comm_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ q = q ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_mult_comm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_zero_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_one_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ q ⋅ p = q ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ q ⋅ !p = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.a_zero_def</span><span> </span><span>local.n_preserve2</span><span> </span><span>n_one</span><span> </span><span>test_double_comp_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_subid'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_subid</span><span> </span><span>n_zero</span><span> </span><span>ord_transl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_subid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_subid'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_idem_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ p = p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_comp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x + t x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_comp_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x + n x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_add_comp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p + !p = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_mult1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ !p ⋅ p = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_mult2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ !p = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.test_mult_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ ∃q. test q ∧ p + q = 1 ∧ p ⋅ q = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>test_add_comp</span><span> </span><span>test_comp_closed</span><span> </span><span>test_comp_mult2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_absorb1'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x + n x ⋅ n y = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_transl</span><span> </span><span>local.de_morgan4</span><span> </span><span>local.n_absorb1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_absorb1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p + p ⋅ q = p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_absorb2'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n x + n y) = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_absorb2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ (p + q) = p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n y + n z) = (n x ⋅ n y) + (n x ⋅ n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add_transl</span><span> </span><span>local.de_morgan4</span><span> </span><span>local.n_distrib1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_distrib_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹  test q ⟹ test r ⟹ p ⋅ (q + r) = p ⋅ q + p ⋅ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_distrib_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !p + !q = !(p ⋅ q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_de_morgan_var2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x + n y) = t x ⋅ t y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_de_morgan</span><span> </span><span>local.test_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_de_morgan_var3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (t x + t y) = n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !p ⋅ !q = !(p + q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !(!p + !q) = p ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.de_morgan1'</span><span> </span><span>local.t_mult_closure</span><span> </span><span>test_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>de_morgan4'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !(!p ⋅ !q) = p + q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_distr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x + (n y ⋅ n z) = (n x + n y) ⋅ (n x + n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_transl</span><span> </span><span>local.n_distrib2</span><span> </span><span>n_de_morgan_var3</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_add_distr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p + q ⋅ r = (p + q) ⋅ (p + r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_add_distr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_add_distl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⋅ n y) + n z = (n x + n z) ⋅ (n y + n z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_commute</span><span> </span><span>n_add_distr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_add_distl_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ⋅ q + r = (p + r) ⋅ (q + r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_commute</span><span> </span><span>test_add_distr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_ord_def_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y ⟷ n x ⋅ n y = n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.join.sup.absorb_iff2</span><span> </span><span>local.n_absorb2'</span><span> </span><span>local.n_mult_lb2</span><span> </span><span>ord_transl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_leq_mult_def_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ≤ q ⟷ p ⋅ q = p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_ord_def_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_anti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y ⟹ t y ≤ t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.ts_ord_anti</span><span> </span><span>ord_transl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_anti_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y ⟷ t y ≤ t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_anti</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_anti_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ≤ q ⟷ !q ≤ !p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_anti_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_restrictl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.mult_isor</span><span> </span><span>n_subid'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_restrictl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>n_restrictl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_lb1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ≤ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.join.sup.orderI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_lb1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ q ≤ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>n_mult_lb1'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_lb2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n y ≤ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>local.n_restrictl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_lb2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ q ≤ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>test_restrictl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_glbI'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ≤ n x ⟹  n z ≤ n y ⟹ n z ≤ n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isor</span><span> </span><span>n_ord_def_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_glbI</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ≤ q ⟹ p ≤ r ⟹ p ≤ q ⋅ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.mult_isor</span><span> </span><span>test_leq_mult_def_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_glb'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ≤ n x ∧ n z ≤ n y ⟷ n z ≤ n x ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.order_trans</span><span> </span><span>n_mult_glbI'</span><span> </span><span>n_mult_lb1'</span><span> </span><span>n_mult_lb2'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_glb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ≤ q ∧ p ≤ r ⟷ p ≤ q ⋅ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_mult_glb'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_galois1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y + n z ⟷ n x ⋅ t y ≤ n z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ n y + n z ⟷ n x ⊑ n y ⊕ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_de_morgan</span><span> </span><span>ord_transl</span><span> </span><span>n_add_op_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ n x ⋅ t y ⊑ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_galois1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ n x ⋅ t y ≤ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_mult</span><span> </span><span>ord_transl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_galois1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ≤ q + r ⟷ p ⋅ !q ≤ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_galois1'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_galois2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ≤ t y + n z ⟷ n x ⋅ n y ≤ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_galois1'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_galois2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ≤ !q + r ⟷ p ⋅ q ≤ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>test_galois1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_huntington2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x + t y) + n (n x + n y) = n n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_huntington2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !(p + q) + !(p + !q) = !p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = !(!p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>test_double_comp_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>n_huntington2</span><span> </span><span>test_double_comp_var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_1_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = y ⋅ n z ⟷ t x ⋅ y ⋅ n z = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ y ⋅ n z = t x ⋅ n x ⋅ y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" t x ⋅ y ⋅ n z = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_mult_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n n x ⋅ y ⋅ n z = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = 1 ⋅ y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.add_zerol</span><span> </span><span>local.distrib_right'</span><span> </span><span>n_add_comp</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ !p ⋅ x ⋅ !q = x ⋅ !q ⟷ p ⋅ x ⋅ !q = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_kat_1_opp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_1_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ y ⋅ t z = y ⋅ t z ⟷ n x ⋅ y ⋅ t z = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_kat_1_opp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ x ⋅ q = x ⋅ q ⟷ !p ⋅ x ⋅ q = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_kat_1_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_21_opp</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"y ⋅ n z ≤ n x ⋅ y ⟹ n x ⋅ y ⋅ n z = y ⋅ n z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ n z ≤ n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ n z + n x ⋅ y = n x ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>local.join.sup_absorb2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = y ⋅ n z + (n x ⋅ (y ⋅ n z) + 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.add_zeror</span><span> </span><span>local.distrib_right'</span><span> </span><span>local.n_mult_idem</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.add_zeror</span><span> </span><span>local.distrib_right'</span><span> </span><span>local.join.sup_absorb2</span><span> </span><span>local.join.sup_left_commute</span><span> </span><span>local.mult_onel</span><span> </span><span>local.n_subid'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_21_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ x ⋅ q ≤ p ⋅ x ⟶ p ⋅ x ⋅ q = x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_kat_21_opp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">" n x ⋅ y ⋅ n z = y ⋅ n z ⟹ y ⋅ n z ≤ n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick*)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_distrib_alt'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ n z = n y ⋅ n z ⟹ n x + n z = n y + n z ⟹ n x = n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_distrib_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_distrib_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ⋅ r = q ⋅ r ∧ p + r = q + r ⟶ p = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_distrib_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ z ∧ t x ⋅ y ≤ z ⟷ y ≤ z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ z ∧ t x ⋅ y ≤ z ⟷ n x ⋅ y + t x ⋅ y ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ (n x + t x) ⋅ y ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.distrib_right'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ y ≤ x ⟷ p ⋅ y ≤ x ∧ !p ⋅ y ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_eq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_dist_var1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x + n y) ⋅ (t x + n z) = t x ⋅ n y + n x ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_transl</span><span> </span><span>local.n_dist_var1</span><span> </span><span>local.test_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_dist_var1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ (p + q) ⋅ (!p + r) = !p ⋅ q + p ⋅ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist_var1'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_dist_var2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n (n x ⋅ n y + t x ⋅ n z) = n x ⋅ t y + t x ⋅ t z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!x ⋅ !y = !(!(!x ⋅ !y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_de_morgan_var3</span><span> </span><span>t_de_morgan_var1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!(!(!x)) = !x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>n_de_morgan_var3</span><span> </span><span>n_dist_var1'</span><span> </span><span>t_de_morgan_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_dist_var2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ !(p ⋅ q + !p ⋅ r) = (p ⋅ !q + !p ⋅ !r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist_var2'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_restrictr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ⋅ p ≤ x"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ z ≤ p ⋅ x + !p ⋅ y ⟷ p ⋅ z ≤ p ⋅ x ∧ !p ⋅ z ≤ !p ⋅ y"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q ⟷ p ⋅ x ≤ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p ⋅ x ⋅ !q = 0⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; x ⋅ !q = !p ⋅ x ⋅ !q⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; p⋅x = x⋅p; p⋅y = y⋅p⟧ ⟹ p⋅(x + y) = (x + y)⋅p"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_add_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; test r; p⋅x = x⋅p; p⋅y = y⋅p⟧ ⟹ p⋅(q⋅x + r⋅y) = (q⋅x + r⋅y)⋅p"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟹ p ⋅ x = p ⋅ x ⋅ p ∧ !p ⋅ x = !p ⋅ x ⋅ !p "</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ (p + q)⋅(q⋅y + !q⋅x) = q⋅y + !q⋅p⋅x"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Near Semirings with Distributive Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We now make the assumption that tests distribute over finite sums of arbitrary elements from the left.
  This can be justified in models such as multirelations and probabilistic predicate transformers.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_near_semiring_zerol_distrib</span><span> </span><span class="delimiter">=</span><span> </span><span>test_near_semiring_zerol</span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>n_left_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (y + z) = n x ⋅ y + n x ⋅ z"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_left_distrib_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ (x + y) = p ⋅ x + p ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_left_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_mult_left_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ n z ⋅ x ≤ n z ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.join.sup.absorb_iff1</span><span> </span><span>local.n_left_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_mult_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ≤ y ⟹ p ⋅ x ≤ p ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_mult_left_iso</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ⋅ p ≤ x"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q ⟷ p ⋅ x ≤ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p ⋅ x ⋅ !q = 0⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; x ⋅ !q = !p ⋅ x ⋅ !q⟧ ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we study tests with commutativity conditions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹  p ⋅ x = x ⋅ p ⟹  p ⋅ y = y ⋅ p ⟹ p ⋅ (x + y) = (x + y) ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_left_distrib_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_add_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ test r ⟹ p ⋅ x = x ⋅ p ⟹ p ⋅ y = y ⋅ p ⟹ p ⋅ (q ⋅ x + r ⋅ y) = (q ⋅ x + r ⋅ y) ⋅ p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ x = x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test r"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ y = y ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (q ⋅ x) = q ⋅ p ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (r ⋅ y) = r ⋅ p ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a4</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f6</span><span> </span><span>a5</span><span> </span><span>a3</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>n_left_distrib_var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ (p + q) ⋅ (q ⋅ y + !q ⋅ x) = q ⋅ y + !q ⋅ p ⋅ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p + q) ⋅ (q ⋅ y + !q ⋅ x) = p ⋅ q ⋅ y + p ⋅ !q ⋅ x + q ⋅ q ⋅ y + q ⋅ !q ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.add.assoc</span><span> </span><span>local.distrib_right'</span><span> </span><span>mult_assoc</span><span> </span><span>n_left_distrib_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p ⋅ q ⋅ y + !q ⋅ p ⋅ x + q ⋅ y"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>local.test_mult_comm_var</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p + 1) ⋅ q ⋅ y + !q ⋅ p ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_commute</span><span> </span><span>local.add.assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = q ⋅ y + !q ⋅ p ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>local.join.sup.absorb2</span><span> </span><span>local.test_subid</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Predioids›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following class is relevant for probabilistic Kleene algebras.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_pre_dioid_zerol</span><span> </span><span class="delimiter">=</span><span> </span><span>test_near_semiring_zerol_distrib</span><span> </span><span class="delimiter">+</span><span> </span><span>pre_dioid</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_restrictr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.mult_isol</span><span> </span><span>local.n_subid'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_restrictr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ⋅ p ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_restrictr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y = n x ⋅ y ⋅ n z ⟷ n x ⋅ y ≤ y ⋅ n z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y = n x ⋅ y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>n_restrictl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y  ≤ n x ⋅ y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.mult_isol</span><span> </span><span>local.n_mult_idem</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y  = n x ⋅ y ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.order.antisym</span><span> </span><span>n_restrictr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ x = p ⋅ x ⋅ q ⟷ p ⋅ x ≤ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_kat_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_2_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ n z = n x ⋅ y ⋅ n z ⟷ y ⋅ n z ≤ n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.n_kat_21_opp</span><span> </span><span>n_restrictr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_2_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ x ⋅ q  = p ⋅ x ⋅ q ⟷ x ⋅ q ≤ p ⋅ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_kat_21_opp</span><span> </span><span>test_restrictr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p⋅x⋅!q = 0⟧ ⟹ p⋅x = p⋅x⋅q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; x⋅!q = !p⋅x⋅!q⟧ ⟹ p⋅x = p⋅x⋅q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ x ⋅ (p + q) ≤ x ⋅ p + x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following class is relevant for Demonic Refinement Algebras.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_semiring_zerol</span><span> </span><span class="delimiter">=</span><span> </span><span>test_near_semiring_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>semiring_one_zerol</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>dioid_one_zerol</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>test_pre_dioid_zerol</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z. !x ⋅ (y + z) = !x ⋅ y + !x ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.distrib_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ t z = 0 ⟹ n x ⋅ y ⋅ n z = n x ⋅ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ t z = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y = n x ⋅ y ⋅ (n z + t z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n x ⋅ y ⋅ n z + n x ⋅ y ⋅ t z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.distrib_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = n x ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ x ⋅ !q = 0 ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_double_comp_var</span><span> </span><span>n_kat_31</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ y ⋅ t z = y ⋅ t z ⟹ n x ⋅ y ⋅ n z = n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_kat_1_var</span><span> </span><span>n_kat_31</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test1_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ x ⋅ !q = !p ⋅ x ⋅ !q ⟹ p ⋅ x = p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_eq4</span><span> </span><span>test_kat_31</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p⋅x⋅!q = 0⟧ ⟹ !p⋅x⋅q = 0"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p⋅x = p⋅x⋅q⟧ ⟹ x⋅!q = !p⋅x⋅!q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p⋅x = p⋅x⋅q⟧ ⟹ p⋅x⋅!q = 0"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; p⋅x = p⋅x⋅q⟧ ⟹ !p⋅x⋅q = 0"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; x⋅!q = !p⋅x⋅!q⟧ ⟹ !p⋅x⋅q = 0"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; !p⋅x⋅q = 0⟧ ⟹ p⋅x = p⋅x⋅q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; !p⋅x⋅q = 0⟧ ⟹ x⋅!q = !p⋅x⋅!q"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q; !p⋅x⋅q = 0⟧ ⟹ p⋅x⋅!q = 0"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = p ⋅ x ⋅ p ∧ !p ⋅ x = !p ⋅ x ⋅ !p ⟹ p ⋅ x = x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test Semirings›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following class is relevant for Kleene Algebra with Tests.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_semiring</span><span> </span><span class="delimiter">=</span><span> </span><span>test_semiring_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>semiring_one_zero</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ t z = 0 ⟷ n x ⋅ y ⋅ n z = n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.annir</span><span> </span><span>local.n_kat_31</span><span> </span><span>local.test_mult_comp</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ p ⋅ x ⋅ !q = 0 ⟷ p ⋅ x =  p ⋅ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_double_comp_var</span><span> </span><span>n_kat_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ t z = 0 ⟷ n x ⋅ y ≤ y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_kat_2</span><span> </span><span>n_kat_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹  p ⋅ x ⋅ !q = 0 ⟷ p ⋅ x ≤ x ⋅ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_kat_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = n x ⋅ y ⟷ t x ⋅ y ⋅ t z = y ⋅ t z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.annir</span><span> </span><span>local.n_kat_1_opp</span><span> </span><span>local.n_kat_var</span><span> </span><span>local.t_n_closed</span><span> </span><span>local.test_mult_comp</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_kat_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q  ⟹  p ⋅ x = p ⋅ x ⋅ q  ⟷ x ⋅ !q = !p ⋅ x ⋅ !q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.annir</span><span> </span><span>local.test1_var</span><span> </span><span>local.test_comp_mult2</span><span> </span><span>local.test_eq4</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_kat_3_opp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ y ⋅ n z = 0 ⟷ y ⋅ n z ≤ n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.n_kat_1_var</span><span> </span><span>local.n_kat_2_opp</span><span> </span><span>local.t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kat_1_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ⋅ n z = y ⋅ n z ⟷ y ⋅ n z ≤ n x ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_kat_2_opp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ (p⋅x⋅!q = 0) ⟹ (!p⋅x⋅q = 0)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y + t x ⋅ z = n x ⋅ y ∨ n x ⋅ y + t x ⋅ z = t x ⋅ z"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Conway_Tests">
<div class="head"><h1>Theory Conway_Tests</h1>
<span class="command">theory</span> <span class="name">Conway_Tests</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/Conway.html"><span class="name">Conway</span></a> <a href="Test_Dioid.html"><span class="name">Test_Dioid</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pre-Conway Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conway_Tests</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.Conway</span><span> </span><span>Test_Dioid</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>near_conway_zerol_tests</span><span> </span><span class="delimiter">=</span><span> </span><span>near_conway_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>test_near_semiring_zerol_distrib</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_preserve1_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ n x ⋅ y ⋅ n x ⟹ n x ⋅ (n x ⋅ y + t x ⋅ z)<span class="hidden">⇧</span><sup>†</sup> ≤ (n x ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ n x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ y ≤ n x ⋅ y ⋅ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n x ⋅ y + t x ⋅ z) = n x ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.add_zeror</span><span> </span><span>local.annil</span><span> </span><span>local.n_left_distrib</span><span> </span><span>local.n_mult_idem</span><span> </span><span>local.test_mult_comp</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n x ⋅ (n x ⋅ y + t x ⋅ z) ≤ n x ⋅ y ⋅ n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" n x ⋅ (n x ⋅ y + t x ⋅ z)<span class="hidden">⇧</span><sup>†</sup> ≤ (n x ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.dagger_simr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve1_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x ≤ p ⋅ x ⋅ p ⟹ p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ≤ (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_double_comp_var</span><span> </span><span>n_preserve1_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>test_pre_conway</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_conway</span><span> </span><span class="delimiter">+</span><span> </span><span>test_pre_dioid_zerol</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>near_conway_zerol_tests</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹  p ⋅ x ≤ p ⋅ x ⋅ p  ⟹ p ⋅ x<span class="hidden">⇧</span><sup>†</sup> = (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.preservation1_eq</span><span> </span><span>local.test_restrictr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x ≤ p ⋅ x ⋅ p ⟹ p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> = (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ x ≤ p ⋅ x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x + !p ⋅ y) ≤ (p ⋅ x) ⋅ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.add_0_right</span><span> </span><span>local.annil</span><span> </span><span>local.n_left_distrib_var</span><span> </span><span>local.test_comp_mult2</span><span> </span><span>local.test_mult_idem_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ≤ (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.dagger_simr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ x ≤ p ⋅ x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p = p ⋅ (p ⋅ x ⋅ p)<span class="hidden">⇧</span><sup>†</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dagger_slide</span><span> </span><span>local.test_mult_idem_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p ⋅ (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>local.order.antisym</span><span> </span><span>local.test_restrictr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p ≤ p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>local.dagger_iso</span><span> </span><span>local.test_mult_isol</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_preserve2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x ⋅ p = p ⋅ x ⟹ p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ≤ x<span class="hidden">⇧</span><sup>†</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.eq_refl</span><span> </span><span>local.test_restrictl</span><span> </span><span>test_preserve</span><span> </span><span>test_preserve1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="KAT">
<div class="head"><h1>Theory KAT</h1>
<span class="command">theory</span> <span class="name">KAT</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/Kleene_Algebra.html"><span class="name">Kleene_Algebra</span></a> <a href="Conway_Tests.html"><span class="name">Conway_Tests</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Kleene Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.Kleene_Algebra</span><span> </span><span>Conway_Tests</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  First, we study left Kleene algebras with tests which also have only a left zero.
  These structures can be expanded to demonic refinement algebras.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>left_kat_zerol</span><span> </span><span class="delimiter">=</span><span>  </span><span>left_kleene_algebra_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>test_semiring_zerol</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_n_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n x ≤ n x ⋅ y<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.n_restrictr</span><span> </span><span>local.star_sim1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_test_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ (p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p ≤ p ⋅ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star_n_export1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_n_export2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n x ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n x ≤ y<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.mult_isor</span><span> </span><span>local.n_restrictl</span><span> </span><span>local.star_iso</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_test_export2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ (p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p ≤ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star_n_export2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_n_export_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y ≤ n y ⋅ x ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y = n y ⋅ (x ⋅ n y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y ≤ n y ⋅ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y = n y ⋅ x ⋅ n y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.n_kat_2_opp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y ≤ n y ⋅ (x ⋅ n y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.star_sim1</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y ≤ n y ⋅ x"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n y ⋅ (x ⋅ n y)<span class="hidden">⇧</span><sup>⋆</sup> ≤ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.star_slide</span><span> </span><span>star_n_export2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_test_export_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ⋅ p ≤ p ⋅ x ⟶ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p = p ⋅ (x ⋅ p)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star_n_export_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_n_export_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ n y ≤ n y ⋅ x ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y = (n y ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.star_slide</span><span> </span><span>star_n_export_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_test_export_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ x ⋅ p ≤ p ⋅ x ⟶ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p = (p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star_n_export_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_n_folk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⋅ x = x ⋅ n z ⟹ n z ⋅ y = y ⋅ n z ⟹ (n z ⋅ x + t z ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n z = n z ⋅ (n z ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⋅ x = x ⋅ n z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⋅ y = y ⋅ n z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⋅ (n z ⋅ x + t z ⋅ y) = (n z ⋅ x + t z ⋅ y) ⋅ n z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.comm_add_var</span><span> </span><span>local.t_n_closed</span><span> </span><span>local.test_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(n z ⋅ x + t z ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n z = n z ⋅ ((n z ⋅ x + t z ⋅ y) ⋅ n z)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.order_refl</span><span> </span><span>star_n_export_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n z ⋅ (n z ⋅ x ⋅ n z + t z ⋅ y ⋅ n z)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n z ⋅ (n z ⋅ n z ⋅ x + t z ⋅ n z ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n z ⋅ (n z ⋅ x + 0 ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.n_mult_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(n z ⋅ x + t z ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n z = n z ⋅ (n z ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_test_folk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟶ p ⋅ y = y ⋅ p ⟶ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p = p ⋅ (p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star_n_folk</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kat_zerol</span><span> </span><span class="delimiter">=</span><span> </span><span>kleene_algebra_zerol</span><span> </span><span class="delimiter">+</span><span> </span><span>test_semiring_zerol</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conway</span><span class="delimiter">:</span><span> </span><span>near_conway_zerol_tests</span><span> </span><span>star</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_star_sim_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n y ⋅ x = x ⋅ n y ⟹ n y ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> = (n y ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.n_mult_idem</span><span> </span><span>local.star_sim3</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_sim_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟶ p ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> = (p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_star_sim_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_star_sim_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n y ⋅ x = x ⋅ n y ⟹ n y ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> = n y ⋅ (x ⋅ n y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.star_slide</span><span> </span><span>n_star_sim_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_sim_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟶ p ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> = p ⋅ (x ⋅ p)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_star_sim_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_comm_star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n z ⋅ x = x ⋅ n z ⟹  n z ⋅ y = y ⋅ n z ⟹ n z ⋅ x ⋅ (n z ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> = n z ⋅ x ⋅ y<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_assoc</span><span> </span><span>n_star_sim_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟶  p ⋅ y = y ⋅ p ⟶ p ⋅ x ⋅ (p ⋅ y)<span class="hidden">⇧</span><sup>⋆</sup> = p ⋅ x ⋅ y<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_comm_star</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_star_sim_right_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n y ⋅ x = x ⋅ n y ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n y = n y ⋅ (x ⋅ n y)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.star_sim3</span><span> </span><span>n_star_sim_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_sim_right_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x = x ⋅ p ⟶ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p = p ⋅ (x ⋅ p)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_star_sim_right_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we define Kleene algebra with tests.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kat</span><span> </span><span class="delimiter">=</span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">+</span><span> </span><span>test_semiring</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conway</span><span class="delimiter">:</span><span> </span><span>test_pre_conway</span><span> </span><span>star</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DRAT">
<div class="head"><h1>Theory DRAT</h1>
<span class="command">theory</span> <span class="name">DRAT</span><br/>
<span class="keyword">imports</span> <a href="KAT.html"><span class="name">KAT</span></a> <a href="../Kleene_Algebra/DRA.html"><span class="name">DRA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Demonic refinement algebra
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Demonic Refinement Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DRAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>KAT</span><span> </span><span>Kleene_Algebra.DRA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we define demonic refinement algebras with tests and prove the most important theorems from
  the literature. In this context, tests are also known as guards.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>drat</span><span> </span><span class="delimiter">=</span><span> </span><span>dra</span><span> </span><span class="delimiter">+</span><span> </span><span>test_semiring_zerol</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>kat_zerol</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  An assertion is a mapping from a guard to a subset similar to tests, but it aborts if the predicate does
  not hold.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>assertion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>o</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p<span class="hidden">⇧</span><sup>o</sup> = !p⋅⊤ + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ q ≤ 1 ∧ 1 ≤ p<span class="hidden">⇧</span><sup>o</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assertion_def</span><span> </span><span>local.test_subid</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assertion_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ y ≤ p<span class="hidden">⇧</span><sup>o</sup>⋅x ⟷ p⋅y ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ p<span class="hidden">⇧</span><sup>o</sup>⋅x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p⋅y ≤ p⋅!p⋅⊤⋅x + p⋅x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>assertion_def</span><span> </span><span>local.distrib_left</span><span> </span><span>local.iteration_prod_unfold</span><span> </span><span>local.iteration_unfoldl_distr</span><span> </span><span>local.mult_isol</span><span> </span><span>local.top_mult_annil</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.test_restrictl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p⋅y ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p⋅y ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p<span class="hidden">⇧</span><sup>o</sup>⋅p⋅y = !p⋅⊤⋅p⋅y + p⋅y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assertion_def</span><span> </span><span>distrib_right'</span><span> </span><span>mult_1_left</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = !p⋅⊤ + p⋅y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>top_mult_annil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p<span class="hidden">⇧</span><sup>o</sup>⋅p⋅y ≤ p<span class="hidden">⇧</span><sup>o</sup>⋅x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p⋅y + p⋅y ≤ !p⋅⊤ + p⋅y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.add_iso</span><span> </span><span>local.top_elim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ p<span class="hidden">⇧</span><sup>o</sup>⋅x"</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>distrib_right'</span><span> </span><span>mult_1_left</span><span> </span><span>order_trans</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assertion_isor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ y ≤ x⋅p ⟷ y⋅p<span class="hidden">⇧</span><sup>o</sup> ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ x⋅p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y⋅p<span class="hidden">⇧</span><sup>o</sup> ≤ x⋅p⋅!p⋅⊤ + x⋅p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isor</span><span> </span><span>assertion_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span> </span><span>mult_1_right</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.iteration_idep</span><span> </span><span>local.join.sup.absorb_iff1</span><span> </span><span>local.join.sup_commute</span><span> </span><span>local.join.sup_ge2</span><span> </span><span>local.mult_1_right</span><span> </span><span>local.mult_isol_var</span><span> </span><span>local.mult_isor</span><span> </span><span>local.mult_onel</span><span> </span><span>local.test_add_comp</span><span> </span><span>local.test_comp_mult2</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y⋅p<span class="hidden">⇧</span><sup>o</sup> ≤ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y⋅p<span class="hidden">⇧</span><sup>o</sup> ≤ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ y⋅(!p⋅⊤ + p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>join.sup_mono</span><span> </span><span>mult_isol</span><span> </span><span>order_refl</span><span> </span><span>order_refl</span><span> </span><span>top_elim</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_1_right</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = y⋅p<span class="hidden">⇧</span><sup>o</sup>⋅p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assertion_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>distrib_right'</span><span> </span><span>mult_1_left</span><span> </span><span>mult.assoc</span><span> </span><span>top_mult_annil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ x⋅p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mult_isor</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assertion_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ x⋅q<span class="hidden">⇧</span><sup>o</sup> ≤ p<span class="hidden">⇧</span><sup>o</sup>⋅x ⟷ p⋅x ≤ x⋅q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assertion_isol</span><span> </span><span>assertion_isor</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_correctness</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ p⋅x⋅!q = 0 ⟷ x⋅!q ≤ !p⋅⊤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.test_eq4</span><span> </span><span>local.top_elim</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annil</span><span> </span><span>antisym</span><span> </span><span>test_comp_mult2</span><span> </span><span>join.bot_least</span><span> </span><span>mult_assoc</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iteration_sim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; p⋅x ≤ x⋅p⟧ ⟹ p⋅x<span class="hidden">⇧</span><sup>∞</sup> ≤ x<span class="hidden">⇧</span><sup>∞</sup>⋅p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iteration_sim</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iteration_annir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ !p⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup> = !p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annil</span><span> </span><span>test_comp_mult1</span><span> </span><span>iteration_idep</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we give an example of a program transformation from von Wright~\cite{Wright02}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop_refinement</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦test p; test q⟧ ⟹ (p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p ≤ (p⋅q⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!(p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p = ((p⋅q) + !(p⋅q))⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.test_mult_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p + !(p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p⋅q)⋅!p + (p⋅q)⋅(p⋅x)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p + !(p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iteration_unfoldr_distr</span><span> </span><span>mult.assoc</span><span> </span><span>iteration_unfold_eq</span><span> </span><span>distrib_left</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p⋅q)⋅(p⋅x)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p + !(p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>less_eq_def</span><span> </span><span>test_preserve2</span><span> </span><span>join.bot_least</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p ≤ p⋅q⋅x⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p + !(p⋅q)⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup>⋅!p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.eq_iff</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>local.test_preserve</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coinduction</span><span> </span><span>add.commute</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we prove different versions of Back's atomicity refinement theorem for action systems.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_step1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅b ≤ b⋅r ⟹ (a + b + r)<span class="hidden">⇧</span><sup>∞</sup> = b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a + b + r)<span class="hidden">⇧</span><sup>∞</sup> = (b + r)<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅(b + r)<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iteration_sep</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc'</span><span> </span><span>add.commute</span><span> </span><span>iteration_denest</span><span class="delimiter">)</span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_step2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = s⋅q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅b = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅q ≤ q⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅l ≤ l⋅q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r<span class="hidden">⇧</span><sup>∞</sup> = r<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup> ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup> ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>star_sim1</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>iteration_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅q⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>local.mult_isor</span><span> </span><span>local.test_restrictr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>iteration_sim</span><span> </span><span>mult.assoc</span><span> </span><span>mult_double_iso</span><span> </span><span>mult_double_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>join.bot_least</span><span> </span><span>iteration_sim</span><span> </span><span>mult.assoc</span><span> </span><span>mult_double_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>test_restrictl</span><span> </span><span>iteration_idem</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup> ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_step3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅l ≤ l⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a⋅l ≤ l⋅a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b⋅l ≤ l⋅b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅l ≤ l⋅q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b<span class="hidden">⇧</span><sup>∞</sup> = b<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup> = (a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + l + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)⋅l ≤ a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅l⋅q + l⋅r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right</span><span> </span><span>join.sup_mono</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ a⋅l⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + l⋅r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>star_sim1</span><span> </span><span>add_iso</span><span> </span><span>mult.assoc</span><span> </span><span>mult_double_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ l⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_iso</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mult_isor</span><span> </span><span>distrib_left</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)⋅l ≤ l⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup> = l<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>mult.assoc</span><span> </span><span>iteration_denest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>iteration_sep</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This is Back's atomicity refinement theorem, as specified by von Wright~\cite {Wright02}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>atom_ref_back</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = s⋅q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = q⋅a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅b = 0"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r⋅b ≤ b⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅l ≤ l⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅q ≤ q⋅r"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"a⋅l ≤ l⋅a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b⋅l ≤ l⋅b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅l ≤ l⋅q"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r<span class="hidden">⇧</span><sup>∞</sup> = r<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b<span class="hidden">⇧</span><sup>∞</sup> = b<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅(a + b + r + l)<span class="hidden">⇧</span><sup>∞</sup>⋅q ≤ s⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r + l)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a + b + r)⋅l ≤ l⋅(a + b + r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>join.sup_mono</span><span> </span><span>distrib_right'</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅(l + a + b + r)<span class="hidden">⇧</span><sup>∞</sup>⋅q = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅(a + b + r)<span class="hidden">⇧</span><sup>∞</sup>⋅q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>mult.assoc</span><span> </span><span>iteration_sep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>10</span><span class="delimiter">,</span><span>11</span><span class="delimiter">)</span><span> </span><span>atom_step1</span><span> </span><span>iteration_slide</span><span> </span><span>eq_refl</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>atom_step2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + l + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>atom_step3</span><span> </span><span>eq_refl</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This variant is due to H\"ofner, Struth and Sutcliffe~\cite{HofnerSS09}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>atom_ref_back_struth</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ s⋅q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ q⋅a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅b = 0"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r⋅b ≤ b⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅q ≤ q⋅r"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(a + r + b)⋅l ≤ l⋅(a + r + b)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q⋅l ≤ l⋅q"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r<span class="hidden">⇧</span><sup>∞</sup> = r<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅(a + b + r + l)<span class="hidden">⇧</span><sup>∞</sup>⋅q ≤ s⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r + l)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s⋅(a + b + r + l)<span class="hidden">⇧</span><sup>∞</sup>⋅q = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅(a + b + r)<span class="hidden">⇧</span><sup>∞</sup>⋅q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>iteration_sep</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅(b + r)<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅(b + r)<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>⋅q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc'</span><span> </span><span>add.commute</span><span> </span><span>iteration_denest</span><span> </span><span>add.commute</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>⋅q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>iteration_sep</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(q⋅a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>⋅q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>iteration_iso</span><span> </span><span>mult_isol_var</span><span> </span><span>eq_refl</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iteration_slide</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅q⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>iteration_sim</span><span> </span><span>mult.assoc</span><span> </span><span>mult_double_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>iteration_idep</span><span> </span><span>mult.assoc</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>⋆</sup>⋅q)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>eq_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>⋆</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>iteration_iso</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>star_sim1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>mult_1_right</span><span> </span><span>mult_double_iso</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅r<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q⋅r<span class="hidden">⇧</span><sup>∞</sup>)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>mult_1_right</span><span> </span><span>mult_double_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = s⋅l<span class="hidden">⇧</span><sup>∞</sup>⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>mult.assoc</span><span> </span><span>iteration_denest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ s⋅(a⋅b<span class="hidden">⇧</span><sup>∞</sup>⋅q + r + l)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>iteration_subdenest</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we prove Cohen's~\cite{Cohen00} variation of the atomicity refinement theorem.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_ref_cohen</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅p⋅y ≤ y⋅r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y⋅p⋅l ≤ l⋅y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅p⋅l ≤ l⋅r"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p⋅r⋅!p = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p⋅l⋅!p = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p⋅l⋅p = 0"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"y⋅0 = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅0 = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y + r + l)<span class="hidden">⇧</span><sup>∞</sup> = (p⋅l)<span class="hidden">⇧</span><sup>∞</sup>⋅(y + !p⋅l + r⋅!p)<span class="hidden">⇧</span><sup>∞</sup>⋅(r⋅p)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y + r)⋅p⋅l ≤ l⋅y + l⋅r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right'</span><span> </span><span>join.sup_mono</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>stepA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y + r)⋅p⋅l ≤ (p⋅l + !p⋅l)⋅(y + r)<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span> </span><span>distrib_right'</span><span> </span><span>mult_1_left</span><span> </span><span>mult_isol</span><span> </span><span>order_trans</span><span> </span><span>star_ext</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subStepB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(!p⋅l + y + p⋅r + !p⋅r)<span class="hidden">⇧</span><sup>∞</sup> = (!p⋅l + y + r⋅p + r⋅!p)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc'</span><span> </span><span>annil</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span> </span><span>distrib_right'</span><span> </span><span>star_slide</span><span> </span><span>star_subid</span><span> </span><span>test_add_comp</span><span> </span><span>join.bot_least</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅p⋅(y + r⋅!p + !p⋅l) ≤ y⋅(r⋅p + r⋅!p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>9</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span> </span><span>add_0_left</span><span> </span><span>add.commute</span><span> </span><span>annil</span><span> </span><span>mult.assoc</span><span> </span><span>test_comp_mult2</span><span> </span><span>distrib_left</span><span> </span><span>mult_oner</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (y + r⋅!p + !p⋅l)⋅(r⋅p + (y + r⋅!p + !p⋅l))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>local.eq_refl</span><span> </span><span>local.join.sup_ge1</span><span> </span><span>local.join.sup_ge2</span><span> </span><span>local.join.sup_mono</span><span> </span><span>local.mult_isol_var</span><span> </span><span>local.order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅p⋅(y + r⋅!p + !p⋅l) ≤ (y + r⋅!p + !p⋅l)⋅(y + r⋅!p + !p⋅l + r⋅p)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>stepB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(!p⋅l + y + p⋅r + !p⋅r)<span class="hidden">⇧</span><sup>∞</sup> = (y + !p⋅l + r⋅!p)<span class="hidden">⇧</span><sup>∞</sup>⋅(r⋅p)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subStepB</span><span> </span><span>iteration_sep3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"r⋅p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y + r⋅!p + !p⋅l"</span></span></span><span class="delimiter">]</span><span>  </span><span>add_assoc'</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y + r + l)<span class="hidden">⇧</span><sup>∞</sup> = (p⋅l + !p⋅l + y + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_comm</span><span> </span><span>add.left_commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>distrib_right'</span><span> </span><span>mult_onel</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p⋅l)<span class="hidden">⇧</span><sup>∞</sup>⋅(!p⋅l + y + r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepA</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>6</span><span>-</span><span>8</span><span class="delimiter">)</span><span> </span><span>annil</span><span> </span><span>add.assoc</span><span> </span><span>add_0_left</span><span> </span><span>distrib_right'</span><span> </span><span>add.commute</span><span> </span><span>mult.assoc</span><span> </span><span>iteration_sep4</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"y+r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p⋅l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p⋅l"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p⋅l)<span class="hidden">⇧</span><sup>∞</sup>⋅(!p⋅l + y + p⋅r + !p⋅r)<span class="hidden">⇧</span><sup>∞</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>combine_common_factor</span><span> </span><span>mult_1_left</span><span> </span><span>test_add_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepB</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DRA_Models">
<div class="head"><h1>Theory DRA_Models</h1>
<span class="command">theory</span> <span class="name">DRA_Models</span><br/>
<span class="keyword">imports</span> <a href="DRAT.html"><span class="name">DRAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Demonic refinement algebra
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Models for Demonic Refinement Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DRA_Models</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>DRAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We formalise the predicate transformer model of demonic refinement algebra.
  Predicate transformers are formalised as strict and additive functions over a field of sets,
  or alternatively as costrict and multiplicative functions. 
  In the future, this should be merged with Preoteasa's more abstract formalisation~\cite{Preoteasa11}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> 
</span><span>  </span><span>plus</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"+"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>less_eq</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'(≤')"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>less_eq</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ≤ _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>comp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>bfun</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Definitions of signature:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>top</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"top ≡ λx. UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bot</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bot ≡ λx. {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint f ≡ (λp. - f (-p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_inter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊓"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ⊓ g ≡ λp. f p ∩ g p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"+"</span></span></span><span> </span><span>52</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f + g ≡ λp. f p ∪ g p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_order</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≤"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ≤ g ≡ ∀p. f p ⊆ g p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_strict_order</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;."</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f &lt;. g ≡ f ≤ g ∧ f ≠ g"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"N f ≡ ((adjoint f o bot) ⊓ id)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>top_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≤ top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>top_def</span><span> </span><span>fun_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bot_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bot ≤ f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bot_def</span><span> </span><span>fun_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oder_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⊓ g = f ⟹ f ≤ g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fun_inter_def</span><span> </span><span>fun_order_def</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>order_def_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≤ g ⟹ f ⊓ g = f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_inter_def</span><span> </span><span>fun_order_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (adjoint f) = f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adjoint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_prop1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f o top) ⊓ (adjoint f o bot) = bot"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>top_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_prop2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f o top) + (adjoint f o bot) = top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_union_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>top_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint (f o g) = adjoint f o adjoint g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adjoint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjoint_top</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adjoint top = bot"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>top_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_comp1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N (N f)) + N f = id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_union_def</span><span> </span><span>N_def</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_comp2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N (N f)) o N f = bot"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_comp3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N f o (N (N f)) = bot"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_de_morgan</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N (N f) o N (N g) = N (N f) ⊓ N (N g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_union_def</span><span> </span><span>N_def</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conj_pred_aux</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λp. x p ∪ y p) = y ⟹ ∀p. x p ⊆ y p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_upper1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Next, we define a type for conjuctive or multiplicative predicate transformers.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>bool_op</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{f::'a bfun. (∀g h. mono f ∧ f ∘ g + f ∘ h = f ∘ (g + h) ∧ bot o f = bot)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>monoI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_order_def</span><span> </span><span>fun_union_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_bool_op</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Conjuctive predicate transformers form a dioid with tests without right annihilator.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span>dioid_one_zerol</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_eq_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op ⇒ 'a bool_op ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>fun_order</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op ⇒ 'a bool_op ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;.)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bot"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bot_def</span><span> </span><span>fun_union_def</span><span> </span><span>fun_order_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"id"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_union_def</span><span> </span><span>fun_order_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op ⇒ 'a bool_op ⇒ 'a bool_op"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(o)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>fun_union_def</span><span> </span><span>fun_order_def</span><span> </span><span>bot_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span> </span><span>metis</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op ⇒ 'a bool_op ⇒ 'a bool_op"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(+)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>fun_union_def</span><span> </span><span>fun_order_def</span><span> </span><span>bot_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>semilattice_sup_class.sup.assoc</span><span> </span><span>semilattice_sup_class.sup.left_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_order_def</span><span> </span><span>fun_strict_order_def</span><span> </span><span>fun_union_def</span><span> </span><span>bot_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span>test_semiring_zerol</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>n_op_bool_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bool_op ⇒ 'a bool_op"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>fun_inter_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>fun_union_def</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>id_def</span><span> </span><span>comp_def</span><span> </span><span>fun_inter_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>id_def</span><span> </span><span>comp_def</span><span> </span><span>fun_inter_def</span><span> </span><span>fun_union_def</span><span> </span><span>mono_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>comp_def</span><span> </span><span>mono_def</span><span> </span><span>fun_union_def</span><span> </span><span>fun_inter_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>N_def</span><span> </span><span>adjoint_def</span><span> </span><span>bot_def</span><span> </span><span>comp_def</span><span> </span><span>mono_def</span><span> </span><span>fun_union_def</span><span> </span><span>fun_inter_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fun_star f = lfp (λr. f o r + id)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fun_iteration</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bfun ⇒ 'a bfun"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fun_iteration f = gfp (λg. f o g + id)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Verifying the iteration laws is left for future work. This could be obtained by integrating
  Preoteasa's approach~\cite{Preoteasa11}.
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="KAT_Models">
<div class="head"><h1>Theory KAT_Models</h1>
<span class="command">theory</span> <span class="name">KAT_Models</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/Kleene_Algebra_Models.html"><span class="name">Kleene_Algebra_Models</span></a> <a href="KAT.html"><span class="name">KAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Models for Kleene Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KAT_Models</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.Kleene_Algebra_Models</span><span> </span><span>KAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We show that binary relations under the obvious definitions form a Kleene algebra with tests.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_dioid_tests</span><span class="delimiter">:</span><span> </span><span>test_semiring</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. Id ∩ ( - x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_kat</span><span class="delimiter">:</span><span> </span><span>kat</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. Id ∩ ( - x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>relation</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV::'a rel set"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_relation</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>type</span><span class="delimiter">)</span><span> </span><span>kat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>n_op_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. Id ∩ ( - x)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>star_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rtrancl"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_eq_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Id"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation ⇒ 'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation ⇒ 'a relation ⇒ 'a relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_dioid.mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_dioid.less_eq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_dioid.less_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kleene_algebra.star_inductl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kleene_algebra.star_inductr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FolkTheorem">
<div class="head"><h1>Theory FolkTheorem</h1>
<span class="command">theory</span> <span class="name">FolkTheorem</span><br/>
<span class="keyword">imports</span> <a href="DRAT.html"><span class="name">DRAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transformation Theorem for while Loops›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FolkTheorem</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Conway_Tests</span><span> </span><span>KAT</span><span> </span><span>DRAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We prove Kozen's transformation theorem for while loops \cite{Kozen97} in a weak setting that unifies
  previous proofs in Kleene algebra with tests, demonic refinement algebras and a variant of probabilistic
  Kleene algebra.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>test_pre_conway</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pres</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pres x y ≡ y ⋅ x = y ⋅ x ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pres_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y z ⟹ pres x z ⟹ pres (x ⋅ y) z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_pres1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ pres p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_pres2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹ pres x q ⟹ pres (p ⋅ x) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pres_comp</span><span> </span><span>test_pres1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_helper1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres x p"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ (p ⋅ z + !p ⋅ w) = p ⋅ x<span class="hidden">⇧</span><sup>†</sup> ⋅ z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ z + !p ⋅ w) = p ⋅ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.add_zerol</span><span> </span><span>local.annil</span><span> </span><span>local.join.sup_commute</span><span> </span><span>local.n_left_distrib_var</span><span> </span><span>local.test_comp_mult2</span><span> </span><span>local.test_mult_idem_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ (p ⋅ z + !p ⋅ w) = (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p ⋅ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.test_preserve1</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.test_preserve</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_helper2</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y (!p)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p ⋅ (p ⋅ x + !p ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ (p ⋅ z + !p ⋅ w) = !p ⋅ y<span class="hidden">⇧</span><sup>†</sup> ⋅ w"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p ⋅ (!p ⋅ y + !(!p) ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ (!p ⋅ w + !(!p) ⋅ z) = !p ⋅ y<span class="hidden">⇧</span><sup>†</sup> ⋅ w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.test_comp_closed</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cond_helper1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_distr_var</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(q ⋅ p + r ⋅ !p) ⋅ (p ⋅ x + !p ⋅ y) = q ⋅ p ⋅ x + r ⋅ !p ⋅ y"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(q ⋅ p + r ⋅ !p) ⋅ (p ⋅ x + !p ⋅ y) = q ⋅ p ⋅ p ⋅ x + q ⋅ p ⋅ !p ⋅ y + r ⋅ !p ⋅ p ⋅ x + r ⋅ !p ⋅ !p ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.distrib_right'</span><span> </span><span>local.join.sup_assoc</span><span> </span><span>local.n_left_distrib_var</span><span> </span><span>local.test_comp_closed</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = q ⋅ p ⋅ x + q ⋅ 0 ⋅ y + r ⋅ 0 ⋅ x + r ⋅ !p  ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.add_zerol</span><span> </span><span>local.annil</span><span> </span><span>local.join.sup_commute</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>local.test_zero_var</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_distr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ q + !p ⋅ r) ⋅ (p ⋅ x + !p ⋅ y) = p ⋅ q ⋅ x + !p ⋅ r ⋅ y"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>cond_distr_var</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>conditional</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test r1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test r2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres x1 q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y1 q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres x2 (!q)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y2 (!q)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ q + !p ⋅ !q) ⋅ (q ⋅ x1 + !q ⋅ x2) ⋅ ((q ⋅ r1 + !q ⋅ r2) ⋅ (q ⋅ y1 + !q ⋅ y2))<span class="hidden">⇧</span><sup>†</sup> ⋅ !(q ⋅ r1 + !q ⋅ r2) =     
(p ⋅ q + !p ⋅ !q) ⋅ (p ⋅ x1 ⋅ (r1 ⋅ y1)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r1 + !p ⋅ x2 ⋅ (r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ q ⋅ x1 ⋅ q ⋅ (q ⋅ r1 ⋅ y1 + !q ⋅ r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ (q ⋅ !r1 + !q ⋅ !r2) = p ⋅ q ⋅ x1 ⋅ q ⋅ (r1 ⋅ y1)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  </span><span>assms</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>cond_helper1</span><span> </span><span>mult_assoc</span><span> </span><span>test_pres2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"!q ⋅ (q ⋅ r1 ⋅ y1 + !q ⋅ r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ (q ⋅ !r1 + !q ⋅ !r2) = !q ⋅ (r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>local.test_comp_closed</span><span> </span><span>cond_helper2</span><span> </span><span>mult_assoc</span><span> </span><span>test_pres2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ q + !p ⋅ !q) ⋅ (q ⋅ x1 + !q ⋅ x2) ⋅ ((q ⋅ r1 + !q ⋅ r2) ⋅ (q ⋅ y1 + !q ⋅ y2))<span class="hidden">⇧</span><sup>†</sup> ⋅ !(q ⋅ r1 + !q ⋅ r2) =
        p ⋅ q ⋅ x1 ⋅ q ⋅ (q ⋅ r1 ⋅ y1 + !q ⋅ r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ (q ⋅ !r1 + !q ⋅ !r2) + !p ⋅ !q ⋅ x2 ⋅ !q ⋅ (q ⋅ r1 ⋅ y1 + !q ⋅ r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ (q ⋅ !r1 + !q ⋅ !r2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>cond_distr</span><span> </span><span>cond_distr_var</span><span> </span><span>local.test_dist_var2</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  p ⋅ q ⋅ x1 ⋅ (r1 ⋅ y1)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r1 + !p ⋅ !q ⋅  x2 ⋅ (r2 ⋅ y2)<span class="hidden">⇧</span><sup>†</sup> ⋅ !r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>b</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cond_distr</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nested_loops</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ x ⋅ ((p + q) ⋅ (q ⋅ y + !q ⋅ x))<span class="hidden">⇧</span><sup>†</sup> ⋅ !(p + q) + !p = (p ⋅ x ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ x ⋅ ((p + q) ⋅ (q ⋅ y + !q ⋅ x))<span class="hidden">⇧</span><sup>†</sup> ⋅ !(p + q) + !p = p ⋅ x ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ (!q ⋅ p ⋅ x ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup>)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ⋅ !p + !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.dagger_denest2</span><span> </span><span>local.test_distrib</span><span> </span><span>mult_assoc</span><span> </span><span>test_mult_comm_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  p ⋅ x ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ⋅ (p ⋅ x ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q)<span class="hidden">⇧</span><sup>†</sup>  ⋅ !p + !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.dagger_slide</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>postcomputation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y (!p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"!p ⋅ y + p ⋅ (p ⋅ x ⋅ (!p ⋅ y + p))<span class="hidden">⇧</span><sup>†</sup> ⋅ !p = (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x ⋅ (!p ⋅ y + p))<span class="hidden">⇧</span><sup>†</sup> ⋅ !p = p ⋅ (1 + p ⋅ x ⋅ ((!p ⋅ y + p) ⋅ p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ (!p ⋅ y + p)) ⋅ !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dagger_prod_unfold</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (p + p ⋅ p ⋅ x ⋅ ((!p ⋅ y + p) ⋅ p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ (!p ⋅ y + p)) ⋅ !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.mult_oner</span><span> </span><span>local.n_left_distrib_var</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p ⋅ x ⋅ (!p ⋅ y ⋅ p ⋅ x + p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ y ⋅ !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p ⋅ x ⋅ (!p ⋅ y ⋅ 0 + p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.annil</span><span> </span><span>local.test_comp_mult1</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p ⋅ x  ⋅ (p  ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ (!p ⋅ y ⋅ 0 ⋅ (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup>)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>add.commute</span><span> </span><span>dagger_denest2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (p ⋅ x ⋅ (!p ⋅ y + p))<span class="hidden">⇧</span><sup>†</sup> ⋅ !p = p ⋅ x ⋅ (p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.add_zeror</span><span> </span><span>local.annil</span><span> </span><span>local.dagger_prod_unfold</span><span> </span><span>local.dagger_slide</span><span> </span><span>local.mult_oner</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dagger_unfoldl_distr</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>composition_helper</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres x p"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ⋅ p = p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ⋅ p ≤ p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.test_restrictr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ q ⋅ x ≤ q ⋅ x ⋅ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.test_kat_2</span><span> </span><span>mult_assoc</span><span> </span><span>test_pres2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ≤ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.dagger_simr</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ≤ p ⋅ (q ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q ⋅ p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.eq_iff</span><span> </span><span>local.test_comp_closed</span><span> </span><span>local.test_kat_2</span><span> </span><span>local.test_mult_comm_var</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>composition</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test q"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pres y (!p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⋅ x)<span class="hidden">⇧</span><sup>†</sup> ⋅ !p ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q = !p ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q + p ⋅ (p ⋅ x ⋅ (!p ⋅ (q ⋅ y)<span class="hidden">⇧</span><sup>†</sup> ⋅ !q + p))<span class="hidden">⇧</span><sup>†</sup> ⋅ !p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>composition_helper</span><span> </span><span>local.test_comp_closed</span><span> </span><span>mult_assoc</span><span> </span><span>postcomputation</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Kleene algebras with tests form pre-Conway algebras, therefore the transformation theorem is valid for KAT as well.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kat</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pre_conway</span><span> </span><span>star</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Demonic refinement algebras form pre-Conway algebras, therefore the transformation theorem is valid for DRA as well.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>drat</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pre_conway</span><span> </span><span>strong_iteration</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.iteration_denest</span><span> </span><span>local.iteration_slide</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.iteration_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.iteration_sim</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We do not currently consider an expansion of probabilistic Kleene algebra.
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PHL_KAT">
<div class="head"><h1>Theory PHL_KAT</h1>
<span class="command">theory</span> <span class="name">PHL_KAT</span><br/>
<span class="keyword">imports</span> <a href="KAT.html"><span class="name">KAT</span></a> <a href="../Kleene_Algebra/PHL_KA.html"><span class="name">PHL_KA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Hoare Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PHL_KAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>KAT</span><span> </span><span>Kleene_Algebra.PHL_KA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a class of pre-dioids with notions of assertions, tests and iteration. The above rules of PHL are derivable in that class.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>at_pre_dioid</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_dioid_one</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>alpha</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"α"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"τ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>at_pres</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α x ⋅ τ y ≤ τ y ⋅ α x ⋅ τ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as_left_supdistl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"α x ⋅ (y + z) ≤ α x ⋅ y + α x ⋅ z"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Only the conditional and the iteration rule need to be considered (in addition to the export laws. 
In this context, they no longer depend on external assumptions. The other ones do not depend on any assumptions anyway.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_phl_cond</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α u ⋅ τ v ⋅ x ≤ x ⋅ z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α u ⋅ τ w ⋅ y ≤ y ⋅ z"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α u ⋅ (τ v ⋅ x + τ w ⋅ y) ≤ (τ v ⋅ x + τ w ⋅ y) ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>as_left_supdistl</span><span> </span><span>at_pres</span><span> </span><span>phl_cond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ht_at_phl_cond</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α u ⋅ τ v⦄ x ⦃z⦄"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α u ⋅ τ w⦄ y ⦃z⦄"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α u⦄ (τ v ⋅ x + τ w ⋅ y) ⦃z⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>at_phl_cond</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>ht_at_phl_export1</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α x ⋅ τ y⦄ z ⦃w⦄"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α x⦄ τ y ⋅ z ⦃w⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>at_pres</span><span> </span><span>ht_phl_export1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ht_at_phl_export2</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x⦄ y ⦃α z⦄"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x⦄ y ⋅ τ w ⦃α z ⋅ τ w⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>at_pres</span><span> </span><span>ht_phl_export2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>at_it_pre_dioid</span><span> </span><span class="delimiter">=</span><span> </span><span>at_pre_dioid</span><span> </span><span class="delimiter">+</span><span> </span><span>it_pre_dioid</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_phl_while</span><span class="delimiter">:</span><span>  
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α p ⋅ τ s ⋅ x ≤ x ⋅ α p"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α p ⋅ (it (τ s ⋅ x) ⋅ τ w)  ≤ it (τ s ⋅ x) ⋅ τ w ⋅ (α p ⋅ τ w)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>at_pres</span><span> </span><span>it_simr</span><span> </span><span>phl_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ht_at_phl_while</span><span class="delimiter">:</span><span>  
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α p ⋅ τ s⦄ x ⦃α p⦄"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃α p⦄ it (τ s ⋅ x) ⋅ τ w ⦃α p ⋅ τ w⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>at_phl_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following statements show that pre-Conway algebras, Kleene algebras with tests
and demonic refinement algebras form pre-dioids with test and assertions. This automatically
generates propositional Hoare logics for these structures.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>test_pre_dioid_zerol</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>phl</span><span class="delimiter">:</span><span> </span><span>at_pre_dioid</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>alpha</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. t x ⋅ t y ≤ t y ⋅ t x ⋅ t y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_mult_comm</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z. t x ⋅ (y + z) ≤ t x ⋅ y + t x ⋅ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_left_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>test_pre_conway</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>phl</span><span class="delimiter">:</span><span> </span><span>at_it_pre_dioid</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>alpha</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>it</span><span> </span><span class="delimiter">=</span><span> </span><span>dagger</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kat_zerol</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>phl</span><span class="delimiter">:</span><span> </span><span>at_it_pre_dioid</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>alpha</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>it</span><span> </span><span class="delimiter">=</span><span> </span><span>star</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>test_pre_dioid_zerol</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>if_then_else</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi ≡ (p ⋅ x + !p ⋅ y)"</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_n_cond</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃n v ⋅ n w⦄ x ⦃z⦄ ⟹ ⦃n v ⋅ t w⦄ y ⦃z⦄ ⟹ ⦃n v⦄ n w ⋅ x + t w ⋅ y ⦃z⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>phl.ht_at_phl_cond</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_test_cond</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃q⦄"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ !b⦄ y ⦃q⦄"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ b ⋅ x + !b ⋅ y ⦃q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>local.test_double_comp_var</span><span> </span><span>phl_n_cond</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_cond_syntax</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃q⦄"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ !b⦄ y ⦃q⦄"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ if b then x else y fi ⦃q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>phl_test_cond</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_cond_syntax_iff</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃q⦄ ∧ ⦃p ⋅ !b⦄ y ⦃q⦄ ⟷ ⦃p⦄ if b then x else y fi ⦃q⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃q⦄ ∧ ⦃p ⋅ !b⦄ y ⦃q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ if b then x else y fi ⦃q⦄"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>phl_test_cond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ if b then x else y fi ⦃q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ b ⋅ x ≤ b ⋅ p ⋅ (b ⋅ x + !b ⋅ y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.mult.assoc</span><span> </span><span>local.subdistl</span><span> </span><span>local.test_preserve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ b ⋅ (b ⋅ x + !b ⋅ y) ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>local.mult_isol</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"...  = (b ⋅ b ⋅ x + b ⋅ !b ⋅ y) ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.n_left_distrib_var</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = b ⋅ x ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ b ⋅ x ≤ x ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.order_trans</span><span> </span><span>local.test_restrictl</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ !b ⋅ y = !b ⋅ p ⋅ !b ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>local.test_preserve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ !b ⋅ p ⋅ (b ⋅ x + !b ⋅ y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.mult_isol</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ !b ⋅ (b ⋅ x + !b ⋅ y) ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>local.mult_isol</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (!b ⋅ b ⋅ x + !b ⋅ !b ⋅ y) ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.n_left_distrib</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = !b ⋅ y ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⋅ !b ⋅ y ≤ y ⋅ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.n_restrictl</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃q⦄ ∧ ⦃p ⋅ !b⦄ y ⦃q⦄"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>test_pre_conway</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>phl_n_while</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x ⋅  n y⦄ z ⦃n x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x⦄ (n y ⋅ z)<span class="hidden">⇧</span><sup>†</sup> ⋅ t y ⦃n x ⋅ t y⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl.ht_at_phl_while</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>kat_zerol</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while b do x od ≡ (b ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ !b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>phl_n_while</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x ⋅  n y⦄ z ⦃n x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x⦄ (n y ⋅ z)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ t y ⦃n x ⋅ t y⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl.ht_at_phl_while</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_test_while</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃p⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ (b ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ !b ⦃p ⋅ !b⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl_n_while</span><span> </span><span>test_double_comp_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_while_syntax</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃p⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ while b do x od ⦃p ⋅ !b⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl_test_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ p ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ p ⟹ p ⋅ x ≤ x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test b ⟹ p ⋅ (b ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ !b ≤ (b ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ !b ⋅ p ⋅ !b ⟹ p ⋅ b ⋅ x ≤ x ⋅ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹  p ⋅ x ⋅ y ≤ x ⋅ y ⋅ q ⟹(∃r. test r ∧ p ⋅ x ≤ x ⋅ r ∧ r ⋅ y  ≤ y ⋅ q)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span>  </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"test p ⟹ test q ⟹  p ⋅ x ⋅ y ⋅ !q = 0 ⟹(∃r. test r ∧ p ⋅ x ⋅ !r = 0 ∧ r ⋅ y ⋅ !q = 0)"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following facts should be moved. They show that the rules of Hoare logic based on Tarlecki triples are invertible.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>near_dioid</span><span class="delimiter">)</span><span> </span><span>tt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦇_⦈_⦇_⦈"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦇x⦈ y ⦇z⦈ ≡ x ⋅ y ≤ z"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>near_dioid_one</span><span class="delimiter">)</span><span> </span><span>tt_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇p⦈ 1 ⦇p⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>near_dioid</span><span class="delimiter">)</span><span> </span><span>tt_cons1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃q'. ⦇p⦈ x ⦇q'⦈ ∧ q'≤ q) ⟷ ⦇p⦈ x ⦇q⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.order_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>near_dioid</span><span class="delimiter">)</span><span> </span><span>tt_cons2</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃p'. ⦇p'⦈ x ⦇q⦈ ∧ p ≤ p') ⟷ ⦇p⦈ x ⦇q⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.mult_isor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>near_dioid</span><span class="delimiter">)</span><span> </span><span>tt_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃r. ⦇p⦈ x ⦇r⦈ ∧ ⦇r⦈ y ⦇q⦈) ⟷ ⦇p⦈ x ⋅ y ⦇q⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.tt_cons2</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid</span><span class="delimiter">)</span><span> </span><span>tt_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇p ⋅ v⦈ x ⦇q⦈ ∧ ⦇p ⋅ w⦈ y ⦇q⦈ ⟷ ⦇p⦈ (v ⋅ x + w ⋅ y)⦇q⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.distrib_left</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kleene_algebra</span><span class="delimiter">)</span><span> </span><span>tt_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w ≤ 1 ⟹ ⦇p ⋅ v⦈ x ⦇p⦈ ⟹ ⦇p⦈ (v ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ w ⦇p⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.star_inductr_var_equiv</span><span> </span><span>local.star_subid</span><span> </span><span>local.tt_seq</span><span> </span><span>local.tt_skip</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The converse implication can be refuted. The situation is similar to the ht case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span>tt_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test v ⟹  ⦇p⦈ (v ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ !v ⦇p⦈ ⟹ ⦇p ⋅ v⦈ x ⦇p⦈"</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick *)</span></span></span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span>tt_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test v ⟹  ⦇p⦈ (v ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>  ⦇p⦈ ⟹ ⦇p ⋅ v⦈ x ⦇p⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.star_inductr_var_equiv</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Perhaps this holds with possibly infinite loops in DRA...›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wlp in KAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>kat</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"test y ⟹ (∃ z. test z ∧ z ⋅ x ⋅ !y = 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.annil</span><span> </span><span>local.test_zero_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>                                                                                             
</span><span>
</span></pre>
</div>
</div><div id="PHL_DRAT">
<div class="head"><h1>Theory PHL_DRAT</h1>
<span class="command">theory</span> <span class="name">PHL_DRAT</span><br/>
<span class="keyword">imports</span> <a href="DRAT.html"><span class="name">DRAT</span></a> <a href="../Kleene_Algebra/PHL_DRA.html"><span class="name">PHL_DRA</span></a> <a href="PHL_KAT.html"><span class="name">PHL_KAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene algebra with tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Hoare Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PHL_DRAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>DRAT</span><span> </span><span>Kleene_Algebra.PHL_DRA</span><span> </span><span>PHL_KAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>drat</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>phl</span><span class="delimiter">:</span><span> </span><span>at_it_pre_dioid</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>alpha</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tau</span><span> </span><span class="delimiter">=</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>it</span><span> </span><span class="delimiter">=</span><span> </span><span>strong_iteration</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>drat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>while</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while b do x od ≡ (b ⋅ x)<span class="hidden">⇧</span><sup>∞</sup> ⋅ !b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>phl_n_while</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x ⋅  n y⦄ z ⦃n x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃n x⦄ (n y ⋅ z)<span class="hidden">⇧</span><sup>∞</sup> ⋅ t y ⦃n x ⋅ t y⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl.ht_at_phl_while</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_test_while</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃p⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ (b ⋅ x)<span class="hidden">⇧</span><sup>∞</sup> ⋅ !b ⦃p ⋅ !b⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl_n_while</span><span> </span><span>test_double_comp_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phl_while_syntax</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p ⋅ b⦄ x ⦃p⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ while b do x od ⦃p ⋅ !b⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>phl_test_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="KAT2">
<div class="head"><h1>Theory KAT2</h1>
<span class="command">theory</span> <span class="name">KAT2</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/Kleene_Algebra.html"><span class="name">Kleene_Algebra</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Kleene Algebra with Tests
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two sorted Kleene Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KAT2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.Kleene_Algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  As an alternative to the one-sorted implementation of tests, we provide a two-sorted, more 
  conventional one. In this setting, Isabelle's Boolean algebra theory can be used.
  This alternative can be developed further along the lines of the one-sorted implementation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_kat"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"`_`"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
val kat_test_vars = ["p","q","r","s","t","p'","q'","r'","s'","t'","p''","q''","r''","s''","t''"]

fun map_ast_variables ast =
  case ast of
    (Ast.Variable v) =&gt;
      if exists (fn tv =&gt; tv = v) kat_test_vars
      then Ast.Appl [Ast.Variable "test", Ast.Variable v]
      else Ast.Variable v
  | (Ast.Constant c) =&gt; Ast.Constant c
  | (Ast.Appl []) =&gt; Ast.Appl []
  | (Ast.Appl (f :: xs)) =&gt; Ast.Appl (f :: map map_ast_variables xs)

structure KATHomRules = Named_Thms
  (val name = @{binding "kat_hom"}
   val description = "KAT test homomorphism rules")

fun kat_hom_tac ctxt n =
  let
    val rev_rules = map (fn thm =&gt; thm RS @{thm sym}) (KATHomRules.get ctxt)
  in
    asm_full_simp_tac (put_simpset HOL_basic_ss ctxt addsimps rev_rules) n
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KATHomRules.setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (CHANGED (kat_hom_tac ctxt 1)))
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_ast_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
let
  fun kat_tr ctxt [t] = map_ast_variables t
in [(@{syntax_const "_kat"}, kat_tr)] end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure VCGRules = Named_Thms
  (val name = @{binding "vcg"}
   val description = "verification condition generator rules")

fun vcg_tac ctxt n =
  let
    fun vcg' [] = no_tac
      | vcg' (r :: rs) = resolve_tac ctxt [r] n ORELSE vcg' rs;
  in REPEAT (CHANGED
       (kat_hom_tac ctxt n
        THEN REPEAT (vcg' (VCGRules.get ctxt))
        THEN kat_hom_tac ctxt n
        THEN TRY (resolve_tac ctxt @{thms order_refl} n ORELSE asm_full_simp_tac (put_simpset HOL_basic_ss ctxt) n)))
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>vcg</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (CHANGED (vcg_tac ctxt 1)))
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹VCGRules.setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dioid_tests</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>test</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::boolean_algebra ⇒ 'b::dioid_one_zerol"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::dioid_one_zerol ⇒ 'b::dioid_one_zerol"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"-"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>test_sup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (sup p q) = `p + q`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_inf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (inf p q) = `p ⋅ q`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_top</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test top = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_bot</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test bot = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (- p) = `-p`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_iso_eq</span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ q ⟷ `p ≤ q`"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>test</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ι"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq</span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q ⟷ `p = q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map (fn thm =&gt; thm RS @{thm sym}) (KATHomRules.get @{context})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ q ⟹ `p ≤ q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Import lemmas and modify them to fit KAT syntax *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_meet_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ q = q ⋅ p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>inf_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>test_one_top</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>top_greatest</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`-p + p = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compl_sup_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p + (-p) = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sup_compl_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`(-p) ⋅ p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.commute</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ (-p) = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kat</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>test</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::boolean_algebra ⇒ 'b::kleene_algebra"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::kleene_algebra ⇒ 'b::kleene_algebra"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"!"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>is_dioid_tests</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dioid_tests test not"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kat</span><span> </span><span class="delimiter">⊆</span><span> </span><span>dioid_tests</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_dioid_tests</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>kat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>test</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ι"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq</span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q ⟷ `p = q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map (fn thm =&gt; thm RS @{thm sym}) (KATHomRules.get @{context})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ q ⟹ `p ≤ q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Import lemmas and modify them to fit KAT syntax *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_meet_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ q = q ⋅ p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>inf_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>test_one_top</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>top_greatest</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_star</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p<span class="hidden">⇧</span><sup>⋆</sup> = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>star_subid</span><span> </span><span>test_iso</span><span> </span><span>test_top</span><span> </span><span>top_greatest</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_star</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p + p = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compl_sup_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p + !p = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sup_compl_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p ⋅ p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.commute</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ !p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hoare_triple</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'b ⇒ 'b ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ _ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃p⦄ c ⦃q⦄ ≡ p⋅c ≤ c⋅q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>hoare_triple_def</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_triple_def_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅c ≤ c⋅q ⟷ p⋅c⋅!q = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"`c ⋅ q ⋅ !q`"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_isor</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅c⋅(!q + q)`"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span> </span><span>add_zerol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"`1 ⋅ c ⋅ q`"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_isor</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>star_sim2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_weakening</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ p' ⟹ q' ≤ q ⟹ `⦃p'⦄ c ⦃q'⦄` ⟹ `⦃p⦄ c ⦃q⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isol</span><span> </span><span>mult_isor</span><span> </span><span>order_trans</span><span> </span><span>test_iso</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p⦄ c ⦃p⦄` ⟹ `⦃p⦄ c<span class="hidden">⇧</span><sup>⋆</sup> ⦃p⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hoare_weakening</span><span class="delimiter">[</span><span>OF</span><span> </span><span>order_refl</span><span> </span><span>_</span><span> </span><span>hoare_star</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_test</span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ t ≤ q` ⟹ `⦃p⦄ t ⦃q⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_le2</span><span> </span><span>le_inf_iff</span><span> </span><span>test_inf</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_mult</span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p⦄ x ⦃r⦄` ⟹ `⦃r⦄ y ⦃q⦄` ⟹ `⦃p⦄ x⋅y ⦃q⦄`"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ x ≤ x ⋅ r`"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`r ⋅ y ≤ y ⋅ q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ (x ⋅ y) ≤ x ⋅ r ⋅ y`"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_isor</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"`... ≤ x ⋅ y ⋅ q`"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.assoc</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_isol</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ (x ⋅ y) ≤ x ⋅ y ⋅ q`"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p ⋅ !p = !p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.idem</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_plus</span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p⦄ x ⦃q⦄` ⟹ `⦃p⦄ y ⦃q⦄` ⟹ `⦃p⦄ x + y ⦃q⦄`"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ι p⦄ x ⦃ι q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ι p⦄ y ⦃ι q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ι p ⋅ (x + y) ≤ x ⋅ ι q + y ⋅ ι q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>distrib_left</span><span> </span><span>hoare_triple_def</span><span> </span><span>join.sup.mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>While</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'b ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"While _ Do _ End"</span></span></span><span> </span><span class="delimiter">[</span><span>50</span><span class="delimiter">,</span><span>50</span><span class="delimiter">]</span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"While t Do c End = (t⋅c)<span class="hidden">⇧</span><sup>⋆</sup>⋅!t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p ⋅ t⦄ c ⦃p⦄` ⟹ `⦃p⦄ While t Do c End ⦃!t ⋅ p⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>While_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p ⋅ t⦄ c ⦃p⦄` ⟹ `!t ⋅ p ≤ q` ⟹ `⦃p⦄ While t Do c End ⦃q⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hoare_weakening</span><span> </span><span>hoare_while</span><span> </span><span>order_refl</span><span> </span><span>test_inf</span><span> </span><span>test_iso_eq</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>If</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'b ⇒ 'b ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"If _ Then _ Else _"</span></span></span><span> </span><span class="delimiter">[</span><span>50</span><span class="delimiter">,</span><span>50</span><span class="delimiter">,</span><span>50</span><span class="delimiter">]</span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"If p Then c1 Else c2 ≡ p⋅c1 + !p⋅c2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_if</span><span> </span><span class="delimiter">[</span><span>vcg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`⦃p ⋅ t⦄ c1 ⦃q⦄` ⟹ `⦃p ⋅ !t⦄ c2 ⦃q⦄` ⟹ `⦃p⦄ If t Then c1 Else c2 ⦃q⦄`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>If_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span> </span><span>assumption</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DRAT2">
<div class="head"><h1>Theory DRAT2</h1>
<span class="command">theory</span> <span class="name">DRAT2</span><br/>
<span class="keyword">imports</span> <a href="../Kleene_Algebra/DRA.html"><span class="name">DRA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Demonic refinement algebra
   Author:     Alasdair Armstrong, Victor B. F. Gomes, Georg Struth
   Maintainer: Georg Struth &lt;g.struth at sheffield.ac.uk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two sorted Demonic Refinement Algebras›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DRAT2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Kleene_Algebra.DRA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  As an alternative to the one-sorted implementation of demonic refinement algebra with tests, 
  we provide a two-sorted, more conventional one.
  This alternative can be developed further along the lines of the one-sorted implementation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_dra"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"`_`"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
val dra_test_vars = ["p","q","r","s","t","p'","q'","r'","s'","t'","p''","q''","r''","s''","t''"]

fun map_ast_variables ast =
  case ast of
    (Ast.Variable v) =&gt;
      if exists (fn tv =&gt; tv = v) dra_test_vars
      then Ast.Appl [Ast.Variable "test", Ast.Variable v]
      else Ast.Variable v
  | (Ast.Constant c) =&gt; Ast.Constant c
  | (Ast.Appl []) =&gt; Ast.Appl []
  | (Ast.Appl (f :: xs)) =&gt; Ast.Appl (f :: map map_ast_variables xs)

structure DRAHomRules = Named_Thms
  (val name = @{binding "kat_hom"}
   val description = "KAT test homomorphism rules")

fun dra_hom_tac ctxt n =
  let
    val rev_rules = map (fn thm =&gt; thm RS @{thm sym}) (DRAHomRules.get ctxt)
  in
    asm_full_simp_tac (put_simpset HOL_basic_ss ctxt addsimps rev_rules) n
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹DRAHomRules.setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (CHANGED (dra_hom_tac ctxt 1)))
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_ast_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
let
  fun dra_tr ctxt [t] = map_ast_variables t
in [(@{syntax_const "_dra"}, dra_tr)] end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure VCGRules = Named_Thms
  (val name = @{binding "vcg"}
   val description = "verification condition generator rules")

fun vcg_tac ctxt n =
  let
    fun vcg' [] = no_tac
      | vcg' (r :: rs) = resolve_tac ctxt [r] n ORELSE vcg' rs;
  in REPEAT (CHANGED
       (dra_hom_tac ctxt n
        THEN REPEAT (vcg' (VCGRules.get ctxt))
        THEN dra_hom_tac ctxt n
        THEN TRY (resolve_tac ctxt @{thms order_refl} n ORELSE asm_full_simp_tac (put_simpset HOL_basic_ss ctxt) n)))
  end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>vcg</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (CHANGED (vcg_tac ctxt 1)))
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹VCGRules.setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>drat</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>test</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::boolean_algebra ⇒ 'b::dra"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::dra ⇒ 'b::dra"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"!"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>test_sup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (sup p q) = `p + q`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_inf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (inf p q) = `p ⋅ q`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_top</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test top = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_bot</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test bot = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_not</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"test (- p) = `!p`"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_iso_eq</span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ q ⟷ `p ≤ q`"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>test</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ι"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq</span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q ⟷ `p = q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_iff</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map (fn thm =&gt; thm RS @{thm sym}) (DRAHomRules.get @{context})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ q ⟹ `p ≤ q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_iso_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_meet_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ q = q ⋅ p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>inf_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>test_one_top</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>top_greatest</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_star</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p<span class="hidden">⇧</span><sup>⋆</sup> = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>star_subid</span><span> </span><span>test_iso</span><span> </span><span>test_top</span><span> </span><span>top_greatest</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>kat_hom</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_star</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_add1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p + p = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>compl_sup_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_add2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p + !p = 1`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>kat_hom</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sup_compl_top</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_mult1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p ⋅ p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.commute</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_comp_mult2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p ⋅ !p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`y ≤ x` ⟷ `p⋅y ≤ x` ∧ `!p⋅y ≤ x`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isol_var</span><span> </span><span>mult_onel</span><span> </span><span>test_not</span><span> </span><span>test_one_top</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"`(p + !p)⋅y ≤ x`"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_onel</span><span> </span><span>sup_compl_top</span><span> </span><span>test_not</span><span> </span><span>test_sup</span><span> </span><span>test_top</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right'</span><span> </span><span>join.sup.bounded_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅x = p⋅x⋅q` ⟹ `p⋅x⋅!q = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅x⋅!q = 0` ⟹ `p⋅x = p⋅x⋅q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_0_left</span><span> </span><span>distrib_left</span><span> </span><span>mult_oner</span><span> </span><span>test_comp_add1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅q⋅p = p⋅q`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.commute</span><span> </span><span>inf.left_idem</span><span> </span><span>test_inf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅q⋅!p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.assoc</span><span> </span><span>inf.idem</span><span> </span><span>inf.left_commute</span><span> </span><span>inf_compl_bot</span><span> </span><span>test_bot</span><span> </span><span>test_inf</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p⋅q⋅p = 0`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>double_compl</span><span> </span><span>test3</span><span> </span><span>test_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_correctness</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅x⋅!q = 0` ⟷ `x⋅!q ≤ !p⋅⊤`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>join.bot.extremum</span><span> </span><span>mult.assoc</span><span> </span><span>test_eq1</span><span> </span><span>top_elim</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>add_zeror</span><span> </span><span>annil</span><span> </span><span>less_eq_def</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>test_comp_mult2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iteration_sim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`p⋅x ≤ x⋅p` ⟹ `p⋅x<span class="hidden">⇧</span><sup>∞</sup> ≤ x<span class="hidden">⇧</span><sup>∞</sup>⋅p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>iteration_sim</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_iteration_annir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"`!p⋅(p⋅x)<span class="hidden">⇧</span><sup>∞</sup> = !p`"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annil</span><span> </span><span>iteration_idep</span><span> </span><span>mult.assoc</span><span> </span><span>test_comp_mult1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>