<div id="Model">
<div class="head"><h1>Theory Model</h1>
<span class="command">theory</span> <span class="name">Model</span><br/>
<span class="keyword">imports</span> <a href="../ConcurrentIMP/CIMP.html"><span class="name">CIMP</span></a> <a href="../../HOL/HOL-Library/Monad_Syntax.html"><span class="name">Monad_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Model</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>ConcurrentIMP.CIMP</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Monad_Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Schism garbage collector \label{sec:gc-model}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The following formalises Figures~2.8 (‹mark_object_fn›),
2.9 (load and store but not alloc), and 2.15 (garbage collector) of
@{cite [cite_macro=citet] "Pizlo201xPhd"}; see also @{cite
[cite_macro=citet] "Pizlo+2010PLDI"}.

We additionally need to model TSO memory, the handshakes and
compare-and-swap (\texttt{CAS}).  We closely model things where
interference is possible and abstract everything else.

\textbf{\emph{NOTE}: this model is for TSO \emph{only}. We elide any details
irrelevant for that memory model.}

We begin by defining the types of the various parts. Our program
locations are labelled with strings for readability. We enumerate the
names of the processes in our system. The safety proof treats an
arbitary (unbounded) number of mutators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>location</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"char list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'mut</span><span> </span><span>process_name</span><span> </span><span class="delimiter">=</span><span> </span><span>mutator</span><span> </span><span class="tfree">'mut</span><span> </span><span class="delimiter">|</span><span> </span><span>gc</span><span> </span><span class="delimiter">|</span><span> </span><span>sys</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The garbage collection process can be in one of the following phases.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>gc_phase</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>ph_Idle</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ph_Init</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ph_Mark</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ph_Sweep</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The garbage collector instructs mutators to perform certain actions,
and blocks until the mutators signal these actions are done. The
mutators always respond with their work list (a set of
references). The handshake can be of one of the specified types.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>handshake_type</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>ht_NOOP</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ht_GetRoots</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ht_GetWork</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We track how many \texttt{noop} and \texttt{get\_roots} handshakes
each process has participated in as ghost state. See
\S\ref{sec:gc_ragged_safepoints}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>handshake_phase</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>hp_Idle</span><span> </span><span class="comment">―‹ done 1 noop ›</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>hp_IdleInit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>hp_InitMark</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>hp_Mark</span><span> </span><span class="comment">―‹ done 4 noops ›</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>hp_IdleMarkSweep</span><span> </span><span class="comment">―‹ done get roots ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_phase ⇒ handshake_phase"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_step ph ≡ case ph of
       hp_Idle          ⇒ hp_IdleInit
     | hp_IdleInit      ⇒ hp_InitMark
     | hp_InitMark      ⇒ hp_Mark
     | hp_Mark          ⇒ hp_IdleMarkSweep
     | hp_IdleMarkSweep ⇒ hp_Idle"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

An object consists of a garbage collection mark and a function that maps
its fields to values. A value is either a reference or \texttt{NULL}.

  @{typ "'field"} is the abstract type of fields.
  @{typ "'ref"} is the abstract type of object references.
  @{typ "'mut"} is the abstract type of the mutators' names.

For simplicity we assume all objects define all fields and ignore all
non-reference payload in objects.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>gc_mark</span><span> </span><span class="delimiter">=</span><span> </span><span>bool</span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>object</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>obj_mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark"</span></span></span><span>
</span><span>  </span><span>obj_fields</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'field ⇒ 'ref option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The TSO store buffers track write actions, represented by ‹('field, 'ref) mem_write_action›.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>mem_write_action</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>mw_Mark</span><span> </span><span class="tfree">'ref</span><span> </span><span>gc_mark</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mw_Mutate</span><span> </span><span class="tfree">'ref</span><span> </span><span class="tfree">'field</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref option"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mw_fA</span><span> </span><span>gc_mark</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mw_fM</span><span> </span><span>gc_mark</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mw_Phase</span><span> </span><span>gc_phase</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following record is the type of all processes's local states. For
the mutators and the garbage collector, consider these to be local
variables or registers.

The system's ‹fA›, ‹fM›, ‹phase› and ‹heap› variables are subject to the TSO memory model, as are all heap
operations.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>local_state</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment">― ‹System-specific fields›</span><span>
</span><span>  </span><span>heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'ref) object option"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹TSO memory state›</span><span>
</span><span>  </span><span>mem_write_buffers</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name ⇒ ('field, 'ref) mem_write_action list"</span></span></span><span>
</span><span>  </span><span>mem_lock</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name option"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹The state of the handshakes›</span><span>
</span><span>  </span><span>handshake_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_type"</span></span></span><span>
</span><span>  </span><span>handshake_pending</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Ghost state›</span><span>
</span><span>  </span><span>ghost_handshake_in_sync</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut ⇒ bool"</span></span></span><span>
</span><span>  </span><span>ghost_handshake_phase</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_phase"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Mutator-specific temporaries›</span><span>
</span><span>  </span><span>new_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref option"</span></span></span><span>
</span><span>  </span><span>roots</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>  </span><span>ghost_honorary_root</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Garbage collector-specific temporaries›</span><span>
</span><span>  </span><span>field_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'field set"</span></span></span><span>
</span><span>  </span><span>mut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut"</span></span></span><span>
</span><span>  </span><span>muts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut set"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Local variables used by multiple processes›</span><span>
</span><span>  </span><span>fA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark"</span></span></span><span>
</span><span>  </span><span>fM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark"</span></span></span><span>
</span><span>  </span><span>cas_mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark option"</span></span></span><span>
</span><span>  </span><span>field</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'field"</span></span></span><span>
</span><span>  </span><span>mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark option"</span></span></span><span>
</span><span>  </span><span>phase</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_phase"</span></span></span><span>
</span><span>  </span><span>tmp_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref"</span></span></span><span>
</span><span>  </span><span>ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref option"</span></span></span><span>
</span><span>  </span><span>refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>  </span><span>W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Ghost state›</span><span>
</span><span>  </span><span>ghost_honorary_grey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

An action is a request by a mutator or the garbage collector to the
system.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>mem_read_action</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>mr_Ref</span><span> </span><span class="tfree">'ref</span><span> </span><span class="tfree">'field</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mr_Mark</span><span> </span><span class="tfree">'ref</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mr_Phase</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mr_fM</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mr_fA</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>request_op</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>ro_MFENCE</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Read</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_read_action"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Write</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Lock</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Unlock</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Alloc</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_Free</span><span> </span><span class="tfree">'ref</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_gc_set_type</span><span> </span><span>handshake_type</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_gc_set_pending</span><span> </span><span class="tfree">'mut</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_gc_read_pending</span><span> </span><span class="tfree">'mut</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_gc_load_W</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_mut_read_type</span><span> </span><span>handshake_type</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ro_hs_mut_done</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ReadfM ≡ ro_Read mr_fM"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ReadMark r ≡ ro_Read (mr_Mark r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ReadPhase ≡ ro_Read mr_Phase"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ReadRef r f ≡ ro_Read (mr_Ref r f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WritefA m ≡ ro_Write (mw_fA m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WritefM m ≡ ro_Write (mw_fM m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WriteMark r m ≡ ro_Write (mw_Mark r m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WritePhase ph ≡ ro_Write (mw_Phase ph)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"WriteRef r f r' ≡ ro_Write (mw_Mutate r f r')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>request</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name × ('field, 'mut, 'ref) request_op"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>response</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>mv_Bool</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mv_Mark</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark option"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mv_Phase</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_phase"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mv_Ref</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref option"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mv_Refs</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref set"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>mv_Void</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We instantiate CIMP's types as follows:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_com</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) response, location, ('field, 'mut, 'ref) request, ('field, 'mut, 'ref) local_state) com"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_loc_comp</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) response, location, ('field, 'mut, 'ref) request, ('field, 'mut, 'ref) local_state) loc_comp"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_pred_state</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) response, location, 'mut process_name, ('field, 'mut, 'ref) request, ('field, 'mut, 'ref) local_state) pred_state"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_pred</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) response, location, 'mut process_name, ('field, 'mut, 'ref) request, ('field, 'mut, 'ref) local_state) pred"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_system</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) response, location, 'mut process_name, ('field, 'mut, 'ref) request, ('field, 'mut, 'ref) local_state) system"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_event</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) request × ('field, 'ref) response"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>gc_history</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_event list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>lst_pred</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) local_state ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>lsts</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name ⇒ ('field, 'mut, 'ref) local_state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'field</span><span class="delimiter">,</span><span> </span><span class="tfree">'mut</span><span class="delimiter">,</span><span> </span><span class="tfree">'ref</span><span class="delimiter">)</span><span> </span><span>lsts_pred</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We use one locale per process to define a namespace for definitions
local to these processes. Mutator definitions are parametrised by the
mutator's identifier ‹m›. We never interpret these locales; we
use their contents typically by prefixing their names the locale
name. This might be considered an abuse. The attributes depend on
locale scoping somewhat, which is a mixed blessing.

If we have more than one mutator then we need to show that mutators do
not mutually interfere. To that end we define an extra locale that
contains these proofs.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>mut_m</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut"</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>mut_m'</span><span> </span><span class="delimiter">=</span><span> </span><span>mut_m</span><span> </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut"</span></span></span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mm'</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gc</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>sys</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Object marking \label{sec:gc-marking}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Both the mutators and the garbage collector mark references, which
indicates that a reference is live in the current round of
collection. This operation is defined in @{cite [cite_macro=citet]
‹Figure~2.8› "Pizlo201xPhd"}. These definitions are
parameterised by the name of the process.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lock</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lock l ≡ ⦃l⦄ Request (λs. (p, ro_Lock)) (λ_ s. {s})"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>lock</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ lock"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>unlock</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unlock l ≡ ⦃l⦄ Request (λs. (p, ro_Unlock)) (λ_ s. {s})"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>unlock</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ unlock"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>read_mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref)
              ⇒ ((gc_mark option ⇒ gc_mark option)
                 ⇒ ('field, 'mut, 'ref) local_state
                 ⇒ ('field, 'mut, 'ref) local_state) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"read_mark l r upd ≡ ⦃l⦄ Request (λs. (p, ReadMark (r s))) (λmv s. { upd ⟨m⟩ s |m. mv = mv_Mark m })"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>read_mark</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ read'_mark"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>read_fM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"read_fM l ≡ ⦃l⦄ Request (λs. (p, ro_Read mr_fM)) (λmv s. { s⦇fM := m⦈ |m. mv = mv_Mark (Some m) })"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>read_fM</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ read'_fM"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>read_phase</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"read_phase l ≡ ⦃l⦄ Request (λs. (p, ReadPhase)) (λmv s. { s⦇phase := ph⦈ |ph. mv = mv_Phase ph })"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>read_phase</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ read'_phase"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>write_mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref) ⇒ (('field, 'mut, 'ref) local_state ⇒ bool) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"write_mark l r fl ≡ ⦃l⦄ Request (λs. (p, WriteMark (r s) (fl s))) (λ_ s. { s⦇ ghost_honorary_grey := {r s} ⦈ })"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>write_mark</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ write'_mark"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>add_to_W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"add_to_W l r ≡ ⦃l⦄ ⌊λs. s⦇ W := W s ∪ {r s}, ghost_honorary_grey := {} ⦈⌋"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>add_to_W</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ add'_to'_W"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The reference we're marking is given in @{const "ref"}. If the current
process wins the \texttt{CAS} race then the reference is marked and
added to the local work list @{const "W"}.

TSO means we cannot avoid having the mark write pending in a store
buffer; in other words, we cannot have objects atomically transition
from white to grey. The following scheme blackens a white object, and
then reverts it to grey. The @{const "ghost_honorary_grey"} variable
is used to track objects undergoing this transition.

As CIMP provides no support for function calls, we prefix each
statement's label with a string from its callsite.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mark_object_fn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mark_object_fn l ≡
     ⦃l @ ''_mo_null''⦄ IF <span class="hidden">❙</span><span class="bold">¬</span> (NULL ref) THEN
       ⦃l @ ''_mo_mark''⦄ read_mark (the ∘ ref) mark_update ;;
       ⦃l @ ''_mo_fM''⦄ read_fM ;;
       ⦃l @ ''_mo_mtest''⦄ IF mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ fM THEN
         ⦃l @ ''_mo_phase''⦄ read_phase ;;
         ⦃l @ ''_mo_ptest''⦄ IF phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩ THEN
           ― ‹CAS: claim object›
           ⦃l @ ''_mo_co_lock''⦄ lock ;;
           ⦃l @ ''_mo_co_cmark''⦄ read_mark (the ∘ ref) cas_mark_update ;;
           ⦃l @ ''_mo_co_ctest''⦄ IF cas_mark <span class="hidden">❙</span><span class="bold">=</span> mark THEN
             ⦃l @ ''_mo_co_mark''⦄ write_mark (the ∘ ref) fM
           FI ;;
           ⦃l @ ''_mo_co_unlock''⦄ unlock ;;
           ⦃l @ ''_mo_co_won''⦄ IF cas_mark <span class="hidden">❙</span><span class="bold">=</span> mark THEN
             ⦃l @ ''_mo_co_W''⦄ add_to_W (the ∘ ref)
           FI
         FI
       FI
     FI"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The worklists (field @{term "W"}) are not subject to TSO. As we later
show (\S\ref{def:valid_W_inv}), these are disjoint and hence
operations on these are private to each process, with the sole
exception of when the GC requests them from the mutators. We describe
that mechanism next.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Handshakes \label{sec:gc_ragged_safepoints}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The garbage collector needs to synchronise with the mutators. In
practice this is implemented with some thread synchronisation
primitives that include memory fences. The scheme we adopt here has
the GC busy waiting. It sets a ‹pending› flag for each mutator
and then waits for each to respond.

The system side of the interface collects the responses from the
mutators into a single worklist, which acts as a proxy for the garbage
collector's local worklist during ‹get_roots› and ‹get_work› handshakes. In practise this involves a \texttt{CAS}
operation. We carefully model the effect these handshakes have on the
process's TSO buffers.

The system and mutators track handshake phases using ghost state.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hp_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_type ⇒ handshake_phase ⇒ handshake_phase"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hp_step ht ≡
     case ht of
         ht_NOOP ⇒ handshake_step
       | ht_GetRoots ⇒ handshake_step
       | ht_GetWork ⇒ id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>sys</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake ≡
     ⦃''sys_hs_gc_set_type''⦄ Response
        (λreq s. { (s⦇ handshake_type := ht,
                       ghost_handshake_in_sync := ⟨False⟩,
                       ghost_handshake_phase := hp_step ht (ghost_handshake_phase s) ⦈,
                    mv_Void)
                 |ht. req = (gc, ro_hs_gc_set_type ht) })
   ⊔ ⦃''sys_hs_gc_mut_reqs''⦄ Response
        (λreq s. { (s⦇ handshake_pending := (handshake_pending s)(m := True) ⦈, mv_Void)
                 |m. req = (gc, ro_hs_gc_set_pending m) })
   ⊔ ⦃''sys_hs_gc_done''⦄ Response
        (λreq s. { (s, mv_Bool (¬handshake_pending s m))
                 |m. req = (gc, ro_hs_gc_read_pending m) })
   ⊔ ⦃''sys_hs_gc_load_W''⦄ Response
        (λreq s. { (s⦇ W := {} ⦈, mv_Refs (W s))
                 |_::unit. req = (gc, ro_hs_gc_load_W) })
   ⊔ ⦃''sys_hs_mut''⦄ Response
        (λreq s. { (s, mv_Void)
                 |m. req = (mutator m, ro_hs_mut_read_type (handshake_type s))
                     ∧ handshake_pending s m })
   ⊔ ⦃''sys_hs_mut_done''⦄ Response
        (λreq s. { (s⦇ handshake_pending := (handshake_pending s)(m := False),
                       W := W s ∪ W',
                       ghost_handshake_in_sync := (ghost_handshake_in_sync s)(m := True) ⦈,
                    mv_Void)
                 |m W'. req = (mutator m, ro_hs_mut_done W') })"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The mutator's side of the interface. Also updates the ghost state
tracking the handshake state for @{const "ht_NOOP"} and @{const
"ht_GetRoots"} but not @{const "ht_GetWork"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>mut_m</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mark_object</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ mark'_object"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ mark_object ≡ mark_object_fn (mutator m) l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mfence</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ MFENCE"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ MFENCE ≡ ⦃l⦄ Request (λs. (mutator m, ro_MFENCE)) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hs_read_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ handshake_type ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ hs'_read'_type"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ hs_read_type ht ≡ ⦃l⦄ Request (λs. (mutator m, ro_hs_mut_read_type ht)) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hs_noop_done</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ hs'_noop'_done"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ hs_noop_done ≡ ⦃l⦄ Request (λs. (mutator m, ro_hs_mut_done {}))
                                  (λ_ s. {s⦇ ghost_handshake_phase := handshake_step (ghost_handshake_phase s) ⦈})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hs_get_roots_done</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref set) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ hs'_get'_roots'_done"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ hs_get_roots_done wl ≡ ⦃l⦄ Request (λs. (mutator m, ro_hs_mut_done (wl s)))
                                          (λ_ s. {s⦇ W := {}, ghost_handshake_phase := handshake_step (ghost_handshake_phase s) ⦈})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hs_get_work_done</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref set) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ hs'_get'_work'_done"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ hs_get_work_done wl ≡ ⦃l⦄ Request (λs. (mutator m, ro_hs_mut_done (wl s)))
                                         (λ_ s. {s⦇ W := {} ⦈})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake ≡
      ⦃''hs_noop''⦄ hs_read_type ht_NOOP ;;
      ⦃''hs_noop_mfence''⦄ MFENCE ;;
      ⦃''hs_noop_done''⦄ hs_noop_done
   ⊔
      ⦃''hs_get_roots''⦄ hs_read_type ht_GetRoots ;;
      ⦃''hs_get_roots_mfence''⦄ MFENCE ;;
      ⦃''hs_get_roots_refs''⦄ ´refs := ´roots ;;
      ⦃''hs_get_roots_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY refs) DO
         ⦃''hs_get_roots_loop_choose_ref''⦄ ´ref :∈ Some ` ´refs ;;
         ⦃''hs_get_roots_loop''⦄ mark_object ;;
         ⦃''hs_get_roots_loop_done''⦄ ´refs := (´refs - {the ´ref})
      OD ;;
      ⦃''hs_get_roots_done''⦄ hs_get_roots_done W
   ⊔
      ⦃''hs_get_work''⦄ hs_read_type ht_GetWork ;;
      ⦃''hs_get_work_mfence''⦄ MFENCE ;;
      ⦃''hs_get_work_done''⦄ hs_get_work_done W"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The garbage collector's side of the interface.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>gc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>set_hs_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ handshake_type ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ set'_hs'_type"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ set_hs_type ht ≡ ⦃l⦄ Request (λs. (gc, ro_hs_gc_set_type ht)) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>set_hs_pending</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'mut) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ set'_hs'_pending"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ set_hs_pending m ≡ ⦃l⦄ Request (λs. (gc, ro_hs_gc_set_pending (m s))) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>handshake_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ handshake_type ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ handshake'_init"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ handshake_init req ≡
     ⦃l @ ''_init_type''⦄ set_hs_type req ;;
     ⦃l @ ''_init_muts''⦄ ´muts := UNIV ;;
     ⦃l @ ''_init_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span> (EMPTY muts) DO
       ⦃l @ ''_init_loop_choose_mut''⦄ ´mut :∈ ´muts ;;
       ⦃l @ ''_init_loop_set_pending''⦄ set_hs_pending mut ;;
       ⦃l @ ''_init_loop_done''⦄ ´muts := (´muts - {´mut})
     OD"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>handshake_done</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ handshake'_done"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ handshake_done ≡
     ⦃l @ ''_done_muts''⦄ ´muts := UNIV ;;
     ⦃l @ ''_done_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY muts) DO
       ⦃l @ ''_done_loop_choose_mut''⦄ ´mut :∈ ´muts ;;
       ⦃l @ ''_done_loop_rendezvous''⦄ Request
               (λs. (gc, ro_hs_gc_read_pending (mut s)))
               (λmv s. { s⦇ muts := muts s - { mut s |done. mv = mv_Bool done ∧ done } ⦈})
     OD"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>load_W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ load'_W"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ load_W ≡ ⦃l @ ''_load_W''⦄ Request (λs. (gc, ro_hs_gc_load_W))
                                          (λresp s. {s⦇W := W'⦈ |W'. resp = mv_Refs W'})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mfence</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ MFENCE"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ MFENCE ≡ ⦃l⦄ Request (λs. (gc, ro_MFENCE)) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>handshake_noop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ handshake'_noop"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ handshake_noop ≡
         ⦃l @ ''_mfence''⦄ MFENCE ;;
         ⦃l⦄ handshake_init ht_NOOP ;;
         ⦃l⦄ handshake_done"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>handshake_get_roots</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ handshake'_get'_roots"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ handshake_get_roots ≡
         ⦃l⦄ handshake_init ht_GetRoots ;;
         ⦃l⦄ handshake_done ;;
         ⦃l⦄ load_W"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>handshake_get_work</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ handshake'_get'_work"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ handshake_get_work ≡
         ⦃l⦄ handshake_init ht_GetWork ;;
         ⦃l⦄ handshake_done ;;
         ⦃l⦄ load_W"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The system process›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The system process models the environment in which the garbage
collector and mutators execute.  We translate the x86-TSO memory model
due to @{cite [cite_macro=citet] "DBLP:journals/cacm/SewellSONM10"}
into a CIMP process. It is a reactive system: it receives requests and
returns values, but initiates no communication itself. It can,
however, autonomously commit a write pending in a TSO store buffer.

The memory bus can be locked by atomic compare-and-swap (\texttt{CAS})
instructions (and others in general). A processor is not blocked
(i.e., it can read from memory) when it holds the lock, or no-one
does.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>not_blocked</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) local_state ⇒ 'mut process_name ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"not_blocked s p ≡ case mem_lock s of None ⇒ True | Some p' ⇒ p = p'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We compute the view a processor has of memory by applying all its
pending writes.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>do_write_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"do_write_action wact ≡ λs.
     case wact of
       mw_Mark r gc_mark    ⇒ s⦇heap := (heap s)(r := map_option (λobj. obj⦇obj_mark := gc_mark⦈) (heap s r))⦈
     | mw_Mutate r f new_r  ⇒ s⦇heap := (heap s)(r := map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := new_r) ⦈) (heap s r))⦈
     | mw_fM gc_mark        ⇒ s⦇fM := gc_mark⦈
     | mw_fA gc_mark        ⇒ s⦇fA := gc_mark⦈
     | mw_Phase gc_phase    ⇒ s⦇phase := gc_phase⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>fold_writes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action list ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fold_writes ws ≡ fold (λw. (∘) (do_write_action w)) ws id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>processors_view_of_memory</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"processors_view_of_memory p s ≡ fold_writes (mem_write_buffers s p) s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>do_read_action</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_read_action
                   ⇒ ('field, 'mut, 'ref) local_state
                   ⇒ ('field, 'ref) response"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"do_read_action ract ≡ λs.
     case ract of
       mr_Ref r f ⇒ mv_Ref (heap s r ⤜ (λobj. obj_fields obj f))
     | mr_Mark r  ⇒ mv_Mark (map_option obj_mark (heap s r))
     | mr_Phase   ⇒ mv_Phase (phase s)
     | mr_fM      ⇒ mv_Mark (Some (fM s))
     | mr_fA      ⇒ mv_Mark (Some (fA s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sys_read</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name
              ⇒ ('field, 'ref) mem_read_action
              ⇒ ('field, 'mut, 'ref) local_state
              ⇒ ('field, 'ref) response"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_read p ract ≡ do_read_action ract ∘ processors_view_of_memory p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>sys</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The semantics of TSO memory following @{cite [cite_macro=citet]
‹\S3› "DBLP:journals/cacm/SewellSONM10"}. This differs
from the earlier @{cite [cite_macro=citet]
"DBLP:conf/tphol/OwensSS09"} by allowing the TSO lock to be taken by a
process with a non-empty write buffer. We omit their treatment of
registers; these are handled by the local states of the other
processes. The system can autonomously take the oldest write in the
write buffer for processor ‹p› and commit it to memory,
provided ‹p› either holds the lock or no processor does.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>mem_TSO</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mem_TSO ≡
        ⦃''sys_read''⦄ Response (λreq s. { (s, sys_read p mr s)
                                         |p mr. req = (p, ro_Read mr) ∧ not_blocked s p })
      ⊔ ⦃''sys_write''⦄ Response (λreq s. { (s⦇ mem_write_buffers := (mem_write_buffers s)(p := mem_write_buffers s p @ [w]) ⦈, mv_Void)
                                          |p w. req = (p, ro_Write w) })
      ⊔ ⦃''sys_mfence''⦄ Response (λreq s. { (s, mv_Void)
                                           |p. req = (p, ro_MFENCE) ∧ mem_write_buffers s p = [] })
      ⊔ ⦃''sys_lock''⦄ Response (λreq s. { (s⦇ mem_lock := Some p ⦈, mv_Void)
                                         |p. req = (p, ro_Lock) ∧ mem_lock s = None })
      ⊔ ⦃''sys_unlock''⦄ Response (λreq s. { (s⦇ mem_lock := None ⦈, mv_Void)
                                         |p. req = (p, ro_Unlock) ∧ mem_lock s = Some p ∧ mem_write_buffers s p = [] })
      ⊔ ⦃''sys_dequeue_write_buffer''⦄ LocalOp (λs. { (do_write_action w s)⦇ mem_write_buffers := (mem_write_buffers s)(p := ws) ⦈
                                                    | p w ws. mem_write_buffers s p = w # ws ∧ not_blocked s p ∧ p ≠ sys })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We track which references are allocated using the domain of @{const
"heap"}.

\label{sec:sys_alloc}

For now we assume that the system process magically allocates and
deallocates references. To model this more closely we would need to
take care of the underlying machine addresses. We should be able to
separate out those issues from GC correctness: the latter should imply
that only alloc and free can interfere with each other.

We also arrange for the object to be marked atomically (see
\S\ref{sec:mut_alloc}) which morally should be done by the mutator. In
practice allocation pools enable this kind of atomicity (wrt the sweep
loop in the GC described in \S\ref{sec:gc-model-gc}).

Note that the \texttt{abort} in @{cite [cite_macro=citet]
‹Figure~2.9: Alloc› "Pizlo201xPhd"} means the atomic
fails and the mutator can revert to activity outside of
\texttt{Alloc}, avoiding deadlock.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>alloc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"alloc ≡ ⦃''sys_alloc''⦄ Response (λreq s.
      { ( s⦇ heap := (heap s)(r := Some ⦇ obj_mark = fA s, obj_fields = ⟨None⟩ ⦈) ⦈, mv_Ref (Some r) )
      |r. r ∉ dom (heap s) ∧ snd req = ro_Alloc })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

References are freed by removing them from @{const "heap"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>free</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free ≡ ⦃''sys_free''⦄ Response (λreq s.
      { (s⦇heap := (heap s)(r := None)⦈, mv_Void) |r. snd req = ro_Free r })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The top-level system process.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>com</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"com ≡
    LOOP DO
        mem_TSO
      ⊔ alloc
      ⊔ free
      ⊔ handshake
    OD"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Mutators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The mutators need to cooperate with the garbage collector. In
particular, when the garbage collector is not idle the mutators use a
\emph{write barrier} (see \S\ref{sec:gc-marking}).

The local state for each mutator tracks a working set of references,
which abstracts from how the process's registers and stack are
traversed to discover roots.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>mut_m</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:mut_alloc}

Allocation is defined in @{cite [cite_macro=citet]
‹Figure~2.9› "Pizlo201xPhd"}. See \S\ref{sec:sys_alloc}
for how we abstract it.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>mut_alloc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_alloc m ≡
    ⦃''alloc''⦄ Request (λs. (mutator m, ro_Alloc))
                        (λmv s. { s⦇ roots := roots s ∪ {r} ⦈ |r. mv = mv_Ref (Some r) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>alloc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"alloc ≡ mut_alloc m"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The mutator can always discard any references it holds.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>discard</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"discard ≡
    ⦃''discard_refs''⦄ LocalOp (λs. { s⦇ roots := roots' ⦈ |roots'. roots' ⊆ roots s })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Load and store are defined in @{cite [cite_macro=citet]
‹Figure~2.9› "Pizlo201xPhd"}.

Dereferencing a reference can increase the set of mutator roots.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>load</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"load ≡
    ⦃''load_choose''⦄ LocalOp (λs. { s⦇ tmp_ref := r, field := f ⦈ |r f. r ∈ roots s }) ;;
    ⦃''load''⦄ Request (λs. (mutator m, ReadRef (tmp_ref s) (field s)))
                       (λmv s. { s⦇ roots := roots s ∪ set_option r ⦈
                               |r. mv = mv_Ref r })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:write-barriers}

Storing a reference involves marking both the old and new references,
i.e., both \emph{insertion} and \emph{deletion} barriers are
installed. The deletion barrier preserves the \emph{weak tricolour
invariant}, and the insertion barrier preserves the \emph{strong
tricolour invariant}; see \S\ref{sec:strong-tricolour-invariant} for
further discussion.

Note that the the mutator reads the overwritten reference but does not
store it in its roots.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>mut_deref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location
          ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref)
          ⇒ (('field, 'mut, 'ref) local_state ⇒ 'field)
          ⇒ (('ref option ⇒ 'ref option) ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ deref"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ deref r f upd ≡ ⦃l⦄ Request (λs. (mutator m, ReadRef (r s) (f s)))
                                   (λmv s. { upd ⟨opt_r'⟩ (s⦇ghost_honorary_root := set_option opt_r'⦈) |opt_r'. mv = mv_Ref opt_r' })"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Does not work in local theory mode:

syntax
  "_mut_fassign" :: "location ⇒ idt ⇒ 'ref ⇒ 'field ⇒ ('field, 'mut, 'ref) gc_com" ("⦃_⦄ ´_ := ´_ → _" [0, 0, 70] 71)
translations
  "⦃l⦄ ´q := ´r→f"    =&gt; "CONST mut_deref l r «f» (_update_name q)"

 ´ref := ´tmp_ref→´field ;;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>write_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location
              ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref)
              ⇒ (('field, 'mut, 'ref) local_state ⇒ 'field)
              ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref option)
              ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ write'_ref"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ write_ref r f r' ≡ ⦃l⦄ Request (λs. (mutator m, WriteRef (r s) (f s) (r' s))) (λ_ s. {s⦇ghost_honorary_root := {}⦈})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>store</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"store ≡
     ― ‹Choose vars for: ‹ref→field := new_ref››
     ⦃''store_choose''⦄ LocalOp (λs. { s⦇ tmp_ref := r, field := f, new_ref := r' ⦈
                                     |r f r'. r ∈ roots s ∧ r' ∈ Some ` roots s ∪ {None} }) ;;
     ― ‹Mark the reference we're about to overwrite. Does not update roots.›
     ⦃''deref_del''⦄ deref tmp_ref field ref_update ;;
     ⦃''store_del''⦄ mark_object ;;
     ― ‹Mark the reference we're about to insert.›
     ⦃''lop_store_ins''⦄ ´ref := ´new_ref ;;
     ⦃''store_ins''⦄ mark_object ;;
     ⦃''store_ins''⦄ write_ref tmp_ref field new_ref"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

A mutator makes a non-deterministic choice amongst its possible
actions. For completeness we allow mutators to issue \texttt{MFENCE}
instructions. We leave \texttt{CAS} (etc) to future work. Neither has
a significant impact on the rest of the development.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>com</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"com ≡
    LOOP DO
        ⦃''mut local computation''⦄ SKIP
      ⊔ alloc
      ⊔ discard
      ⊔ load
      ⊔ store
      ⊔ ⦃''mut mfence''⦄ MFENCE
      ⊔ handshake
    OD"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Garbage collector \label{sec:gc-model-gc}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We abstract the primitive actions of the garbage collector thread.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>gc_deref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location
             ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref)
             ⇒ (('field, 'mut, 'ref) local_state ⇒ 'field)
             ⇒ (('ref option ⇒ 'ref option) ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_deref l r f upd ≡ ⦃l⦄ Request (λs. (gc, ReadRef (r s) (f s)))
                                    (λmv s. { upd ⟨r'⟩ s |r'. mv = mv_Ref r' })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>gc_read_mark</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location
                ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref)
                ⇒ ((gc_mark option ⇒ gc_mark option) ⇒ ('field, 'mut, 'ref) local_state ⇒ ('field, 'mut, 'ref) local_state)
                ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_read_mark l r upd ≡ ⦃l⦄ Request (λs. (gc, ReadMark (r s))) (λmv s. { upd ⟨m⟩ s |m. mv = mv_Mark m })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_gc_fassign"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ idt ⇒ 'ref ⇒ 'field ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ ´_ := ´_ → _"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_gc_massign"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ idt ⇒ 'ref ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ ´_ := ´_ → flag"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ´q := ´r→f"</span></span></span><span>    </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST gc_deref l r «f» (_update_name q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ´m := ´r→flag"</span></span></span><span> </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST gc_read_mark l r (_update_name m)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>gc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>write_fA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ gc_mark) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ write'_fA"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ write_fA f ≡ ⦃l⦄ Request (λs. (gc, WritefA (f s))) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>read_fM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ read'_fM"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ read_fM ≡ ⦃l⦄ Request (λs. (gc, ReadfM)) (λmv s. { s⦇fM := m⦈ |m. mv = mv_Mark (Some m) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>write_fM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ write'_fM"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ write_fM ≡ ⦃l⦄ Request (λs. (gc, WritefM (fM s))) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>write_phase</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ gc_phase ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ write'_phase"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ write_phase ph ≡ ⦃l⦄ Request (λs. (gc, WritePhase ph)) (λ_ s. {s⦇ phase := ph ⦈})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mark_object</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ mark'_object"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ mark_object ≡ mark_object_fn gc l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>free</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ (('field, 'mut, 'ref) local_state ⇒ 'ref) ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ free"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ free r ≡ ⦃l⦄ Request (λs. (gc, ro_Free (r s))) (λ_ s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following CIMP program encodes the garbage collector algorithm
proposed in Figure~2.15 of @{cite [cite_macro=citet] "Pizlo201xPhd"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span>
</span><span>  </span><span>com</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"com ≡
     LOOP DO
       ⦃''idle_noop''⦄ handshake_noop ;; ― ‹‹hp_Idle››

       ⦃''idle_read_fM''⦄ read_fM ;;
       ⦃''idle_invert_fM''⦄ ´fM := (¬ ´fM) ;;
       ⦃''idle_write_fM''⦄ write_fM ;;

       ⦃''idle_flip_noop''⦄ handshake_noop ;; ― ‹‹hp_IdleInit››

       ⦃''idle_phase_init''⦄ write_phase ph_Init ;;

       ⦃''init_noop''⦄ handshake_noop ;; ― ‹‹hp_InitMark››

       ⦃''init_phase_mark''⦄ write_phase ph_Mark ;;
       ⦃''mark_read_fM''⦄ read_fM ;;
       ⦃''mark_write_fA''⦄ write_fA fM ;;

       ⦃''mark_noop''⦄ handshake_noop ;; ― ‹‹hp_Mark››

       ⦃''mark_loop_get_roots''⦄ handshake_get_roots ;; ― ‹‹hp_IdleMarkSweep››

       ⦃''mark_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY W) DO
         ⦃''mark_loop_inner''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY W) DO
           ⦃''mark_loop_choose_ref''⦄ ´tmp_ref :∈ ´W ;;
           ⦃''mark_loop_fields''⦄ ´field_set := UNIV ;;
           ⦃''mark_loop_mark_object_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY field_set) DO
             ⦃''mark_loop_mark_choose_field''⦄ ´field :∈ ´field_set ;;
             ⦃''mark_loop_mark_deref''⦄ ´ref := ´tmp_ref→´field ;;
             ⦃''mark_loop''⦄ mark_object ;;
             ⦃''mark_loop_mark_field_done''⦄ ´field_set := (´field_set - {´field})
           OD ;;
           ⦃''mark_loop_blacken''⦄ ´W := (´W - {´tmp_ref})
         OD ;;
         ⦃''mark_loop_get_work''⦄ handshake_get_work
       OD ;;

       ― ‹sweep›

       ⦃''mark_end''⦄ write_phase ph_Sweep ;;
       ⦃''sweep_read_fM''⦄ read_fM ;;
       ⦃''sweep_refs''⦄ ´refs := UNIV ;;
       ⦃''sweep_loop''⦄ WHILE <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY refs) DO
         ⦃''sweep_loop_choose_ref''⦄ ´tmp_ref :∈ ´refs ;;
         ⦃''sweep_loop_read_mark''⦄ ´mark := ´tmp_ref→flag ;;
         ⦃''sweep_loop_check''⦄ IF <span class="hidden">❙</span><span class="bold">¬</span>(NULL mark) <span class="hidden">❙</span><span class="bold">∧</span> the ∘ mark <span class="hidden">❙</span><span class="bold">≠</span> fM THEN
           ⦃''sweep_loop_free''⦄ free tmp_ref
         FI ;;
         ⦃''sweep_loop_ref_done''⦄ ´refs := (´refs - {´tmp_ref})
       OD ;;
       ⦃''sweep_idle''⦄ write_phase ph_Idle
     OD"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>gc_pgms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name ⇒ ('field, 'mut, 'ref) gc_com"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_pgms (mutator m) = mut_m.com m"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_pgms gc = gc.com"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_pgms sys = sys.com"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Tactics">
<div class="head"><h1>Theory Tactics</h1>
<span class="command">theory</span> <span class="name">Tactics</span><br/>
<span class="keyword">imports</span> <a href="Model.html"><span class="name">Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Tactics</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Model</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Sublist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants and Proofs \label{sec:gc-invs}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Constructors for sets of locations.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>prefixed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ location set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixed p ≡ { l . prefix p l }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>suffixed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ location set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"suffixed p ≡ { l . suffix p l }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Hoare triples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Specialise CIMP's pre/post validity to our system.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>valid_proc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred ⇒ 'mut process_name ⇒ ('field, 'mut, 'ref) gc_pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ _ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ p ⦃Q⦄ ≡ ∀(c, afts) ∈ vcg_fragments (gc_pgms p). (gc_pgms, p, afts ⊨ ⦃P⦄ c ⦃Q⦄)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_proc_inv_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred ⇒ 'mut process_name ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ _"</span></span></span><span> </span><span class="delimiter">[</span><span>100</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ p ≡ ⦃P⦄ p ⦃P⦄"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃Q⦄ p ⦃R⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. P s ⟹ Q s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ p ⦃R⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_proc_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>vcg_pre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_conj_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ p ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P'⦄ p ⦃Q'⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦃P <span class="hidden">❙</span><span class="bold">∧</span> P'⦄ p ⦃Q <span class="hidden">❙</span><span class="bold">∧</span> Q'⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_proc_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_conj</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Ball_def</span><span> </span><span>valid_proc_def</span><span> </span><span>split_paired_All</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>y</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Ball_def</span><span> </span><span>valid_proc_def</span><span> </span><span>split_paired_All</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_all_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⦃P x⦄ p ⦃Q x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λs. ∀x. P x s⦄ p ⦃λs. ∀x. Q x s⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_proc_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg_all_lift</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

As we elide formal proofs in this document, we also omit our
specialised proof tactics. These support essentially traditional local
correctness and non-interference proofs. Their most interesting aspect
is the use of Isabelle's parallelism to greatly reduce system latency.

›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Tactics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>nie</span><span> </span><span class="string"><span class="delete"><span class="delete">"Non-interference elimination rules"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Collect the component definitions. Inline everything.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* gc.com_def *)</span></span></span></span></span><span> </span><span>gc.handshake_done_def</span><span> </span><span>gc.handshake_init_def</span><span> </span><span>gc.handshake_noop_def</span><span> </span><span>gc.handshake_get_roots_def</span><span> </span><span>gc.handshake_get_work_def</span><span>
</span><span>  </span><span>mark_object_fn_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mut.com_def *)</span></span></span></span></span><span> </span><span>mut_m.handshake_def</span><span> </span><span>mut_m.store_def</span><span>
</span><span>  </span><span>mark_object_fn_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sys_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sys.com_def *)</span></span></span></span></span><span> </span><span>sys.alloc_def</span><span> </span><span>sys.free_def</span><span> </span><span>sys.mem_TSO_def</span><span> </span><span>sys.handshake_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_all_defs</span><span class="delimiter">[</span><span>com</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>gc.com_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>gc_defs</span><span> </span><span>append.simps</span><span> </span><span>if_True</span><span> </span><span>if_False</span><span class="delimiter">]</span><span>
</span><span>  </span><span>mut_m.com_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>mut_defs</span><span> </span><span>append.simps</span><span> </span><span>if_True</span><span> </span><span>if_False</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sys.com_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>sys_defs</span><span> </span><span>append.simps</span><span> </span><span>if_True</span><span> </span><span>if_False</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME not automation friendly. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atS_dests</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS p ls s; atS p ls' s ⟧ ⟹ atS p (ls ∪ ls') s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ¬atS p ls s; ¬atS p ls' s ⟧ ⟹ ¬atS p (ls ∪ ls') s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ¬atS p ls s; atS p ls' s ⟧ ⟹ atS p (ls' - ls) s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ¬atS p ls s; at p l s ⟧ ⟹ atS p ({l} - ls) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME these leave ¬at ... assumptions when P is easy to contradict. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>thin_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ at p l' s ⟶ P; at p l s; l' ≠ l ∨ P ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS p ls s ⟶ P; at p l s; l ∉ ls ∨ P ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  "⟦ at p l' s ⟶ P; atS p ls s; ... FIXME strategy: reduce atS to at and use the first of thin_locs. *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  "⟦ atS p ls' s ⟶ P; atS p ls s; ¬atS p (ls' ∩ ls) s ∨ P ⟹ Q ⟧ ⟹ Q" *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following is unfortunately overspecialised to the GC. One might
hope for general tactics that work on all CIMP programs.

The system responds to all requests. The schematic variable is
instantiated with the semantics of the responses. Thanks to Thomas
Sewell for the hackery.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>system_responds_actionE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (⦃l⦄ Response action, afts) ∈ fragments (gc_pgms p) ⟨False⟩; v ∈ action x s;
     ⟦ p = sys; ?P ⟧ ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc_all_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"x ∨ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"v ∈ action p k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>p</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ action p k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>conj_disj_distribR</span><span> </span><span>conj_assoc</span><span> </span><span>mem_Collect_eq</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = sys"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>system_responds_action_caseE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (⦃l⦄ Response action, afts) ∈ fragments (gc_pgms p) ⟨False⟩; v ∈ action (pname, req) s;
     ⟦ p = sys; case_request_op ?P1 ?P2 ?P3 ?P4 ?P5 ?P6 ?P7 ?P8 ?P9 ?P10 ?P11 ?P12 ?P13 req ⟧ ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>system_responds_actionE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>req</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>request_op.simps</span><span> </span><span>prod.inject</span><span> </span><span>simp_thms</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>meta_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>TrueI</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>meta_mp</span><span class="delimiter">,</span><span> </span><span>erule_tac</span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A ∧ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>triv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>system_responds_action_specE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (⦃l⦄ Response action, afts) ∈ fragments (gc_pgms p) ⟨False⟩; v ∈ action x s;
     ⟦ p = sys; case_request_op ?P1 ?P2 ?P3 ?P4 ?P5 ?P6 ?P7 ?P8 ?P9 ?P10 ?P11 ?P12 ?P13 (snd x) ⟧ ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>system_responds_action_caseE</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pname</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>req</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"snd x"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Simplification rules for locations. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>loc_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>bex_simps</span><span>
</span><span>  </span><span>append.simps</span><span> </span><span>list.simps</span><span> </span><span>rev.simps</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* evaluate string equality *)</span></span></span></span></span><span>
</span><span>  </span><span>char.inject</span><span> </span><span>cong_exp_iff_simps</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* evaluate character equality *)</span></span></span></span></span><span>
</span><span>  </span><span>prefix_code</span><span> </span><span>suffix_to_prefix</span><span>
</span><span>  </span><span>mem_Collect_eq</span><span> </span><span>Un_iff</span><span> </span><span>UNION_eq</span><span> </span><span>Compl_iff</span><span> </span><span>insertI1</span><span> </span><span>insertI2</span><span> </span><span>singleton_iff</span><span> </span><span>Diff_iff</span><span> </span><span>UNIV_I</span><span>
</span><span>  </span><span>if_True</span><span> </span><span>if_False</span><span>
</span><span>  </span><span>fun_upd_same</span><span> </span><span>fun_upd_other</span><span> </span><span>process_name.simps</span><span>
</span><span>  </span><span>refl</span><span> </span><span>simp_thms</span><span>
</span><span>  </span><span>atS_simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>vcg_fragments'_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>valid_proc_def</span><span> </span><span>gc_pgms.simps</span><span> </span><span>vcg_fragments'.simps</span><span> </span><span>atC.simps</span><span>
</span><span>  </span><span>ball_Un</span><span> </span><span>bool_simps</span><span> </span><span>if_False</span><span> </span><span>if_True</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* equations for deriving useful things from eq_imp facts. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>eq_imp_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>eq_imp_def</span><span>
</span><span>  </span><span>all_conj_distrib</span><span>
</span><span>  </span><span>split_paired_All</span><span> </span><span>split_def</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>prod_eq_iff</span><span>
</span><span>  </span><span>conj_explode</span><span>
</span><span>  </span><span>simp_thms</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Tweak the default simpset:
  - "not in dom" as a premise negates the goal
  - we always want to execute suffix
  - we may as well simplify under our non-recursive datatypes.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>dom_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>suffix_to_prefix</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>gc_phase.case_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>mem_write_action.case_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>process_name.case_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>handshake_phase.case_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

(* Thanks BNF people. *)
fun ss_only thms ctxt = clear_simpset (put_simpset HOL_basic_ss ctxt) addsimps thms;

(* Thanks BNF people. Actually use HOL_ss rather than HOL_basic_ss *)
fun HOL_ss_only thms ctxt = clear_simpset (put_simpset HOL_ss ctxt) addsimps thms;

fun vcg_clarsimp_tac ctxt =
        simp_tac (ss_only (@{thms vcg_fragments'_simps} @ Named_Theorems.get ctxt @{named_theorems com}) ctxt)
  THEN' SELECT_GOAL (safe_tac ctxt)

val _ =
  Theory.setup (Method.setup @{binding vcg_clarsimp}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_clarsimp_tac))
    "unfold com defs, execute vcg_fragments' and split goals")

fun vcg_sem_tac ctxt =
        Tactic.match_tac ctxt @{thms vcg.intros}
  THEN' (TRY o (Tactic.ematch_tac ctxt @{thms system_responds_action_specE} THEN' assume_tac ctxt))
  THEN' Rule_Insts.thin_tac ctxt "hist s = h" [(@{binding s}, NONE, NoSyn), (@{binding h}, NONE, NoSyn)] (* FIXME discard history: we don't use it here *)
  THEN' clarsimp_tac ctxt

val _ =
  Theory.setup (Method.setup @{binding vcg_sem}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_sem_tac))
    "turn VCG goal into semantics and clarsimp")

fun vcg_jackhammer_gen_tac terminal_tac ctxt =
  SELECT_GOAL (
    HEADGOAL (vcg_clarsimp_tac ctxt)
  THEN
    PARALLEL_ALLGOALS (
                 vcg_sem_tac ctxt
    THEN_ALL_NEW (full_simp_tac (Splitter.add_split @{thm lcond_split_asm} (ctxt addsimps Named_Theorems.get ctxt @{named_theorems inv})))
    THEN_ALL_NEW ( (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms conjE}))
             THEN' (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms thin_locs} THEN' REPEAT1 o assume_tac ctxt))
             THEN' asm_full_simp_tac (ss_only (@{thms loc_simps} @ Named_Theorems.get ctxt @{named_theorems loc}) ctxt)
             THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Rule_Insts.thin_tac ctxt "True" [])) (* FIXME weird, must be a standard way to do this. Leaving them in can cause simp to diverge ?? *)
             THEN_ALL_NEW clarsimp_tac (ctxt addsimps (Named_Theorems.get ctxt @{named_theorems loc} @ @{thms atS_simps})) (* FIXME smelly *)
             THEN_ALL_NEW Rule_Insts.thin_tac ctxt "AT _ = _" [] (* FIXME discard ‹AT s = s'(funupd)› fact *)
             THEN_ALL_NEW TRY o terminal_tac ctxt)))

val _ =
  Theory.setup (Method.setup @{binding vcg_jackhammer}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_jackhammer_gen_tac (fn _ =&gt; SELECT_GOAL all_tac)))
    "VCG supertactic, no terminal method")

val _ =
  Theory.setup (Method.setup @{binding vcg_jackhammer_ff}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_jackhammer_gen_tac fast_force_tac))
    "VCG supertactic, fastforce the survivors")

fun vcg_ni_tac ctxt =
  SELECT_GOAL (
    HEADGOAL (TRY o vcg_clarsimp_tac ctxt)
  THEN
    PARALLEL_ALLGOALS (
                   vcg_sem_tac ctxt
             THEN' (TRY o SELECT_GOAL (Local_Defs.unfold_tac ctxt (Named_Theorems.get ctxt @{named_theorems inv})))
             THEN' (TRY o REPEAT_ALL_NEW (Tactic.match_tac ctxt @{thms conjI})) (* expose the location predicates, do not split the consequents *)
      THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.match_tac ctxt @{thms impI}))
                       (* Preserve the label sets in atS but normalise the label in at; turn s' into s *)
      THEN_ALL_NEW asm_full_simp_tac ctxt (* FIXME diverges on some invariants *)
      THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms conjE}))
                       (* The effect of vcg_pre: should be cheap *)
      THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms thin_locs} THEN' REPEAT1 o assume_tac ctxt))
      THEN_ALL_NEW asm_full_simp_tac (ss_only (@{thms loc_simps} @ Named_Theorems.get ctxt @{named_theorems loc}) ctxt)
      THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Rule_Insts.thin_tac ctxt "True" [])) (* FIXME weird, must be a standard way to do this. Leaving them in can cause simp to diverge ?? *)
(*      THEN_ALL_NEW Rule_Insts.thin_tac ctxt "AT _ = _" [] (* FIXME discard ‹AT s = s'(funupd)› fact *) doesn't work when processes communicate! see gc_sweep_loop_invL *)
      THEN_ALL_NEW clarsimp_tac ctxt))

fun vcg_nihe_tac ctxt =
  SELECT_GOAL (
    HEADGOAL (vcg_clarsimp_tac ctxt)
  THEN
    PARALLEL_ALLGOALS (
                     (vcg_sem_tac ctxt
        THEN_ALL_NEW (Tactic.ematch_tac ctxt (Named_Theorems.get ctxt @{named_theorems nie})
        THEN_ALL_NEW clarsimp_tac ctxt
        THEN_ALL_NEW SELECT_GOAL no_tac))
      ORELSE' SELECT_GOAL all_tac)) (* FIXME perhaps replace with vcg_ni? but less diagnosable then *)

val _ =
  Theory.setup (Method.setup @{binding vcg_ni}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_ni_tac))
    "VCG non-interference supertactic, no terminal method")

val _ =
  Theory.setup (Method.setup @{binding vcg_nihe}
    (Method.sections clasimp_modifiers &gt;&gt; K (SIMPLE_METHOD' o vcg_nihe_tac))
    "cheap VCG non-interference tactic: apply non-interference Hoare and elimination rules, leaving remaining goals as Hoare triples")
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Proofs_basis">
<div class="head"><h1>Theory Proofs_basis</h1>
<span class="command">theory</span> <span class="name">Proofs_basis</span><br/>
<span class="keyword">imports</span> <a href="Tactics.html"><span class="name">Tactics</span></a> <a href="../../HOL/HOL-Library/Simps_Case_Conv.html"><span class="name">Simps_Case_Conv</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Proofs_basis</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Tactics</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Simps_Case_Conv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Functions and predicates›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We define a pile of predicates and accessor functions for the
process's local states. One might hope that a more sophisticated
approach would automate all of this (cf @{cite [cite_macro=citet]
"DBLP:journals/entcs/SchirmerW09"}).

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mw_Mark w ≡ ∃r fl. w = mw_Mark r fl"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mw_Mutate w ≡ ∃r f r'. w = mw_Mutate r f r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mw_fA w ≡ ∃fl. w = mw_fA fl"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mw_fM w ≡ ∃fl. w = mw_fM fl"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mw_Phase w ≡ ∃ph. w = mw_Phase ph"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pred_in_W</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'mut process_name ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in'_W"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r in_W p ≡ λs. r ∈ W (s p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pred_in_ghost_honorary_grey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'mut process_name ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in'_ghost'_honorary'_grey"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r in_ghost_honorary_grey p ≡ λs. r ∈ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>gc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_gc_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ ('field, 'mut, 'ref) gc_pred ⇒ bool"</span></span></span><span>
</span><span>                       </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _/ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ⦃Q⦄ ≡ gc_pgms, gc, afts ⊨ ⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>valid_gc_inv_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ≡ afts ⊨ ⦃P⦄ c ⦃P⦄"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_cas_mark s ≡ cas_mark (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_fM s ≡ fM (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_field s ≡ field (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_field_set s ≡ field_set (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mark s ≡ mark (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_mut s ≡ mut (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_muts s ≡ muts (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_phase s ≡ phase (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_tmp_ref s ≡ tmp_ref (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_ghost_honorary_grey s ≡ ghost_honorary_grey (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_ref s ≡ ref (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_refs s ≡ refs (s gc)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_the_ref ≡ the ∘ gc_ref"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gc_W s ≡ W (s gc)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>at_gc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"at_gc l P ≡ at gc l <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>atS_gc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS_gc ls P ≡ atS gc ls <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>mut_m</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_mut_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ ('field, 'mut, 'ref) gc_pred ⇒ bool"</span></span></span><span>
</span><span>                    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _/ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ⦃Q⦄ ≡ gc_pgms, mutator m, afts ⊨ ⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>valid_mut_inv_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ≡ afts ⊨ ⦃P⦄ c ⦃P⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>at_mut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"at_mut l P ≡ at (mutator m) l <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>atS_mut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS_mut ls P ≡ atS (mutator m) ls <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_cas_mark s ≡ cas_mark (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_field s ≡ field (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_fM s ≡ fM (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ghost_honorary_grey s ≡ ghost_honorary_grey (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ghost_handshake_phase s ≡ ghost_handshake_phase (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ghost_honorary_root s ≡ ghost_honorary_root (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_mark s ≡ mark (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_new_ref s ≡ new_ref (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_phase s ≡ phase (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ref s ≡ ref (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_tmp_ref s ≡ tmp_ref (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_the_new_ref ≡ the ∘ mut_new_ref"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_the_ref ≡ the ∘ mut_ref"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_refs s ≡ refs (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_roots s ≡ roots (s (mutator m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_W s ≡ W (s (mutator m))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>sys</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_sys_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ ('field, 'mut, 'ref) gc_pred ⇒ bool"</span></span></span><span>
</span><span>                    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _/ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ⦃Q⦄ ≡ gc_pgms, sys, afts ⊨ ⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>valid_sys_inv_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_loc_comp ⇒ ('field, 'mut, 'ref) gc_pred ⇒ ('field, 'mut, 'ref) gc_com ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊨ ⦃_⦄/ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"afts ⊨ ⦃P⦄ c ≡ afts ⊨ ⦃P⦄ c ⦃P⦄"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>sys_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts ⇒ 'ref ⇒ ('field, 'ref) object option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s ≡ heap (s sys)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_fA s ≡ fA (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_fM s ≡ fM (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_honorary_grey s ≡ ghost_honorary_grey (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_in_sync m s ≡ ghost_handshake_in_sync (s sys) m"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_phase s ≡ ghost_handshake_phase (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_handshake_pending m s ≡ handshake_pending (s sys) m"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_handshake_type s ≡ handshake_type (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers p s ≡ mem_write_buffers (s sys) p"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_lock s ≡ mem_lock (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_phase s ≡ phase (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_W s ≡ W (s sys)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>atS_sys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS_sys ls P ≡ atS sys ls <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Projections on TSO buffers.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_unlocked s ≡ mem_lock (s sys) = None"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_locked_by p s ≡ mem_lock (s sys) = Some p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending p P s ≡ filter P (mem_write_buffers (s sys) p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_write p w s ≡ w ∈ set (mem_write_buffers (s sys) p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_fA p ≡ tso_pending p is_mw_fA"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_fM p ≡ tso_pending p is_mw_fM"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mark p ≡ tso_pending p is_mw_Mark"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mutate p ≡ tso_pending p is_mw_Mutate"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_phase p ≡ tso_pending p is_mw_Phase"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_no_pending_marks ≡ <span class="hidden">❙</span><span class="bold">∀</span>p. LIST_NULL (tso_pending_mark p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

A somewhat-useful abstraction of the heap, following l4.verified,
which asserts that there is an object at the given reference with the
given property.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>obj_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('field, 'ref) object ⇒ bool) ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at P r ≡ λs. case sys_heap s r of None ⇒ False | Some obj ⇒ P obj"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>valid_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_ref r ≡ obj_at ⟨True⟩ r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_null_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref option ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_null_ref r ≡ case r of None ⇒ ⟨True⟩ | Some r' ⇒ valid_ref r'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pred_points_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"points'_to"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x points_to y ≡ λs. obj_at (λobj. y ∈ ran (obj_fields obj)) x s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We use Isabelle's standard transitive-reflexive closure to define
reachability through the heap.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pred_reaches</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reaches"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x reaches y ≡ λs. (λx y. (x points_to y) s)<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup> x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The predicate ‹obj_at_field_on_heap› asserts that @{term ‹valid_ref r›}
and if ‹f› is a field of the object referred to by ‹r› then it it satisfies ‹P›.

›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rename *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>obj_at_field_on_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ref ⇒ bool) ⇒ 'ref ⇒ 'field ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at_field_on_heap P r f ≡ λs.
     case Option.map_option obj_fields (sys_heap s r) of
         None ⇒ False
       | Some fs ⇒ (case fs f of None ⇒ True
                               | Some r' ⇒ P r')"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Garbage collector locations ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idle_locs = prefixed ''idle''"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_locs = prefixed ''init''"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mark_locs = prefixed ''mark''"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mark_loop_locs = prefixed ''mark_loop''"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sweep_locs = prefixed ''sweep''"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Lemma bucket ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q (obj_at P r s) = ((sys_heap s r = None ⟶ Q False) ∧ (∀obj. sys_heap s r = Some obj ⟶ Q (P obj)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_split_asm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q (obj_at P r s) = (¬ ((sys_heap s r = None ∧ ¬Q False) ∨ (∃obj. sys_heap s r = Some obj ∧ ¬ Q (P obj))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>obj_at_splits</span><span> </span><span class="delimiter">=</span><span> </span><span>obj_at_split</span><span> </span><span>obj_at_split_asm</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_not_sys</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ≠ sys ⟷ p = gc ∨ (∃m. p = mutator m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>m'm</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m' ≠ m"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mm'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. map_option P (sys_heap s r))
          (obj_at P r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>obj_at_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">simps_of_case</span></span><span> </span><span>handshake_step_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>handshake_step_def</span><span> </span><span class="delimiter">(</span><span>splits</span><span class="delimiter">:</span><span> </span><span>handshake_phase.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Looks like a good idea but seems very weak. The split rules do a better job. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_weakenE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ obj_at P r s; ⋀s. P s ⟹ P' s ⟧ ⟹ obj_at P' r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_ref_sweep_loop_free</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at P r (s(sys := (s sys)⦇heap := (sys_heap s)(r' := None)⦈)) ⟷ obj_at P r s ∧ r ≠ r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_heap s r' = None
  ⟹ obj_at P r (s(Mut m := mut_m_s', sys := (s sys)⦇ heap := sys_heap s(r' ↦ obj) ⦈))
  ⟷ (obj_at P r s ∨ (r = r' ∧ P obj))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">simps_of_case</span></span><span> </span><span>do_read_action_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>do_read_action_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>atomize_eq</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="delimiter">(</span><span>splits</span><span class="delimiter">:</span><span> </span><span>mem_read_action.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">simps_of_case</span></span><span> </span><span>do_write_action_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>do_write_action_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>atomize_eq</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="delimiter">(</span><span>splits</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This gives some indication of how much we're cheating on the TSO front. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>do_write_action_prj_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fM (do_write_action w s) = fl ⟷ (fM s = fl ∧ w ≠ mw_fM (¬fM s)) ∨ w = mw_fM fl"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fl = fM (do_write_action w s) ⟷ (fl = fM s ∧ w ≠ mw_fM (¬fM s)) ∨ w = mw_fM fl"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA (do_write_action w s) = fl ⟷ (fA s = fl ∧ w ≠ mw_fA (¬fA s)) ∨ w = mw_fA fl"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fl = fA (do_write_action w s) ⟷ (fl = fA s ∧ w ≠ mw_fA (¬fA s)) ∨ w = mw_fA fl"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_handshake_in_sync (do_write_action w s) = ghost_handshake_in_sync s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_handshake_phase (do_write_action w s) = ghost_handshake_phase s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (do_write_action w s) = ghost_honorary_grey s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_pending (do_write_action w s) = handshake_pending s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_type (do_write_action w s) = handshake_type s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap (do_write_action w s) r = None ⟷ heap s r = None"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mem_lock (do_write_action w s) = mem_lock s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phase (do_write_action w s) = ph ⟷ (phase s = ph ∧ (∀ph'. w ≠ mw_Phase ph') ∨ w = mw_Phase ph)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ph = phase (do_write_action w s) ⟷ (ph = phase s ∧ (∀ph'. w ≠ mw_Phase ph') ∨ w = mw_Phase ph)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"W (do_write_action w s) = W s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_null_ref_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. r ⤜ (Option.map_option ⟨True⟩ ∘ sys_heap s))
          (valid_null_ref r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>obj_at_def</span><span> </span><span>valid_null_ref_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>valid_null_ref_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_null_ref_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_null_ref_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_null_ref None s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_null_ref (Some r) s ⟷ valid_ref r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_null_ref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heap_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. sys_heap s r)
          (obj_at_field_on_heap P r f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>obj_at_field_on_heap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>obj_at_field_on_heap_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_field_on_heap_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heapE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ obj_at_field_on_heap P r f s; sys_heap s' r = sys_heap s r; ⋀r'. P r' ⟹ P' r' ⟧
       ⟹ obj_at_field_on_heap P' r f s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heap_mw_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at_field_on_heap P r0 f0
         (s(sys := (s sys)⦇ heap := (sys_heap s)(r := Option.map_option (λobj :: ('field, 'ref) object. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                            mem_write_buffers := (mem_write_buffers (s Sys))(p := ws) ⦈))
⟷ ( (r ≠ r0 ∨ f ≠ f0) ∧ obj_at_field_on_heap P r0 f0 s )
   ∨ (r = r0 ∧ f = f0 ∧ valid_ref r s ∧ (case opt_r' of Some r'' ⇒ P r'' | _ ⇒ True))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at_field_on_heap P r f (s(sys := s sys⦇heap := (sys_heap s)(r' := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r')), mem_write_buffers := sb'⦈))
⟷ obj_at_field_on_heap P r f s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heap_no_pending_writes</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; ∀opt_r'. mw_Mutate r f opt_r' ∉ set (sys_mem_write_buffers (mutator m) s); valid_ref r s ⟧
     ⟹ obj_at_field_on_heap (λr. opt_r' = Some r) r f s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. obj_at_field_on_heap (λr'. heap (fr (s sys)) r ⤜ (λobj. obj_fields obj f) = Some r') r f s"</span></span></span><span>
</span><span>                             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. w ∈ set (sys_mem_write_buffers (mutator m) s)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>do_write_action_def</span><span> </span><span>Option.map_option_case</span><span>
</span><span>           </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heap_imp_valid_ref</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at_field_on_heap P r f s ⟹ valid_ref r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at_field_on_heap P r f s ⟹ valid_null_ref (Some r) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>valid_null_ref_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ obj_at_field_on_heap P r f s; ⋀s. P s ⟹ P' s⟧ ⟹ obj_at_field_on_heap P' r f s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Set_bind_insert</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"insert a A ⤜ B = B a ∪ (A ⤜ B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Set.bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_bind_invE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ f ⤜ g = None; ⋀a. ⟦ f = Some a; g a = None ⟧ ⟹ Q; f = None ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ f ⤜ g = Some x; ⋀a. ⟦ f = Some a; g a = Some x ⟧ ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="TSO">
<div class="head"><h1>Theory TSO</h1>
<span class="command">theory</span> <span class="name">TSO</span><br/>
<span class="keyword">imports</span> <a href="Proofs_basis.html"><span class="name">Proofs_basis</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>TSO</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Proofs_basis</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Coarse TSO invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Very coarse invariants about what processes write, and when they hold
the TSO lock.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gc_writes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_writes w ≡ case w of mw_Mark _ _ ⇒ True | mw_Phase _ ⇒ True | mw_fM _ ⇒ True | mw_fA _ ⇒ True | _ ⇒ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mut_writes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_writes w ≡ case w of mw_Mutate _ _ _ ⇒ True | mw_Mark _ _ ⇒ True | _ ⇒ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tso_writes_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv ≡
      (<span class="hidden">❙</span><span class="bold">∀</span>w.   tso_pending_write gc          w <span class="hidden">❙</span><span class="bold">⟶</span> ⟨gc_writes w⟩)
   <span class="hidden">❙</span><span class="bold">∧</span> (<span class="hidden">❙</span><span class="bold">∀</span>m w. tso_pending_write (mutator m) w <span class="hidden">❙</span><span class="bold">⟶</span> ⟨mut_writes w⟩)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_writes_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λp s. mem_write_buffers (s sys) p)
          tso_writes_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>tso_writes_inv_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tso_writes_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_writes_invD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s ⟹ ¬sys_mem_write_buffers gc s = mw_Mutate r f r' # ws"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s ⟹ ¬sys_mem_write_buffers (mutator m) s = mw_fA fl # ws"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s ⟹ ¬sys_mem_write_buffers (mutator m) s = mw_fM fl # ws"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s ⟹ ¬sys_mem_write_buffers (mutator m) s = mw_Phase ph # ws"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_do_write_action</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = w # ws; tso_writes_inv s ⟧ ⟹ fA (do_write_action w (s sys)) = sys_fA s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = w # ws; tso_writes_inv s ⟧ ⟹ fM (do_write_action w (s sys)) = sys_fM s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = w # ws; tso_writes_inv s ⟧ ⟹ phase (do_write_action w (s sys)) = sys_phase s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_writes_inv_sys_read_Mut</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ract, v) ∈ { (mr_fM, mv_Mark (Some (sys_fM s))), (mr_fA, mv_Mark (Some (sys_fA s))), (mr_Phase, mv_Phase (sys_phase s)) }"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read (mutator m) ract (s sys) = v"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. do_read_action ract (fr (s sys)) = v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mut_writes"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_read_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_writes_inv_sys_read_GC</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_writes_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read gc (mr_Ref r f) (s sys) = mv_Ref (sys_heap s r ⤜ (λobj. obj_fields obj f))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = mv_Ref ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. heap (fr (s sys)) r ⤜ (λobj. obj_fields obj f) = ?rhs"</span></span></span><span>
</span><span>                             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. ∀r f r'. w ≠ mw_Mutate r f r'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>Option.map_option_case</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_no_pending_marksD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mark p s = []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read p (mr_Mark r) (s sys) = mv_Mark (Option.map_option obj_mark (sys_heap s r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. Option.map_option obj_mark (heap (fr (s sys)) r) = Option.map_option obj_mark (sys_heap s r)"</span></span></span><span>
</span><span>                             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. ∀fl. w ≠ mw_Mark r fl"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Option.map_option_case</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_pending_phase_sys_read</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_phase p s = []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read p mr_Phase (s sys) = mv_Phase (sys_phase s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. phase (fr (s sys)) = sys_phase s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. ∀ph. w ≠ mw_Phase ph"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_no_pending_fM_write</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_fM gc s = []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read gc mr_fM (s sys) = mv_Mark (Some (sys_fM s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. fM (fr (s sys)) = sys_fM s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. ∀fl. w ≠ mw_fM fl"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>tso_gc_writes_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP tso_writes_inv ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>tso_writes_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP tso_writes_inv ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>tso_writes_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP tso_writes_inv ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_writes_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Locations where the TSO lock is held›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The GC holds the TSO lock only during the \texttt{CAS} in @{const
"mark_object"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span>gc_tso_lock_locs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_tso_lock_locs ≡ ⋃l∈{ ''mo_co_cmark'', ''mo_co_ctest'', ''mo_co_mark'', ''mo_co_unlock'' }. suffixed l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>tso_lock_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_lock_invL ≡
     atS_gc gc_tso_lock_locs (tso_locked_by gc)
   <span class="hidden">❙</span><span class="bold">∧</span> atS_gc (- gc_tso_lock_locs) (<span class="hidden">❙</span><span class="bold">¬</span> (tso_locked_by gc))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ tso_lock_invL ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.tso_lock_invL ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.tso_lock_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

A mutator holds the TSO lock only during the \texttt{CAS}s in @{const
"mark_object"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_tso_lock_locs =
  (⋃l∈{ ''mo_co_cmark'', ''mo_co_ctest'', ''mo_co_mark'', ''mo_co_unlock'' }. suffixed l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>tso_lock_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_lock_invL =
    (atS_mut mut_tso_lock_locs     (tso_locked_by (mutator m))
   <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (- mut_tso_lock_locs) (<span class="hidden">❙</span><span class="bold">¬</span>(tso_locked_by (mutator m))))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ tso_lock_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.tso_lock_invL m ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.tso_lock_invL m ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>tso_lock_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ tso_lock_invL ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Handshakes">
<div class="head"><h1>Theory Handshakes</h1>
<span class="command">theory</span> <span class="name">Handshakes</span><br/>
<span class="keyword">imports</span> <a href="TSO.html"><span class="name">TSO</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Handshakes</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>TSO</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Handshake phases›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The mutators can be at most one step behind the garbage collector (and
system). If any mutator is behind then the GC is stalled on a pending
handshake. Unfortunately this is a complicated by needing to consider
the handshake type due to ‹get_work›. This relation is very
precise.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hp_step_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool × handshake_type × handshake_phase × handshake_phase) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hp_step_rel ≡
  { True }  × ({ (ht_NOOP, hp, hp) |hp. hp ∈ {hp_Idle, hp_IdleInit, hp_InitMark, hp_Mark} }
            ∪ { (ht_GetRoots, hp_IdleMarkSweep, hp_IdleMarkSweep)
              , (ht_GetWork,  hp_IdleMarkSweep, hp_IdleMarkSweep) })
∪ { False } × { (ht_NOOP,     hp_Idle,          hp_IdleMarkSweep)
              , (ht_NOOP,     hp_IdleInit,      hp_Idle)
              , (ht_NOOP,     hp_InitMark,      hp_IdleInit)
              , (ht_NOOP,     hp_Mark,          hp_InitMark)
              , (ht_GetRoots, hp_IdleMarkSweep, hp_Mark)
              , (ht_GetWork,  hp_IdleMarkSweep, hp_IdleMarkSweep) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_phase_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_phase_inv = (<span class="hidden">❙</span><span class="bold">∀</span>m.
      (sys_ghost_handshake_in_sync m <span class="hidden">❙</span><span class="bold">⊗</span> sys_handshake_type
        <span class="hidden">❙</span><span class="bold">⊗</span> sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">⊗</span> mut_m.mut_ghost_handshake_phase m) <span class="hidden">❙</span><span class="bold">∈</span> ⟨hp_step_rel⟩
  <span class="hidden">❙</span><span class="bold">∧</span> (sys_handshake_pending m <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_ghost_handshake_in_sync m)))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Sanity *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>handshake_step_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hp' = handshake_step hp ⟹ ∃in' ht. (in', ht, hp', hp) ∈ hp_step_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>hp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Sanity *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>handshake_step_invD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(False, ht, hp', hp) ∈ hp_step_rel ⟹ hp' = hp_step ht hp"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ht</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_phase_inv s ⟹ (sys_ghost_handshake_in_sync m s, sys_handshake_type s, sys_ghost_handshake_phase s, mut_ghost_handshake_phase s) ∈ hp_step_rel
                          ∧ (sys_handshake_pending m s ⟶ ¬sys_ghost_handshake_in_sync m s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>handshake_phase_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>handshake_in_syncD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ All (ghost_handshake_in_sync (s sys)); handshake_phase_inv s ⟧
     ⟹ ∀m'. mut_m.mut_ghost_handshake_phase m' s = sys_ghost_handshake_phase s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>handshake_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP handshake_phase_inv ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Connect @{const "sys_ghost_handshake_phase"} with locations in the GC.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hp_Idle_locs =
  (prefixed ''idle_noop'' - { ''idle_noop_mfence'', ''idle_noop_init_type'' })
∪ { ''idle_read_fM'', ''idle_invert_fM'', ''idle_write_fM'', ''idle_flip_noop_mfence'', ''idle_flip_noop_init_type'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hp_IdleInit_locs =
    (prefixed ''idle_flip_noop'' - { ''idle_flip_noop_mfence'', ''idle_flip_noop_init_type'' })
  ∪ { ''idle_phase_init'', ''init_noop_mfence'', ''init_noop_init_type'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hp_InitMark_locs =
  (prefixed ''init_noop'' - { ''init_noop_mfence'', ''init_noop_init_type'' })
∪ { ''init_phase_mark'', ''mark_read_fM'', ''mark_write_fA'', ''mark_noop_mfence'', ''mark_noop_init_type'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hp_IdleMarkSweep_locs =
     { ''idle_noop_mfence'', ''idle_noop_init_type'', ''mark_end'' }
  ∪  sweep_locs
  ∪ (mark_loop_locs - { ''mark_loop_get_roots_init_type'' })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hp_Mark_locs =
    (prefixed ''mark_noop'' - { ''mark_noop_mfence'', ''mark_noop_init_type'' })
  ∪ { ''mark_loop_get_roots_init_type'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hs_noop_prefixes ≡ {''idle_noop'', ''idle_flip_noop'', ''init_noop'', ''mark_noop'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_noop_locs =
  (⋃l ∈ hs_noop_prefixes. prefixed l - (suffixed ''_noop_mfence'' ∪ suffixed ''_noop_init_type''))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_get_roots_locs =
  prefixed ''mark_loop_get_roots'' - {''mark_loop_get_roots_init_type''}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_get_work_locs =
  prefixed ''mark_loop_get_work'' - {''mark_loop_get_work_init_type''}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_prefixes ≡
  hs_noop_prefixes ∪ { ''mark_loop_get_roots'', ''mark_loop_get_work'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_init_loop_locs = (⋃l ∈ hs_prefixes. prefixed (l @ ''_init_loop''))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_done_loop_locs = (⋃l ∈ hs_prefixes. prefixed (l @ ''_done_loop''))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_done_locs = (⋃l ∈ hs_prefixes. prefixed (l @ ''_done''))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_none_pending_locs = - (hs_init_loop_locs ∪ hs_done_locs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_in_sync_locs =
  (- ( (⋃l ∈ hs_prefixes. prefixed (l @ ''_init'')) ∪ hs_done_locs ))
  ∪ (⋃l ∈ hs_prefixes. {l @ ''_init_type''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_out_of_sync_locs =
  (⋃l ∈ hs_prefixes. {l @ ''_init_muts''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_mut_in_muts_locs =
  (⋃l ∈ hs_prefixes. {l @ ''_init_loop_set_pending'', l @ ''_init_loop_done''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_init_loop_done_locs =
  (⋃l ∈ hs_prefixes. {l @ ''_init_loop_done''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hs_init_loop_not_done_locs =
  (hs_init_loop_locs - (⋃l ∈ hs_prefixes. {l @ ''_init_loop_done''}))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_invL =
     (atS_gc hs_noop_locs         (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_NOOP⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_get_roots_locs    (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_GetRoots⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_get_work_locs     (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_GetWork⟩)

    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_mut_in_muts_locs      (gc_mut <span class="hidden">❙</span><span class="bold">∈</span> gc_muts)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_init_loop_locs        (<span class="hidden">❙</span><span class="bold">∀</span>m. <span class="hidden">❙</span><span class="bold">¬</span>(⟨m⟩ <span class="hidden">❙</span><span class="bold">∈</span> gc_muts) <span class="hidden">❙</span><span class="bold">⟶</span> sys_handshake_pending m
                                                                  <span class="hidden">❙</span><span class="bold">∨</span> sys_ghost_handshake_in_sync m)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_init_loop_not_done_locs (<span class="hidden">❙</span><span class="bold">∀</span>m.   ⟨m⟩ <span class="hidden">❙</span><span class="bold">∈</span> gc_muts <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_handshake_pending m)
                                                                 <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_ghost_handshake_in_sync m))
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_init_loop_done_locs     ( (sys_handshake_pending <span class="hidden">❙</span><span class="bold">$</span> gc_mut
                                        <span class="hidden">❙</span><span class="bold">∨</span> sys_ghost_handshake_in_sync <span class="hidden">❙</span><span class="bold">$</span> gc_mut)
                                      <span class="hidden">❙</span><span class="bold">∧</span> (<span class="hidden">❙</span><span class="bold">∀</span>m. ⟨m⟩ <span class="hidden">❙</span><span class="bold">∈</span> gc_muts <span class="hidden">❙</span><span class="bold">∧</span> ⟨m⟩ <span class="hidden">❙</span><span class="bold">≠</span> gc_mut
                                                                 <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_handshake_pending m)
                                                                   <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_ghost_handshake_in_sync m)) )
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_done_locs       (<span class="hidden">❙</span><span class="bold">∀</span>m. sys_handshake_pending m <span class="hidden">❙</span><span class="bold">∨</span> sys_ghost_handshake_in_sync m)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_done_loop_locs  (<span class="hidden">❙</span><span class="bold">∀</span>m. <span class="hidden">❙</span><span class="bold">¬</span>(⟨m⟩ <span class="hidden">❙</span><span class="bold">∈</span> gc_muts) <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_handshake_pending m))
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_none_pending_locs (<span class="hidden">❙</span><span class="bold">∀</span>m. <span class="hidden">❙</span><span class="bold">¬</span>(sys_handshake_pending m))
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_in_sync_locs      (<span class="hidden">❙</span><span class="bold">∀</span>m. sys_ghost_handshake_in_sync m)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hs_out_of_sync_locs  (<span class="hidden">❙</span><span class="bold">∀</span>m. <span class="hidden">❙</span><span class="bold">¬</span>(sys_handshake_pending m)
                                         <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(sys_ghost_handshake_in_sync m))

    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hp_Idle_locs          (sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_Idle⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hp_IdleInit_locs      (sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleInit⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hp_InitMark_locs      (sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_InitMark⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hp_IdleMarkSweep_locs (sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩)
    <span class="hidden">❙</span><span class="bold">∧</span> atS_gc hp_Mark_locs          (sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_Mark⟩))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hs_get_roots_locs ⊆ hp_IdleMarkSweep_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hs_get_roots_locs_def</span><span> </span><span>hp_IdleMarkSweep_locs_def</span><span> </span><span>mark_loop_locs_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hs_get_work_locs ⊆ hp_IdleMarkSweep_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hs_get_work_locs_def</span><span> </span><span>hp_IdleMarkSweep_locs_def</span><span> </span><span>mark_loop_locs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_handshake_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. (AT s gc, s↓ gc, sys_ghost_handshake_phase s↓, handshake_pending (s↓ sys), ghost_handshake_in_sync (s↓ sys), sys_handshake_type s↓))
          gc.handshake_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.handshake_invL_def</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_handshake_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc_handshake_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer_ff</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.handshake_invL ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP handshake_phase_inv ⦄ gc ⦃ LSTP handshake_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer_ff</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_inv_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Local handshake phase invariant for the mutators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_no_pending_mutates_locs =
    (prefixed ''hs_noop'' - { ''hs_noop'', ''hs_noop_mfence'' })
  ∪ (prefixed ''hs_get_roots'' - { ''hs_get_roots'', ''hs_get_roots_mfence'' })
  ∪ (prefixed ''hs_get_work'' - { ''hs_get_work'', ''hs_get_work_mfence'' })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_invL =
   (atS_mut (prefixed ''hs_noop_'')     (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_NOOP⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_handshake_pending m)
 <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''hs_get_roots_'') (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_GetRoots⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_handshake_pending m)
 <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''hs_get_work_'')  (sys_handshake_type <span class="hidden">❙</span><span class="bold">=</span> ⟨ht_GetWork⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_handshake_pending m)
 <span class="hidden">❙</span><span class="bold">∧</span> atS_mut mut_no_pending_mutates_locs  (LIST_NULL (tso_pending_mutate (mutator m))))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. (AT s (mutator m), s↓ (mutator m), sys_handshake_type s↓, handshake_pending (s↓ sys), mem_write_buffers (s↓ sys) (mutator m)))
          handshake_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_m_handshake_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.handshake_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mut_m.handshake_invL m ⦄ gc ⦃ mut_m.handshake_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.handshake_invL m ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_handshake_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL ⦄ mutator m ⦃ gc.handshake_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP handshake_phase_inv ⦄ mutator m ⦃ LSTP handshake_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Relate @{const "sys_ghost_handshake_phase"}, @{const "gc_phase"},
@{const "sys_phase"} and writes to the phase in the GC's TSO buffer.

The first relation treats the case when the GC's TSO buffer does not
contain any writes to the phase.

The second relation exhibits the data race on the phase variable: we
need to precisely track the possible states of the GC's TSO buffer.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>handshake_phase_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_phase ⇒ bool ⇒ gc_phase ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"handshake_phase_rel hp in_sync ph ≡
     case hp of
       hp_Idle          ⇒ ph = ph_Idle
     | hp_IdleInit      ⇒ ph = ph_Idle ∨ (in_sync ∧ ph = ph_Init)
     | hp_InitMark      ⇒ ph = ph_Init ∨ (in_sync ∧ ph = ph_Mark)
     | hp_Mark          ⇒ ph = ph_Mark
     | hp_IdleMarkSweep ⇒ ph = ph_Mark ∨ (in_sync ∧ ph ∈ { ph_Idle, ph_Sweep })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phase_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool × handshake_phase × gc_phase × gc_phase × ('field, 'ref) mem_write_action list) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phase_rel ≡
      { (in_sync, hp, ph, ph, []) |in_sync hp ph. handshake_phase_rel hp in_sync ph }
    ∪ ({True} × { (hp_IdleInit, ph_Init, ph_Idle, [mw_Phase ph_Init]),
                  (hp_InitMark, ph_Mark, ph_Init, [mw_Phase ph_Mark]),
                  (hp_IdleMarkSweep, ph_Sweep, ph_Mark, [mw_Phase ph_Sweep]),
                  (hp_IdleMarkSweep, ph_Idle, ph_Mark, [mw_Phase ph_Sweep, mw_Phase ph_Idle]),
                  (hp_IdleMarkSweep, ph_Idle, ph_Sweep, [mw_Phase ph_Idle]) })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phase_rel_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phase_rel_inv = ((<span class="hidden">❙</span><span class="bold">∀</span>m. sys_ghost_handshake_in_sync m) <span class="hidden">❙</span><span class="bold">⊗</span> sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">⊗</span> gc_phase <span class="hidden">❙</span><span class="bold">⊗</span> sys_phase <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_phase gc <span class="hidden">❙</span><span class="bold">∈</span> ⟨phase_rel⟩)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">simps_of_case</span></span><span> </span><span>handshake_phase_rel_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>handshake_phase_rel_def</span><span> </span><span class="delimiter">(</span><span>splits</span><span class="delimiter">:</span><span> </span><span>handshake_phase.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phase_rel_invD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phase_rel_inv s ⟹ (∀m. sys_ghost_handshake_in_sync m s, sys_ghost_handshake_phase s, gc_phase s, sys_phase s, tso_pending_phase gc s) ∈ phase_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>phase_rel_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phases_rel_Id</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀m. sys_ghost_handshake_in_sync m s, sys_ghost_handshake_phase s, gc_phase s, sys_phase s, tso_pending_phase gc s) ∈ phase_rel
     ⟹ (∀ph. mw_Phase ph ∉ set (sys_mem_write_buffers gc s)) ⟷ sys_phase s = gc_phase s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>filter_eq_Cons_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Tie the garbage collector's control location to the value of @{const
"gc_phase"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span>no_pending_phase_locs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_pending_phase_locs ≡
       (idle_locs - { ''idle_noop_mfence'' })
     ∪ (init_locs - { ''init_noop_mfence'' })
     ∪ (mark_locs - { ''mark_read_fM'', ''mark_write_fA'', ''mark_noop_mfence'' })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>phase_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phase_invL =
     (atS_gc idle_locs             (gc_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Idle⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc init_locs             (gc_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Init⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc mark_locs             (gc_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Mark⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc sweep_locs            (gc_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Sweep⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc no_pending_phase_locs (LIST_NULL (tso_pending_phase gc)))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>phase_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr (s :: ('field, 'mut, 'ref) gc_pred_state). (AT s gc, s↓ gc, tso_pending_phase gc s↓))
          phase_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_phase_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc.phase_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>phase_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ phase_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP phase_rel_inv ⦄ gc ⦃ phase_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>phase_rel_invD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_phase_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.phase_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.phase_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP tso_writes_inv ⦄ sys ⦃ gc.phase_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_phase_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.phase_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.phase_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>phase_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>phase_rel_inv_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> phase_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP phase_rel_inv ⦄ gc ⦃ LSTP phase_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer_ff</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>phase_rel_invD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>phase_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.phase_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span> </span><span>phase_rel_inv_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄ sys ⦃ LSTP phase_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>p_not_sys</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>phase_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv) ⦄
     mutator m
   ⦃ LSTP phase_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span>
</span><span>             </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span>
</span><span>             </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span>
</span><span>             </span><span>simp</span><span class="delimiter">:</span><span> </span><span>handshake_phase_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Validity of @{const "sys_fM"} wrt @{const "gc_fM"} and the handshake
phase. Effectively we use @{const "gc_fM"} as ghost state. We also
include the TSO lock to rule out the GC having any pending marks
during the @{const "hp_Idle"} handshake phase.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fM_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool × handshake_phase × gc_mark × gc_mark × ('field, 'ref) mem_write_action list × bool) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fM_rel =
      { (in_sync, hp, fM, fM, [], l) |fM hp in_sync l. hp = hp_Idle ⟶ ¬in_sync }
    ∪ { (in_sync, hp_Idle, fM, fM', [], l) |fM fM' in_sync l. in_sync }
    ∪ { (in_sync, hp_Idle, ¬fM, fM, [mw_fM (¬fM)], False) |fM in_sync. in_sync }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fM_rel_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fM_rel_inv = ((<span class="hidden">❙</span><span class="bold">∀</span>m. sys_ghost_handshake_in_sync m) <span class="hidden">❙</span><span class="bold">⊗</span> sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">⊗</span> gc_fM <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_fM gc <span class="hidden">❙</span><span class="bold">⊗</span> (sys_mem_lock <span class="hidden">❙</span><span class="bold">=</span> ⟨Some gc⟩) <span class="hidden">❙</span><span class="bold">∈</span> ⟨fM_rel⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fA_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool × handshake_phase × gc_mark × gc_mark × ('field, 'ref) mem_write_action list) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA_rel =
      { (in_sync, hp_Idle,          fA,  fM, []) |fA fM in_sync. ¬in_sync ⟶ fA = fM }
    ∪ { (in_sync, hp_IdleInit,      fA, ¬fA, []) |fA in_sync. True }
    ∪ { (in_sync, hp_InitMark,      fA, ¬fA, [mw_fA (¬fA)]) |fA in_sync. in_sync }
    ∪ { (in_sync, hp_InitMark,      fA,  fM, []) |fA fM in_sync. ¬in_sync ⟶ fA ≠ fM }
    ∪ { (in_sync, hp_Mark,          fA,  fA, []) |fA in_sync. True }
    ∪ { (in_sync, hp_IdleMarkSweep, fA,  fA, []) |fA in_sync. True }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fA_rel_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA_rel_inv = ((<span class="hidden">❙</span><span class="bold">∀</span>m. sys_ghost_handshake_in_sync m) <span class="hidden">❙</span><span class="bold">⊗</span> sys_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">⊗</span> sys_fA <span class="hidden">❙</span><span class="bold">⊗</span> gc_fM <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_fA gc <span class="hidden">❙</span><span class="bold">∈</span> ⟨fA_rel⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fM_eq_locs = (- { ''idle_write_fM'', ''idle_flip_noop_mfence'' })"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fM_tso_empty_locs = (- { ''idle_flip_noop_mfence'' })"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fA_tso_empty_locs = (- { ''mark_noop_mfence'' })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA_eq_locs ≡ { ''idle_read_fM'', ''idle_invert_fM'' }
              ∪ prefixed ''idle_noop''
              ∪ (mark_locs - { ''mark_read_fM'', ''mark_write_fA'', ''mark_noop_mfence'' })
              ∪ sweep_locs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA_neq_locs ≡ { ''idle_phase_init'', ''idle_write_fM'', ''mark_read_fM'', ''mark_write_fA'' }
               ∪ prefixed ''idle_flip_noop''
               ∪ init_locs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>fM_fA_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fM_fA_invL =
   (atS_gc fM_eq_locs                    (sys_fM  <span class="hidden">❙</span><span class="bold">=</span> gc_fM)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''idle_write_fM''              (sys_fM <span class="hidden">❙</span><span class="bold">≠</span> gc_fM)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''idle_flip_noop_mfence''      (sys_fM <span class="hidden">❙</span><span class="bold">≠</span> gc_fM <span class="hidden">❙</span><span class="bold">⟶</span> (<span class="hidden">❙</span><span class="bold">¬</span>(LIST_NULL (tso_pending_fM gc))))
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc fM_tso_empty_locs             (LIST_NULL (tso_pending_fM gc))

  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc fA_eq_locs                    (sys_fA  <span class="hidden">❙</span><span class="bold">=</span> gc_fM)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc fA_neq_locs                   (sys_fA <span class="hidden">❙</span><span class="bold">≠</span> gc_fM)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_noop_mfence''           (sys_fA <span class="hidden">❙</span><span class="bold">≠</span> gc_fM <span class="hidden">❙</span><span class="bold">⟶</span> (<span class="hidden">❙</span><span class="bold">¬</span>(LIST_NULL (tso_pending_fA gc))))
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc fA_tso_empty_locs             (LIST_NULL (tso_pending_fA gc)))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fM_rel_invD</span><span> </span><span class="delimiter">=</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fM_rel_inv_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>atomize_eq</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>do_write_action_fM</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = w # ws; tso_writes_inv s; handshake_phase_inv s; fM_rel_inv s;
     ghost_handshake_phase (s (mutator m)) ≠ hp_Idle ∨ (sys_ghost_handshake_phase s = hp_IdleMarkSweep ∧ All (ghost_handshake_in_sync (s sys)));
     p ≠ sys ⟧
     ⟹ fM (do_write_action w (s sys)) = fM (s sys)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>p_not_sys</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fA_rel_invD</span><span> </span><span class="delimiter">=</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fA_rel_inv_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>atomize_eq</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_fM_fA_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. (AT s gc, s↓ gc, sys_fA s↓, sys_fM s↓, sys_mem_write_buffers gc s↓))
          gc.fM_fA_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.fM_fA_invL_def</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_fM_fA_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc_fM_fA_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>fM_fA_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>fM_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP fM_rel_inv ⦄
     gc
   ⦃ LSTP fM_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>fA_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP fA_rel_inv ⦄
     gc
   ⦃ LSTP fA_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_fM_fA_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.fM_fA_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>fM_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP fM_rel_inv ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME trivial but eta reduction plays merry hell *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>fA_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP fA_rel_inv ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fA_neq_locs_diff_fA_tso_empty_locs</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fA_neq_locs - fA_tso_empty_locs = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fA_neq_locs_def</span><span> </span><span>fA_tso_empty_locs_def</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_fM_fA_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.fM_fA_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     sys
   ⦃ gc.fM_fA_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fA_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>atS_dests</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fA_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>fM_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄ sys ⦃ LSTP fM_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>fA_rel_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄ sys ⦃ LSTP fA_rel_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fA_rel_def</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_get_roots_no_fM_write</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS (mutator m) (prefixed ''hs_get_roots_'') s; mut_m.handshake_invL m s; handshake_phase_inv s↓; fM_rel_inv s↓; tso_writes_inv s↓; p ≠ sys ⟧
     ⟹ ¬sys_mem_write_buffers p s↓ = mw_fM fl # ws"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mut_m.handshake_invL_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>fM_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>loc</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_get_roots_no_phase_write</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS (mutator m) (prefixed ''hs_get_roots_'') s; mut_m.handshake_invL m s; handshake_phase_inv s↓; phase_rel_inv s↓; tso_writes_inv s↓; p ≠ sys ⟧
     ⟹ ¬sys_mem_write_buffers p s↓ = mw_Phase ph # ws"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mut_m.handshake_invL_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>loc</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_not_idle_no_fM_write</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_handshake_phase (s (mutator m)) ≠ hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_writes_inv s; p ≠ sys ⟧
     ⟹ ¬sys_mem_write_buffers p s = mw_fM fl # ws"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>fM_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mut_ghost_handshake_phase_idle</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_ghost_handshake_phase s = hp_Idle; handshake_phase_inv s; phase_rel_inv s ⟧
     ⟹ sys_phase s = ph_Idle"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>phase_rel_invD</span><span> </span><span>handshake_phase_invD</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="MarkObject">
<div class="head"><h1>Theory MarkObject</h1>
<span class="command">theory</span> <span class="name">MarkObject</span><br/>
<span class="keyword">imports</span> <a href="Handshakes.html"><span class="name">Handshakes</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MarkObject</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Handshakes</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Object colours, reference validity, worklist validity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We adopt the classical tricolour scheme for object colours due to
@{cite [cite_macro=citet] "DBLP:journals/cacm/DijkstraLMSS78"}, but
tweak it somewhat in the presence of worklists and TSO. Intuitively:
\begin{description}
\item[White] potential garbage, not yet reached
\item[Grey] reached, presumed live, a source of possible new references (work)
\item[Black] reached, presumed live, not a source of new references
\end{description}

In this particular setting we use the following interpretation:
\begin{description}
\item[White:] not marked
\item[Grey:] on a worklist
\item[Black:] marked and not on a worklist
\end{description}

Note that this allows the colours to overlap: an object being marked
may be white (on the heap) and in @{const "ghost_honorary_grey"} for
some process, i.e. grey.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>marked</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked r s ≡ obj_at (λobj. obj_mark obj = sys_fM s) r s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>white</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r s ≡ obj_at (λobj. obj_mark obj = (¬sys_fM s)) r s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>WL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name ⇒ ('field, 'mut, 'ref) lsts ⇒ 'ref set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WL p ≡ λs. W (s p) ∪ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>grey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r ≡ <span class="hidden">❙</span><span class="bold">∃</span>p. ⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> WL p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>black</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r ≡ marked r <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(grey r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We show that if a mutator can load a reference into its roots (its
working set of references), then there is an object in the heap at
that reference.

In this particular collector, we can think of grey references and
pending TSO heap mutations as extra mutator roots; in particular the
GC holds no roots itself but marks everything reachable from its
worklist, and so we need to know these objects exist. By the strong
tricolour invariant (\S\ref{sec:strong-tricolour-invariant}), black
objects point to black or grey objects, and so we do not need to treat
these specially.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>write_refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ 'ref set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"write_refs w ≡ case w of mw_Mutate r f r' ⇒ {r} ∪ Option.set_option r' | _ ⇒ {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>tso_write_refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts ⇒ 'ref set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_write_refs = (λs. ⋃w ∈ set (sys_mem_write_buffers (mutator m) s). write_refs w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable y = (<span class="hidden">❙</span><span class="bold">∃</span>x. ⟨x⟩ <span class="hidden">❙</span><span class="bold">∈</span> mut_roots <span class="hidden">❙</span><span class="bold">∪</span> mut_ghost_honorary_root <span class="hidden">❙</span><span class="bold">∪</span> tso_write_refs
                    <span class="hidden">❙</span><span class="bold">∧</span> x reaches y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>grey_reachable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey_reachable y = (<span class="hidden">❙</span><span class="bold">∃</span>g. grey g <span class="hidden">❙</span><span class="bold">∧</span> g reaches y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_refs_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv = (<span class="hidden">❙</span><span class="bold">∀</span>x. ((<span class="hidden">❙</span><span class="bold">∃</span>m. mut_m.reachable m x) <span class="hidden">❙</span><span class="bold">∨</span> grey_reachable x) <span class="hidden">❙</span><span class="bold">⟶</span> valid_ref x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{def:valid_W_inv}

The worklists track the grey objects. The following invariant asserts
that grey objects are marked on the heap except for a few steps near
the end of @{const "mark_object_fn"}, the processes' worklists and
@{const "ghost_honorary_grey"}s are disjoint, and that pending marks
are sensible.

The safety of the collector does not to depend on disjointness; we
include it as proof that the single-threading of grey objects in the
implementation is sound.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_W_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_W_inv = (<span class="hidden">❙</span><span class="bold">∀</span>p q r fl.
    (r in_W p <span class="hidden">❙</span><span class="bold">∨</span> (sys_mem_lock <span class="hidden">❙</span><span class="bold">≠</span> ⟨Some p⟩ <span class="hidden">❙</span><span class="bold">∧</span> r in_ghost_honorary_grey p) <span class="hidden">❙</span><span class="bold">⟶</span> marked r)
  <span class="hidden">❙</span><span class="bold">∧</span> (⟨p ≠ q⟩ <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> WL p <span class="hidden">❙</span><span class="bold">∧</span> ⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> WL q))
  <span class="hidden">❙</span><span class="bold">∧</span> (<span class="hidden">❙</span><span class="bold">¬</span>(r in_ghost_honorary_grey p <span class="hidden">❙</span><span class="bold">∧</span> r in_W q))
  <span class="hidden">❙</span><span class="bold">∧</span> (EMPTY sys_ghost_honorary_grey)
  <span class="hidden">❙</span><span class="bold">∧</span> (tso_pending_write p (mw_Mark r fl)
       <span class="hidden">❙</span><span class="bold">⟶</span> ( ⟨fl⟩ <span class="hidden">❙</span><span class="bold">=</span> sys_fM
             <span class="hidden">❙</span><span class="bold">∧</span> r in_ghost_honorary_grey p
             <span class="hidden">❙</span><span class="bold">∧</span> tso_locked_by p
             <span class="hidden">❙</span><span class="bold">∧</span> white r
             <span class="hidden">❙</span><span class="bold">∧</span> tso_pending_mark p <span class="hidden">❙</span><span class="bold">=</span> ⟨[mw_Mark r fl]⟩ )))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_at_mark_dequeue</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_at P r (s(sys := s sys⦇ heap := (sys_heap s)(r' := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r')), mem_write_buffers := wb' ⦈))
⟷ (r = r' ⟶ obj_at (λobj. (P (obj⦇ obj_mark := fl ⦈))) r s) ∧ (r ≠ r' ⟶ obj_at P r s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_not_white</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r s ⟹ ¬marked r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_ref_valid_null_ref_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_ref r (s(sys := do_write_action w (s sys)⦇mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈)) ⟷ valid_ref r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_null_ref r' (s(sys := do_write_action w (s sys)⦇mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈)) ⟷ valid_null_ref r' s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_null_ref r' (s(mutator m := mut_s', sys := (s sys)⦇ heap := (heap (s sys))(r'' ↦ obj) ⦈)) ⟷ valid_null_ref r' s ∨ r' = Some r''"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>valid_null_ref_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹points to, reaches, reachable mut, reachable grey›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_fields</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x reaches y) s'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. (Option.set_option (sys_heap s' r) ⤜ ran ∘ obj_fields) = (Option.set_option (sys_heap s r) ⤜ ran ∘ obj_fields)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x reaches y) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y points_to z) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s y"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr s. Option.set_option (sys_heap s r) ⤜ ran ∘ obj_fields)
          (x reaches y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>reaches_fields</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reaches_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reaches_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr'. mut_roots <span class="hidden">❙</span><span class="bold">⊗</span> mut_ghost_honorary_root <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.set_option (sys_heap s r') ⤜ ran ∘ obj_fields) <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate (mutator m))
          (reachable r)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>reachable_def</span><span> </span><span>tso_write_refs_def</span><span> </span><span>ex_disj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r'. (∃w∈set (sys_mem_write_buffers (mutator m) s). r' ∈ write_refs w) ⟷ (∃w∈set (sys_mem_write_buffers (mutator m) s'). r' ∈ write_refs w)"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (x reaches r) s ⟷ (x reaches r) s'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reaches_fields</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>set</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>r'</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>r'</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reachable_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.reachable_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachableI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ mut_m.mut_roots m s ⟹ mut_m.reachable m x s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ mut_m.tso_write_refs m s ⟹ mut_m.reachable m x s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachableE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (x points_to y) s; mut_m.reachable m x s ⟧ ⟹ mut_m.reachable m y s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span>
</span><span>         </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_induct</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>root</span><span> </span><span>ghost_honorary_root</span><span> </span><span>tso_root</span><span> </span><span>reaches</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable y s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>root</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⟦ x ∈ mut_roots s ⟧ ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ghost_honorary_root</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⟦ x ∈ mut_ghost_honorary_root s ⟧ ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>tso_root</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⟦ x ∈ tso_write_refs s ⟧ ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>reaches</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. ⟦ reachable x s; (x points_to y) s; P x ⟧ ⟹ P y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachable_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x reaches y) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ mut_roots s ∪ mut_ghost_honorary_root s ∪ tso_write_refs s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>root</span><span> </span><span>ghost_honorary_root</span><span> </span><span>tso_root</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reaches</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reachable_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>mut_m.reachable_induct</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>root</span><span> </span><span>ghost_honorary_root</span><span> </span><span>tso_root</span><span> </span><span>reaches</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mut_reachableE</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>mut_root</span><span> </span><span>tso_write_refs</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable y s;
     ⋀x. ⟦ (x reaches y) s; x ∈ mut_roots s ⟧ ⟹ Q;
     ⋀x. ⟦ (x reaches y) s; x ∈ mut_ghost_honorary_root s ⟧ ⟹ Q;
     ⋀x. ⟦ (x reaches y) s; x ∈ tso_write_refs s ⟧ ⟹ Q ⟧ ⟹ Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_reachable_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr'. (λs. ⋃p. WL p s) <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.set_option (sys_heap s r') ⤜ ran ∘ obj_fields))
          (grey_reachable r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>grey_reachable_def</span><span> </span><span>grey_def</span><span> </span><span>set_eq_iff</span><span> </span><span>reaches_fields</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>grey_reachable_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>grey_reachable_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_reachableI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey g s ⟹ grey_reachable g s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_reachableE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (g points_to y) s; grey_reachable g s ⟧ ⟹ grey_reachable y s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_reachable_def</span><span>
</span><span>         </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹colours and work lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ_::unit. (λs. r ∈ (⋃p. WL p s)) <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark (sys_heap s r)))
          (black r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>white_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ_::unit. sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark (sys_heap s r)))
          (white r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>obj_at_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ_::unit. (λs. r ∈ (⋃p. WL p s)))
          (grey r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>black_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>black_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>grey_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>grey_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>white_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>white_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ These demonstrate the overlap in colours. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_distinct</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r s ⟹ ¬grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r s ⟹ ¬white r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r s  ⟹ ¬black r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r s ⟹ ¬black r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_imp_black_or_grey</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked r s ⟹ black r s ∨ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ white r s ⟹ ¬ valid_ref r s ∨ black r s ∨ grey r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blackD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r s ⟹ marked r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r s ⟹ r ∉ WL p s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹valid refs inv›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(m', r'). (λs. roots (s (mutator m'))) <span class="hidden">❙</span><span class="bold">⊗</span> (λs. ghost_honorary_root (s (mutator m'))) <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_fields (sys_heap s r')) <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate (mutator m') <span class="hidden">❙</span><span class="bold">⊗</span> (λs. ⋃p. WL p s))
          valid_refs_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. valid_ref r s ⟷ valid_ref r s'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. Option.set_option (sys_heap s x) ⤜ ran ∘ obj_fields = Option.set_option (sys_heap s' x) ⤜ ran ∘ obj_fields"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.reachable_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>grey_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reaches_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_eq_iff</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>elem_set</span><span> </span><span>not_Some_eq</span><span> </span><span>option.inject</span><span> </span><span>map_option_eq_Some</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_option_is_None</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_option_eq_Some</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>valid_refs_inv_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_refs_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_invD</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ ∃obj. sys_heap s y = Some obj"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.tso_write_refs m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.tso_write_refs m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ ∃obj. sys_heap s y = Some obj"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ w ∈ set (sys_mem_write_buffers (mutator m) s); x ∈ write_refs w; (x reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ w ∈ set (sys_mem_write_buffers (mutator m) s); x ∈ write_refs w; (x reaches y) s; valid_refs_inv s ⟧ ⟹ ∃obj. sys_heap s y = Some obj"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ grey x s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.reachable m x s; valid_refs_inv s ⟧ ⟹ valid_ref x s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.reachable m x s; valid_refs_inv s ⟧ ⟹ ∃obj. sys_heap s x = Some obj"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x ∈ mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s ⟧ ⟹ ∃obj. sys_heap s y = Some obj"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_invD2</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.reachable m x s;  valid_refs_inv s; (x reaches y) s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rtranclp_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_invD3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = mw_Mutate r f opt_r' # ws; (r reaches y) s; valid_refs_inv s ⟧ ⟹ valid_ref y s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WLI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ∈ W (s p) ⟹ r ∈ WL p s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ∈ ghost_honorary_grey (s p) ⟹ r ∈ WL p s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. (ghost_honorary_grey (s p), W (s p)))
          (WL p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>WL_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>WL_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greyI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ∈ ghost_honorary_grey (s p) ⟹ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ∈ W (s p) ⟹ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r ∈ WL p s ⟹ grey r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{const "valid_W_inv"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(p, r). (λs. W (s p)) <span class="hidden">❙</span><span class="bold">⊗</span> (λs. ghost_honorary_grey (s p)) <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark (sys_heap s r)) <span class="hidden">❙</span><span class="bold">⊗</span> sys_mem_lock <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mark p)
          valid_W_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>valid_W_inv_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. WL p s = WL p s'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. obj_at (λobj. obj_mark obj = sys_fM s') x s ⟷ obj_at (λobj. obj_mark obj = sys_fM s') x s'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. obj_at (λobj. obj_mark obj = (¬sys_fM s')) x s ⟷ obj_at (λobj. obj_mark obj = (¬sys_fM s')) x s'"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x xa xb. mw_Mark xa xb ∈ set (sys_mem_write_buffers x s) ⟷ mw_Mark xa xb ∈ set (sys_mem_write_buffers x s')"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xa</span><span> </span><span>xb</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>set</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s' x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s' x"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>valid_W_inv_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_W_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_invD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ W (s p); valid_W_inv s ⟧ ⟹ marked r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ W (s p); valid_W_inv s ⟧ ⟹ valid_ref r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ WL p s;  valid_W_inv s; p ≠ q ⟧ ⟹ r ∉ WL q s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ W (s p); valid_W_inv s; p ≠ q ⟧ ⟹ r ∉ WL q s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ W (s p); valid_W_inv s ⟧ ⟹ r ∉ ghost_honorary_grey (s q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ ghost_honorary_grey (s p); valid_W_inv s ⟧ ⟹ r ∉ W (s q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ ghost_honorary_grey (s p); valid_W_inv s; p ≠ q ⟧ ⟹ r ∉ WL q s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_def</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME horrible but effective (?) *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_invD2</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark ws = []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mw_Mark r fl ∈ set (sys_mem_write_buffers p s); valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark (sys_mem_write_buffers p s) = [mw_Mark r fl]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>p</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_invD3</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mw_Mark r fl ∈ set (sys_mem_write_buffers p s); valid_W_inv s ⟧ ⟹ r ∈ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ ghost_honorary_grey (s p); sys_mem_lock s ≠ Some p; valid_W_inv s ⟧ ⟹ marked r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ ghost_honorary_grey (s p); sys_mem_lock s ≠ Some p; valid_W_inv s ⟧ ⟹ valid_ref r s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_invD4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mutate r' f r'' # ws; mw_Mark r fl ∈ set ws; valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark ws = [mw_Mark r fl]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_fA fl' # ws; mw_Mark r fl ∈ set ws; valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark ws = [mw_Mark r fl]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_fM fl' # ws; mw_Mark r fl ∈ set ws; valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark ws = [mw_Mark r fl]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Phase ph # ws; mw_Mark r fl ∈ set ws; valid_W_inv s ⟧
     ⟹ fl = sys_fM s ∧ r ∈ ghost_honorary_grey (s p) ∧ tso_locked_by p s ∧ white r s ∧ filter is_mw_Mark ws = [mw_Mark r fl]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>p</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_iff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_W_inv s ⟹ sys_ghost_honorary_grey s = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_inv_no_mark_writes_invD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_lock s ≠ Some p; valid_W_inv s ⟧
     ⟹ tso_pending p is_mw_Mark s = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>filter_False</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_inv_sys_read</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_lock s ≠ Some p; valid_W_inv s ⟧
     ⟹ sys_read p (mr_Mark r) (s sys) = mv_Mark (Option.map_option obj_mark (sys_heap s r))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. Option.map_option obj_mark (heap (fr (s sys)) r) = Option.map_option obj_mark (sys_heap s r)"</span></span></span><span>
</span><span>                             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. ∀r fl. w ≠ mw_Mark r fl"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Option.map_option_case</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Mark Object›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Local invariants for @{const "mark_object_fn"}. Invoking this code in
phases where @{const "sys_fM"} is constant marks the reference in
@{const "ref"}. When @{const "sys_fM"} could vary this code is not
called. The two cases are distinguished by @{term "p_ph_enabled"}.

Each use needs to provide extra facts to justify validity of
references, etc.  We do not include a post-condition for @{const
"mark_object_fn"} here as it is different at each call site.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>mark_object</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'mut process_name"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p_ph_enabled</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p_ph_enabled_eq_imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. s p) p_ph_enabled"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_cas_mark s ≡ cas_mark (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_mark s ≡ mark (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_fM s ≡ fM (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_ghost_handshake_phase s ≡ ghost_handshake_phase (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_ghost_honorary_grey s ≡ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_ghost_handshake_in_sync s ≡ ghost_handshake_in_sync (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_phase s ≡ phase (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_ref s ≡ ref (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_the_ref ≡ the ∘ p_ref"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_W s ≡ W (s p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>at_p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ ('field, 'mut, 'ref) lsts_pred ⇒ ('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"at_p l' P ≡ at p (l @ l') <span class="hidden">❙</span><span class="bold">⟶</span> LSTP P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_en_cond P ≡ p_ph_enabled <span class="hidden">❙</span><span class="bold">⟶</span> P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_valid_ref ≡ <span class="hidden">❙</span><span class="bold">¬</span>(NULL p_ref) <span class="hidden">❙</span><span class="bold">∧</span> valid_ref <span class="hidden">❙</span><span class="bold">$</span> p_the_ref"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_tso_no_pending_mark ≡ LIST_NULL (tso_pending_mark p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_tso_no_pending_mutate ≡ LIST_NULL (tso_pending_mutate p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p_valid_W_inv ≡ ((p_cas_mark <span class="hidden">❙</span><span class="bold">≠</span> p_mark <span class="hidden">❙</span><span class="bold">∨</span> p_tso_no_pending_mark) <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> p_the_ref)
                <span class="hidden">❙</span><span class="bold">∧</span> (tso_pending_mark p <span class="hidden">❙</span><span class="bold">∈</span> (λs. {[], [mw_Mark (p_the_ref s) (p_fM s)]}) )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p_mark_inv ≡ <span class="hidden">❙</span><span class="bold">¬</span>(NULL p_mark)
            <span class="hidden">❙</span><span class="bold">∧</span> ((λs. obj_at (λobj. Some (obj_mark obj) = p_mark s) (p_the_ref s) s)
              <span class="hidden">❙</span><span class="bold">∨</span> marked <span class="hidden">❙</span><span class="bold">$</span> p_the_ref)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p_cas_mark_inv ≡ (λs. obj_at (λobj. Some (obj_mark obj) = p_cas_mark s) (p_the_ref s) s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"p_valid_fM ≡ p_fM <span class="hidden">❙</span><span class="bold">=</span> sys_fM"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p_ghg_eq_ref ≡ p_ghost_honorary_grey <span class="hidden">❙</span><span class="bold">=</span> pred_singleton (the ∘ p_ref)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p_ghg_inv ≡ If p_cas_mark <span class="hidden">❙</span><span class="bold">=</span> p_mark Then p_ghg_eq_ref Else EMPTY p_ghost_honorary_grey"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mark_object_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mark_object_invL =
   (at_p ''_mo_null''        ⟨True⟩
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_mark''        (p_valid_ref)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_fM''          (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_en_cond (p_mark_inv))
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_mtest''       (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_en_cond (p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM))
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_phase''       (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ p_fM <span class="hidden">❙</span><span class="bold">∧</span> p_en_cond (p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM))
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_ptest''       (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ p_fM <span class="hidden">❙</span><span class="bold">∧</span> p_en_cond (p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM))
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_lock''     (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> p_mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ p_fM <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mark)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_cmark''    (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> p_mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ p_fM <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mark)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_ctest''    (p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> p_mark <span class="hidden">❙</span><span class="bold">≠</span> Some ∘ p_fM <span class="hidden">❙</span><span class="bold">∧</span> p_cas_mark_inv <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mark)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_mark''     (p_cas_mark <span class="hidden">❙</span><span class="bold">=</span> p_mark <span class="hidden">❙</span><span class="bold">∧</span> p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> white <span class="hidden">❙</span><span class="bold">$</span> p_the_ref <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mark)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_unlock''   (p_ghg_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> p_valid_W_inv)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_won''      (p_ghg_inv <span class="hidden">❙</span><span class="bold">∧</span> p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> marked <span class="hidden">❙</span><span class="bold">$</span> p_the_ref <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mutate)
  <span class="hidden">❙</span><span class="bold">∧</span> at_p ''_mo_co_W''        (p_ghg_eq_ref <span class="hidden">❙</span><span class="bold">∧</span> p_valid_ref <span class="hidden">❙</span><span class="bold">∧</span> p_valid_fM <span class="hidden">❙</span><span class="bold">∧</span> marked <span class="hidden">❙</span><span class="bold">$</span> p_the_ref <span class="hidden">❙</span><span class="bold">∧</span> p_tso_no_pending_mutate))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_object_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) s. (AT s p, s↓ p, sys_heap s↓, sys_fM s↓, sys_mem_write_buffers p s↓))
          mark_object_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cut_tac</span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s'↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p_ph_enabled_eq_imp</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mark_object_invL_def</span><span> </span><span>obj_at_def</span><span>
</span><span>                </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mark_object_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mark_object_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The uses of @{const "mark_object_fn"} in the GC and during the root
marking are straightforward.

›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME we'd like:

sublocale mut &lt; get_roots: mark_object "mutator mut" "''hs_get_roots_loop''" .

but this doesn't seem to get promoted to the top-level, so we can't
use it in the other process locales.

This interpretation promotes the [inv] attribute to the top-level.

*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>gc_mark</span><span class="delimiter">:</span><span> </span><span>mark_object</span><span> </span><span class="string"><span class="delete"><span class="delete">"gc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''mark_loop''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨True⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_mark_mark_object_invL_def2</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>gc_mark.mark_object_invL_def</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>mut_get_roots</span><span class="delimiter">:</span><span> </span><span>mark_object</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''hs_get_roots_loop''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨True⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_get_roots_mark_object_invL_def2</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>mut_get_roots.mark_object_invL_def</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The most interesting cases are the two asynchronous uses of @{const
"mark_object_fn"} in the mutators: we need something that holds even
before we read the phase. In particular we need to avoid interference
by an @{const "fM"} flip.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>mut_store_del</span><span class="delimiter">:</span><span> </span><span>mark_object</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''store_del''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.mut_ghost_handshake_phase m <span class="hidden">❙</span><span class="bold">≠</span> ⟨hp_Idle⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_store_del_mark_object_invL_def2</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>mut_store_del.mark_object_invL_def</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>mut_store_ins</span><span class="delimiter">:</span><span> </span><span>mark_object</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''store_ins''"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.mut_ghost_handshake_phase m <span class="hidden">❙</span><span class="bold">≠</span> ⟨hp_Idle⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_store_ins_mark_object_invL_def2</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>mut_store_ins.mark_object_invL_def</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Local invariant for the mutator's uses of @{term "mark_object"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_hs_get_roots_loop_locs = prefixed ''hs_get_roots_loop''"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_hs_get_roots_loop_mo_locs =
  prefixed ''hs_get_roots_loop_mo'' ∪ {''hs_get_roots_loop_done''}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_async_mark_object_prefixes ≡ { ''store_del'', ''store_ins'' }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_hs_not_hp_Idle_locs =
  (⋃pref∈mut_async_mark_object_prefixes.
     ⋃l∈{''mo_co_lock'', ''mo_co_cmark'', ''mo_co_ctest'', ''mo_co_mark'', ''mo_co_unlock'', ''mo_co_won'', ''mo_co_W''}. {pref @ ''_'' @ l})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_async_mo_ptest_locs =
  (⋃pref∈mut_async_mark_object_prefixes. {pref @ ''_mo_ptest''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_mo_ptest_locs =
  (⋃pref∈mut_async_mark_object_prefixes. {pref @ ''_mo_ptest''})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_mo_valid_ref_locs =
  (prefixed ''store_del'' ∪ prefixed ''store_ins'' ∪ { ''deref_del'', ''lop_store_ins''})"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_hs_get_roots_loop_locs_subseteq_hs_get_roots</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_hs_get_roots_loop_locs ⊆ prefixed ''hs_get_roots_''"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_hs_get_roots_loop_locs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_ghost_handshake_phase_not_hp_Idle</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS (mutator m) mut_hs_get_roots_loop_locs s; mut_m.handshake_invL m s; handshake_phase_inv s↓ ⟧
     ⟹ ghost_handshake_phase (s↓ (mutator m)) ≠ hp_Idle"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mut_m.handshake_invL_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>mut_hs_get_roots_loop_locs_subseteq_hs_get_roots</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

This local invariant for the mutators illustrates the handshake
structure: we can rely on the insertion barrier earlier than on the
deletion barrier. Both need to be installed before ‹get_roots›
to ensure we preserve the strong tricolour invariant. All black
objects at that point are allocated: we need to know that the
insertion barrier is installed to preserve it. This limits when ‹fA› can be set.

It is interesting to contrast the two barriers. Intuitively a mutator
can locally guarantee that it, in the relevant phases, will insert
only marked references. Less often can it be sure that the reference
it is overwriting is marked. We also need to consider writes pending
in TSO buffers: it is key that after the ‹''init_noop''›
handshake there are no pending white insertions
(mutations that insert unmarked references). This ensures the deletion barrier
does its job.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey_empty_locs ≡
     - (⋃pref∈{ ''mark_loop'', ''hs_get_roots_loop'', ''store_del'', ''store_ins'' }.
        ⋃l∈{ ''mo_co_unlock'', ''mo_co_won'', ''mo_co_W'' }. {pref @ ''_'' @ l})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_root_empty_locs ≡
     - (prefixed ''store_del'' ∪ {''lop_store_ins''} ∪ prefixed ''store_ins'')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mark_object_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mark_object_invL =
   (atS_mut mut_hs_get_roots_loop_locs    (mut_refs <span class="hidden">❙</span><span class="bold">⊆</span> mut_roots <span class="hidden">❙</span><span class="bold">∧</span> (<span class="hidden">❙</span><span class="bold">∀</span>r. ⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> mut_roots <span class="hidden">❙</span><span class="bold">-</span> mut_refs <span class="hidden">❙</span><span class="bold">⟶</span> marked r))
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut mut_hs_get_roots_loop_mo_locs (<span class="hidden">❙</span><span class="bold">¬</span>(NULL mut_ref) <span class="hidden">❙</span><span class="bold">∧</span> mut_the_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_roots)
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''hs_get_roots_loop_done''     (marked <span class="hidden">❙</span><span class="bold">$</span> mut_the_ref)
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''hs_get_roots_loop_mo_ptest'' (mut_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''hs_get_roots_done''          (<span class="hidden">❙</span><span class="bold">∀</span>r. ⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> mut_roots <span class="hidden">❙</span><span class="bold">⟶</span> marked r)

  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut mut_mo_valid_ref_locs         ( (<span class="hidden">❙</span><span class="bold">¬</span>(NULL mut_new_ref) <span class="hidden">❙</span><span class="bold">⟶</span> mut_the_new_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_roots)
                                          <span class="hidden">❙</span><span class="bold">∧</span> (mut_tmp_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_roots) )
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''store_del_mo_null''          (<span class="hidden">❙</span><span class="bold">¬</span>(NULL mut_ref) <span class="hidden">❙</span><span class="bold">⟶</span> mut_the_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_ghost_honorary_root)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''store_del'' - {''store_del_mo_null''}) (mut_the_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_ghost_honorary_root)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''store_ins'')      (mut_ref <span class="hidden">❙</span><span class="bold">=</span> mut_new_ref)

  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (suffixed ''_mo_ptest'')      (mut_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩ <span class="hidden">❙</span><span class="bold">⟶</span> mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨hp_Idle⟩)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut mut_hs_not_hp_Idle_locs       (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨hp_Idle⟩)

  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut mut_mo_ptest_locs             (mut_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Idle⟩ <span class="hidden">❙</span><span class="bold">⟶</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">∈</span> ⟨{hp_Idle, hp_IdleInit}⟩
                                                                          <span class="hidden">❙</span><span class="bold">∨</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩
                                                                                <span class="hidden">❙</span><span class="bold">∧</span> sys_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Idle⟩)))
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut ghost_honorary_grey_empty_locs (EMPTY mut_ghost_honorary_grey)
― ‹insertion barrier›
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''store_ins''                  ( (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">∈</span> ⟨{hp_InitMark, hp_Mark}⟩
                                            <span class="hidden">❙</span><span class="bold">∨</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩))
                                           <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(NULL mut_new_ref)
                                           <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> mut_the_new_ref )
― ‹deletion barrier›
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''store_del_mo'' ∪ {''lop_store_ins''})
                                          ( (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_Mark⟩
                                            <span class="hidden">❙</span><span class="bold">∨</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩))
                                           <span class="hidden">❙</span><span class="bold">∧</span> (λs. ∀opt_r'. ¬tso_pending_write (mutator m) (mw_Mutate (mut_tmp_ref s) (mut_field s) opt_r') s)
                                          <span class="hidden">❙</span><span class="bold">⟶</span> (λs. obj_at_field_on_heap (λr. mut_ref s = Some r ∨ marked r s) (mut_tmp_ref s) (mut_field s) s))
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''lop_store_ins''              ( (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_Mark⟩
                                             <span class="hidden">❙</span><span class="bold">∨</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩))
                                           <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(NULL mut_ref)
                                          <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> mut_the_ref )
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut (prefixed ''store_ins'')
                                            ( (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_Mark⟩
                                             <span class="hidden">❙</span><span class="bold">∨</span> (mut_ghost_handshake_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨hp_IdleMarkSweep⟩ <span class="hidden">❙</span><span class="bold">∧</span> sys_phase <span class="hidden">❙</span><span class="bold">≠</span> ⟨ph_Idle⟩))
                                          <span class="hidden">❙</span><span class="bold">∧</span> (λs. ∀opt_r'. ¬tso_pending_write (mutator m) (mw_Mutate (mut_tmp_ref s) (mut_field s) opt_r') s)
                                          <span class="hidden">❙</span><span class="bold">⟶</span> (λs. obj_at_field_on_heap (λr'. marked r' s) (mut_tmp_ref s) (mut_field s) s) )
―‹after ‹''init_noop''››
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''load''         (mut_tmp_ref <span class="hidden">❙</span><span class="bold">∈</span> mut_roots)
  <span class="hidden">❙</span><span class="bold">∧</span> at_mut ''hs_noop_done'' (LIST_NULL (tso_pending_mutate (mutator m))) ―‹ key: no pending white insertions ›
  <span class="hidden">❙</span><span class="bold">∧</span> atS_mut ghost_honorary_root_empty_locs (EMPTY mut_ghost_honorary_root) )"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_roots_get_work_subseteq_ghost_honorary_grey_empty_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hs_get_roots_locs ∪ hs_get_work_locs ⊆ ghost_honorary_grey_empty_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ghost_honorary_grey_empty_locs_def</span><span> </span><span>hs_get_roots_locs_def</span><span> </span><span>hs_get_work_locs_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mark_object_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr s. (AT s (mutator m), s↓ (mutator m), sys_heap s↓ r, sys_fM s↓, sys_phase s↓, tso_pending_mutate (mutator m) s↓))
          mark_object_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>mark_object_invL_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>obj_at_field_on_heap_def</span><span>
</span><span>                </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. marked r s↓ ⟷ marked r s'↓"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. valid_null_ref r s↓ ⟷ valid_null_ref r s'↓"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r f opt_r'. mw_Mutate r f opt_r' ∉ set (sys_mem_write_buffers (mutator m) s↓) ⟷ mw_Mutate r f opt_r' ∉ set (sys_mem_write_buffers (mutator m) s'↓)"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>set</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_def</span><span> </span><span>valid_null_ref_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_def</span><span> </span><span>valid_null_ref_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mut_m_mark_object_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.mark_object_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL
      <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> LSTP (phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ mark_object_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store_ins_mo_ptest *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store_ins_mo_ptest *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>y</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_phase s↓"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>y</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_phase s↓"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_no_pending_writes</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop mo phase *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop choose ref *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>mut_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mark_object_invL ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mut_store_ins_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_store_ins.mark_object_invL m <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ mut_store_ins.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span> </span><span>valid_W_inv_no_mark_writes_invD</span><span>
</span><span>           </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_not_idle_no_fM_writeD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_fM fl # ws; ghost_handshake_phase (s (mutator m)) ≠ hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_writes_inv s; p ≠ sys ⟧
     ⟹ False"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>fM_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_store_ins_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m_not_idle_no_fM_writeD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.tso_lock_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     sys
   ⦃ mut_store_ins.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_blocked_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_get_roots_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.tso_lock_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_m.handshake_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     sys
   ⦃ mut_get_roots.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_blocked_def</span><span> </span><span>p_not_sys</span><span>
</span><span>             </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_store_del_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m_not_idle_no_fM_writeD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.tso_lock_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     sys
   ⦃ mut_store_del.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>not_blocked_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mut_store_del_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_store_del.mark_object_invL m <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ mut_store_del.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span> </span><span>valid_W_inv_no_mark_writes_invD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mut_get_roots_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_get_roots.mark_object_invL m <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ mut_get_roots.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_no_mark_writes_invD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>mut_get_roots_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_get_roots.mark_object_invL m ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>mut_store_ins_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_store_ins.mark_object_invL m ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>mut_store_del_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_store_del.mark_object_invL m ⦄ mutator m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_get_roots_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mut_m.handshake_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m ⦄ gc ⦃ mut_get_roots.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We now show that the GC's use of @{const "mark_object_fn"} is correct.

When we take grey @{const "tmp_ref"} to black, all of the objects it
points to are marked, ergo the new black does not point to white, and
so we preserve the strong tricolour invariant.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_inv =
     (<span class="hidden">❙</span><span class="bold">∀</span>f. ⟨f⟩ <span class="hidden">❙</span><span class="bold">∈</span> (- gc_field_set) <span class="hidden">❙</span><span class="bold">⟶</span> (λs. obj_at_field_on_heap (λr. marked r s) (gc_tmp_ref s) f s))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ_::unit. gc_field_set <span class="hidden">❙</span><span class="bold">⊗</span> gc_tmp_ref <span class="hidden">❙</span><span class="bold">⊗</span> sys_heap <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate gc)
          obj_fields_marked_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>obj_fields_marked_inv_def</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>obj_at_def</span><span>
</span><span>             </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_obj_fields_marked_inv_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc.obj_fields_marked_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv_UNIV</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_inv (s(gc := (s gc)⦇ field_set := UNIV ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv_mark_field_done</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ obj_at_field_on_heap (λr. marked r s) (gc_tmp_ref s) (gc_field s) s; obj_fields_marked_inv s ⟧
     ⟹ obj_fields_marked_inv (s(gc := (s gc)⦇field_set := gc_field_set s - {gc_field s}⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_inv_def</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_locs ≡
     { ''mark_loop_mark_object_loop'', ''mark_loop_mark_choose_field'', ''mark_loop_mark_deref'', ''mark_loop_mark_field_done'', ''mark_loop_blacken'' }
   ∪ prefixed ''mark_loop_mo''"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_invL ≡
    (atS_gc obj_fields_marked_locs       (obj_fields_marked_inv <span class="hidden">❙</span><span class="bold">∧</span> gc_tmp_ref <span class="hidden">❙</span><span class="bold">∈</span> gc_W)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc (prefixed ''mark_loop_mo'' ∪ { ''mark_loop_mark_field_done'' })
                                          (λs. obj_at_field_on_heap (λr. gc_ref s = Some r ∨ marked r s) (gc_tmp_ref s) (gc_field s) s)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc (prefixed ''mark_loop_mo'')  (<span class="hidden">❙</span><span class="bold">∀</span>y. <span class="hidden">❙</span><span class="bold">¬</span>(NULL gc_ref) <span class="hidden">❙</span><span class="bold">∧</span> (λs. ((gc_the_ref s) reaches y) s) <span class="hidden">❙</span><span class="bold">⟶</span> valid_ref y)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop_fields''          (gc_tmp_ref <span class="hidden">❙</span><span class="bold">∈</span> gc_W)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop_mark_field_done'' (<span class="hidden">❙</span><span class="bold">¬</span>(NULL gc_ref) <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> gc_the_ref)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop_blacken''         (EMPTY gc_field_set)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc ghost_honorary_grey_empty_locs (EMPTY gc_ghost_honorary_grey))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) (s :: ('field, 'mut, 'ref) gc_pred_state). (AT s gc, s↓ gc, sys_heap s↓, sys_fM s↓, sys_W s↓, tso_pending_mutate gc s↓))
          obj_fields_marked_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>inv</span><span> </span><span>obj_at_def</span><span> </span><span>obj_fields_marked_inv_def</span><span> </span><span>obj_at_field_on_heap_def</span><span>
</span><span>             </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_obj_fields_marked_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc.obj_fields_marked_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>gc_mark_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
        <span class="hidden">❙</span><span class="bold">∧</span> LSTP valid_W_inv ⦄
     gc
   ⦃ gc_mark.mark_object_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_jackhammer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_no_mark_writes_invD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> phase_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     gc
   ⦃ obj_fields_marked_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mark_field_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obj_fields_marked_inv_mark_field_done</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mark_deref *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"grey (gc_tmp_ref s↓) s↓"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(gc_tmp_ref s↓ reaches x) s↓"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_obj_fields_marked_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.obj_fields_marked_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.obj_fields_marked_invL
             <span class="hidden">❙</span><span class="bold">∧</span> LSTP (tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
           mutator m
         ⦃ gc.obj_fields_marked_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rules *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc.obj_fields_marked_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ra</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heapE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"grey (gc_tmp_ref s↓) s↓"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gc_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>greyI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_mark_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc_mark.mark_object_invL ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_mark_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.tso_lock_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.phase_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.fM_fA_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.phase_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.tso_lock_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     sys
   ⦃ gc_mark.mark_object_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>not_blocked_def</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="StrongTricolour">
<div class="head"><h1>Theory StrongTricolour</h1>
<span class="command">theory</span> <span class="name">StrongTricolour</span><br/>
<span class="keyword">imports</span> <a href="MarkObject.html"><span class="name">MarkObject</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>StrongTricolour</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>MarkObject</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The strong-tricolour invariant \label{sec:strong-tricolour-invariant} ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

As the GC algorithm uses both insertion and deletion barriers, it
preserves the \emph{strong tricolour-invariant}:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>points_to_white</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"points'_to'_white"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x points_to_white y ≡ x points_to y <span class="hidden">❙</span><span class="bold">∧</span> white y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strong_tricolour_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strong_tricolour_inv = (<span class="hidden">❙</span><span class="bold">∀</span>b w. black b <span class="hidden">❙</span><span class="bold">⟶</span> <span class="hidden">❙</span><span class="bold">¬</span>(b points_to_white w))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Intuitively this invariant says that there are no pointers from
completely processed objects to the unexplored space; i.e., the grey
references properly separate the two. In contrast the weak tricolour
invariant allows such pointers, provided there is a grey reference
that protects the unexplored object.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_white_path_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has'_white'_path'_to"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x has_white_path_to y ≡ λs. (λx y. (x points_to_white y) s)<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup> x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>grey_protects_white</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ 'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"grey'_protects'_white"</span></span></span><span> </span><span>51</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"g grey_protects_white w = (grey g <span class="hidden">❙</span><span class="bold">∧</span> g has_white_path_to w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>weak_tricolour_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weak_tricolour_inv =
     (<span class="hidden">❙</span><span class="bold">∀</span>b w. black b <span class="hidden">❙</span><span class="bold">∧</span> b points_to_white w <span class="hidden">❙</span><span class="bold">⟶</span> (<span class="hidden">❙</span><span class="bold">∃</span>g. g grey_protects_white w))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strong_tricolour_inv s ⟹ weak_tricolour_inv s"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span> </span><span>weak_tricolour_inv_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The key invariant that the mutators establish as they perform ‹get_roots›: they protect their white-reachable references with grey
objects.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>in_snapshot</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_snapshot r = (black r <span class="hidden">❙</span><span class="bold">∨</span> (<span class="hidden">❙</span><span class="bold">∃</span>g. g grey_protects_white r))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv = (<span class="hidden">❙</span><span class="bold">∀</span>r. reachable r <span class="hidden">❙</span><span class="bold">⟶</span> in_snapshot r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Note that it is not easy to specify precisely when the snapshot (of
objects the GC will retain) is taken due to the raggedness of the
initialisation.

In some phases we need to know that the insertion and deletion
barriers are installed, in order to preserve the snapshot. These can
ignore TSO effects as marks hit system memory in a timely way.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>marked_insertion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked_insertion w ≡ λs. case w of mw_Mutate r f (Some r') ⇒ marked r' s | _ ⇒ True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked_insertions = (<span class="hidden">❙</span><span class="bold">∀</span>w. tso_pending_write (mutator m) w <span class="hidden">❙</span><span class="bold">⟶</span> marked_insertion w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>marked_deletion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'ref) mem_write_action ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked_deletion w ≡ λs. case w of mw_Mutate r f opt_r' ⇒ obj_at_field_on_heap (λr'. marked r' s) r f s | _ ⇒ True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_deletions</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked_deletions = (<span class="hidden">❙</span><span class="bold">∀</span>w. tso_pending_write (mutator m) w <span class="hidden">❙</span><span class="bold">⟶</span> marked_deletion w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Finally, in some phases the heap is somewhat monochrome.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>black_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap = (<span class="hidden">❙</span><span class="bold">∀</span>r. valid_ref r <span class="hidden">❙</span><span class="bold">⟶</span> black r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>white_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white_heap = (<span class="hidden">❙</span><span class="bold">∀</span>r. valid_ref r <span class="hidden">❙</span><span class="bold">⟶</span> white r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>no_black_refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_black_refs = (<span class="hidden">❙</span><span class="bold">∀</span>r. <span class="hidden">❙</span><span class="bold">¬</span>(black r))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>no_grey_refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs = (<span class="hidden">❙</span><span class="bold">∀</span>r. <span class="hidden">❙</span><span class="bold">¬</span>(grey r))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_black_refsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_black_refs s ⟹ ¬black r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_black_refs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_to_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> sys_heap)
          (x has_white_path_to y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>has_white_path_to_def</span><span> </span><span>obj_at_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>has_white_path_to_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>has_white_path_to_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_toD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x has_white_path_to y) s ⟹ white y s ∨ x = y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_white_path_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_toI</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x has_white_path_to x) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_toE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (x points_to y) s; white y s ⟧ ⟹ (x has_white_path_to y) s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (x has_white_path_to y) s; (y points_to z) s; white z s ⟧ ⟹ (x has_white_path_to z) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_white_path_to_def</span><span>
</span><span>         </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_to_reaches</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x has_white_path_to y) s ⟹ (x reaches y) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>has_white_path_to_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>has_white_path_to_blacken</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x has_white_path_to w) (s(gc := s gc⦇ W := gc_W s - rs ⦈)) ⟷ (x has_white_path_to w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WL›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WL_mo_co_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s p) = {}
     ⟹ WL p' (s(p := s p⦇ ghost_honorary_grey := rs ⦈)) = WL p' s ∪ { r |r. p' = p ∧ r ∈ rs}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WL_blacken</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_ghost_honorary_grey s = {}
    ⟹ WL p (s(gc := s gc⦇ W := gc_W s - rs ⦈)) = WL p s - { r |r. p = gc ∧ r ∈ rs }"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WL_hs_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s (mutator m)) = {}
     ⟹ WL p (s(mutator m := s (mutator m)⦇ W := {}, ghost_handshake_phase := hp' ⦈,
                 sys   := s sys⦇ handshake_pending := hsp', W := sys_W s ∪ W (s (mutator m)),
                                 ghost_handshake_in_sync := in' ⦈))
      = (case p of gc ⇒ WL gc s | mutator m' ⇒ (if m' = m then {} else WL (mutator m') s) | sys ⇒ WL sys s ∪ WL (mutator m) s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s (mutator m)) = {}
     ⟹ WL p (s(mutator m := s (mutator m)⦇ W := {} ⦈,
                 sys   := s sys⦇ handshake_pending := hsp', W := sys_W s ∪ W (s (mutator m)),
                                 ghost_handshake_in_sync := in' ⦈))
      = (case p of gc ⇒ WL gc s | mutator m' ⇒ (if m' = m then {} else WL (mutator m') s) | sys ⇒ WL sys s ∪ WL (mutator m) s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_load_W</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W s = {} ⟹ black r (s(gc := (s gc)⦇W := W (s sys)⦈, sys := (s sys)⦇W := {}⦈)) ⟷ black r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W s = {} ⟹ grey r (s(gc := (s gc)⦇W := W (s sys)⦈, sys := (s sys)⦇W := {}⦈)) ⟷ grey r s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_sweep_loop_free</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r (s(sys := s sys⦇heap := (heap (s sys))(r' := None)⦈)) ⟷ (black r s ∧ r ≠ r')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r (s(sys := s sys⦇heap := (heap (s sys))(r' := None)⦈)) ⟷ (grey r s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r (s(sys := s sys⦇heap := (heap (s sys))(r' := None)⦈)) ⟷ (white r s ∧ r ≠ r')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_get_work_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r (s(mutator m := (s (mutator m))⦇W := {}⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ black r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r (s(mutator m := (s (mutator m))⦇W := {}⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r (s(mutator m := (s (mutator m))⦇W := {}⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ white r s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>process_name.distinct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_get_roots_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r (s(mutator m := (s (mutator m))⦇ W := {}, ghost_handshake_phase := hs' ⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ black r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r (s(mutator m := (s (mutator m))⦇ W := {}, ghost_handshake_phase := hs' ⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white r (s(mutator m := (s (mutator m))⦇ W := {}, ghost_handshake_phase := hs' ⦈,
              sys := (s sys)⦇ handshake_pending := hp', W := W (s sys) ∪ W (s (mutator m)),
                              ghost_handshake_in_sync := his' ⦈)) ⟷ white r s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>process_name.distinct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_honorary_grey (s p) = {} ⟧ ⟹ black b (s(p := s p⦇ghost_honorary_grey := {r}⦈)) ⟷ black b s ∧ b ≠ r"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_honorary_grey (s p) = {} ⟧ ⟹ grey g (s(p := (s p)⦇ghost_honorary_grey := {r}⦈)) ⟷ grey g s ∨ g = r"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_honorary_grey (s p) = {} ⟧ ⟹ white w (s(p := s p⦇ghost_honorary_grey := {r}⦈))  ⟷ white w s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_flip_fM</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fl ≠ sys_fM s ⟹ black b (s(sys := (s sys)⦇fM := fl, mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈)) ⟷ white b s ∧ ¬grey b s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap (s sys) r' = None
     ⟹ black r (s(mutator m := (s (mutator m))⦇ roots := roots' ⦈, sys := (s sys)⦇heap := heap (s sys)(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ black r s ∨ (r' = r ∧ fl = sys_fM s ∧ ¬grey r' s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r (s(mutator m := (s (mutator m))⦇ roots := roots' ⦈, sys := (s sys)⦇heap := heap (s sys)(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ grey r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap (s sys) r' = None
     ⟹ white r (s(mutator m := (s (mutator m))⦇ roots := roots' ⦈, sys := (s sys)⦇heap := heap (s sys)(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ white r s ∨ (r' = r ∧ fl ≠ sys_fM s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_blacken</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_W_inv s ⟹ black b (s(gc := s gc⦇W := gc_W s - {r}⦈)) ⟷ black b s ∨ (r ∈ gc_W s ∧ b = r)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ r ∈ gc_W s; valid_W_inv s ⟧ ⟹ grey g (s(gc := s gc⦇W := gc_W s - {r}⦈)) ⟷ (grey g s ∧ g ≠ r)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white w (s(gc := s gc⦇W := gc_W s - {r}⦈)) ⟷ white w s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_dequeue</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black b (s(sys := (s sys)⦇ heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws) ⦈))
⟷ (black b s ∧ b ≠ r) ∨ (b = r ∧ fl = sys_fM s ∧ valid_ref r s ∧ ¬grey r s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>W_load_W</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W s = {} ⟹ (⋃p. W (if p = sys then (s sys)⦇W := {}⦈ else if p = gc then (s gc)⦇W := sys_W s⦈ else s p)) = (⋃p. W (s p))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WL_load_W</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W s = {}
    ⟹ (WL p (s(gc := (s gc)⦇W := sys_W s⦈, sys := (s sys)⦇W := {}⦈)))
     = (case p of gc ⇒ WL gc s ∪ sys_W s | mutator m ⇒ WL (mutator m) s | sys ⇒ sys_ghost_honorary_grey s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>colours_mo_co_W</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s p') = {r}
     ⟹ (WL p (s(p' := (s p')⦇W := insert r (W (s p')), ghost_honorary_grey := {}⦈))) = (WL p s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s p') = {r}
     ⟹ grey g (s(p' := (s p')⦇W := insert r (W (s p')), ghost_honorary_grey := {}⦈)) ⟷ grey g s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>process_name.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). (λs. ⋃p. WL p s))
          no_grey_refs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>grey_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>set_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>no_grey_refs_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>no_grey_refs_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; valid_W_inv s ⟧ ⟹ tso_no_pending_marks s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>filter_False</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_blackD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; reachable_snapshot_inv s; reachable r s ⟧ ⟹ black r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_reachable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; reachable_snapshot_inv s; white r s ⟧ ⟹ ¬reachable r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; reachable_snapshot_inv s; white r s ⟧
     ⟹ r ∉ mut_roots s ∧ r ∉ mut_ghost_honorary_root s ∧ r ∉ tso_write_refs s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_reachable</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_not_grey_reachableD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s ⟹ ¬grey_reachable x s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_white_root</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ white w s; w ∈ mut_roots s ∨ w ∈ mut_ghost_honorary_root s; reachable_snapshot_inv s ⟧ ⟹ ∃g. (g grey_protects_white w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>               </span><span>reachable_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s ⟹ r ∉ W (s p)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s ⟹ r ∉ WL p s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s ⟹ r ∉ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_marked</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ marked r s; no_grey_refs s ⟧ ⟹ black r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_bwD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ heap (s sys) r = Some obj; no_grey_refs s ⟧ ⟹ black r s ∨ white r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹tso write refs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_write_refs_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(mutator m' := s (mutator m')⦇roots := roots'⦈))
 = mut_m.tso_write_refs m s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(mutator m' := s (mutator m')⦇ghost_honorary_root := {}⦈,
                             sys := s sys⦇mem_write_buffers := (mem_write_buffers (s sys))(mutator m' := sys_mem_write_buffers (mutator m') s @ [mw_Mutate r f opt_r'])⦈))
 = mut_m.tso_write_refs m s ∪ (if m' = m then write_refs (mw_Mutate r f opt_r') else {})"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(sys := s sys⦇heap := (sys_heap s)(r' := None)⦈))
 = mut_m.tso_write_refs m s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(mutator m' := s (mutator m')⦇roots := insert r (roots (s (mutator m')))⦈, sys := s sys⦇heap := sys_heap s(r ↦ obj)⦈))
 = mut_m.tso_write_refs m s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(mutator m' := s (mutator m')⦇ghost_honorary_root := Option.set_option opt_r', ref := opt_r'⦈))
 = mut_m.tso_write_refs m s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.tso_write_refs m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                          mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))
 = (if p = mutator m then ⋃w ∈ set ws. write_refs w else mut_m.tso_write_refs m s)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers p s = mw_Mark r fl # ws
⟹ mut_m.tso_write_refs m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))
 = mut_m.tso_write_refs m s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mutator_reachable_tso</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m) s = mw_Mutate r f opt_r' # ws
    ⟹ mut_m.reachable m r s ∧ (∀r'. opt_r' = Some r' ⟶ mut_m.reachable m r' s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹coloured heaps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). (λs. ⋃p. WL p s) <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark ∘ sys_heap s))
          black_heap"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>black_heap_def</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. marked x s ⟷ marked x s'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. valid_ref x s ⟷ valid_ref x s'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (∀p. x ∉ WL p s) ⟷ (∀p. x ∉ WL p s')"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_eq_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Option.map_option ⟨True⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_option.compositionality</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_option.compositionality</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Option.map_option (λfl. fl = sys_fM s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_option.compositionality</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>white_heap_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark ∘ sys_heap s))
          white_heap"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>eq_imp_def</span><span> </span><span>white_heap_def</span><span> </span><span>obj_at_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>map_option_eq_Some</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_black_refs_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). (λs. (⋃p. WL p s)) <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark ∘ sys_heap s))
          no_black_refs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>no_black_refs_def</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>fun_eq_iff</span><span> </span><span>set_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. marked x s ⟷ marked x s'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>black_heap_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>black_heap_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>white_heap_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>white_heap_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>no_black_refs_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>no_black_refs_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>white_heap_imp_no_black_refs</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white_heap s ⟹ no_black_refs s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>white_heap_def</span><span> </span><span>no_black_refs_def</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>no_black_refs_dequeue</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; no_black_refs s; valid_W_inv s ⟧
   ⟹ no_black_refs (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mutate r f r' # ws; no_black_refs s ⟧
     ⟹ no_black_refs (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := r')⦈) (sys_heap s r)),
                                      mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span> </span><span>map_option.compositionality</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_no_greys</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ black_heap s; valid_refs_inv s ⟧ ⟹ no_grey_refs s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; ∀r. marked r s ∨ ¬valid_ref r s ⟧ ⟹ black_heap s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>black_heap_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_colours_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ heap (s sys) r' = None; valid_refs_inv s ⟧
  ⟹ black_heap (s(mutator m := s (mutator m)⦇roots := insert r' (roots (s (mutator m)))⦈, sys := s sys⦇heap := sys_heap s(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
  ⟷ black_heap s ∧ fl = sys_fM s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap (s sys) r' = None
  ⟹ white_heap (s(mutator m := s (mutator m)⦇roots := insert r' (roots (s (mutator m)))⦈, sys := s sys⦇heap := sys_heap s(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
  ⟷ white_heap s ∧ fl ≠ sys_fM s"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>white_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>obj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_colours_colours</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap s ⟹ ¬white r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"white_heap s ⟹ ¬black r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>white_heap_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heap_colours_marked</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ black_heap s; obj_at P r s ⟧ ⟹ marked r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ white_heap s; obj_at P r s ⟧ ⟹ white r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>white_heap_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv_blacken</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ gc_field_set s = {}; obj_fields_marked_inv s; (gc_tmp_ref s points_to w) s; white w s; tso_writes_inv s ⟧ ⟹ False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_inv_def</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>obj_fields_marked_inv_has_white_path_to_blacken</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ gc_field_set s = {}; gc_tmp_ref s ∈ gc_W s; (gc_tmp_ref s has_white_path_to w) s; obj_fields_marked_inv s; valid_W_inv s; tso_writes_inv s ⟧ ⟹ w = gc_tmp_ref s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>converse_rtranclpE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_inv_def</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_writes_points_to</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>conj_explode</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"heap (fold_writes ws (s sys)) r = Some obj ∧ obj_fields obj f = Some r'
     ⟶ (r points_to r') s ∨ (∃w ∈ set ws. r' ∈ write_refs w)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P (fold_writes ws) obj"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fold_writes_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fold_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfr. ∀obj. ?P fr obj"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λw. w ∈ set ws"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.split_asm</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_load</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ mut_roots s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m' y (s(mutator m := s (mutator m)⦇ roots := mut_roots s ∪ Option.set_option r' ⦈)) ⟷ mut_m.reachable m' y s"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m' = m"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_read_def</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>fold_writes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fold_writes_points_to</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* filthy *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_deref_del</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r ∈ mut_roots s; mut_ghost_honorary_root s = {} ⟧
   ⟹ mut_m.reachable m' y (s(mutator m := s (mutator m)⦇ ghost_honorary_root := Option.set_option opt_r', ref := opt_r' ⦈))
   ⟷ mut_m.reachable m' y s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>sys_read_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>option_bind_invE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fold_writes_points_to</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>              </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹strong tricolour›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_tricolour_invD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ black x s; (x points_to y) s; valid_ref y s; strong_tricolour_inv s ⟧
     ⟹ marked y s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹grey protects white›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_whiteD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) s ⟹ grey g s ∧ (g = w ∨ white w s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_whiteI</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey g s ⟹ (g grey_protects_white g) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_whiteE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (g points_to w) s; grey g s; white w s ⟧ ⟹ (g grey_protects_white w) s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (g grey_protects_white y) s; (y points_to w) s; white w s ⟧ ⟹ (g grey_protects_white w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_white_reaches</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) s ⟹ (g reaches w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_white_hs_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) (s(mutator m := s (mutator m)⦇ W := {}, ghost_handshake_phase := hs' ⦈,
                              sys := s sys⦇ handshake_pending := hp', W := sys_W s ∪ W (s (mutator m)),
                                            ghost_handshake_in_sync := his' ⦈))
  ⟷ (g grey_protects_white w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_white_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ fl = sys_fM s; sys_heap s r = None ⟧
     ⟹ (g grey_protects_white w) (s(mutator m := s (mutator m)⦇roots := insert r (roots (s (mutator m)))⦈, sys := s sys⦇heap := sys_heap s(r ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ (g grey_protects_white w) s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹reachable snapshot inv›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_invI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀y. reachable y s ⟹ in_snapshot y s) ⟹ reachable_snapshot_inv s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λr. mut_roots <span class="hidden">❙</span><span class="bold">⊗</span> mut_ghost_honorary_root <span class="hidden">❙</span><span class="bold">⊗</span> (λs. r ∈ (⋃p. WL p s)) <span class="hidden">❙</span><span class="bold">⊗</span> sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> sys_heap <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate (mutator m))
          reachable_snapshot_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>grey_def</span><span> </span><span>obj_at_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>has_white_path_to_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (∀p. x ∉ WL p s) ⟷ (∀p. x ∉ WL p s')"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>reachable_snapshot_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.reachable_snapshot_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snapshotI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black r s ⟹ in_snapshot r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grey r s ⟹ in_snapshot r s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ white w s; (g grey_protects_white w) s ⟧ ⟹ in_snapshot w s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snapshot_colours</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"in_snapshot r s ⟹ black r s ∨ grey r s ∨ white r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snapshot_valid_ref</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ in_snapshot r s; valid_refs_inv s ⟧ ⟹ valid_ref r s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_snapshot_colours</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_sweep_loop_free</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nmr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"white r s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ngs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv (s(sys := (s sys)⦇heap := (heap (s sys))(r := None)⦈))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ref"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>rx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable y ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"black y s ∧ y ≠ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ngs</span><span> </span><span>nmr</span><span> </span><span>rsi</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>reachable_blackD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ghost_honorary_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ngs</span><span> </span><span>nmr</span><span> </span><span>rsi</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reachable_blackD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>tso_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ngs</span><span> </span><span>nmr</span><span> </span><span>rsi</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reachable_blackD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>reaches</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ngs</span><span> </span><span>nmr</span><span> </span><span>rsi</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>predicate2D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx y. (x points_to y) s"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>predicate2I</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reachable_blackD</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reachable_blackD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_snapshot y ?s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>in_snapshot_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachableI2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ mut_m.mut_ghost_honorary_root m s ⟹ mut_m.reachable m x s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s r = None"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m r' (s(mutator m' := (s (mutator m'))⦇roots := insert r (roots (s (mutator m')))⦈, sys := (s sys)⦇heap := (sys_heap s)(r ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ mut_m.reachable m r' s ∨ (m' = m ∧ r' = r)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>reaches</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m r' s"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>tso_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>reaches</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rn</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' = m ∧ r' = r"</span></span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rn</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_heap s r = None"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fl = sys_fM s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv (s(mutator m' := (s (mutator m'))⦇roots := insert r (roots (s (mutator m')))⦈, sys := (s sys)⦇heap := (sys_heap s)(r ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>reachable_fun_upd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_discard_roots</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable_snapshot_inv s; roots' ⊆ roots (s (mutator m)) ⟧
     ⟹ reachable_snapshot_inv (s(mutator m := (s (mutator m))⦇roots := roots'⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>reachable_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>grey_protects_white_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ghg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ghost_honorary_grey (s p) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) (s(p := s p⦇ ghost_honorary_grey := {r} ⦈)))
      ⟷ (∃g'. (g' grey_protects_white w) s) ∨ (r has_white_path_to w) s"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) (s(p := s p⦇ghost_honorary_grey := {r}⦈))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>ghg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span> </span><span>if_distrib</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ghg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r has_white_path_to w) s"</span></span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ghg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

We need phase invariants in terms of both @{const
"mut_ghost_handshake_phase"} and @{const "sys_ghost_handshake_phase"}
which respectively track what the mutators and GC know by virtue of
the synchronisation structure of the system.

Read the following as ``when mutator ‹m› is past the specified
handshake, and has yet to reach the next one, ... holds.''

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_phase ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv_aux hp_Idle          = ⟨True⟩"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv_aux hp_IdleInit      = no_black_refs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv_aux hp_InitMark      = marked_insertions"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv_aux hp_Mark          = (marked_insertions <span class="hidden">❙</span><span class="bold">∧</span> marked_deletions)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv_aux hp_IdleMarkSweep = (marked_insertions <span class="hidden">❙</span><span class="bold">∧</span> marked_deletions <span class="hidden">❙</span><span class="bold">∧</span> reachable_snapshot_inv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mutator_phase_inv s ≡ mutator_phase_inv_aux (mut_ghost_handshake_phase s) s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mutators_phase_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mutators_phase_inv ≡ (<span class="hidden">❙</span><span class="bold">∀</span>m. mut_m.mutator_phase_inv m)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

This is what the GC guarantees. Read this as ``when the GC is at or
past the specified handshake, ... holds.''

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sys_phase_inv_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"handshake_phase ⇒ ('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv_aux hp_Idle          = ( (If sys_fA <span class="hidden">❙</span><span class="bold">=</span> sys_fM Then black_heap Else white_heap) <span class="hidden">❙</span><span class="bold">∧</span> no_grey_refs )"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv_aux hp_IdleInit      = no_black_refs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv_aux hp_InitMark      = (sys_fA <span class="hidden">❙</span><span class="bold">≠</span> sys_fM <span class="hidden">❙</span><span class="bold">⟶</span> no_black_refs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv_aux hp_Mark          = ⟨True⟩"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv_aux hp_IdleMarkSweep = ( (sys_phase <span class="hidden">❙</span><span class="bold">=</span> ⟨ph_Idle⟩ <span class="hidden">❙</span><span class="bold">∨</span> tso_pending_write gc (mw_Phase ph_Idle)) <span class="hidden">❙</span><span class="bold">⟶</span> no_grey_refs )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>sys_phase_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_phase_inv s ≡ sys_phase_inv_aux (sys_ghost_handshake_phase s) s"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>mut_m.mutator_phase_inv_aux.simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>mutator_phase_inv_aux_case</span><span class="delimiter">:</span><span> </span><span>mut_m.mutator_phase_inv_aux.simps</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>sys_phase_inv_aux_case</span><span class="delimiter">:</span><span> </span><span>sys_phase_inv_aux.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tso_pending_mutate_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ filter is_mw_Mutate (sys_mem_write_buffers p s) = filter is_mw_Mutate (sys_mem_write_buffers p s'); ⋀r f r'. P r f r' ⟷ Q r f r' ⟧
     ⟹ (∀r f r'. mw_Mutate r f r' ∈ set (sys_mem_write_buffers p s)  ⟶ P r f r') =
        (∀r f r'. mw_Mutate r f r' ∈ set (sys_mem_write_buffers p s') ⟶ Q r f r')"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iff_allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>set</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> (λs. Option.map_option obj_mark ∘ sys_heap s) <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate (mutator m))
          marked_insertions"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>marked_insertions_def</span><span> </span><span>obj_at_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>tso_pending_mutate_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>opt</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>marked_insertions_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.marked_insertions_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_insertionD</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = mw_Mutate r f (Some r') # ws; mut_m.marked_insertions m s ⟧
     ⟹ marked r' s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions_store_buffer_empty</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mutate (mutator m) s = [] ⟹ marked_insertions s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_insertions_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions_blacken</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"marked_insertions (s(gc := (s gc)⦇ W := gc_W s - {r} ⦈)) ⟷ marked_insertions s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_insertions_def</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ heap (s sys) r' = None; valid_refs_inv s ⟧
  ⟹ marked_insertions (s(mutator m' := s (mutator m')⦇roots := roots'⦈, sys := s sys⦇heap := sys_heap s(r' ↦ obj')⦈))
  ⟷ marked_insertions s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ref</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>field</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>r'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_insertions_free</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.marked_insertions m s; white r s ⟧
     ⟹ mut_m.marked_insertions m (s(sys := (s sys)⦇heap := (heap (s sys))(r := None)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_deletions_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit). sys_fM <span class="hidden">❙</span><span class="bold">⊗</span> sys_heap <span class="hidden">❙</span><span class="bold">⊗</span> tso_pending_mutate (mutator m))
          marked_deletions"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>marked_deletions_def</span><span> </span><span>obj_at_field_on_heap_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>full_types</span><span class="delimiter">)</span><span> </span><span>filter_set</span><span> </span><span>member_filter</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* opposite dir *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>full_types</span><span class="delimiter">)</span><span> </span><span>filter_set</span><span> </span><span>member_filter</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>obj_at_eq_imp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>marked_deletions_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.marked_deletions_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_deletions_store_buffer_empty</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mutate (mutator m) s = [] ⟹ marked_deletions s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_deletions_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_deletions_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ marked_deletions s; heap (s sys) r' = None; valid_refs_inv s ⟧
  ⟹ marked_deletions (s(mutator m' := s (mutator m')⦇roots := roots'⦈, sys := s sys⦇heap := sys_heap s(r' ↦ obj')⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_deletions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"ref = r'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Mutator proofs ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_hs_get_roots_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strong_tricolour_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r ∈ mut_roots s. marked r s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ghr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ghost_honorary_root s = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tso_pending_mutate (mutator m) s = []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv
               (s(mutator m := s (mutator m)⦇W := {}, ghost_handshake_phase := ghp'⦈,
                  sys := s sys⦇handshake_pending := hp', W := sys_W s ∪ mut_W s, ghost_handshake_in_sync := in'⦈))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable r s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_snapshot r ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>m</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME intro rules *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>marked_imp_black_or_grey</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ghost_honorary_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ghr</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>tso_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span> </span><span>tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>reaches</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>reaches</span><span> </span><span>vri</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_ref x s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_ref y s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reaches</span><span> </span><span>sti</span><span> </span><span>vri</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_imp_black_or_grey</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"white y s"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>grey_protects_whiteE</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_imp_black_or_grey</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_hs_get_work_done</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable_snapshot_inv s
    ⟹ reachable_snapshot_inv
               (s(mutator m := s (mutator m)⦇W := {}⦈,
                   sys := s sys⦇handshake_pending := (handshake_pending (s sys))(m := False), W := sys_W s ∪ mut_W s,
                                ghost_handshake_in_sync := (ghost_handshake_in_sync (s sys))(m := True)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_write_enqueue</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable r (s(sys := s sys⦇mem_write_buffers := (mem_write_buffers (s sys))(mutator m := sys_mem_write_buffers (mutator m) s @ [w])⦈))
  ⟷ reachable r s ∨ (∃x. x ∈ write_refs w ∧ (x reaches r) s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_black_refs_mo_co_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_honorary_grey (s p) = {}; white r s ⟧
     ⟹ no_black_refs (s(p := s p⦇ghost_honorary_grey := {r}⦈)) ⟷ no_black_refs s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_mo_co_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_honorary_grey (s p) = {}; reachable_snapshot_inv s ⟧
     ⟹ reachable_snapshot_inv (s(p := s p⦇ ghost_honorary_grey := {r} ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span> </span><span>reachable_snapshot_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>no_black_refs_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ heap (s sys) r' = None; no_black_refs s ⟧
     ⟹ no_black_refs (s(mutator m' := s (mutator m')⦇roots := roots'⦈, sys := s sys⦇heap := sys_heap s(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))
     ⟷ fl ≠ sys_fM s ∨ grey r' s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_load</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable_snapshot_inv s; sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r ∈ mut_roots s ⟧
     ⟹ reachable_snapshot_inv (s(mutator m := s (mutator m)⦇ roots := mut_roots s ∪ Option.set_option r' ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_store_ins</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable_snapshot_inv s; r ∈ mut_roots s; (∃r'. opt_r' = Some r') ⟶ the opt_r' ∈ mut_roots s ⟧
     ⟹ reachable_snapshot_inv (s(mutator m := s (mutator m)⦇ghost_honorary_root := {}⦈,
                                  sys := s sys⦇  mem_write_buffers := (mem_write_buffers (s sys))(mutator m := sys_mem_write_buffers (mutator m) s @ [mw_Mutate r f opt_r']) ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_insertions_store_ins</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ marked_insertions s; (∃r'. opt_r' = Some r') ⟶ marked (the opt_r') s ⟧
     ⟹ marked_insertions
               (s(mutator m := s (mutator m)⦇ghost_honorary_root := {}⦈,
                   sys := s sys
                     ⦇mem_write_buffers := (mem_write_buffers (s sys))(mutator m := sys_mem_write_buffers (mutator m) s @ [mw_Mutate r f opt_r'])⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_insertions_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>marked_deletions_store_ins</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ marked_deletions s; obj_at_field_on_heap (λr'. marked r' s) r f s ⟧
     ⟹ marked_deletions
               (s(mutator m := s (mutator m)⦇ghost_honorary_root := {}⦈,
                   sys := s sys
                     ⦇mem_write_buffers := (mem_write_buffers (s sys))(mutator m := sys_mem_write_buffers (mutator m) s @ [mw_Mutate r f opt_r'])⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_deletions_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_deref_del</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable_snapshot_inv s; sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r ∈ mut_roots s; mut_ghost_honorary_root s = {} ⟧
     ⟹ reachable_snapshot_inv (s(mutator m := s (mutator m)⦇ghost_honorary_root := Option.set_option opt_r', ref := opt_r'⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL
       <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL
       <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> strong_tricolour_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     mutator m
   ⦃ LSTP mutator_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span class="delimiter">;</span><span>
</span><span>       </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mutator_phase_inv_aux_case</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME annoying: unfolding fA_rel early leads to non-termination *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reachable_snapshot_inv_alloc</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME annoying: unfolding fA_rel early leads to non-termination *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>marked_deletions_store_ins</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME shuffle the following into this lemma *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀opt_r'. mw_Mutate (mut_tmp_ref s↓) (mut_field s↓) opt_r' ∉ set (sys_mem_write_buffers (mutator m) s↓))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_deletions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>marked_insertions_store_ins</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>reachable_blackD</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>blackD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>marked_deletions_store_ins</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME as above *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_phase s↓"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME invert handshake_phase_rel *)</span></span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>r</span><span class="delimiter">=</span><span>x2a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blackD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_blackD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mut_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>reachableE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>r</span><span class="delimiter">=</span><span>x2a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blackD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_blackD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mut_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>reachableE</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>marked_deletions_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_noop_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_ghost_handshake_phase s↓"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME invert handshake_step *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>marked_insertions_store_buffer_empty</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME simp? *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>marked_deletions_store_buffer_empty</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME simp? *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_roots_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_work_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m'</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mut_m.handshake_invL m'
       <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m'
       <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m'
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m'
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m'
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m'
   ⦃ LSTP mutator_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mutator_phase_inv_aux_case</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reachable_snapshot_inv_alloc</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span> </span><span>reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>grey_protects_white_dequeue_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fl = sys_fM s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ ghost_honorary_grey (s p)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈)))
      ⟷ (∃g. (g grey_protects_white w) s)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) ?s') ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃g. (g grey_protects_white w) ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) ?s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"white c s"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>g</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtranclp.intros</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g' grey_protects_white w) s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃g. (g grey_protects_white w) ?s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = r"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>g</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtranclp.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_dequeue_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; mut_m.reachable_snapshot_inv m s; valid_W_inv s ⟧
     ⟹ mut_m.reachable_snapshot_inv m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>reachable_fun_upd</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>Not</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>grey_protects_white_dequeue_mark</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>marked_insertions_dequeue_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; mut_m.marked_insertions m s; tso_writes_inv s; valid_W_inv s ⟧
     ⟹ mut_m.marked_insertions m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m = p"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>marked_insertions_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mutate r f r' # ws; mut_m.marked_insertions m s ⟧
     ⟹ mut_m.marked_insertions m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := r')⦈) (sys_heap s r)),
                                                    mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m = p"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* redundant to fit with other rules. Perhaps want points_to with explicit witness for f? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>points_to_mw_Mutate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x points_to y)
         (s(sys := (s sys)⦇ heap := (sys_heap s)(r := Option.map_option (λobj :: ('field, 'ref) object. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                            mem_write_buffers := (mem_write_buffers (s sys))(p := ws) ⦈))
  ⟷ (r ≠ x ∧ (x points_to y) s) ∨ (r = x ∧ valid_ref r s ∧ (opt_r' = Some y ∨ ( (x points_to y) s ∧ obj_at (λobj. ∃f'. obj_fields obj f' = Some y ∧ f ≠ f') r s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* shows the snapshot is preserved by the two marks. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>grey_protects_white_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m) s = mw_Mutate r f opt_r' # ws"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.marked_insertions m s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>md</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.marked_deletions m s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                                        mem_write_buffers := (mem_write_buffers (s sys))(mutator m := ws)⦈)))
      ⟷ (∃g. (g grey_protects_white w) s)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) ?s') ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) ?s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) ?s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mi</span><span> </span><span>sb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>c</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate r f (Some c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃g. (g grey_protects_white w) ?s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g grey_protects_white w) s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>md</span><span> </span><span>sb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_protects_white_def</span><span> </span><span>has_white_path_to_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"b = r"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>obj_at_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule: witness field for r points_to c *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>c</span><span> </span><span>g</span><span> </span><span>x2</span><span> </span><span>aa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"aa = f"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>g</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtranclp.intros</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_deletions_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate r f opt_r'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* write barrier installed but not all mutators are necessarily past get_roots *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m') s = mw_Mutate r f opt_r' # ws"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.marked_insertions m' s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>md</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.marked_deletions m' s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable_snapshot_inv m s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sti</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strong_tricolour_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable_snapshot_inv m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                                        mem_write_buffers := (mem_write_buffers (s sys))(mutator m' := ws)⦈))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable_snapshot_inv m ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mut_m.reachable_snapshot_invI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m y ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(mut_m.reachable m y s ∨ mut_m.reachable m' y s) ∧ in_snapshot y ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mi</span><span> </span><span>md</span><span> </span><span>rsi</span><span> </span><span>sb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>                  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ghost_honorary_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mi</span><span> </span><span>md</span><span> </span><span>rsi</span><span> </span><span>sb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>                  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>tso_root</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mi</span><span> </span><span>md</span><span> </span><span>rsi</span><span> </span><span>sb</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>                  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>xa</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_deletions_def</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m x s"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reachableI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>reaches</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>reaches</span><span> </span><span>sb</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m y s ∨ mut_m.reachable m' y s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>reachableE</span><span> </span><span>mutator_reachable_tso</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>y</span><span> </span><span>vri</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_ref y s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reaches</span><span> </span><span>mi</span><span> </span><span>md</span><span> </span><span>rsi</span><span> </span><span>sb</span><span> </span><span>sti</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(black y s ∨ (∃x. (x grey_protects_white y) s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>                  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>mut_m.marked_deletions_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME lemmas *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate r f opt_r'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME probably want points_to_mw_Mutate as an elim rule to make this robust, reduce duplication *)</span></span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>reachableE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>reachableE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>strong_tricolour_invD</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>grey_protects_whiteI</span><span> </span><span>marked_imp_black_or_grey</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"white y s"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME lemma *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>grey_protects_whiteE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>strong_tricolour_invD</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"white y s"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME lemma *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>grey_protects_whiteE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>strong_tricolour_invD</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"white y s"</span></span></span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME lemma *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>grey_protects_whiteE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mi</span><span> </span><span>md</span><span> </span><span>rsi</span><span> </span><span>sb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span>
</span><span>                  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_snapshot y ?s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_invI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀m x y. ⟦ (x reaches y) s; x ∈ mut_m.mut_roots m s ∨ x ∈ mut_m.mut_ghost_honorary_root m s ∨ x ∈ mut_m.tso_write_refs m s ∨ grey x s ⟧ ⟹ valid_ref y s
   ⟧ ⟹ valid_refs_inv s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_reachable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m y s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"black_heap s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"black y s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obj_at_weakenE</span><span> </span><span>reachableE</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_inv_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m') s = mw_Mutate r f opt_r' # ws"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                        mem_write_buffers := (mem_write_buffers (s sys))(mutator m' := ws)⦈))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_refs_invI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?root</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λm x (s::('field, 'mut, 'ref) lsts). x ∈ mut_m.mut_roots m s ∨ x ∈ mut_m.mut_ghost_honorary_root m s ∨ x ∈ mut_m.tso_write_refs m s ∨ grey x s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x reaches y) ?s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?root m x ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃m x. ?root m x s ∧ (x reaches y) s) ∧ valid_ref y ?s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span>sb</span><span> </span><span>vri</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>obj_at_fun_upd</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rtranclp.rtrancl_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rules *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sb</span><span> </span><span>vri</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>obj_at_fun_upd</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>obj_at_fun_upd</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m'</span><span class="delimiter">]</span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_ref y ?s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>map_option.compositionality</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m') s = mw_Mutate r f opt_r' # ws"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"black_heap s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ngr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable_snapshot_inv m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                                        mem_write_buffers := (mem_write_buffers (s sys))(mutator m' := ws)⦈))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable_snapshot_inv m ?s'"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mut_m.reachable_snapshot_invI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>in_snapshotI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>black_heap_reachable</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bh</span><span> </span><span>vri</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bh</span><span> </span><span>ngr</span><span> </span><span>sb</span><span> </span><span>vri</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>black_heap_reachable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>marked_deletions_dequeue_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; mut_m.marked_deletions m s; tso_writes_inv s; valid_W_inv s ⟧
     ⟹ mut_m.marked_deletions m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_deletions_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"mutator m = p"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>marked_deletions_dequeue_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m') s = mw_Mutate r f opt_r' # ws; mut_m.marked_deletions m s; mut_m.marked_insertions m' s ⟧
     ⟹ mut_m.marked_deletions m (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                                 mem_write_buffers := (mem_write_buffers (s sys))((mutator m') := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_deletions_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>black_heap_marked_insertions_dequeue</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ black_heap s; valid_refs_inv s ⟧ ⟹ mut_m.marked_insertions m s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span> </span><span>black_heap_def</span><span> </span><span>black_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>option.splits</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> strong_tricolour_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ LSTP (mut_m.mutator_phase_inv m) ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>mutator_phase_inv_aux_case</span><span> </span><span>p_not_sys</span><span> </span><span>hp_step_rel_def</span><span> </span><span>do_write_action_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fM *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME mess *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ws</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span> </span><span>ma</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>marked_deletions_dequeue_ref</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>marked_deletions_dequeue_ref</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The infamous termination argument.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We need to know that if the GC does not receive any further work to do
at ‹get_roots› and ‹get_work›, then there are no grey
objects left. Essentially this encodes the stability property that
grey objects must exist for mutators to create grey objects.

Note that this is not invariant across the scan: it is possible for
the GC to hold all the grey references. The two handshakes transform
the GC's local knowledge that it has no more work to do into a global
property, or gives it more work.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_mut_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W_empty_mut_inv =
      ((EMPTY sys_W <span class="hidden">❙</span><span class="bold">∧</span> sys_ghost_handshake_in_sync m <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY (WL (mutator m))))
   <span class="hidden">❙</span><span class="bold">⟶</span> (<span class="hidden">❙</span><span class="bold">∃</span>m'. <span class="hidden">❙</span><span class="bold">¬</span>(sys_ghost_handshake_in_sync m') <span class="hidden">❙</span><span class="bold">∧</span> <span class="hidden">❙</span><span class="bold">¬</span>(EMPTY (WL (mutator m')))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_locs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W_empty_locs ≡
       idle_locs ∪ init_locs ∪ sweep_locs ∪ { ''mark_read_fM'', ''mark_write_fA'', ''mark_end'' }
     ∪ prefixed ''mark_noop''
     ∪ prefixed ''mark_loop_get_roots''
     ∪ prefixed ''mark_loop_get_work''"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"black_heap_locs = { ''sweep_idle'', ''idle_noop_mfence'', ''idle_noop_init_type'' }"</span></span></span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs_locs = black_heap_locs ∪ sweep_locs ∪ {''mark_end''}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_W_empty_invL =
   (atS_gc (hs_get_roots_locs ∪ hs_get_work_locs)  (<span class="hidden">❙</span><span class="bold">∀</span>m. mut_m.gc_W_empty_mut_inv m)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop_get_roots_load_W''          (EMPTY sys_W <span class="hidden">❙</span><span class="bold">⟶</span> no_grey_refs)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop_get_work_load_W''           (EMPTY sys_W <span class="hidden">❙</span><span class="bold">⟶</span> no_grey_refs)
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''mark_loop''                           (EMPTY gc_W <span class="hidden">❙</span><span class="bold">⟶</span> no_grey_refs)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc no_grey_refs_locs                      no_grey_refs
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc gc_W_empty_locs                        (EMPTY gc_W))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_mut_inv_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λm'. sys_W <span class="hidden">❙</span><span class="bold">⊗</span> WL (mutator m') <span class="hidden">❙</span><span class="bold">⊗</span> sys_ghost_handshake_in_sync m')
          gc_W_empty_mut_inv"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_W_empty_mut_inv_fun_upd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mut_m.gc_W_empty_mut_inv_eq_imp</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(m', p) s. (AT s gc, s↓ gc, sys_W s↓, WL p s↓, sys_ghost_handshake_in_sync m' s↓))
          gc_W_empty_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>gc_W_empty_invL_def</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_W_empty_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc.gc_W_empty_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_roots_get_work_subseteq_gc_W_empty_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hs_get_roots_locs ∪ hs_get_work_locs ⊆ gc_W_empty_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hs_get_roots_locs_def</span><span> </span><span>hs_get_work_locs_def</span><span> </span><span>gc_W_empty_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_mut_inv_handshake_init</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.gc_W_empty_mut_inv m (s(sys := s sys⦇handshake_type := ht, ghost_handshake_in_sync := ⟨False⟩⦈))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.gc_W_empty_mut_inv m (s(sys := s sys⦇handshake_type := ht, ghost_handshake_in_sync := ⟨False⟩, ghost_handshake_phase := hp' ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_W_empty_mut_inv_load_W</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ∀m. mut_m.gc_W_empty_mut_inv m s; ∀m. sys_ghost_handshake_in_sync m s; WL gc s = {}; WL sys s = {} ⟧
     ⟹ no_grey_refs s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> LSTP valid_W_inv ⦄
     gc
   ⦃ gc_W_empty_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>gc_W_empty_mut_inv_load_W</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_gc_W_empty_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.gc_W_empty_invL ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_nihe</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_get_rootsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc hs_get_roots_locs s; handshake_invL s ⟧ ⟹ sys_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ sys_handshake_type s↓ = ht_GetRoots"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_get_workD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc hs_get_work_locs s; handshake_invL s ⟧ ⟹ sys_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ sys_handshake_type s↓ = ht_GetWork"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>handshake_get_roots_get_workD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc (hs_get_roots_locs ∪ hs_get_work_locs) s; handshake_invL s ⟧ ⟹ sys_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ sys_handshake_type s↓ ∈ {ht_GetWork, ht_GetRoots}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Un_subset_iff</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs</span><span> </span><span>hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_un</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_locs_subseteq_hs_in_sync_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs_locs ⊆ hs_in_sync_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_locs_def</span><span> </span><span>black_heap_locs_def</span><span> </span><span>hs_in_sync_locs_def</span><span> </span><span>hs_done_locs_def</span><span> </span><span>sweep_locs_def</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prefix_same_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>handshake_sweep_mark_endD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc no_grey_refs_locs s; gc.handshake_invL s; handshake_phase_inv s↓ ⟧
     ⟹ mut_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ All (ghost_handshake_in_sync (s↓ sys))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>no_grey_refs_locs_subseteq_hs_in_sync_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_locs_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>atS_state_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_un</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ls'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"hp_IdleMarkSweep_locs"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_locs_def</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ls'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"hp_IdleMarkSweep_locs"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_IdleMarkSweep_locs_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_simps</span><span> </span><span>loc</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_WL_GC</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc (hs_get_roots_locs ∪ hs_get_work_locs) s; gc.obj_fields_marked_invL s ⟧ ⟹ gc_ghost_honorary_grey s↓ = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc.obj_fields_marked_invL_def</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>get_roots_get_work_subseteq_ghost_honorary_grey_empty_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* think about showing gc_W_empty_invL instead *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_mut_mo_co_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ∀x. mut_m.gc_W_empty_mut_inv x s↓; mutators_phase_inv s↓;
     mut_ghost_honorary_grey s↓ = {};
     r ∈ mut_roots s↓ ∪ mut_ghost_honorary_root s↓; white r s↓;
     atS gc (hs_get_roots_locs ∪ hs_get_work_locs) s; gc.handshake_invL s; gc.obj_fields_marked_invL s;
     atS gc gc_W_empty_locs s ⟶ gc_W s↓ = {};
     handshake_phase_inv s↓; valid_W_inv s↓ ⟧
    ⟹ mut_m.gc_W_empty_mut_inv m' (s↓(mutator m := s↓ (mutator m)⦇ghost_honorary_grey := {r}⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gc.handshake_get_roots_get_workD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* before get work *)</span></span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* past get work *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_white_root</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>grey_protects_whiteD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>g</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Can't be the GC *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>empty_WL_GC</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>get_roots_get_work_subseteq_gc_W_empty_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Can't be sys *)</span></span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>g</span><span> </span><span>mut</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_in_sync mut s↓"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>mut</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>mut</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* before get roots *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* after get roots *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>reachable_snapshot_inv_white_root</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>grey_protects_whiteD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>g</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Can't be the GC *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>empty_WL_GC</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>get_roots_get_work_subseteq_gc_W_empty_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Can't be sys *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>g</span><span> </span><span>mut</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_in_sync mut s↓"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>mut</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>mut</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME common up *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_mo_co_mark</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mutators_phase_inv s↓;
     no_grey_refs s↓;
     gc.handshake_invL s;
     at gc ''mark_loop'' s ∨ at gc ''mark_loop_get_roots_load_W'' s ∨ at gc ''mark_loop_get_work_load_W'' s ∨ atS gc no_grey_refs_locs s;
     r ∈ mut_roots s↓ ∪ mut_ghost_honorary_root s↓; white r s↓;
     handshake_phase_inv s↓ ⟧
    ⟹ no_grey_refs (s↓(mutator m := s↓ (mutator m)⦇ghost_honorary_grey := {r}⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_simps</span><span> </span><span>gc.handshake_invL_def</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_simps</span><span> </span><span>gc.handshake_invL_def</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_simps</span><span> </span><span>gc.handshake_invL_def</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>handshake_sweep_mark_endD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_W_empty_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.gc_W_empty_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
             <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
             <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
             <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
           <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.obj_fields_marked_invL
           <span class="hidden">❙</span><span class="bold">∧</span> gc.gc_W_empty_invL
             <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     mutator m
   ⦃ gc.gc_W_empty_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* apply vcg_ni -- very slow *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
let val ctxt = @{context} in

  TRY (HEADGOAL (vcg_clarsimp_tac ctxt))
THEN
  PARALLEL_ALLGOALS (
               vcg_sem_tac ctxt
         THEN' (TRY o SELECT_GOAL (Local_Defs.unfold_tac ctxt (Named_Theorems.get ctxt @{named_theorems inv})))
         THEN' (TRY o REPEAT_ALL_NEW (Tactic.match_tac ctxt @{thms conjI})) (* expose the location predicates, do not split the consequents *)
  THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.match_tac ctxt @{thms impI}))
                   (* Preserve the label sets in atS but normalise the label in at; turn s' into s *)
  THEN_ALL_NEW full_simp_tac ctxt (* FIXME vcg_ni uses asm_full_simp_tac here *)
  THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms conjE}))
                   (* The effect of vcg_pre: should be cheap *)
  THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Tactic.ematch_tac ctxt @{thms thin_locs} THEN' REPEAT1 o assume_tac ctxt))
  THEN_ALL_NEW asm_full_simp_tac (ss_only (@{thms loc_simps} @ Named_Theorems.get ctxt @{named_theorems loc}) ctxt)
  THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (Rule_Insts.thin_tac ctxt "True" []))
  THEN_ALL_NEW clarsimp_tac ctxt)

end
›</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_noop_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_un</span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_roots_done: gc_W_empty *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_roots_done: no_grey_refs *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_work_done: gc_W_empty *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.gc_W_empty_mut_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_work_done: no_grey_refs *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Sweep loop invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locset_definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sweep_loop_locs = prefixed ''sweep_loop''"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inv_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>sweep_loop_invL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sweep_loop_invL =
   (at_gc ''sweep_loop_check''        ( (<span class="hidden">❙</span><span class="bold">¬</span>(NULL gc_mark) <span class="hidden">❙</span><span class="bold">⟶</span> (λs. obj_at (λobj. Some (obj_mark obj) = gc_mark s) (gc_tmp_ref s) s))
                                      <span class="hidden">❙</span><span class="bold">∧</span> (  NULL gc_mark <span class="hidden">❙</span><span class="bold">⟶</span> valid_ref <span class="hidden">❙</span><span class="bold">$</span> gc_tmp_ref <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> gc_tmp_ref ) )
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''sweep_loop_free''         ( <span class="hidden">❙</span><span class="bold">¬</span>(NULL gc_mark) <span class="hidden">❙</span><span class="bold">∧</span> the ∘ gc_mark <span class="hidden">❙</span><span class="bold">≠</span> gc_fM <span class="hidden">❙</span><span class="bold">∧</span> (λs. obj_at (λobj. Some (obj_mark obj) = gc_mark s) (gc_tmp_ref s) s) )
  <span class="hidden">❙</span><span class="bold">∧</span> at_gc ''sweep_loop_ref_done''     (valid_ref <span class="hidden">❙</span><span class="bold">$</span> gc_tmp_ref <span class="hidden">❙</span><span class="bold">⟶</span> marked <span class="hidden">❙</span><span class="bold">$</span> gc_tmp_ref)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc sweep_loop_locs            (<span class="hidden">❙</span><span class="bold">∀</span>r. <span class="hidden">❙</span><span class="bold">¬</span>(⟨r⟩ <span class="hidden">❙</span><span class="bold">∈</span> gc_refs) <span class="hidden">❙</span><span class="bold">⟶</span> valid_ref r <span class="hidden">❙</span><span class="bold">⟶</span> marked r)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc black_heap_locs            (<span class="hidden">❙</span><span class="bold">∀</span>r. valid_ref r <span class="hidden">❙</span><span class="bold">⟶</span> marked r)
  <span class="hidden">❙</span><span class="bold">∧</span> atS_gc (prefixed ''sweep_loop_'' - { ''sweep_loop_choose_ref'' }) (gc_tmp_ref <span class="hidden">❙</span><span class="bold">∈</span> gc_refs))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>sweep_loop_invL_eq_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp (λ(_::unit) (s :: ('field, 'mut, 'ref) gc_pred_state). (AT s gc, s↓ gc, sys_fM s↓, Option.map_option obj_mark ∘ sys_heap s↓))
          sweep_loop_invL"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. valid_ref r s↓ ⟷ valid_ref r s'↓"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀P r. obj_at (λobj. P (obj_mark obj)) r s↓ ⟷ obj_at (λobj. P (obj_mark obj)) r s'↓"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λmark. Some mark = gc_mark s'↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λmark. mark = sys_fM s'↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_option_eq_Some</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gc_sweep_loop_invL_niE</span><span class="delimiter">[</span><span>nie</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>gc.sweep_loop_invL_eq_imp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>eq_imp_simps</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conj_explode</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>sweep_loop_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> phase_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
         <span class="hidden">❙</span><span class="bold">∧</span> LSTP (phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     gc
   ⦃ sweep_loop_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>phase_rel_inv_def</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ gc_refs s↓"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sweep_loop_sweep_locs</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sweep_loop_locs ⊆ sweep_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sweep_loop_locs_def</span><span> </span><span>sweep_locs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sweep_locs_subseteq_fM_tso_empty_locs</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sweep_locs ⊆ fM_tso_empty_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sweep_locs_def</span><span> </span><span>fM_tso_empty_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sweep_loop_locs_fM_eq_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sweep_loop_locs ⊆ fM_eq_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sweep_loop_locs_def</span><span> </span><span>fM_eq_locs_def</span><span> </span><span>sweep_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sweep_loop_locs_fA_eq_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sweep_loop_locs ⊆ fA_eq_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sweep_loop_locs_def</span><span> </span><span>fA_eq_locs_def</span><span> </span><span>sweep_locs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subset_insertI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_locs_subseteq_fM_tso_empty_locs</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap_locs ⊆ fM_tso_empty_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_locs_def</span><span> </span><span>fM_tso_empty_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_locs_fM_eq_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap_locs ⊆ fM_eq_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_locs_def</span><span> </span><span>fM_eq_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_locs_fA_eq_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap_locs ⊆ fA_eq_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_locs_def</span><span> </span><span>fA_eq_locs_def</span><span> </span><span>sweep_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>fM_invL_tso_emptyD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc ls s; fM_fA_invL s; ls ⊆ fM_tso_empty_locs ⟧ ⟹ tso_pending_fM gc s↓ = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_fA_invL_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>atS_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_sweep_loop_invL_locsE</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(atS gc (sweep_locs ∪ black_heap_locs) s ⟶ False) ⟹ gc.sweep_loop_invL s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.sweep_loop_invL_def</span><span> </span><span>atS_un</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>loc</span><span> </span><span>atS_simps</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>atS_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sweep_locs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_sweep_loop_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.phase_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ gc.sweep_loop_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span>
</span><span>                </span><span>elim</span><span class="delimiter">:</span><span> </span><span>gc_sweep_loop_invL_niE</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME elimination rule using tso_writes_inv *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>ref</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gc_sweep_loop_invL_locsE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>gc.gc_W_empty_invL_def</span><span> </span><span>no_grey_refs_locs_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>atS_state_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_un</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>p</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>p</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mutate *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>gc_sweep_loop_invL_niE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME should be automatic *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_fA *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>gc_sweep_loop_invL_niE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME should be automatic *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_fM *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gc_sweep_loop_invL_locsE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>gc.fM_invL_tso_emptyD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mv_Phase *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>gc_sweep_loop_invL_niE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME should be automatic *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME weird: expect more aggressive use of gc_sweep_loop_invL_niE by clarsimp *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>gc_sweep_loop_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ gc.sweep_loop_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv</span><span> </span><span>gc.sweep_loop_invL_def</span><span> </span><span>gc.fM_fA_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* four subgoals *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>thin_locs</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>thin_locs</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ra</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>sweep_loop_locs_fA_eq_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>sweep_loop_locs_fM_eq_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ra</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>black_heap_locs_fA_eq_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>black_heap_locs_fM_eq_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME crappy split *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>sys_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL
       <span class="hidden">❙</span><span class="bold">∧</span> phase_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
     gc
   ⦃ LSTP sys_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>black_heap_no_greys</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>phase_rel_invD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>filter_empty_conv</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>no_black_refs_sweep_loop_free</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"no_black_refs s ⟹ no_black_refs (s(sys := s sys⦇heap := (sys_heap s)(gc_tmp_ref s := None)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>no_black_refs_load_W</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_black_refs s; gc_W s = {} ⟧
     ⟹ no_black_refs (s(gc := s gc⦇W := sys_W s⦈, sys := s sys⦇W := {}⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_deletions_sweep_loop_free</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.marked_deletions m s; mut_m.reachable_snapshot_inv m s; no_grey_refs s; white r s ⟧
     ⟹ mut_m.marked_deletions m (s(sys := s sys⦇heap := (sys_heap s)(r := None)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_deletions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate ref field option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>grey_protects_whiteD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>r</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_snapshot_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>grey_protects_whiteD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mutator_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     gc
   ⦃ LSTP (mut_m.mutator_phase_inv m) ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mutator_phase_inv_aux_case</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sweep_loop_free *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mut_m.reachable_snapshot_inv_sweep_loop_free</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ''mark_loop_get_work_load_W'' *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_blacken *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>x</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obj_fields_marked_inv_has_white_path_to_blacken</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mo_co_mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>mut_m.reachable_snapshot_inv_mo_co_mark</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME hoist to the top level *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_get_roots_load_W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>grey_protects_white_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>sys_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL
             <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL
             <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
             <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
             <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
        <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ LSTP sys_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sys_phase_inv_aux_case</span><span> </span><span>heap_colours_colours</span><span>
</span><span>              </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* alloc *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>no_black_refs_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store_ins_mo_co_mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>                </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>                  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_rootD</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store_del_mo_co_unlock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>                </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>no_grey_refs_not_rootD</span><span>
</span><span>                  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_rootD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_rootD</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_roots_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_roots_loop_mo_co_mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs_get_work_done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span> </span><span>filter_empty_conv</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>handshake_phase_invD</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_no_marks</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; valid_W_inv s ⟧ ⟹ ¬sys_mem_write_buffers p s = mw_Mark r fl # ws"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>sys</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_dequeue_mark</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mark r fl # ws; black_heap s; valid_W_inv s ⟧
   ⟹ black_heap (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (obj_mark_update (λ_. fl)) (sys_heap s r)), mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_dequeue_ref</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mutate r f r' # ws; black_heap s ⟧
     ⟹ black_heap (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := r')⦈) (sys_heap s r)),
                                   mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>black_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>white_heap_dequeue_fM</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"black_heap s↓
     ⟹ white_heap (s↓(sys := s↓ sys⦇fM := ¬ sys_fM s↓, mem_write_buffers := (mem_write_buffers (s↓ sys))(gc := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>white_heap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>black_heap_dequeue_fM</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ white_heap s↓; no_grey_refs s↓ ⟧
     ⟹ black_heap (s↓(sys := s↓ sys⦇fM := ¬ sys_fM s↓, mem_write_buffers := (mem_write_buffers (s↓ sys))(gc := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>black_heap_def</span><span> </span><span>white_heap_def</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>white_heap_dequeue_ref</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers p s = mw_Mutate r f r' # ws; white_heap s ⟧
     ⟹ white_heap (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := r')⦈) (sys_heap s r)),
                                   mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>white_heap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>sys_phase_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ LSTP sys_phase_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>sys_phase_inv_aux_case</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>handshake_phase.splits</span><span> </span><span>if_splits</span><span class="delimiter">;</span><span>
</span><span>    </span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_inv_unlockE</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_lock s = Some p; sys_mem_write_buffers p s = [];
     ⋀r. r ∈ ghost_honorary_grey (s p) ⟹ marked r s;
     valid_W_inv s
   ⟧ ⟹ valid_W_inv (s(sys := mem_lock_update Map.empty (s sys)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_W_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>emptyE</span><span> </span><span>empty_set</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_W_inv_mark</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_lock s = Some p; white w s; valid_W_inv s ⟧
     ⟹ w ∈ ghost_honorary_grey (s p) ∨ (∀q. w ∉ WL q s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>WL_def</span><span> </span><span>marked_not_white</span><span> </span><span>option.inject</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>valid_W_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD2</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD3</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL
       <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL
       <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     gc
   ⦃ LSTP valid_W_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sweep loop free: what's with the case splitting? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_get_work_load_W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_blacken *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mo_co_W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mo_co_unlock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>iff</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mo_co_mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_W_inv_mark</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME want a cheaper contradiction between white and marked *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark_loop_mo_co_lock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ''mark_loop_get_roots_load_W'' *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_W_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD2</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD3</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
      <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     mutator m
   ⦃ LSTP valid_W_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* alloc *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store ins mo co W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store ins mo co unlock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = mutator m"</span></span></span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store ins mo co mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_W_inv_mark</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME want a cheaper contradiction between white and marked *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store ins mo co lock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store del mo co W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store del mo co unlock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = mutator m"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store del mo co mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_W_inv_mark</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME want a cheaper contradiction between white and marked *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store del mo co lock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get roots done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop mo co W *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop mo co unlock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = mutator m"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop mo co mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_W_inv_mark</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME want a cheaper contradiction between white and marked *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get roots loop mo co lock *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hs get work done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span> </span><span>process_name.splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>valid_W_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD2</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD3</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>valid_W_invD4</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>o_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ LSTP valid_W_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_W_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>fM_rel_inv_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mutate, mw_fA *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_fM *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>bool</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p_not_sys</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_ghost_handshake_phase s↓ = hp_Idle"</span></span></span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_no_pending_marks</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Phase *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>strong_tricolour_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (strong_tricolour_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     gc
   ⦃ LSTP strong_tricolour_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_inv_blacken</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>strong_tricolour</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mark_object_invL
      <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> strong_tricolour_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv) ⦄
     mutator m
   ⦃ LSTP strong_tricolour_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fM_rel_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sys_phase_inv_aux_case</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME rule *)</span></span></span></span></span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_black_refsD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_black_refsD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>strong_tricolour_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> strong_tricolour_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ LSTP strong_tricolour_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_jackhammer</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>fM_rel_inv_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ref</span><span> </span><span>field</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>xa</span><span> </span><span>ref</span><span> </span><span>field</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ref"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_Mutate *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>xa</span><span> </span><span>ref</span><span> </span><span>field</span><span> </span><span>option</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mutator_phase_inv_aux_case</span><span> </span><span>hp_step_rel_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>handshake_phase.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refsD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME split less *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>heap_colours_colours</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_black_refs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mw_Mutate x field (Some xa)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_not_white</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mw_fM *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>xa</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>black_heap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>colours_distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>white_heap_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Remaining non-interference proofs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>marked_insertionsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ sys_mem_write_buffers (mutator m) s = mw_Mutate r f (Some r') # ws; mut_m.marked_insertions m s ⟧
     ⟹ marked r' s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.marked_insertions_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_hs_get_roots_loop_locs_subseteq_hs_get_roots</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_hs_get_roots_loop_locs ⊆ prefixed ''hs_get_roots_''"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_hs_get_roots_loop_locs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_m_handshake_invL_get_roots</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mut_m.handshake_invL m s; atS (mutator m) mut_hs_get_roots_loop_locs s ⟧
     ⟹ sys_handshake_type s↓ = ht_GetRoots ∧ sys_handshake_pending m s↓"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mut_m.handshake_invL_def</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>mut_hs_get_roots_loop_locs_subseteq_hs_get_roots</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_mut_mo_valid_ref_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixed ''store_del_mo'' ∪ {''lop_store_ins''} ⊆ mut_mo_valid_ref_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_mo_valid_ref_locs_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_mut_mo_valid_ref_locs2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixed ''store_ins'' ⊆ mut_mo_valid_ref_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_mo_valid_ref_locs_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_phase_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ghost_handshake_phase (s (mutator m)) = hp_Mark ∨ ghost_handshake_phase (s (mutator m)) = hp_IdleMarkSweep ∧ sys_phase s ≠ ph_Idle;
     mut_m.mutator_phase_inv_aux m (ghost_handshake_phase (s (mutator m))) s ⟧
     ⟹ mut_m.marked_insertions m s ∧ mut_m.marked_deletions m s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ghost_handshake_phase (s (mutator m))"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>mut_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>do_write_action_fM</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>do_write_action_prj_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>do_write_action_prj_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m_get_roots_no_fM_write</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m_get_roots_no_phase_write</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m_ghost_handshake_phase_not_hp_Idle</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>atS_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>filter_empty_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ mut_m.handshake_invL m <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m
             <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄
           sys
         ⦃ mut_m.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>               </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_at_weakenE</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>               </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_at_weakenE</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span> </span><span>loc</span><span>
</span><span>               </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>               </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_at_weakenE</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>p_not_sys</span><span> </span><span>loc</span><span> </span><span>fM_rel_inv_def</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valid_W_invD2</span><span>
</span><span>                 </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_at_weakenE</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>obj_at_weakenE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>w</span><span> </span><span>ws</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subseteq_mut_mo_valid_ref_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"atS p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"at p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>p_not_sys</span><span> </span><span>loc</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD2</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_phase_inv</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>refa</span><span> </span><span>fielda</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"refa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD3</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"tmp_ref (s↓ (mutator m))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>marked_insertionsD</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* super messy case *)</span></span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_imp_valid_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ma</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>marked_insertionsD</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>handshake_phase.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>handshake_phase.distinct</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>w</span><span> </span><span>ws</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>handshake_phase.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>handshake_phase.distinct</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>w</span><span> </span><span>ws</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subseteq_mut_mo_valid_ref_locs2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"atS p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"at p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>do_write_action_fM</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>p_not_sys</span><span>
</span><span>                 </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_phase_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>refa</span><span> </span><span>fielda</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"refa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD3</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"tmp_ref (s↓ (mutator m))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>marked_insertionsD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* super messy case *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_imp_valid_ref</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ma</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ma</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>phase_rel_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>marked_insertionsD</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>phase_rel_invD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>atS_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
            <span class="hidden">❙</span><span class="bold">∧</span> mut_m.handshake_invL m
            <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m
            <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv) ⦄
           gc
         ⦃ mut_m.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_m_handshake_invL_get_roots</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mut_m.handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_null_ref_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_m.reachable_blackD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subseteq_mut_mo_valid_ref_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"atS p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"at p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_null_ref_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_m.reachable_blackD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subseteq_mut_mo_valid_ref_locs2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"atS p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"at p ls s ⟶ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>ls</span><span> </span><span>s</span><span> </span><span>Q</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_null_ref_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mut_m.reachable_blackD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_at_field_on_heap_def</span><span> </span><span>black_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_store_old_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL
      <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mutator_phase_inv m) ⦄
     gc
   ⦃ mut_store_del.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span>
</span><span>                   </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">,</span><span> </span><span>drule_tac</span><span> </span><span>r</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gc_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.no_grey_refs_not_rootD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>mut_store_ins_mark_object_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>mut_m.mark_object_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL
      <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
      <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mut_m.mutator_phase_inv m) ⦄
     gc
   ⦃ mut_store_ins.mark_object_invL m ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_ni</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span>
</span><span>                   </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">,</span><span> </span><span>drule_tac</span><span> </span><span>r</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gc_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.no_grey_refs_not_rootD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_locs ⊆ hp_IdleMarkSweep_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_locs_def</span><span> </span><span>hp_IdleMarkSweep_locs_def</span><span> </span><span>mark_loop_locs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obj_fields_marked_locs_subseteq_hs_in_sync_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obj_fields_marked_locs ⊆ hs_in_sync_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>obj_fields_marked_locs_def</span><span> </span><span>hs_in_sync_locs_def</span><span> </span><span>hs_done_locs_def</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prefix_same_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>handshake_obj_fields_markedD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc obj_fields_marked_locs s; gc.handshake_invL s ⟧ ⟹ sys_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ All (ghost_handshake_in_sync (s↓ sys))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>obj_fields_marked_locs_subseteq_hs_in_sync_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_loop_mo_mark_loop_field_done_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixed ''mark_loop_mo'' ∪ {''mark_loop_mark_field_done''} ⊆ hp_IdleMarkSweep_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_IdleMarkSweep_locs_def</span><span> </span><span>mark_loop_locs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>append_prefixD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixed ''mark_loop_mo'' ∪ {''mark_loop_mark_field_done''} ⊆ hs_in_sync_locs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hs_in_sync_locs_def</span><span> </span><span>hs_done_locs_def</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prefix_same_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_loop_mo_mark_loop_field_done_hp_phaseD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS gc (prefixed ''mark_loop_mo'' ∪ {''mark_loop_mark_field_done''}) s; gc.handshake_invL s ⟧ ⟹ sys_ghost_handshake_phase s↓ = hp_IdleMarkSweep ∧ All (ghost_handshake_in_sync (s↓ sys))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gc.handshake_invL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>mark_loop_mo_mark_loop_field_done_subseteq_hp_IdleMarkSweep_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>atS_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* an alternative is some kind of ghost_honorary_XXX for the GC while marking *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gc_marking_reaches_mw_Mutate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xys</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. (x reaches y) s ⟶ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x reaches y) (s(sys := s sys⦇heap := (sys_heap s)(r := Option.map_option (λobj. obj⦇obj_fields := (obj_fields obj)(f := opt_r')⦈) (sys_heap s r)),
                                             mem_write_buffers := (mem_write_buffers (s sys))(p := ws)⦈))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sys_mem_write_buffers (mutator m) s = mw_Mutate r f opt_r' # ws"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_ref y s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xy</span><span> </span><span>xys</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. z ∈ {x} ∪ mut_m.tso_write_refs m s ∧ (z reaches y) s ∧ valid_ref y s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rtrancl_refl</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rtrancl_into_rtrancl</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sb</span><span> </span><span>vri</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>points_to_mw_Mutate</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>gc_obj_fields_marked_invL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>gc.obj_fields_marked_invL_def</span><span class="delimiter">[</span><span>inv</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ gc.fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc.obj_fields_marked_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fM_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     sys
   ⦃ gc.obj_fields_marked_invL ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_nihe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>vcg_ni</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p_not_sys</span><span> </span><span>fM_rel_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc.obj_fields_marked_inv_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>handshake_obj_fields_markedD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>ref</span><span> </span><span>bool</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD2</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ref *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>x23</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fM *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>x4</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>w</span><span> </span><span>ws</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc.obj_fields_marked_inv_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mark_loop_mo_mark_loop_field_done_hp_phaseD</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark *)</span></span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_W_invD2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obj_at_field_on_heap_weakenE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ref *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>option</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m.handshake_phase_invD</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hp_step_rel_def</span><span> </span><span>conj_disj_distribR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"gc_tmp_ref s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>m</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_refs_invD</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.tso_write_refs_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>marked_insertionD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fM *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>p</span><span> </span><span>w</span><span> </span><span>ws</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>predicate2D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>predicate2I</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ref *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_un</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>gc_marking_reaches_mw_Mutate</span><span class="delimiter">;</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark loop mark field done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span>
</span><span>               </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* mark *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fM *)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc.handshake_invL_def</span><span> </span><span>loc</span><span> </span><span>atS_simps</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fM_rel_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_sweep_loop_free</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_m.reachable m r (s(sys := s sys⦇heap := (sys_heap s)(r' := None)⦈))
   ⟹ mut_m.reachable m r s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>predicate2D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>predicate2I</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_inv_sweep_loop_free</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ngr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_grey_refs s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rsi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m'. mut_m.reachable_snapshot_inv m' s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"white r' s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_refs_inv (s(sys := s sys⦇heap := (sys_heap s)(r' := None)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span> </span><span>no_grey_refs_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>reachable_sweep_loop_free</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mut_m.reachable_blackD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ngr</span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rsi</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ fM_fA_invL <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL <span class="hidden">❙</span><span class="bold">∧</span> phase_invL <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP (handshake_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> mutators_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv) ⦄
     gc
   ⦃ LSTP valid_refs_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sweep loop free *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>handshake_in_syncD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ LSTP (valid_refs_inv <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv) ⦄ sys ⦃ LSTP valid_refs_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>do_write_action_def</span><span> </span><span>p_not_sys</span><span>
</span><span>           </span><span>split</span><span class="delimiter">:</span><span> </span><span>mem_write_action.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv_discard_roots</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs_inv s; roots' ⊆ mut_roots s ⟧
     ⟹ valid_refs_inv (s(mutator m := s (mutator m)⦇roots := roots'⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv_load</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs_inv s; sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r ∈ mut_roots s ⟧
     ⟹ valid_refs_inv (s(mutator m := s (mutator m)⦇roots := mut_roots s ∪ Option.set_option r'⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv_alloc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs_inv s; sys_heap s r' = None ⟧
     ⟹ valid_refs_inv (s(mutator m := s (mutator m)⦇roots := insert r' (mut_roots s)⦈, sys := s sys⦇heap := sys_heap s(r' ↦ ⦇obj_mark = fl, obj_fields = Map.empty⦈)⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>converse_rtranclpE</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv_store_ins</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs_inv s; r ∈ mut_roots s; (∃r'. opt_r' = Some r') ⟶ the opt_r' ∈ mut_roots s ⟧
     ⟹ valid_refs_inv (s(mutator m := s (mutator m)⦇ ghost_honorary_root := {} ⦈,
                          sys := s sys⦇ mem_write_buffers := (mem_write_buffers (s sys))(mutator m := sys_mem_write_buffers (mutator m) s @ [mw_Mutate r f opt_r']) ⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_reachable_def</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"xa = m"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv_deref_del</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs_inv s; sys_read (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r ∈ mut_roots s; mut_ghost_honorary_root s = {} ⟧
     ⟹ valid_refs_inv (s(mutator m := s (mutator m)⦇ghost_honorary_root := Option.set_option opt_r', ref := opt_r'⦈))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>valid_refs_inv</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ mark_object_invL
       <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
       <span class="hidden">❙</span><span class="bold">∧</span> LSTP valid_refs_inv ⦄
     mutator m
   ⦃ LSTP valid_refs_inv ⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_jackhammer</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store ins mo co mark - FIXME some elim/dest rule really gets in the way here *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* store del mo co mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valid_refs_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_refs_invD</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get roots done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get roots loop mo co mark *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get work done *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>grey_reachable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Proofs">
<div class="head"><h1>Theory Proofs</h1>
<span class="command">theory</span> <span class="name">Proofs</span><br/>
<span class="keyword">imports</span> <a href="StrongTricolour.html"><span class="name">StrongTricolour</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Proofs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>StrongTricolour</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Top-level safety \label{sec:top-level-correctness}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>invsL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invsL ≡
    fM_fA_invL
  <span class="hidden">❙</span><span class="bold">∧</span> gc_mark.mark_object_invL
  <span class="hidden">❙</span><span class="bold">∧</span> gc_W_empty_invL
  <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL
  <span class="hidden">❙</span><span class="bold">∧</span> obj_fields_marked_invL
  <span class="hidden">❙</span><span class="bold">∧</span> phase_invL
  <span class="hidden">❙</span><span class="bold">∧</span> sweep_loop_invL
  <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
  <span class="hidden">❙</span><span class="bold">∧</span> LSTP (fA_rel_inv <span class="hidden">❙</span><span class="bold">∧</span> fM_rel_inv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>invsL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invsL ≡
    mark_object_invL
  <span class="hidden">❙</span><span class="bold">∧</span> mut_get_roots.mark_object_invL m
  <span class="hidden">❙</span><span class="bold">∧</span> mut_store_ins.mark_object_invL m
  <span class="hidden">❙</span><span class="bold">∧</span> mut_store_del.mark_object_invL m
  <span class="hidden">❙</span><span class="bold">∧</span> handshake_invL
  <span class="hidden">❙</span><span class="bold">∧</span> tso_lock_invL
  <span class="hidden">❙</span><span class="bold">∧</span> LSTP mutator_phase_inv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"invs ≡
    handshake_phase_inv
  <span class="hidden">❙</span><span class="bold">∧</span> phase_rel_inv
  <span class="hidden">❙</span><span class="bold">∧</span> strong_tricolour_inv
  <span class="hidden">❙</span><span class="bold">∧</span> sys_phase_inv
  <span class="hidden">❙</span><span class="bold">∧</span> tso_writes_inv
  <span class="hidden">❙</span><span class="bold">∧</span> valid_refs_inv
  <span class="hidden">❙</span><span class="bold">∧</span> valid_W_inv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I ≡
     gc.invsL
  <span class="hidden">❙</span><span class="bold">∧</span> (<span class="hidden">❙</span><span class="bold">∀</span>m. mut_m.invsL m)
  <span class="hidden">❙</span><span class="bold">∧</span> LSTP invs"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>I_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>gc.invsL_def</span><span> </span><span>mut_m.invsL_def</span><span> </span><span>invs_def</span><span> </span><span>I_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>gc</span><span class="delimiter">)</span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ I ⦄ gc"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_pre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span>rule</span><span> </span><span>valid_conj_lift</span><span> </span><span>valid_all_lift</span><span> </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>sys</span><span class="delimiter">)</span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ I ⦄ sys"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_pre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span>rule</span><span> </span><span>valid_conj_lift</span><span> </span><span>valid_all_lift</span><span> </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We need to separately treat the two cases of a single mutator and
multiple mutators. In the latter case we have the additional
obligation of showing mutual non-interference amongst mutators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mut_invsL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃I⦄ mutator m ⦃mut_m.invsL m'⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>mut_m</span><span> </span><span>m'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_pre</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span>rule</span><span> </span><span>valid_conj_lift</span><span> </span><span>valid_all_lift</span><span> </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>mut_m'</span><span> </span><span>m'</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_pre</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span>rule</span><span> </span><span>valid_conj_lift</span><span> </span><span>valid_all_lift</span><span> </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>mut_m</span><span class="delimiter">)</span><span> </span><span>I</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃ I ⦄ mutator m"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_def</span><span> </span><span>gc.invsL_def</span><span> </span><span>invs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_pre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span> </span><span>rule</span><span> </span><span>valid_conj_lift</span><span> </span><span>valid_all_lift</span><span> </span><span class="delimiter">|</span><span> </span><span>fastforce</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Initial conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We ask that the GC and system initially agree on some things:
\begin{itemize}

\item All objects on the heap are marked (have their flags equal to
  @{const "sys_fM"}, and there are no grey references, i.e. the heap
  is uniformly black.

\item The GC and system have the same values for @{term "fA"}, @{term
  "fM"}, etc. and the phase is @{term "Idle"}.

\item No process holds the TSO lock and all write buffers are empty.

\item All root-reachable references are backed by objects.

\end{itemize}
Note that these are merely sufficient initial conditions and can be
weakened.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gc_system</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>initial_mark</span><span> </span><span class="delimiter">::</span><span> </span><span>gc_mark</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gc_initial_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lst_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_initial_state s ≡
     fM s = initial_mark
   ∧ phase s = ph_Idle
   ∧ ghost_honorary_grey s = {}
   ∧ W s = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mut_initial_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lst_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_initial_state s ≡
     ghost_handshake_phase s = hp_IdleMarkSweep
   ∧ ghost_honorary_grey s = {}
   ∧ ghost_honorary_root s = {}
   ∧ W s = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sys_initial_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lst_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_initial_state s ≡
     (∀m. ¬handshake_pending s m ∧ ghost_handshake_in_sync s m)
   ∧ ghost_handshake_phase s = hp_IdleMarkSweep ∧ handshake_type s = ht_GetRoots
   ∧ obj_mark ` ran (heap s) ⊆ {initial_mark}
   ∧ fA s = initial_mark
   ∧ fM s = initial_mark
   ∧ phase s = ph_Idle
   ∧ ghost_honorary_grey s = {}
   ∧ W s = {}
   ∧ (∀p. mem_write_buffers s p = [])
   ∧ mem_lock s = None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_reachable y ≡ <span class="hidden">❙</span><span class="bold">∃</span>m x. ⟨x⟩ <span class="hidden">❙</span><span class="bold">∈</span> mut_m.mut_roots m <span class="hidden">❙</span><span class="bold">∧</span> x reaches y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_refs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_refs ≡ <span class="hidden">❙</span><span class="bold">∀</span>y. root_reachable y <span class="hidden">❙</span><span class="bold">⟶</span> valid_ref y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gc_system_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) lsts_pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_system_init ≡
       (λs. gc_initial_state (s gc))
     <span class="hidden">❙</span><span class="bold">∧</span> (λs. ∀m. mut_initial_state (s (mutator m)))
     <span class="hidden">❙</span><span class="bold">∧</span> (λs. sys_initial_state (s sys))
     <span class="hidden">❙</span><span class="bold">∧</span> valid_refs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The system consists of the programs and these constraints on the initial state.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gc_system</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('field, 'mut, 'ref) gc_system"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_system ≡ (gc_pgms, gc_system_init)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_strong_tricolour_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ obj_mark ` ran (sys_heap (mkP (s, []))↓) ⊆ {gc_fM (mkP (s, []))↓};
     sys_fM (mkP (s, []))↓ = gc_fM (mkP (s, []))↓ ⟧
     ⟹ strong_tricolour_inv (mkP (s, []))↓"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strong_tricolour_inv_def</span><span> </span><span>ran_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_no_grey_refs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ gc_W (mkP (s, []))↓ = {}; ∀m. W ((mkP (s, []))↓ (mutator m)) = {}; sys_W (mkP (s, []))↓ = {};
     gc_ghost_honorary_grey (mkP (s, []))↓ = {}; ∀m. ghost_honorary_grey ((mkP (s, []))↓ (mutator m)) = {}; sys_ghost_honorary_grey (mkP (s, []))↓ = {} ⟧
     ⟹ no_grey_refs (mkP (s, []))↓"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_imp_valid_refs_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs s; no_grey_refs s; ∀p. sys_mem_write_buffers p s = []; ∀m. ghost_honorary_root (s (mutator m)) = {} ⟧
     ⟹ valid_refs_inv s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_def</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_not_grey_reachableD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_grey_refs_imp_valid_W_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ no_grey_refs s; ∀p. sys_mem_write_buffers p s = [] ⟧
     ⟹ valid_W_inv s"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_W_inv_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_grey_refs_def</span><span> </span><span>grey_def</span><span> </span><span>WL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_inv_sys</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈initial_states gc_system. invs (mkP (s, []))↓"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>initial_statesD</span><span>
</span><span>              </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc_system_init_def</span><span> </span><span>invs_def</span><span> </span><span>gc_initial_state_def</span><span> </span><span>mut_initial_state_def</span><span> </span><span>sys_initial_state_def</span><span>
</span><span>                    </span><span>inv</span><span>
</span><span>                    </span><span>handshake_phase_rel_def</span><span> </span><span>handshake_phase_inv_def</span><span> </span><span>hp_step_rel_def</span><span> </span><span>phase_rel_inv_def</span><span> </span><span>phase_rel_def</span><span>
</span><span>                    </span><span>tso_writes_inv_def</span><span>
</span><span>                    </span><span>init_no_grey_refs</span><span> </span><span>init_strong_tricolour_inv</span><span> </span><span>no_grey_refs_imp_valid_W_inv</span><span>
</span><span>                    </span><span>valid_refs_imp_valid_refs_inv</span><span>
</span><span>                    </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_inv_gc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈initial_states gc_system. gc.invsL (mkP (s, []))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>initial_statesD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>gc</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hacky *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>com</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc_system_init_def</span><span> </span><span>gc_initial_state_def</span><span> </span><span>mut_initial_state_def</span><span> </span><span>sys_initial_state_def</span><span>
</span><span>                      </span><span>gc.invsL_def</span><span> </span><span>inv</span><span>
</span><span>                      </span><span>gc.fM_fA_invL_def</span><span> </span><span>fA_rel_inv_def</span><span> </span><span>fA_rel_def</span><span> </span><span>fM_rel_inv_def</span><span> </span><span>fM_rel_def</span><span> </span><span>gc.handshake_invL_def</span><span>
</span><span>                      </span><span>gc.obj_fields_marked_invL_def</span><span> </span><span>gc.phase_invL_def</span><span> </span><span>gc.sweep_loop_invL_def</span><span>
</span><span>                      </span><span>gc.tso_lock_invL_def</span><span> </span><span>gc.gc_W_empty_invL_def</span><span>
</span><span>                      </span><span>init_no_grey_refs</span><span>
</span><span>                      </span><span>loc</span><span> </span><span>atS_simps</span><span>
</span><span>                      </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>image_subset_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_refs_imp_reachable_snapshot_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ valid_refs s; obj_mark ` ran (sys_heap s) ⊆ {sys_fM s}; ∀p. sys_mem_write_buffers p s = []; ∀m. ghost_honorary_root (s (mutator m)) = {} ⟧
     ⟹ mut_m.reachable_snapshot_inv m s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_snapshot_inv_def</span><span> </span><span>in_snapshot_def</span><span> </span><span>valid_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span> </span><span>ran_def</span><span> </span><span>black_def</span><span> </span><span>mut_m.reachable_def</span><span> </span><span>mut_m.tso_write_refs_def</span><span>
</span><span>           </span><span>split</span><span class="delimiter">:</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_inv_mut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈initial_states gc_system. mut_m.invsL m (mkP (s, []))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>initial_statesD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"mutator m"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* hacky *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>com</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc_system_init_def</span><span> </span><span>mut_initial_state_def</span><span> </span><span>sys_initial_state_def</span><span>
</span><span>                      </span><span>valid_refs_imp_reachable_snapshot_inv</span><span>
</span><span>                      </span><span>mut_m.invsL_def</span><span> </span><span>inv</span><span>
</span><span>                      </span><span>mut_m.mark_object_invL_def</span><span>
</span><span>                      </span><span>mut_m.handshake_invL_def</span><span> </span><span>mut_m.tso_lock_invL_def</span><span>
</span><span>                      </span><span>mut_m.marked_deletions_def</span><span> </span><span>mut_m.marked_insertions_def</span><span>
</span><span>                      </span><span>loc</span><span> </span><span>atS_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s∈initial_states gc_system. I (mkP (s, []))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_def</span><span> </span><span>init_inv_sys</span><span> </span><span>init_inv_gc</span><span> </span><span>init_inv_mut</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ reachable_states gc_system ⟹ I (mkP s)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>VCG</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mut_m.I</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>valid_proc_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gc.I</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>valid_proc_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sys.I</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>valid_proc_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Our headline safety result follows directly.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>safety</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ∈ reachable_states gc_system ⟹ valid_refs (mkP s)↓"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_def</span><span> </span><span>invs_def</span><span> </span><span>valid_refs_inv_def</span><span> </span><span>valid_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xa</span><span> </span><span>xb</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mut_m.reachable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The GC is correct for the remaining fixed-but-arbitrary initial
conditions.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>gc_system_interpretation</span><span class="delimiter">:</span><span> </span><span>gc_system</span><span> </span><span>undefined</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A concrete system state›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We demonstrate that our definitions are not vacuous by exhibiting a
concrete initial state that satisfies the initial conditions. We use
Isabelle's notation for types of a given size.

›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Concrete_heap">
<div class="head"><h1>Theory Concrete_heap</h1>
<span class="command">theory</span> <span class="name">Concrete_heap</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Saturated.html"><span class="name">Saturated</span></a> <a href="Proofs.html"><span class="name">Proofs</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Concrete_heap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Saturated"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"../Proofs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>field</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"3"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>mut</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"2"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ref</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"5"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>concrete_local_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(field, mut, ref) local_state"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>clsts</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(field, mut, ref) lsts"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mut_common_init_state</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_common_init_state ≡ undefined⦇ ghost_handshake_phase := hp_IdleMarkSweep, ghost_honorary_grey := {}, ghost_honorary_root := {}, roots := {}, W := {} ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>gc_system</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>sys_init_heap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ref ⇒ (field, ref) object option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_init_heap ≡
  [   0 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = [ 0 ↦ 5 ] ⦈,
      1 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = Map.empty ⦈,
      2 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = Map.empty ⦈,
      3 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = [ 0 ↦ 1 , 1 ↦ 2 ] ⦈,
      4 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = [ 1 ↦ 0 ] ⦈,
      5 ↦ ⦇ obj_mark = initial_mark,
           obj_fields = Map.empty ⦈
  ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mut_init_state0</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_init_state0 ≡ mut_common_init_state ⦇ roots := {1, 2, 3} ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mut_init_state1</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_init_state1 ≡ mut_common_init_state ⦇ roots := {3} ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mut_init_state2</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mut_init_state2 ≡ mut_common_init_state ⦇ roots := {2, 5} ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Concrete">
<div class="head"><h1>Theory Concrete</h1>
<span class="command">theory</span> <span class="name">Concrete</span><br/>
<span class="keyword">imports</span> <a href="Concrete_heap.html"><span class="name">Concrete_heap</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Concrete</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Concrete_heap</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>gc_system</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>sys_init_state</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sys_init_state ≡
     undefined⦇ fA := initial_mark
              , fM := initial_mark
              , heap := sys_init_heap
              , handshake_pending := ⟨False⟩
              , handshake_type := ht_GetRoots
              , mem_lock := None
              , mem_write_buffers := ⟨[]⟩
              , phase := ph_Idle
              , W := {}
              , ghost_honorary_grey := {}
              , ghost_handshake_in_sync := ⟨True⟩
              , ghost_handshake_phase := hp_IdleMarkSweep ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gc_init_state</span><span> </span><span class="delimiter">::</span><span> </span><span>concrete_local_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_init_state ≡
     undefined⦇ fM := initial_mark
              , fA := initial_mark
              , phase := ph_Idle
              , W := {}
              , ghost_honorary_grey := {} ⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lookup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('k × 'v) list ⇒ 'v ⇒ 'k ⇒ 'v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lookup [] v0 k = v0"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup (kv # kvs) v0 k = (if fst kv = k then snd kv else lookup kvs v0 k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>muts_init_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mut × concrete_local_state) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"muts_init_states ≡ [ (0, mut_init_state0), (1, mut_init_state1), (2, mut_init_state2) ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>init_state</span><span> </span><span class="delimiter">::</span><span> </span><span>clsts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"init_state ≡ λp. case p of
              gc ⇒ gc_init_state
            | sys ⇒ sys_init_state
            | mutator m ⇒ lookup muts_init_states mut_common_init_state m"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gc_system_init init_state"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gc_system_init_def</span><span>
</span><span>                      </span><span>gc_initial_state_def</span><span>
</span><span>                      </span><span>mut_initial_state_def</span><span>
</span><span>                      </span><span>sys_initial_state_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_refs_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtranclp.cases</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>obj_at_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>