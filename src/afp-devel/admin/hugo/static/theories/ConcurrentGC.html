<div id="Model">
<div class="head">
<h1>Theory Model</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Model
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../ConcurrentIMP/CIMP.html">ConcurrentIMP.CIMP</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Sublist.html">HOL-Library.Sublist</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* From 40e16c534243 by Makarius. Doesn't seem to have a huge impact on run time now (2021-01-07) *)</span>
<span class="keyword1"><span class="command">declare</span></span> subst_all <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹A model of a Schism garbage collector \label{sec:gc-model}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The following formalises Figures~2.8 (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mark_object_fn›</span></span></span></span>),
2.9 (load and store but not alloc), and 2.15 (garbage collector) of
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span>; see also <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span>
[cite_macro=citet] "Pizlo+2010PLDI"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

We additionally need to model TSO memory, the handshakes and
compare-and-swap (\texttt{CAS}).  We closely model things where
interference is possible and abstract everything else.

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">bold</span></span> ‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹NOTE›<span class="antiquote"><span class="antiquote">}</span></span></span></span>: this model is for TSO
\emph{only}. We elide any details irrelevant for that memory
model.›<span class="antiquote"><span class="antiquote">}</span></span></span></span>

We begin by defining the types of the various parts. Our program
locations are labelled with strings for readability. We enumerate the
names of the processes in our system. The safety proof treats an
arbitary (unbounded) number of mutators.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> location <span class="main">=</span> <span class="quoted">string</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'mut</span> process_name <span class="main">=</span> mutator <span class="tfree"><span class="quoted"><span class="tfree">'mut</span></span></span> <span class="main">|</span> gc <span class="main">|</span> sys

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The garbage collection process can be in one of the following phases.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> gc_phase
  <span class="main">=</span> ph_Idle
  <span class="main">|</span> ph_Init
  <span class="main">|</span> ph_Mark
  <span class="main">|</span> ph_Sweep

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The garbage collector instructs mutators to perform certain actions,
and blocks until the mutators signal these actions are done. The
mutators always respond with their work list (a set of
references). The handshake can be of one of the specified types.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> hs_type
  <span class="main">=</span> ht_NOOP
  <span class="main">|</span> ht_GetRoots
  <span class="main">|</span> ht_GetWork

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We track how many \texttt{noop} and \texttt{get\_roots} handshakes
each process has participated in as ghost state. See
\S\ref{sec:gc_handshakes}.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> hs_phase
  <span class="main">=</span> hp_Idle <span class="comment1">― ‹done 1 noop›</span>
  <span class="main">|</span> hp_IdleInit
  <span class="main">|</span> hp_InitMark
  <span class="main">|</span> hp_Mark <span class="comment1">― ‹done 4 noops›</span>
  <span class="main">|</span> hp_IdleMarkSweep <span class="comment1">― ‹done get roots›</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">hs_step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_phase <span class="main">⇒</span> hs_phase"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hs_step</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="keyword1">of</span>
       hp_Idle          <span class="main">⇒</span> hp_IdleInit
     <span class="main">|</span> hp_IdleInit      <span class="main">⇒</span> hp_InitMark
     <span class="main">|</span> hp_InitMark      <span class="main">⇒</span> hp_Mark
     <span class="main">|</span> hp_Mark          <span class="main">⇒</span> hp_IdleMarkSweep
     <span class="main">|</span> hp_IdleMarkSweep <span class="main">⇒</span> hp_Idle<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

An object consists of a garbage collection mark and two partial
maps. Firstly the types:

<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'field</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the abstract type of fields.
<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'ref</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the abstract type of object references.
<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'mut</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the abstract type of the mutators' names.

The maps:

<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obj_fields›</span></span></span></span> maps <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'field</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s to object
  references (or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "None"<span class="antiquote"><span class="antiquote">}</span></span></span></span> signifying \texttt{NULL} or type
  error).
<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obj_payload›</span></span></span></span> maps a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'field</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to non-reference
  data. For convenience we similarly allow that to be \texttt{NULL}.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> gc_mark <span class="main">=</span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> object <span class="main">=</span>
  obj_mark <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_mark"</span></span>
  obj_fields <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'field</span> <span class="main">⇀</span> <span class="tfree">'ref</span>"</span></span>
  obj_payload <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'field</span> <span class="main">⇀</span> <span class="tfree">'payload</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The TSO store buffers track store actions, represented by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>('field, 'ref) mem_store_action›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action
  <span class="main">=</span> mw_Mark <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span> <span class="quoted">gc_mark</span>
  <span class="main">|</span> mw_Mutate <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'field</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> option"</span></span>
  <span class="main">|</span> mw_Mutate_Payload <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'field</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'payload</span> option"</span></span>
  <span class="main">|</span> mw_fA <span class="quoted">gc_mark</span>
  <span class="main">|</span> mw_fM <span class="quoted">gc_mark</span>
  <span class="main">|</span> mw_Phase <span class="quoted">gc_phase</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

An action is a request by a mutator or the garbage collector to the
system.

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_load_action
  <span class="main">=</span> mr_Ref <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'field</span></span></span>
  <span class="main">|</span> mr_Payload <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'field</span></span></span>
  <span class="main">|</span> mr_Mark <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span>
  <span class="main">|</span> mr_Phase
  <span class="main">|</span> mr_fM
  <span class="main">|</span> mr_fA

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request_op
  <span class="main">=</span> ro_MFENCE
  <span class="main">|</span> ro_Load <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_load_action"</span></span>
  <span class="main">|</span> ro_Store <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action"</span></span>
  <span class="main">|</span> ro_Lock
  <span class="main">|</span> ro_Unlock
  <span class="main">|</span> ro_Alloc
  <span class="main">|</span> ro_Free <span class="tfree"><span class="quoted"><span class="tfree">'ref</span></span></span>
  <span class="main">|</span> ro_hs_gc_load_pending <span class="tfree"><span class="quoted"><span class="tfree">'mut</span></span></span>
  <span class="main">|</span> ro_hs_gc_store_type <span class="quoted">hs_type</span>
  <span class="main">|</span> ro_hs_gc_store_pending <span class="tfree"><span class="quoted"><span class="tfree">'mut</span></span></span>
  <span class="main">|</span> ro_hs_gc_load_W
  <span class="main">|</span> ro_hs_mut_load_pending
  <span class="main">|</span> ro_hs_mut_load_type
  <span class="main">|</span> ro_hs_mut_done <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">LoadfM</span> <span class="main">≡</span> ro_Load mr_fM"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">LoadMark</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> ro_Load <span class="main">(</span>mr_Mark <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">LoadPayload</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> ro_Load <span class="main">(</span>mr_Payload <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">LoadPhase</span> <span class="main">≡</span> ro_Load mr_Phase"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">LoadRef</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> ro_Load <span class="main">(</span>mr_Ref <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StorefA</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_fA <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StorefM</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_fM <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StoreMark</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_Mark <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StorePayload</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">pl</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_Mutate_Payload <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">pl</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StorePhase</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_Phase <span class="free"><span class="bound"><span class="entity">ph</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">StoreRef</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r'</span></span></span> <span class="main">≡</span> ro_Store <span class="main">(</span>mw_Mutate <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">×</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request_op"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response
  <span class="main">=</span> mv_Bool <span class="quoted"><span class="quoted">"bool"</span></span>
  <span class="main">|</span> mv_Mark <span class="quoted"><span class="quoted">"gc_mark option"</span></span>
  <span class="main">|</span> mv_Payload <span class="quoted"><span class="quoted">"<span class="tfree">'payload</span> option"</span></span> <span class="comment1">―‹ the requested reference might be invalid ›</span>
  <span class="main">|</span> mv_Phase <span class="quoted"><span class="quoted">"gc_phase"</span></span>
  <span class="main">|</span> mv_Ref <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> option"</span></span>
  <span class="main">|</span> mv_Refs <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>
  <span class="main">|</span> mv_Void
  <span class="main">|</span> mv_hs_type <span class="quoted">hs_type</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following record is the type of all processes's local states. For
the mutators and the garbage collector, consider these to be local
variables or registers.

The system's <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fA›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fM›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>phase›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap›</span></span></span></span> variables are subject to the TSO memory model, as are all heap
operations.

›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">=</span>
  <span class="comment1">― ‹System-specific fields›</span>
  heap <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> object"</span></span>
  <span class="comment1">― ‹TSO memory state›</span>
  mem_store_buffers <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action list"</span></span>
  mem_lock <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name option"</span></span>
  <span class="comment1">― ‹Handshake state›</span>
  hs_pending <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> <span class="main">⇒</span> bool"</span></span>
  <span class="comment1">― ‹Ghost state›</span>
  ghost_hs_in_sync <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> <span class="main">⇒</span> bool"</span></span>
  ghost_hs_phase <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_phase"</span></span>

  <span class="comment1">― ‹Mutator-specific temporaries›</span>
  new_ref <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> option"</span></span>
  roots <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>
  ghost_honorary_root <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>
  payload_value <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'payload</span> option"</span></span>
  mutator_data <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'field</span> <span class="main">⇀</span> <span class="tfree">'payload</span>"</span></span>
  mutator_hs_pending <span class="main">::</span> <span class="quoted"><span class="quoted">"bool"</span></span>

  <span class="comment1">― ‹Garbage collector-specific temporaries›</span>
  field_set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'field</span> set"</span></span>
  mut <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span>"</span></span>
  muts <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> set"</span></span>

  <span class="comment1">― ‹Local variables used by multiple processes›</span>
  fA <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_mark"</span></span>
  fM <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_mark"</span></span>
  cas_mark <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_mark option"</span></span>
  field <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'field</span>"</span></span>
  mark <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_mark option"</span></span>
  phase <span class="main">::</span> <span class="quoted"><span class="quoted">"gc_phase"</span></span>
  tmp_ref <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span>"</span></span>
  ref <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> option"</span></span>
  refs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>
  W <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>
  <span class="comment1">― ‹Handshake state›</span>
  hs_type <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_type"</span></span>
  <span class="comment1">― ‹Ghost state›</span>
  ghost_honorary_grey <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> set"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We instantiate CIMP's types as follows:›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response<span class="main">,</span> location<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> com"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_loc_comp
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response<span class="main">,</span> location<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> loc_comp"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response<span class="main">,</span> location<span class="main">,</span> <span class="tfree">'mut</span> process_name<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> state_pred"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_system
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response<span class="main">,</span> location<span class="main">,</span> <span class="tfree">'mut</span> process_name<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request<span class="main">,</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> system"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_event
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> request <span class="main">×</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_history
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_event list"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lst_pred
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We use one locale per process to define a namespace for definitions
local to these processes. Mutator definitions are parametrised by the
mutator's identifier <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m›</span></span></span></span>. We never interpret these locales; we
typically use their contents by prefixing identifiers with the locale
name. This might be considered an abuse. The attributes depend on
locale scoping somewhat, which is a mixed blessing.

If we have more than one mutator then we need to show that mutators do
not mutually interfere. To that end we define an extra locale that
contains these proofs.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> mut_m <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span>"</span></span>
<span class="keyword1"><span class="command">locale</span></span> mut_m' <span class="main">=</span> mut_m <span class="main">+</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span>"</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> mm'<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">locale</span></span> gc
<span class="keyword1"><span class="command">locale</span></span> sys


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Object marking \label{sec:gc-marking}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Both the mutators and the garbage collector mark references, which
indicates that a reference is live in the current round of
collection. This operation is defined in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
‹Figure~2.8› "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. These definitions are
parameterised by the name of the process.

›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lock_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lock_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> ro_Lock<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> lock_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">lock</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">unlock_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unlock_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> ro_Unlock<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> unlock_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">unlock</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">load_mark_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span>
              <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>gc_mark option <span class="main">⇒</span> gc_mark option<span class="main">)</span>
                 <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state
                 <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">load_mark_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> LoadMark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="bound">s</span> <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Mark <span class="bound">m</span> <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> load_mark_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">load'_mark</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">load_fM_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">load_fM_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> ro_Load mr_fM<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span>fM <span class="main">:=</span> <span class="bound">m</span><span class="main">⦈</span> <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Mark <span class="main">(</span>Some <span class="bound">m</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> load_fM_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">load'_fM</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">load_phase</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">load_phase</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> LoadPhase<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span>phase <span class="main">:=</span> <span class="bound">ph</span><span class="main">⦈</span> <span class="main">|</span><span class="bound">ph</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Phase <span class="bound">ph</span> <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> load_phase <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">load'_phase</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">store_mark_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">store_mark_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">fl</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> StoreMark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">fl</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">}</span> <span class="main">⦈</span> <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> store_mark_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">store'_mark</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">add_to_W_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_to_W_syn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="main">⌊</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⦇</span> W <span class="main">:=</span> W <span class="bound">s</span> <span class="main">∪</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">}</span><span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">⌋</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> add_to_W_syn <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">add'_to'_W</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The reference we're marking is given in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ref"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. If the current
process wins the \texttt{CAS} race then the reference is marked and
added to the local work list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "W"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

TSO means we cannot avoid having the mark store pending in a store
buffer; in other words, we cannot have objects atomically transition
from white to grey. The following scheme blackens a white object, and
then reverts it to grey. The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ghost_honorary_grey"<span class="antiquote"><span class="antiquote">}</span></span></span></span> variable
is used to track objects undergoing this transition.

As CIMP provides no support for function calls, we prefix each
statement's label with a string from its callsite.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mark_object_fn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mark_object_fn</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_null''</span><span class="main">⦄</span> <span class="keyword1">IF</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span> <span class="main">(</span><span class="keyword1">NULL</span> ref<span class="main">)</span> <span class="keyword1">THEN</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_mark''</span><span class="main">⦄</span> <span class="keyword1">load_mark</span> <span class="main">(</span>the <span class="main">∘</span> ref<span class="main">)</span> mark_update <span class="main">;;</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_fM''</span><span class="main">⦄</span> <span class="keyword1">load_fM</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_mtest''</span><span class="main">⦄</span> <span class="keyword1">IF</span> mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> fM <span class="keyword1">THEN</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_phase''</span><span class="main">⦄</span> <span class="keyword1">load_phase</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_ptest''</span><span class="main">⦄</span> <span class="keyword1">IF</span> phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span> <span class="keyword1">THEN</span>
           <span class="comment1">― ‹CAS: claim object›</span>
           <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_lock''</span><span class="main">⦄</span> <span class="keyword1">lock</span> <span class="main">;;</span>
           <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_cmark''</span><span class="main">⦄</span> <span class="keyword1">load_mark</span> <span class="main">(</span>the <span class="main">∘</span> ref<span class="main">)</span> cas_mark_update <span class="main">;;</span>
           <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_ctest''</span><span class="main">⦄</span> <span class="keyword1">IF</span> cas_mark <span class="main"><span class="hidden">❙</span><b>=</b></span> mark <span class="keyword1">THEN</span>
             <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_mark''</span><span class="main">⦄</span> <span class="keyword1">store_mark</span> <span class="main">(</span>the <span class="main">∘</span> ref<span class="main">)</span> fM
           <span class="keyword1">FI</span> <span class="main">;;</span>
           <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_unlock''</span><span class="main">⦄</span> <span class="keyword1">unlock</span> <span class="main">;;</span>
           <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_won''</span><span class="main">⦄</span> <span class="keyword1">IF</span> cas_mark <span class="main"><span class="hidden">❙</span><b>=</b></span> mark <span class="keyword1">THEN</span>
             <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mo_co_W''</span><span class="main">⦄</span> <span class="keyword1">add_to_W</span> <span class="main">(</span>the <span class="main">∘</span> ref<span class="main">)</span>
           <span class="keyword1">FI</span>
         <span class="keyword1">FI</span>
       <span class="keyword1">FI</span>
     <span class="keyword1">FI</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The worklists (field <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"W"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) are not subject to TSO. As we later
show (\S\ref{def:valid_W_inv}), these are disjoint and hence
operations on these are private to each process, with the sole
exception of when the GC requests them from the mutators. We describe
that mechanism next.

›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Handshakes \label{sec:gc_handshakes}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The garbage collector needs to synchronise with the mutators.
Here we do so by having the GC busy-wait: it sets a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pending›</span></span></span></span> flag for each mutator
and then waits for each to respond.

The system side of the interface collects the responses from the
mutators into a single worklist, which acts as a proxy for the garbage
collector's local worklist during <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_roots›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_work›</span></span></span></span> handshakes.
We carefully model the effect these handshakes have on the processes' TSO buffers.

The system and mutators track handshake phases using ghost state; see
\S\ref{sec:phase-invariants}.

The handshake type and handshake pending bit are not subject to TSO as we expect
a realistic implementation of handshakes would involve synchronisation.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hp_step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_type <span class="main">⇒</span> hs_phase <span class="main">⇒</span> hs_phase"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hp_step</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span>
     <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="keyword1">of</span>
         ht_NOOP <span class="main">⇒</span> hs_step
       <span class="main">|</span> ht_GetRoots <span class="main">⇒</span> hs_step
       <span class="main">|</span> ht_GetWork <span class="main">⇒</span> id"</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">handshake</span> <span class="main">=</span>
     <span class="main">⦃</span><span class="inner_quoted">''sys_hs_gc_set_type''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> hs_type <span class="main">:=</span> <span class="bound">ht</span><span class="main">,</span>
                       ghost_hs_in_sync <span class="main">:=</span> <span class="main">⟨</span>False<span class="main">⟩</span><span class="main">,</span>
                       ghost_hs_phase <span class="main">:=</span> hp_step <span class="bound">ht</span> <span class="main">(</span>ghost_hs_phase <span class="bound">s</span><span class="main">)</span> <span class="main">⦈</span><span class="main">,</span>
                    mv_Void<span class="main">)</span>
                 <span class="main">|</span><span class="bound">ht</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_store_type <span class="bound">ht</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_gc_mut_reqs''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="main">(</span>hs_pending <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">m</span> <span class="main">:=</span> True<span class="main">)</span> <span class="main">⦈</span><span class="main">,</span> mv_Void<span class="main">)</span>
                 <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_store_pending <span class="bound">m</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_gc_done''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> mv_Bool <span class="main">(</span><span class="main">¬</span>hs_pending <span class="bound">s</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_load_pending <span class="bound">m</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_gc_load_W''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">,</span> mv_Refs <span class="main">(</span>W <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_load_W<span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_mut_pending''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> mv_Bool <span class="main">(</span>hs_pending <span class="bound">s</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">,</span> ro_hs_mut_load_pending<span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_mut''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> mv_hs_type <span class="main">(</span>hs_type <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">,</span> ro_hs_mut_load_type<span class="main">)</span> <span class="main">}</span><span class="main">)</span>
   <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''sys_hs_mut_done''</span><span class="main">⦄</span> <span class="keyword1">Response</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="main">(</span>hs_pending <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">m</span> <span class="main">:=</span> False<span class="main">)</span><span class="main">,</span>
                       W <span class="main">:=</span> W <span class="bound">s</span> <span class="main">∪</span> <span class="bound">W'</span><span class="main">,</span>
                       ghost_hs_in_sync <span class="main">:=</span> <span class="main">(</span>ghost_hs_in_sync <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">m</span> <span class="main">:=</span> True<span class="main">)</span> <span class="main">⦈</span><span class="main">,</span>
                    mv_Void<span class="main">)</span>
                 <span class="main">|</span><span class="bound">m</span> <span class="bound">W'</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">,</span> ro_hs_mut_done <span class="bound">W'</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The mutators' side of the interface. Also updates the ghost state
tracking the handshake state for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ht_NOOP"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"ht_GetRoots"<span class="antiquote"><span class="antiquote">}</span></span></span></span> but not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ht_GetWork"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Again we could make these subject to TSO, but that would be over specification.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mark_object_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">mark'_object</span>"</span> <span class="main">[</span>0<span class="main">]</span> 71<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">mark_object</span></span> <span class="main">≡</span> mark_object_fn <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mfence_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">MFENCE</span>"</span> <span class="main">[</span>0<span class="main">]</span> 71<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">MFENCE</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_MFENCE<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hs_load_pending_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">hs'_load'_pending'_</span>"</span> <span class="main">[</span>0<span class="main">]</span> 71<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">hs_load_pending_</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_hs_mut_load_pending<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> mutator_hs_pending <span class="main">:=</span> <span class="bound">b</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">b</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Bool <span class="bound">b</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hs_load_type_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">hs'_load'_type</span>"</span> <span class="main">[</span>0<span class="main">]</span> 71<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">hs_load_type</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_hs_mut_load_type<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> hs_type <span class="main">:=</span> <span class="bound">ht</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">ht</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_hs_type <span class="bound">ht</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hs_noop_done_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">hs'_noop'_done'_</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">hs_noop_done_</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_hs_mut_done <span class="main">{}</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span> ghost_hs_phase <span class="main">:=</span> hs_step <span class="main">(</span>ghost_hs_phase <span class="bound">s</span><span class="main">)</span> <span class="main">⦈</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hs_get_roots_done_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">hs'_get'_roots'_done'_</span>"</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">hs_get_roots_done_</span></span> <span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_hs_mut_done <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                           <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> hs_step <span class="main">(</span>ghost_hs_phase <span class="bound">s</span><span class="main">)</span> <span class="main">⦈</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hs_get_work_done_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">hs'_get'_work'_done</span>"</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">hs_get_work_done</span></span> <span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_hs_mut_done <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                         <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">handshake</span> <span class="main">=</span>
      <span class="main">⦃</span><span class="inner_quoted">''hs_load_pending''</span><span class="main">⦄</span> <span class="keyword1">hs_load_pending_</span> <span class="main">;;</span>
      <span class="main">⦃</span><span class="inner_quoted">''hs_pending''</span><span class="main">⦄</span> <span class="keyword1">IF</span> mutator_hs_pending
      <span class="keyword1">THEN</span>
        <span class="main">⦃</span><span class="inner_quoted">''hs_mfence''</span><span class="main">⦄</span> <span class="keyword1">MFENCE</span> <span class="main">;;</span>
        <span class="main">⦃</span><span class="inner_quoted">''hs_load_ht''</span><span class="main">⦄</span> <span class="keyword1">hs_load_type</span> <span class="main">;;</span>
        <span class="main">⦃</span><span class="inner_quoted">''hs_noop''</span><span class="main">⦄</span> <span class="keyword1">IF</span> hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_NOOP<span class="main">⟩</span>
        <span class="keyword1">THEN</span>
          <span class="main">⦃</span><span class="inner_quoted">''hs_noop_done''</span><span class="main">⦄</span> <span class="keyword1">hs_noop_done_</span>
        <span class="keyword1">ELSE</span> <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots''</span><span class="main">⦄</span> <span class="keyword1">IF</span> hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetRoots<span class="main">⟩</span>
        <span class="keyword1">THEN</span>
          <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_refs''</span><span class="main">⦄</span> <span class="main">´</span>refs <span class="main">:=</span> <span class="main">´</span>roots <span class="main">;;</span>
          <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> refs <span class="keyword1">DO</span>
            <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_loop_choose_ref''</span><span class="main">⦄</span> <span class="main">´</span>ref <span class="main">:∈</span> Some <span class="main">`</span> <span class="main">´</span>refs <span class="main">;;</span>
            <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_loop''</span><span class="main">⦄</span> <span class="keyword1">mark_object</span> <span class="main">;;</span>
            <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_loop_done''</span><span class="main">⦄</span> <span class="main">´</span>refs <span class="main">:=</span> <span class="main">(</span><span class="main">´</span>refs <span class="main">-</span> <span class="main">{</span>the <span class="main">´</span>ref<span class="main">}</span><span class="main">)</span>
          <span class="keyword1">OD</span> <span class="main">;;</span>
          <span class="main">⦃</span><span class="inner_quoted">''hs_get_roots_done''</span><span class="main">⦄</span> <span class="keyword1">hs_get_roots_done_</span> W
        <span class="keyword1">ELSE</span> <span class="main">⦃</span><span class="inner_quoted">''hs_get_work''</span><span class="main">⦄</span> <span class="keyword1">IF</span> hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetWork<span class="main">⟩</span>
        <span class="keyword1">THEN</span>
          <span class="main">⦃</span><span class="inner_quoted">''hs_get_work_done''</span><span class="main">⦄</span> <span class="keyword1">hs_get_work_done</span> W
        <span class="keyword1">FI</span> <span class="keyword1">FI</span> <span class="keyword1">FI</span>
      <span class="keyword1">FI</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The garbage collector's side of the interface.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">set_hs_type</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> hs_type <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">set'_hs'_type</span>"</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">set_hs_type</span></span> <span class="free"><span class="bound"><span class="entity">ht</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_store_type <span class="free"><span class="bound"><span class="entity">ht</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">set_hs_pending</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'mut</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">set'_hs'_pending</span>"</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">set_hs_pending</span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_store_pending <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">load_W</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">load'_W</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">load_W</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_load_W''</span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_load_W<span class="main">)</span><span class="main">)</span>
                                          <span class="main">(</span><span class="main">λ</span><span class="bound">resp</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="bound">W'</span><span class="main">⦈</span> <span class="main">|</span><span class="bound">W'</span><span class="main">.</span> <span class="bound">resp</span> <span class="main">=</span> mv_Refs <span class="bound">W'</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mfence</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">MFENCE</span>"</span><span class="main">)</span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">MFENCE</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_MFENCE<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> hs_type <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">handshake'_init</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">handshake_init</span></span> <span class="free"><span class="bound"><span class="entity">req</span></span></span> <span class="main">=</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_type''</span><span class="main">⦄</span> <span class="keyword1">set_hs_type</span> <span class="free"><span class="bound"><span class="entity">req</span></span></span> <span class="main">;;</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_muts''</span><span class="main">⦄</span> <span class="main">´</span>muts <span class="main">:=</span> UNIV <span class="main">;;</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span> <span class="main">(</span><span class="keyword1">EMPTY</span> muts<span class="main">)</span> <span class="keyword1">DO</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_choose_mut''</span><span class="main">⦄</span> <span class="main">´</span>mut <span class="main">:∈</span> <span class="main">´</span>muts <span class="main">;;</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_set_pending''</span><span class="main">⦄</span> <span class="keyword1">set_hs_pending</span> mut <span class="main">;;</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_done''</span><span class="main">⦄</span> <span class="main">´</span>muts <span class="main">:=</span> <span class="main">(</span><span class="main">´</span>muts <span class="main">-</span> <span class="main">{</span><span class="main">´</span>mut<span class="main">}</span><span class="main">)</span>
     <span class="keyword1">OD</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake_done</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">handshake'_done</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">handshake_done</span></span> <span class="main">=</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_done_muts''</span><span class="main">⦄</span> <span class="main">´</span>muts <span class="main">:=</span> UNIV <span class="main">;;</span>
     <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_done_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> muts <span class="keyword1">DO</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_done_loop_choose_mut''</span><span class="main">⦄</span> <span class="main">´</span>mut <span class="main">:∈</span> <span class="main">´</span>muts <span class="main">;;</span>
       <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_done_loop_rendezvous''</span><span class="main">⦄</span> <span class="keyword1">Request</span>
               <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_hs_gc_load_pending <span class="main">(</span>mut <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> muts <span class="main">:=</span> muts <span class="bound">s</span> <span class="main">-</span> <span class="main">{</span> mut <span class="bound">s</span> <span class="main">|</span><span class="bound">done</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Bool <span class="bound">done</span> <span class="main">∧</span> <span class="bound">done</span> <span class="main">}</span> <span class="main">⦈</span><span class="main">}</span><span class="main">)</span>
     <span class="keyword1">OD</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake_noop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">handshake'_noop</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">handshake_noop</span></span> <span class="main">=</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">@</span> <span class="inner_quoted">''_mfence''</span><span class="main">⦄</span> <span class="keyword1">MFENCE</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_init</span> ht_NOOP <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_done</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake_get_roots</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">handshake'_get'_roots</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">handshake_get_roots</span></span> <span class="main">=</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_init</span> ht_GetRoots <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_done</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">load_W</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">handshake_get_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">handshake'_get'_work</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">handshake_get_work</span></span> <span class="main">=</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_init</span> ht_GetWork <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">handshake_done</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">load_W</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The system process›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The system process models the environment in which the garbage
collector and mutators execute.  We translate the x86-TSO memory model
due to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "DBLP:journals/cacm/SewellSONM10"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
into a CIMP process. It is a reactive system: it receives requests and
returns values, but initiates no communication itself. It can,
however, autonomously commit a store pending in a TSO store buffer.

The memory bus can be locked by atomic compare-and-swap (\texttt{CAS})
instructions (and others in general). A processor is not blocked
(i.e., it can read from memory) when it holds the lock, or no-one
does.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">not_blocked</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'mut</span> process_name <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">not_blocked</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> mem_lock <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">p'</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="bound">p'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We compute the view a processor has of memory by applying all its
pending stores.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">do_store_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_store_action</span> <span class="free"><span class="bound"><span class="entity">wact</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">wact</span></span></span> <span class="keyword1">of</span>
       mw_Mark <span class="bound">r</span> <span class="bound">gc_mark</span>    <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_mark <span class="main">:=</span> <span class="bound">gc_mark</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>
     <span class="main">|</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">new_r</span>  <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="bound">f</span> <span class="main">:=</span> <span class="bound">new_r</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>
     <span class="main">|</span> mw_Mutate_Payload <span class="bound">r</span> <span class="bound">f</span> <span class="bound">pl</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_payload <span class="main">:=</span> <span class="main">(</span>obj_payload <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="bound">f</span> <span class="main">:=</span> <span class="bound">pl</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>
     <span class="main">|</span> mw_fM <span class="bound">gc_mark</span>        <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>fM <span class="main">:=</span> <span class="bound">gc_mark</span><span class="main">⦈</span>
     <span class="main">|</span> mw_fA <span class="bound">gc_mark</span>        <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>fA <span class="main">:=</span> <span class="bound">gc_mark</span><span class="main">⦈</span>
     <span class="main">|</span> mw_Phase <span class="bound">gc_phase</span>    <span class="main">⇒</span> <span class="bound">s</span><span class="main">⦇</span>phase <span class="main">:=</span> <span class="bound">gc_phase</span><span class="main">⦈</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fold_stores</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fold_stores</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">w</span><span class="main">.</span> <span class="main">(∘)</span> <span class="main">(</span>do_store_action <span class="bound">w</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span> id"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">processors_view_of_memory</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">processors_view_of_memory</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fold_stores <span class="main">(</span>mem_store_buffers <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">do_load_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_load_action
                   <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state
                   <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">do_load_action</span> <span class="free"><span class="bound"><span class="entity">ract</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ract</span></span></span> <span class="keyword1">of</span>
       mr_Ref <span class="bound">r</span> <span class="bound">f</span> <span class="main">⇒</span> mv_Ref <span class="main">(</span>Option.bind <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_fields <span class="bound">obj</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> mr_Payload <span class="bound">r</span> <span class="bound">f</span> <span class="main">⇒</span> mv_Payload <span class="main">(</span>Option.bind <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_payload <span class="bound">obj</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> mr_Mark <span class="bound">r</span>  <span class="main">⇒</span> mv_Mark <span class="main">(</span>map_option obj_mark <span class="main">(</span>heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> mr_Phase   <span class="main">⇒</span> mv_Phase <span class="main">(</span>phase <span class="bound">s</span><span class="main">)</span>
     <span class="main">|</span> mr_fM      <span class="main">⇒</span> mv_Mark <span class="main">(</span>Some <span class="main">(</span>fM <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> mr_fA      <span class="main">⇒</span> mv_Mark <span class="main">(</span>Some <span class="main">(</span>fA <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">sys_load</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name
              <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_load_action
              <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state
              <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> response"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_load</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">ract</span></span></span> <span class="main">=</span> do_load_action <span class="free"><span class="bound"><span class="entity">ract</span></span></span> <span class="main">∘</span> processors_view_of_memory <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The semantics of TSO memory following <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
‹\S3› "DBLP:journals/cacm/SewellSONM10"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This differs
from the earlier <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
"DBLP:conf/tphol/OwensSS09"<span class="antiquote"><span class="antiquote">}</span></span></span></span> by allowing the TSO lock to be taken by a
process with a non-empty store buffer. We omit their treatment of
registers; these are handled by the local states of the other
processes. The system can autonomously take the oldest store in the
store buffer for processor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> and commit it to memory,
provided <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> either holds the lock or no processor does.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mem_TSO</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mem_TSO</span> <span class="main">=</span>
        <span class="main">⦃</span><span class="inner_quoted">''tso_load''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> sys_load <span class="bound">p</span> <span class="bound">mr</span> <span class="bound">s</span><span class="main">)</span>
                                         <span class="main">|</span><span class="bound">p</span> <span class="bound">mr</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> ro_Load <span class="bound">mr</span><span class="main">)</span> <span class="main">∧</span> not_blocked <span class="bound">s</span> <span class="bound">p</span> <span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''tso_store''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">p</span> <span class="main">:=</span> mem_store_buffers <span class="bound">s</span> <span class="bound">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">w</span><span class="main">]</span><span class="main">)</span> <span class="main">⦈</span><span class="main">,</span> mv_Void<span class="main">)</span>
                                          <span class="main">|</span><span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> ro_Store <span class="bound">w</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''tso_mfence''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> mv_Void<span class="main">)</span>
                                           <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> ro_MFENCE<span class="main">)</span> <span class="main">∧</span> mem_store_buffers <span class="bound">s</span> <span class="bound">p</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''tso_lock''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> mem_lock <span class="main">:=</span> Some <span class="bound">p</span> <span class="main">⦈</span><span class="main">,</span> mv_Void<span class="main">)</span>
                                         <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> ro_Lock<span class="main">)</span> <span class="main">∧</span> mem_lock <span class="bound">s</span> <span class="main">=</span> None <span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''tso_unlock''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span> mem_lock <span class="main">:=</span> None <span class="main">⦈</span><span class="main">,</span> mv_Void<span class="main">)</span>
                                         <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="bound">req</span> <span class="main">=</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> ro_Unlock<span class="main">)</span> <span class="main">∧</span> mem_lock <span class="bound">s</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">∧</span> mem_store_buffers <span class="bound">s</span> <span class="bound">p</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''tso_dequeue_store_buffer''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span>do_store_action <span class="bound">w</span> <span class="bound">s</span><span class="main">)</span><span class="main">⦇</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">p</span> <span class="main">:=</span> <span class="bound">ws</span><span class="main">)</span> <span class="main">⦈</span>
                                                    <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span> <span class="bound">ws</span><span class="main">.</span> mem_store_buffers <span class="bound">s</span> <span class="bound">p</span> <span class="main">=</span> <span class="bound">w</span> <span class="main">#</span> <span class="bound">ws</span> <span class="main">∧</span> not_blocked <span class="bound">s</span> <span class="bound">p</span> <span class="main">∧</span> <span class="bound">p</span> <span class="main">≠</span> sys <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We track which references are allocated using the domain of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"heap"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

\label{sec:sys_alloc}

For now we assume that the system process magically allocates and
deallocates references.

We also arrange for the object to be marked atomically (see
\S\ref{sec:mut_alloc}) which morally should be done by the mutator. In
practice allocation pools enable this kind of atomicity (wrt the sweep
loop in the GC described in \S\ref{sec:gc-model-gc}).

Note that the \texttt{abort} in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
‹Figure~2.9: Alloc› "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span> means the atomic
fails and the mutator can revert to activity outside of
\texttt{Alloc}, avoiding deadlock. We instead signal the exhaustion of
the heap explicitly, i.e., the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ro_Alloc"<span class="antiquote"><span class="antiquote">}</span></span></span></span> action cannot fail.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">alloc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">alloc</span> <span class="main">=</span> <span class="main">⦃</span><span class="inner_quoted">''alloc''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span>
      <span class="keyword1">if</span> dom <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> UNIV
      <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> mv_Ref None<span class="main">)</span> <span class="main">|</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> snd <span class="bound">req</span> <span class="main">=</span> ro_Alloc <span class="main">}</span>
      <span class="keyword1">else</span> <span class="main">{</span> <span class="main">(</span> <span class="bound">s</span><span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span> <span class="main">:=</span> Some <span class="main">⦇</span> obj_mark <span class="main">=</span> fA <span class="bound">s</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">)</span> <span class="main">⦈</span><span class="main">,</span> mv_Ref <span class="main">(</span>Some <span class="bound">r</span><span class="main">)</span> <span class="main">)</span>
           <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∉</span> dom <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> snd <span class="bound">req</span> <span class="main">=</span> ro_Alloc <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

References are freed by removing them from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "heap"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">free</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">free</span> <span class="main">=</span> <span class="main">⦃</span><span class="inner_quoted">''sys_free''</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="main">(</span><span class="main">λ</span><span class="bound">req</span> <span class="bound">s</span><span class="main">.</span>
      <span class="main">{</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">r</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">,</span> mv_Void<span class="main">)</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> snd <span class="bound">req</span> <span class="main">=</span> ro_Free <span class="bound">r</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The top-level system process.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">com</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">com</span> <span class="main">=</span>
    <span class="keyword1">LOOP</span> <span class="keyword1">DO</span>
        mem_TSO
      <span class="main">⊕</span> alloc
      <span class="main">⊕</span> free
      <span class="main">⊕</span> handshake
    <span class="keyword1">OD</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Mutators›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The mutators need to cooperate with the garbage collector. In
particular, when the garbage collector is not idle the mutators use a
\emph{write barrier} (see \S\ref{sec:gc-marking}).

The local state for each mutator tracks a working set of references,
which abstracts from how the process's registers and stack are
traversed to discover roots.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:mut_alloc}

Allocation is defined in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
‹Figure~2.9› "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. See \S\ref{sec:sys_alloc}
for how we abstract it.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">alloc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">alloc</span> <span class="main">≡</span>
    <span class="main">⦃</span><span class="inner_quoted">''alloc''</span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> ro_Alloc<span class="main">)</span><span class="main">)</span>
                        <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> roots <span class="main">:=</span> roots <span class="bound">s</span> <span class="main">∪</span> set_option <span class="bound">opt_r</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">opt_r</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Ref <span class="bound">opt_r</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The mutator can always discard any references it holds.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">discard</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">discard</span> <span class="main">≡</span>
    <span class="main">⦃</span><span class="inner_quoted">''discard_refs''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> roots <span class="main">:=</span> <span class="bound">roots'</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">roots'</span><span class="main">.</span> <span class="bound">roots'</span> <span class="main">⊆</span> roots <span class="bound">s</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Load and store are defined in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
‹Figure~2.9› "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Dereferencing a reference can increase the set of mutator roots.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">load</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">load</span> <span class="main">≡</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_load_choose''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> tmp_ref <span class="main">:=</span> <span class="bound">r</span><span class="main">,</span> field <span class="main">:=</span> <span class="bound">f</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">r</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> roots <span class="bound">s</span> <span class="main">}</span><span class="main">)</span> <span class="main">;;</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_load''</span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> LoadRef <span class="main">(</span>tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>field <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                           <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> roots <span class="main">:=</span> roots <span class="bound">s</span> <span class="main">∪</span> set_option <span class="bound">r</span> <span class="main">⦈</span>
                                   <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Ref <span class="bound">r</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:write-barriers}

Storing a reference involves marking both the old and new references,
i.e., both \emph{insertion} and \emph{deletion} barriers are
installed. The deletion barrier preserves the \emph{weak tricolour
invariant}, and the insertion barrier preserves the \emph{strong
tricolour invariant}; see \S\ref{sec:strong-tricolour-invariant} for
further discussion.

Note that the the mutator reads the overwritten reference but does not
store it in its roots.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">mut_deref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location
          <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span>
          <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'field</span><span class="main">)</span>
          <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'ref</span> option <span class="main">⇒</span> <span class="tfree">'ref</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">deref</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">deref</span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> LoadRef <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">⟨</span><span class="bound">opt_r'</span><span class="main">⟩</span> <span class="main">(</span><span class="bound">s</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> set_option <span class="bound">opt_r'</span><span class="main">⦈</span><span class="main">)</span> <span class="main">|</span><span class="bound">opt_r'</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Ref <span class="bound">opt_r'</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="comment1">(*
Does not work in local theory mode:

syntax
  "_mut_fassign" :: "location ⇒ idt ⇒ 'ref ⇒ 'field ⇒ ('field, 'mut, 'payload, 'ref) gc_com" ("⦃_⦄ ´_ := ´_ → _" [0, 0, 70] 71)
translations
  "⦃l⦄ ´q := ´r→f"    =&gt; "CONST mut_deref l r «f» (_update_name q)"

 ´ref := ´tmp_ref→´field ;;
*)</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">store_ref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location
              <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span>
              <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'field</span><span class="main">)</span>
              <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span> option<span class="main">)</span>
              <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">store'_ref</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">store_ref</span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r'</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> StoreRef <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r'</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">store</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">store</span> <span class="main">=</span>
     <span class="comment1">― ‹Choose vars for <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ref→field := new_ref›</span></span>›</span>
     <span class="main">⦃</span><span class="inner_quoted">''store_choose''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> tmp_ref <span class="main">:=</span> <span class="bound">r</span><span class="main">,</span> field <span class="main">:=</span> <span class="bound">f</span><span class="main">,</span> new_ref <span class="main">:=</span> <span class="bound">r'</span> <span class="main">⦈</span>
                                     <span class="main">|</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> roots <span class="bound">s</span> <span class="main">∧</span> <span class="bound">r'</span> <span class="main">∈</span> Some <span class="main">`</span> roots <span class="bound">s</span> <span class="main">∪</span> <span class="main">{</span>None<span class="main">}</span> <span class="main">}</span><span class="main">)</span> <span class="main">;;</span>
     <span class="comment1">― ‹Mark the reference we're about to overwrite. Does not update roots.›</span>
     <span class="main">⦃</span><span class="inner_quoted">''deref_del''</span><span class="main">⦄</span> <span class="keyword1">deref</span> tmp_ref field ref_update <span class="main">;;</span>
     <span class="main">⦃</span><span class="inner_quoted">''store_del''</span><span class="main">⦄</span> <span class="keyword1">mark_object</span> <span class="main">;;</span>
     <span class="comment1">― ‹Mark the reference we're about to insert.›</span>
     <span class="main">⦃</span><span class="inner_quoted">''lop_store_ins''</span><span class="main">⦄</span> <span class="main">´</span>ref <span class="main">:=</span> <span class="main">´</span>new_ref <span class="main">;;</span>
     <span class="main">⦃</span><span class="inner_quoted">''store_ins''</span><span class="main">⦄</span> <span class="keyword1">mark_object</span> <span class="main">;;</span>
     <span class="main">⦃</span><span class="inner_quoted">''store_ins''</span><span class="main">⦄</span> <span class="keyword1">store_ref</span> tmp_ref field new_ref"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Load and store payload data.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">load_payload</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">load_payload</span> <span class="main">≡</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_load_payload_choose''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> tmp_ref <span class="main">:=</span> <span class="bound">r</span><span class="main">,</span> field <span class="main">:=</span> <span class="bound">f</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">r</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> roots <span class="bound">s</span> <span class="main">}</span><span class="main">)</span> <span class="main">;;</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_load_payload''</span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> LoadPayload <span class="main">(</span>tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>field <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> mutator_data <span class="main">:=</span> <span class="main">(</span>mutator_data <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">var</span> <span class="main">:=</span> <span class="bound">pl</span><span class="main">)</span> <span class="main">⦈</span>
                                           <span class="main">|</span><span class="bound">var</span> <span class="bound">pl</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Payload <span class="bound">pl</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">store_payload</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">store_payload</span> <span class="main">≡</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_store_payload_choose''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> tmp_ref <span class="main">:=</span> <span class="bound">r</span><span class="main">,</span> field <span class="main">:=</span> <span class="bound">f</span><span class="main">,</span> payload_value <span class="main">:=</span> <span class="bound">pl</span> <span class="bound">s</span> <span class="main">⦈</span> <span class="main">|</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">pl</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> roots <span class="bound">s</span> <span class="main">}</span><span class="main">)</span> <span class="main">;;</span>
    <span class="main">⦃</span><span class="inner_quoted">''mut_store_payload''</span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">,</span> StorePayload <span class="main">(</span>tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>field <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>payload_value <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                   <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span> mutator_data <span class="main">:=</span> <span class="main">(</span>mutator_data <span class="bound">s</span><span class="main">)</span><span class="main">(</span><span class="bound">f</span> <span class="main">:=</span> <span class="bound">pl</span><span class="main">)</span> <span class="main">⦈</span>
                                           <span class="main">|</span><span class="bound">f</span> <span class="bound">pl</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Payload <span class="bound">pl</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A mutator makes a non-deterministic choice amongst its possible
actions. For completeness we allow mutators to issue \texttt{MFENCE}
instructions. We leave \texttt{CAS} (etc) to future work. Neither has
a significant impact on the rest of the development.

›</span></span>
<span class="comment1">(*
FIXME add SKIP before alloc, mfence. handshake needs work too: want to
commit to checking for handshakes in a strongly fair way. A SKIP
at the top level of ‹handshake› + a noop transition + appropriate fairness constraints might work.

FIXME is mut local computation strong enough? only works on mutator data; not roots.
*)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">com</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">com</span> <span class="main">=</span>
    <span class="keyword1">LOOP</span> <span class="keyword1">DO</span>
        <span class="main">⦃</span><span class="inner_quoted">''mut_local_computation''</span><span class="main">⦄</span> <span class="keyword1">LocalOp</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span>mutator_data <span class="main">:=</span> <span class="bound">f</span> <span class="main">(</span>mutator_data <span class="bound">s</span><span class="main">)</span><span class="main">⦈</span> <span class="main">|</span><span class="bound">f</span><span class="main">.</span> True<span class="main">}</span><span class="main">)</span>
      <span class="main">⊕</span> alloc
      <span class="main">⊕</span> discard
      <span class="main">⊕</span> load
      <span class="main">⊕</span> store
      <span class="main">⊕</span> load_payload
      <span class="main">⊕</span> store_payload
      <span class="main">⊕</span> <span class="main">⦃</span><span class="inner_quoted">''mut_mfence''</span><span class="main">⦄</span> <span class="keyword1">MFENCE</span>
      <span class="main">⊕</span> handshake
    <span class="keyword1">OD</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Garbage collector \label{sec:gc-model-gc}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We abstract the primitive actions of the garbage collector thread.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">gc_deref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location
             <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span>
             <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'field</span><span class="main">)</span>
             <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'ref</span> option <span class="main">⇒</span> <span class="tfree">'ref</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_deref</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> LoadRef <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                    <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">⟨</span><span class="bound">r'</span><span class="main">⟩</span> <span class="bound">s</span> <span class="main">|</span><span class="bound">r'</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Ref <span class="bound">r'</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">gc_load_mark</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location
                <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span>
                <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>gc_mark option <span class="main">⇒</span> gc_mark option<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state<span class="main">)</span>
                <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_load_mark</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> LoadMark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">upd</span></span></span> <span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="bound">s</span> <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Mark <span class="bound">m</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_gc_fassign"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> idt <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'field</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">´</span>_ <span class="keyword1">:=</span> <span class="keyword1">´</span>_ <span class="keyword1">→</span> _"</span> <span class="main">[</span>0<span class="main">,</span> 0<span class="main">,</span> 0<span class="main">,</span> 70<span class="main">]</span> 71<span class="main">)</span>
  <span class="quoted">"_gc_massign"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> idt <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">´</span>_ <span class="keyword1">:=</span> <span class="keyword1">´</span>_ <span class="keyword1">→</span> <span class="keyword1">flag</span>"</span> <span class="main">[</span>0<span class="main">,</span> 0<span class="main">,</span> 0<span class="main">]</span> 71<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">l</span><span class="main">⦄</span> <span class="main">´</span><span class="free">q</span> <span class="main">:=</span> <span class="main">´</span><span class="free">r</span><span class="main">→</span><span class="free">f</span>"</span>    <span class="main">=&gt;</span> <span class="quoted">"<span class="keyword1">CONST</span> gc_deref <span class="free">l</span> <span class="free">r</span> <span class="main">«</span><span class="free">f</span><span class="main">»</span> <span class="main">(</span>_update_name <span class="free">q</span><span class="main">)</span>"</span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">l</span><span class="main">⦄</span> <span class="main">´</span><span class="free">m</span> <span class="main">:=</span> <span class="main">´</span><span class="free">r</span><span class="main">→</span><span class="keyword1">flag</span>"</span> <span class="main">=&gt;</span> <span class="quoted">"<span class="keyword1">CONST</span> gc_load_mark <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>_update_name <span class="free">m</span><span class="main">)</span>"</span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">store_fA_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> gc_mark<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">store'_fA</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">store_fA</span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> StorefA <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">load_fM_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">load'_fM</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">load_fM</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> LoadfM<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mv</span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span> <span class="bound">s</span><span class="main">⦇</span>fM <span class="main">:=</span> <span class="bound">m</span><span class="main">⦈</span> <span class="main">|</span><span class="bound">m</span><span class="main">.</span> <span class="bound">mv</span> <span class="main">=</span> mv_Mark <span class="main">(</span>Some <span class="bound">m</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">store_fM_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">store'_fM</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">store_fM</span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> StorefM <span class="main">(</span>fM <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">store_phase_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> gc_phase <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">store'_phase</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">store_phase</span></span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> StorePhase <span class="free"><span class="bound"><span class="entity">ph</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">⦇</span> phase <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">⦈</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mark_object_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">mark'_object</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">mark_object</span></span> <span class="main">≡</span> mark_object_fn gc <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">free_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> local_state <span class="main">⇒</span> <span class="tfree">'ref</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> <span class="keyword1">free</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="keyword1"><span class="free">free</span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⦄</span> <span class="keyword1">Request</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>gc<span class="main">,</span> ro_Free <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following CIMP program encodes the garbage collector algorithm
proposed in Figure~2.15 of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "Pizlo201xPhd"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span>
  <span class="entity">com</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">com</span> <span class="main">=</span>
     <span class="keyword1">LOOP</span> <span class="keyword1">DO</span>
       <span class="main">⦃</span><span class="inner_quoted">''idle_noop''</span><span class="main">⦄</span> <span class="keyword1">handshake_noop</span> <span class="main">;;</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hp_Idle›</span></span>›</span>

       <span class="main">⦃</span><span class="inner_quoted">''idle_load_fM''</span><span class="main">⦄</span> <span class="keyword1">load_fM</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''idle_invert_fM''</span><span class="main">⦄</span> <span class="main">´</span>fM <span class="main">:=</span> <span class="main">(</span><span class="main">¬</span> <span class="main">´</span>fM<span class="main">)</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''idle_store_fM''</span><span class="main">⦄</span> <span class="keyword1">store_fM</span> <span class="main">;;</span>

       <span class="main">⦃</span><span class="inner_quoted">''idle_flip_noop''</span><span class="main">⦄</span> <span class="keyword1">handshake_noop</span> <span class="main">;;</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hp_IdleInit›</span></span>›</span>

       <span class="main">⦃</span><span class="inner_quoted">''idle_phase_init''</span><span class="main">⦄</span> <span class="keyword1">store_phase</span> ph_Init <span class="main">;;</span>

       <span class="main">⦃</span><span class="inner_quoted">''init_noop''</span><span class="main">⦄</span> <span class="keyword1">handshake_noop</span> <span class="main">;;</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hp_InitMark›</span></span>›</span>

       <span class="main">⦃</span><span class="inner_quoted">''init_phase_mark''</span><span class="main">⦄</span> <span class="keyword1">store_phase</span> ph_Mark <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''mark_load_fM''</span><span class="main">⦄</span> <span class="keyword1">load_fM</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''mark_store_fA''</span><span class="main">⦄</span> <span class="keyword1">store_fA</span> fM <span class="main">;;</span>

       <span class="main">⦃</span><span class="inner_quoted">''mark_noop''</span><span class="main">⦄</span> <span class="keyword1">handshake_noop</span> <span class="main">;;</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hp_Mark›</span></span>›</span>

       <span class="main">⦃</span><span class="inner_quoted">''mark_loop_get_roots''</span><span class="main">⦄</span> <span class="keyword1">handshake_get_roots</span> <span class="main">;;</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hp_IdleMarkSweep›</span></span>›</span>

       <span class="main">⦃</span><span class="inner_quoted">''mark_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> W <span class="keyword1">DO</span>
         <span class="main">⦃</span><span class="inner_quoted">''mark_loop_inner''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> W <span class="keyword1">DO</span>
           <span class="main">⦃</span><span class="inner_quoted">''mark_loop_choose_ref''</span><span class="main">⦄</span> <span class="main">´</span>tmp_ref <span class="main">:∈</span> <span class="main">´</span>W <span class="main">;;</span>
           <span class="main">⦃</span><span class="inner_quoted">''mark_loop_fields''</span><span class="main">⦄</span> <span class="main">´</span>field_set <span class="main">:=</span> UNIV <span class="main">;;</span>
           <span class="main">⦃</span><span class="inner_quoted">''mark_loop_mark_object_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> field_set <span class="keyword1">DO</span>
             <span class="main">⦃</span><span class="inner_quoted">''mark_loop_mark_choose_field''</span><span class="main">⦄</span> <span class="main">´</span>field <span class="main">:∈</span> <span class="main">´</span>field_set <span class="main">;;</span>
             <span class="main">⦃</span><span class="inner_quoted">''mark_loop_mark_deref''</span><span class="main">⦄</span> <span class="main">´</span>ref <span class="main">:=</span> <span class="main">´</span>tmp_ref<span class="main">→</span><span class="main">´</span>field <span class="main">;;</span>
             <span class="main">⦃</span><span class="inner_quoted">''mark_loop''</span><span class="main">⦄</span> <span class="keyword1">mark_object</span> <span class="main">;;</span>
             <span class="main">⦃</span><span class="inner_quoted">''mark_loop_mark_field_done''</span><span class="main">⦄</span> <span class="main">´</span>field_set <span class="main">:=</span> <span class="main">(</span><span class="main">´</span>field_set <span class="main">-</span> <span class="main">{</span><span class="main">´</span>field<span class="main">}</span><span class="main">)</span>
           <span class="keyword1">OD</span> <span class="main">;;</span>
           <span class="main">⦃</span><span class="inner_quoted">''mark_loop_blacken''</span><span class="main">⦄</span> <span class="main">´</span>W <span class="main">:=</span> <span class="main">(</span><span class="main">´</span>W <span class="main">-</span> <span class="main">{</span><span class="main">´</span>tmp_ref<span class="main">}</span><span class="main">)</span>
         <span class="keyword1">OD</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="inner_quoted">''mark_loop_get_work''</span><span class="main">⦄</span> <span class="keyword1">handshake_get_work</span>
       <span class="keyword1">OD</span> <span class="main">;;</span>

       <span class="comment1">― ‹sweep›</span>

       <span class="main">⦃</span><span class="inner_quoted">''mark_end''</span><span class="main">⦄</span> <span class="keyword1">store_phase</span> ph_Sweep <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''sweep_load_fM''</span><span class="main">⦄</span> <span class="keyword1">load_fM</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''sweep_refs''</span><span class="main">⦄</span> <span class="main">´</span>refs <span class="main">:=</span> UNIV <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''sweep_loop''</span><span class="main">⦄</span> <span class="keyword1">WHILE</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> refs <span class="keyword1">DO</span>
         <span class="main">⦃</span><span class="inner_quoted">''sweep_loop_choose_ref''</span><span class="main">⦄</span> <span class="main">´</span>tmp_ref <span class="main">:∈</span> <span class="main">´</span>refs <span class="main">;;</span>
         <span class="main">⦃</span><span class="inner_quoted">''sweep_loop_load_mark''</span><span class="main">⦄</span> <span class="main">´</span>mark <span class="main">:=</span> <span class="main">´</span>tmp_ref<span class="main">→</span><span class="keyword1">flag</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="inner_quoted">''sweep_loop_check''</span><span class="main">⦄</span> <span class="keyword1">IF</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mark <span class="main"><span class="hidden">❙</span><b>∧</b></span> the <span class="main">∘</span> mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> fM <span class="keyword1">THEN</span>
           <span class="main">⦃</span><span class="inner_quoted">''sweep_loop_free''</span><span class="main">⦄</span> <span class="keyword1">free</span> tmp_ref
         <span class="keyword1">FI</span> <span class="main">;;</span>
         <span class="main">⦃</span><span class="inner_quoted">''sweep_loop_ref_done''</span><span class="main">⦄</span> <span class="main">´</span>refs <span class="main">:=</span> <span class="main">(</span><span class="main">´</span>refs <span class="main">-</span> <span class="main">{</span><span class="main">´</span>tmp_ref<span class="main">}</span><span class="main">)</span>
       <span class="keyword1">OD</span> <span class="main">;;</span>
       <span class="main">⦃</span><span class="inner_quoted">''sweep_idle''</span><span class="main">⦄</span> <span class="keyword1">store_phase</span> ph_Idle
     <span class="keyword1">OD</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="entity">gc_coms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_com"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_coms</span> <span class="main">(</span>mutator <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> mut_m.com <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">gc_coms</span> gc <span class="main">=</span> gc.com"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">gc_coms</span> sys <span class="main">=</span> sys.com"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Proofs_Basis">
<div class="head">
<h1>Theory Proofs_Basis</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Proofs_Basis
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Model.html">Model</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Simps_Case_Conv.html">HOL-Library.Simps_Case_Conv</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* From 40e16c534243 by Makarius. Doesn't seem to have a huge impact on run time now (2021-01-07) *)</span>
<span class="keyword1"><span class="command">declare</span></span> subst_all <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Proofs Basis \label{sec:proofs-basis}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Extra HOL.

›</span></span>

<span class="keyword1" id="Proofs_Basis-Set_bind_insert"><span class="command">lemma</span></span> Set_bind_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Set.bind <span class="main">(</span>insert <span class="free">a</span> <span class="free">A</span><span class="main">)</span> <span class="free">B</span> <span class="main">=</span> <span class="free">B</span> <span class="free">a</span> <span class="main">∪</span> <span class="main">(</span>Set.bind <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Set.bind_def<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-option_bind_invE"><span class="command">lemma</span></span> option_bind_invE<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Option.bind <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> None<span class="main">;</span> <span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">f</span> <span class="main">=</span> Some <span class="bound">a</span><span class="main">;</span> <span class="free">g</span> <span class="bound">a</span> <span class="main">=</span> None <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">;</span> <span class="free">f</span> <span class="main">=</span> None <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Option.bind <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> Some <span class="free">x</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">a</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">f</span> <span class="main">=</span> Some <span class="bound">a</span><span class="main">;</span> <span class="free">g</span> <span class="bound">a</span> <span class="main">=</span> Some <span class="free">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> conj_explode <span class="main">=</span> conj_imp_eq_imp_imp

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Tweak the default simpset:
<span class="antiquoted"><span class="antiquoted">▪</span></span> "not in dom" as a premise negates the goal
<span class="antiquoted"><span class="antiquoted">▪</span></span> we always want to execute suffix
<span class="antiquoted"><span class="antiquoted">▪</span></span> we try to make simplification rules about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹fun_upd›<span class="antiquote"><span class="antiquote">}</span></span></span></span> more stable

›</span></span>

<span class="keyword1"><span class="command">declare</span></span> dom_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> suffix_to_prefix<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> map_option.compositionality<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> o_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Option.Option.option.set_map<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> bind_image<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> fun_upd_same<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> fun_upd_other<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> gc_phase.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> mem_store_action.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> process_name.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> hs_phase.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> hs_type.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Collect the component definitions. Inline everything. This is what the proofs work on.
Observe we lean heavily on locales.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> all_com_defs <span class="main">=</span>
  <span class="comment1">(* gc.com_def *)</span> handshake_done_def handshake_init_def handshake_noop_def handshake_get_roots_def handshake_get_work_def
  mark_object_fn_def

<span class="keyword1"><span class="command">lemmas</span></span> com_def2 <span class="main">=</span> com_def<span class="main">[</span><span class="operator">simplified</span> all_com_defs append.simps if_True if_False<span class="main">]</span>

<span class="keyword1"><span class="command">intern_com</span></span> com_def2

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> all_com_defs <span class="main">=</span>
  <span class="comment1">(* mut.com_def *)</span> mut_m.handshake_def mut_m.store_def
  mark_object_fn_def

<span class="keyword1"><span class="command">lemmas</span></span> com_def2 <span class="main">=</span> mut_m.com_def<span class="main">[</span><span class="operator">simplified</span> all_com_defs append.simps if_True if_False<span class="main">]</span>

<span class="keyword1"><span class="command">intern_com</span></span> com_def2

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> all_com_defs <span class="main">=</span>
  <span class="comment1">(* sys.com_def *)</span> sys.alloc_def sys.free_def sys.mem_TSO_def sys.handshake_def

<span class="keyword1"><span class="command">lemmas</span></span> com_def2 <span class="main">=</span> com_def<span class="main">[</span><span class="operator">simplified</span> all_com_defs append.simps if_True if_False<span class="main">]</span>

<span class="keyword1"><span class="command">intern_com</span></span> com_def2

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> all_com_interned_defs <span class="main">=</span> gc.com_interned mut_m.com_interned sys.com_interned

<span class="keyword1"><span class="command">named_theorems</span></span> inv <span class="quoted">"Location-sensitive invariant definitions"</span>
<span class="keyword1"><span class="command">named_theorems</span></span> nie <span class="quoted">"Non-interference elimination rules"</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Model-specific functions and predicates ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We define a pile of predicates and accessor functions for the
process's local states. One might hope that a more sophisticated
approach would automate all of this (cf <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
"DBLP:journals/entcs/SchirmerW09"<span class="antiquote"><span class="antiquote">}</span></span></span></span>).

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">prefixed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> location set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prefixed</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="bound">l</span> <span class="main">.</span> prefix <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">l</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">suffixed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> location set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">suffixed</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="bound">l</span> <span class="main">.</span> suffix <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">l</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_Mark</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">r</span> <span class="bound">fl</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_Mark <span class="bound">r</span> <span class="bound">fl</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_Mutate</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_Mutate_Payload</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">pl</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_Mutate_Payload <span class="bound">r</span> <span class="bound">f</span> <span class="bound">pl</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_fA</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">fl</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_fA <span class="bound">fl</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_fM</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">fl</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_fM <span class="bound">fl</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_mw_Phase</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">ph</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> mw_Phase <span class="bound">ph</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pred_in_W</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">in'_W</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1"><span class="free">in_W</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∈</span> W <span class="main">(</span><span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pred_in_ghost_honorary_grey</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">in'_ghost'_honorary'_grey</span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1"><span class="free">in_ghost_honorary_grey</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_cas_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> cas_mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_fM</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fM <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_field</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> field <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_field_set</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> field_set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_mut</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mut <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_muts</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> muts <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_tmp_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> tmp_ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_ghost_honorary_grey</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_honorary_grey <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_refs</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> refs <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_the_ref</span> <span class="main">≡</span> the <span class="main">∘</span> gc_ref"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gc_W</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> W <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> gc<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">at_gc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">at_gc</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> at gc <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">atS_gc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">atS_gc</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> atS gc <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">at_mut</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">at_mut</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> at <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">atS_mut</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">atS_mut</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> atS <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_cas_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> cas_mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_field</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> field <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_fM</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fM <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_ghost_honorary_grey</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_honorary_grey <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_ghost_hs_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_hs_phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_ghost_honorary_root</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_honorary_root <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_hs_pending</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mutator_hs_pending <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_hs_type</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> hs_type <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_new_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> new_ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_tmp_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> tmp_ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_the_new_ref</span> <span class="main">≡</span> the <span class="main">∘</span> mut_new_ref"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_the_ref</span> <span class="main">≡</span> the <span class="main">∘</span> mut_ref"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_refs</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> refs <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_roots</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> roots <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_W</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> W <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sys_heap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> object option"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_heap</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> heap <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_fA</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fA <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_fM</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fM <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_ghost_honorary_grey</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_honorary_grey <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_ghost_hs_in_sync</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_hs_in_sync <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_ghost_hs_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_hs_phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_hs_pending</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> hs_pending <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_hs_type</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> hs_type <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_mem_store_buffers</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mem_store_buffers <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_mem_lock</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mem_lock <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">sys_W</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> W <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">atS_sys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">atS_sys</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> atS sys <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Projections on TSO buffers.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_unlocked</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mem_lock <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_locked_by</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mem_lock <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> filter <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_store</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">∈</span> set <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> sys<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_fA</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> is_mw_fA"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_fM</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> is_mw_fM"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_mark</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> is_mw_Mark"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_mw_mutate</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> is_mw_Mutate"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_mutate</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>is_mw_Mutate <span class="main"><span class="hidden">❙</span><b>∨</b></span> is_mw_Mutate_Payload<span class="main">)</span>"</span></span> <span class="comment1">―‹ TSO makes it (mostly) not worth distinguishing these. ›</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_pending_phase</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> tso_pending <span class="free"><span class="bound"><span class="entity">p</span></span></span> is_mw_Phase"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">tso_no_pending_marks</span> <span class="main">≡</span> <span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">p</span><span class="main">.</span> <span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_mark <span class="bound">p</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A somewhat-useful abstraction of the heap, following l4.verified,
which asserts that there is an object at the given reference with the
given property. In some sense this encodes a three-valued logic.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">obj_at</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> object <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">obj_at</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> sys_heap <span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="bound">obj</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">obj</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">valid_ref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_ref</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> obj_at <span class="main">⟨</span>True<span class="main">⟩</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_null_ref</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_null_ref</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">⟨</span>True<span class="main">⟩</span> <span class="main">|</span> Some <span class="bound">r'</span> <span class="main">⇒</span> valid_ref <span class="bound">r'</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">pred_points_to</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">points'_to</span>"</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">points_to</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∈</span> ran <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">s</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We use Isabelle's standard transitive-reflexive closure to define
reachability through the heap.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reaches</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">reaches</span>"</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">reaches</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">points_to</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obj_at_field_on_heap›</span></span></span></span> asserts that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹valid_ref <span class="free"><span class="free">r</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and if <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> is a field of the object referred to by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span> then it it satisfies <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">obj_at_field_on_heap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ref</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'field</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">obj_at_field_on_heap</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span>
     <span class="keyword1">case</span> map_option obj_fields <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
         None <span class="main">⇒</span> False
       <span class="main">|</span> Some <span class="bound">fs</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">fs</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> True
                               <span class="main">|</span> Some <span class="bound">r'</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">r'</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Object colours›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We adopt the classical tricolour scheme for object colours due to
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "DBLP:journals/cacm/DijkstraLMSS78"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, but
tweak it somewhat in the presence of worklists and TSO. Intuitively:
\begin{description}
\item[White] potential garbage, not yet reached
\item[Grey] reached, presumed live, a source of possible new references (work)
\item[Black] reached, presumed live, not a source of new references
\end{description}

In this particular setting we use the following interpretation:
\begin{description}
\item[White:] not marked
\item[Grey:] on a worklist or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹ghost_honorary_grey›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\item[Black:] marked and not on a worklist
\end{description}

Note that this allows the colours to overlap: an object being marked
may be white (on the heap) and in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ghost_honorary_grey"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for
some process, i.e. grey.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">marked</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">marked</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> sys_fM <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">white</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">white</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">≠</span> sys_fM <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">WL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts <span class="main">⇒</span> <span class="tfree">'ref</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">WL</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> W <span class="main">(</span><span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∪</span> ghost_honorary_grey <span class="main">(</span><span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">grey</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">grey</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">p</span><span class="main">.</span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> WL <span class="bound">p</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">black</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">black</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> marked <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>grey <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ These demonstrate the overlap in colours. ›</span></span>

<span class="keyword1" id="Proofs_Basis-colours_distinct"><span class="command">lemma</span></span> colours_distinct<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>white <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="free">s</span>  <span class="main">⟹</span> <span class="main">¬</span>black <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>black <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def white_def obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> <span class="comment1">(* FIXME invisible *)</span>

<span class="keyword1" id="Proofs_Basis-marked_imp_black_or_grey"><span class="command">lemma</span></span> marked_imp_black_or_grey<span class="main">:</span>
  <span class="quoted"><span class="quoted">"marked <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span> valid_ref <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> black <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def grey_def white_def obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>  <span class="comment1">(* FIXME invisible *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

In some phases the heap is monochrome.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">black_heap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">black_heap</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> valid_ref <span class="bound">r</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> black <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">white_heap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">white_heap</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> valid_ref <span class="bound">r</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> white <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">no_black_refs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">no_black_refs</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>black <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">no_grey_refs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">no_grey_refs</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>grey <span class="bound">r</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Reachability›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We treat pending TSO heap mutations as extra mutator roots.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">store_refs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> <span class="tfree">'ref</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">store_refs</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">of</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">r</span><span class="main">}</span> <span class="main">∪</span> Option.set_option <span class="bound">r'</span> <span class="main">|</span> mw_Mutate_Payload <span class="bound">r</span> <span class="bound">f</span> <span class="bound">pl</span> <span class="main">⇒</span> <span class="main">{</span><span class="bound">r</span><span class="main">}</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">tso_store_refs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts <span class="main">⇒</span> <span class="tfree">'ref</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tso_store_refs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">w</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> store_refs <span class="bound">w</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">root</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">root</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots <span class="main"><span class="hidden">❙</span><b>∪</b></span> mut_ghost_honorary_root <span class="main"><span class="hidden">❙</span><b>∪</b></span> tso_store_refs"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">reachable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reachable</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">x</span><span class="main">.</span> root <span class="bound">x</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">grey_reachable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">grey_reachable</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">g</span><span class="main">.</span> grey <span class="bound">g</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">g</span> <span class="keyword1">reaches</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Sundry detritus ›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> eq_imp_simps <span class="main">=</span> <span class="comment1">―‹equations for deriving useful things from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹eq_imp›<span class="antiquote">}</span></span> facts›</span>
  eq_imp_def
  all_conj_distrib
  split_paired_All split_def fst_conv snd_conv prod_eq_iff
  conj_explode
  simp_thms

<span class="keyword1" id="Proofs_Basis-p_not_sys"><span class="command">lemma</span></span> p_not_sys<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> gc <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> mutator <span class="bound">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> m'm<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">≠</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mm' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ obj at ›</span></span>

<span class="keyword1" id="Proofs_Basis-obj_at_cong"><span class="command">lemma</span></span> obj_at_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">obj</span> <span class="main">=</span> <span class="free">P'</span> <span class="bound">obj</span><span class="main">;</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span><span class="main">;</span> <span class="free">s</span> <span class="main">=</span> <span class="free">s'</span><span class="main">⟧</span>
   <span class="main">⟹</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span> <span class="main">⟷</span> obj_at <span class="free">P'</span> <span class="free">r'</span> <span class="free">s'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_at_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_split"><span class="command">lemma</span></span> obj_at_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="free">Q</span> False<span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">⟶</span> <span class="free">Q</span> <span class="main">(</span><span class="free">P</span> <span class="bound">obj</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_split_asm"><span class="command">lemma</span></span> obj_at_split_asm<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> <span class="main">(</span><span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">∧</span> <span class="main">¬</span><span class="free">Q</span> False<span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">Q</span> <span class="main">(</span><span class="free">P</span> <span class="bound">obj</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> obj_at_splits <span class="main">=</span> obj_at_split obj_at_split_asm

<span class="keyword1" id="Proofs_Basis-obj_at_eq_imp"><span class="command">lemma</span></span> obj_at_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> map_option <span class="free">P</span> <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>obj_at <span class="free">P</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> obj_at_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> obj_at_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">]</span>

<span class="keyword1" id="Proofs_Basis-obj_at_simps"><span class="command">lemma</span></span> obj_at_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="free">P</span> <span class="bound">obj</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">obj</span><span class="main">)</span> <span class="free">r</span> <span class="free">s</span> <span class="main">⟷</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> obj_at <span class="free">Q</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="comment1">(*  "obj_at (λobj. R) r s ⟷ valid_ref r s ∧ R" looks good but applies to valid_ref *)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ obj at field on heap ›</span></span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_cong"><span class="command">lemma</span></span> obj_at_field_on_heap_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span><span class="bound">r'</span> <span class="bound">obj</span><span class="main">.</span> <span class="main">⟦</span>sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span><span class="main">;</span> obj_fields <span class="bound">obj</span> <span class="free">f</span> <span class="main">=</span> Some <span class="bound">r'</span><span class="main">⟧</span><span class="main">⟹</span> <span class="free">P</span> <span class="bound">r'</span> <span class="main">=</span> <span class="free">P'</span> <span class="bound">r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span><span class="main">;</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f'</span><span class="main">;</span> <span class="free">s</span> <span class="main">=</span> <span class="free">s'</span><span class="main">⟧</span>
   <span class="main">⟹</span> obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span> <span class="main">⟷</span> obj_at_field_on_heap <span class="free">P'</span> <span class="free">r'</span> <span class="free">f'</span> <span class="free">s'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_at_field_on_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_split"><span class="command">lemma</span></span> obj_at_field_on_heap_split<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="free">Q</span> False<span class="main">)</span>
                                 <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">∧</span> obj_fields <span class="bound">obj</span> <span class="free">f</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="free">Q</span> True<span class="main">)</span>
                                 <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r'</span> <span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">∧</span> obj_fields <span class="bound">obj</span> <span class="free">f</span> <span class="main">=</span> Some <span class="bound">r'</span> <span class="main">⟶</span> <span class="free">Q</span> <span class="main">(</span><span class="free">P</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_split_asm"><span class="command">lemma</span></span> obj_at_field_on_heap_split_asm<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span> <span class="main">(</span><span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">∧</span> <span class="main">¬</span><span class="free">Q</span> False<span class="main">)</span>
                                    <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">∧</span> obj_fields <span class="bound">obj</span> <span class="free">f</span> <span class="main">=</span> None <span class="main">∧</span> <span class="main">¬</span> <span class="free">Q</span> True<span class="main">)</span>
                                    <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r'</span> <span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> Some <span class="bound">obj</span> <span class="main">∧</span> obj_fields <span class="bound">obj</span> <span class="free">f</span> <span class="main">=</span> Some <span class="bound">r'</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">Q</span> <span class="main">(</span><span class="free">P</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> obj_at_field_on_heap_splits <span class="main">=</span> obj_at_field_on_heap_split obj_at_field_on_heap_split_asm

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_eq_imp"><span class="command">lemma</span></span> obj_at_field_on_heap_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> sys_heap <span class="bound">s</span> <span class="free">r</span><span class="main">)</span>
          <span class="main">(</span>obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def obj_at_field_on_heap_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> obj_at_field_on_heap_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> obj_at_field_on_heap_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">]</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_imp_valid_ref"><span class="command">lemma</span></span> obj_at_field_on_heap_imp_valid_ref<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span> <span class="main">⟹</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span> <span class="main">⟹</span> valid_null_ref <span class="main">(</span>Some <span class="free">r</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def valid_null_ref_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits option.splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heapE"><span class="command">lemma</span></span> obj_at_field_on_heapE<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span><span class="main">;</span> sys_heap <span class="free">s'</span> <span class="free">r</span> <span class="main">=</span> sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">r'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">r'</span> <span class="main">⟹</span> <span class="free">P'</span> <span class="bound">r'</span> <span class="main">⟧</span>
       <span class="main">⟹</span> obj_at_field_on_heap <span class="free">P'</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-valid_null_ref_eq_imp"><span class="command">lemma</span></span> valid_null_ref_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> Option.bind <span class="free">r</span> <span class="main">(</span>map_option <span class="main">⟨</span>True<span class="main">⟩</span> <span class="main">∘</span> sys_heap <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>valid_null_ref <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def obj_at_def valid_null_ref_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> valid_null_ref_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> valid_null_ref_eq_imp<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1" id="Proofs_Basis-valid_null_ref_simps"><span class="command">lemma</span></span> valid_null_ref_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_null_ref None <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"valid_null_ref <span class="main">(</span>Some <span class="free">r</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟷</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_null_ref_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Derive simplification rules from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>case›</span></span></span></span> expressions›</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> hs_step_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> hs_step_def <span class="main">(</span>splits<span class="main">:</span> hs_phase.split<span class="main">)</span>
<span class="keyword1"><span class="command">simps_of_case</span></span> do_load_action_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> fun_cong<span class="main">[</span><span class="operator">OF</span> do_load_action_def<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> atomize_eq<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="main">(</span>splits<span class="main">:</span> mem_load_action.split<span class="main">)</span>
<span class="keyword1"><span class="command">simps_of_case</span></span> do_store_action_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> fun_cong<span class="main">[</span><span class="operator">OF</span> do_store_action_def<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> atomize_eq<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="main">(</span>splits<span class="main">:</span> mem_store_action.split<span class="main">)</span>

<span class="comment1">(* This gives some indication of how much we're cheating on the TSO front. *)</span>
<span class="keyword1" id="Proofs_Basis-do_store_action_prj_simps"><span class="command">lemma</span></span> do_store_action_prj_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fM <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">fl</span> <span class="main">⟷</span> <span class="main">(</span>fM <span class="free">s</span> <span class="main">=</span> <span class="free">fl</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">≠</span> mw_fM <span class="main">(</span><span class="main">¬</span>fM <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_fM <span class="free">fl</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fl</span> <span class="main">=</span> fM <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">fl</span> <span class="main">=</span> fM <span class="free">s</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">≠</span> mw_fM <span class="main">(</span><span class="main">¬</span>fM <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_fM <span class="free">fl</span>"</span></span>
  <span class="quoted"><span class="quoted">"fA <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">fl</span> <span class="main">⟷</span> <span class="main">(</span>fA <span class="free">s</span> <span class="main">=</span> <span class="free">fl</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">≠</span> mw_fA <span class="main">(</span><span class="main">¬</span>fA <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_fA <span class="free">fl</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fl</span> <span class="main">=</span> fA <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">fl</span> <span class="main">=</span> fA <span class="free">s</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">≠</span> mw_fA <span class="main">(</span><span class="main">¬</span>fA <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_fA <span class="free">fl</span>"</span></span>
  <span class="quoted"><span class="quoted">"ghost_hs_in_sync <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> ghost_hs_in_sync <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"ghost_hs_phase <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> ghost_hs_phase <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> ghost_honorary_grey <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"hs_pending <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> hs_pending <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"hs_type <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> hs_type <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"heap <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">⟷</span> heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"mem_lock <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> mem_lock <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"phase <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">ph</span> <span class="main">⟷</span> <span class="main">(</span>phase <span class="free">s</span> <span class="main">=</span> <span class="free">ph</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">ph'</span><span class="main">.</span> <span class="free">w</span> <span class="main">≠</span> mw_Phase <span class="bound">ph'</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_Phase <span class="free">ph</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ph</span> <span class="main">=</span> phase <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">ph</span> <span class="main">=</span> phase <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">ph'</span><span class="main">.</span> <span class="free">w</span> <span class="main">≠</span> mw_Phase <span class="bound">ph'</span><span class="main">)</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">=</span> mw_Phase <span class="free">ph</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"W <span class="main">(</span>do_store_action <span class="free">w</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> W <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ reaches ›</span></span>

<span class="keyword1" id="Proofs_Basis-reaches_refl"><span class="command">lemma</span></span> reaches_refl<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span> <span class="keyword1">reaches</span> <span class="free">r</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Proofs_Basis-reaches_step"><span class="command">lemma</span></span> reaches_step<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">points_to</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">y</span> <span class="keyword1">reaches</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reaches_def
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> converse_rtranclp_into_rtranclp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Proofs_Basis-reaches_induct"><span class="command">lemma</span></span> reaches_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> refl step<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">set</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> reaches<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span> <span class="keyword1">points_to</span> <span class="bound">z</span><span class="main">)</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtranclp.induct<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-converse_reachesE"><span class="command">lemma</span></span> converse_reachesE<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> base step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span> <span class="keyword1">reaches</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="free">P</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> converse_rtranclpE<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-reaches_fields"><span class="command">lemma</span></span> reaches_fields<span class="main">:</span> <span class="comment1">― ‹Complicated condition takes care of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>alloc›</span></span>: collapses no object and object with no fields›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="free">s'</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="free">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="keyword1">points_to</span> <span class="skolem">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sys_heap <span class="free">s</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> 10 10 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Proofs_Basis-reaches_eq_imp"><span class="command">lemma</span></span> reaches_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span> <span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> reaches_fields<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> reaches_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> reaches_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Location-specific facts.

›</span></span>

<span class="keyword1" id="Proofs_Basis-obj_at_mark_dequeue"><span class="command">lemma</span></span> obj_at_mark_dequeue<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_at <span class="free">P</span> <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="free">wb'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
<span class="main">⟷</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="main">(</span><span class="free">P</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="keyword1">then</span> <span class="bound">obj</span><span class="main">⦇</span> obj_mark <span class="main">:=</span> <span class="free">fl</span> <span class="main">⦈</span> <span class="keyword1">else</span> <span class="bound">obj</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_mw_simps"><span class="command">lemma</span></span> obj_at_field_on_heap_mw_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_at_field_on_heap <span class="free">P</span> <span class="free">r0</span> <span class="free">f0</span>
         <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> object<span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                            mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> <span class="free">Sys</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
<span class="main">⟷</span> <span class="main">(</span> <span class="main">(</span><span class="free">r</span> <span class="main">≠</span> <span class="free">r0</span> <span class="main">∨</span> <span class="free">f</span> <span class="main">≠</span> <span class="free">f0</span><span class="main">)</span> <span class="main">∧</span> obj_at_field_on_heap <span class="free">P</span> <span class="free">r0</span> <span class="free">f0</span> <span class="free">s</span> <span class="main">)</span>
   <span class="main">∨</span> <span class="main">(</span><span class="free">r</span> <span class="main">=</span> <span class="free">r0</span> <span class="main">∧</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f0</span> <span class="main">∧</span> valid_ref <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">opt_r'</span> <span class="keyword1">of</span> Some <span class="bound">r''</span> <span class="main">⇒</span> <span class="free">P</span> <span class="bound">r''</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="free">sb'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
<span class="main">⟷</span> obj_at_field_on_heap <span class="free">P</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Proofs_Basis-obj_at_field_on_heap_no_pending_stores"><span class="command">lemma</span></span> obj_at_field_on_heap_no_pending_stores<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">opt_r'</span><span class="main">;</span> <span class="main">∀</span><span class="bound">opt_r'</span><span class="main">.</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="bound">opt_r'</span> <span class="main">∉</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> valid_ref <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">opt_r'</span> <span class="main">=</span> Some <span class="bound">r</span><span class="main">)</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sys_load_def fold_stores_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> obj_at_field_on_heap <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">r'</span></span><span class="main"><span class="main">.</span></span> Option.bind <span class="main"><span class="main">(</span></span>heap <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">obj</span></span><span class="main"><span class="main">.</span></span> obj_fields <span class="bound"><span class="bound">obj</span></span> <span class="free"><span class="free">f</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> Some <span class="bound"><span class="bound">r'</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">r</span></span> <span class="free"><span class="free">f</span></span> <span class="free"><span class="free">s</span></span>"</span></span></span>
                             <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">∈</span></span> set <span class="main"><span class="main">(</span></span>sys_mem_store_buffers <span class="main"><span class="main">(</span></span>mutator <span class="free"><span class="free">m</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def map_option_case fun_upd_apply
           <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits option.splits obj_at_splits mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Global_Invariants">
<div class="head">
<h1>Theory Global_Invariants</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Global_Invariants
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Proofs_Basis.html">Proofs_Basis</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Global Invariants \label{sec:global-invariants}›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The valid references invariant›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The key safety property of a GC is that it does not free objects that
are reachable from mutator roots. The GC also requires that there are
objects for all references reachable from grey objects.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_refs_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">valid_refs_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span> <span class="bound">x</span><span class="main">.</span> mut_m.reachable <span class="bound">m</span> <span class="bound">x</span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> grey_reachable <span class="bound">x</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> valid_ref <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The remainder of the invariants support the inductive argument that
this one holds.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The strong-tricolour invariant \label{sec:strong-tricolour-invariant} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

As the GC algorithm uses both insertion and deletion barriers, it
preserves the \emph{strong tricolour-invariant}:

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">points_to_white</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">points'_to'_white</span>"</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">points_to_white</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">points_to</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> white <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strong_tricolour_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strong_tricolour_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">b</span> <span class="bound">w</span><span class="main">.</span> black <span class="bound">b</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="bound">b</span> <span class="keyword1">points_to_white</span> <span class="bound">w</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively this invariant says that there are no pointers from
completely processed objects to the unexplored space; i.e., the grey
references properly separate the two. In contrast the weak tricolour
invariant allows such pointers, provided there is a grey reference
that protects the unexplored object.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">has_white_path_to</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">has'_white'_path'_to</span>"</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">has_white_path_to</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">points_to_white</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">grey_protects_white</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">grey'_protects'_white</span>"</span> 51<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1"><span class="free">grey_protects_white</span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="main">(</span>grey <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">has_white_path_to</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weak_tricolour_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weak_tricolour_inv</span> <span class="main">=</span>
     <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">b</span> <span class="bound">w</span><span class="main">.</span> black <span class="bound">b</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">b</span> <span class="keyword1">points_to_white</span> <span class="bound">w</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">g</span><span class="main">.</span> <span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="bound">w</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"strong_tricolour_inv <span class="free">s</span> <span class="main">⟹</span> weak_tricolour_inv <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> strong_tricolour_inv_def weak_tricolour_inv_def grey_protects_white_def<span class="main">)</span> <span class="comment1">(* FIXME elide *)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The key invariant that the mutators establish as they perform <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_roots›</span></span></span></span>: they protect their white-reachable references with grey
objects.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">in_snapshot</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">in_snapshot</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="main">(</span>black <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">g</span><span class="main">.</span> <span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">reachable_snapshot_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reachable_snapshot_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> reachable <span class="bound">r</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> in_snapshot <span class="bound">r</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Phase invariants \label{sec:phase-invariants}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="quoted"><span class="plain_text">‹

The phase structure of this GC algorithm greatly complicates this
safety proof. The following assertions capture this structure in
several relations.

We begin by relating the mutators' <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"mut_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which tracks the GC's. Each mutator can be at most one handshake step
behind the GC. If any mutator is behind then the GC is stalled on a
pending handshake. We include the handshake type as
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_work›</span></span></span></span> can occur any number of times.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hp_step_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">×</span> hs_type <span class="main">×</span> hs_phase <span class="main">×</span> hs_phase<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hp_step_rel</span> <span class="main">=</span>
  <span class="main">{</span> True <span class="main">}</span>  <span class="main">×</span> <span class="main">(</span><span class="main">{</span> <span class="main">(</span>ht_NOOP<span class="main">,</span> <span class="bound">hp</span><span class="main">,</span> <span class="bound">hp</span><span class="main">)</span> <span class="main">|</span><span class="bound">hp</span><span class="main">.</span> <span class="bound">hp</span> <span class="main">∈</span> <span class="main">{</span>hp_Idle<span class="main">,</span> hp_IdleInit<span class="main">,</span> hp_InitMark<span class="main">,</span> hp_Mark<span class="main">}</span> <span class="main">}</span>
            <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span>ht_GetRoots<span class="main">,</span> hp_IdleMarkSweep<span class="main">,</span> hp_IdleMarkSweep<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_GetWork<span class="main">,</span>  hp_IdleMarkSweep<span class="main">,</span> hp_IdleMarkSweep<span class="main">)</span> <span class="main">}</span><span class="main">)</span>
<span class="main">∪</span> <span class="main">{</span> False <span class="main">}</span> <span class="main">×</span> <span class="main">{</span> <span class="main">(</span>ht_NOOP<span class="main">,</span>     hp_Idle<span class="main">,</span>          hp_IdleMarkSweep<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_NOOP<span class="main">,</span>     hp_IdleInit<span class="main">,</span>      hp_Idle<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_NOOP<span class="main">,</span>     hp_InitMark<span class="main">,</span>      hp_IdleInit<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_NOOP<span class="main">,</span>     hp_Mark<span class="main">,</span>          hp_InitMark<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_GetRoots<span class="main">,</span> hp_IdleMarkSweep<span class="main">,</span> hp_Mark<span class="main">)</span>
              <span class="main">,</span> <span class="main">(</span>ht_GetWork<span class="main">,</span>  hp_IdleMarkSweep<span class="main">,</span> hp_IdleMarkSweep<span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">handshake_phase_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">handshake_phase_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span>
     sys_ghost_hs_in_sync <span class="bound">m</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_hs_type <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> mut_m.mut_ghost_hs_phase <span class="bound">m</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span>hp_step_rel<span class="main">⟩</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span>sys_hs_pending <span class="bound">m</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

In some phases we need to know that the insertion and deletion
barriers are installed, in order to preserve the snapshot. These can
ignore TSO effects as the process doing the marking holds the TSO lock
until the mark is committed to the shared memory (see
\S\ref{def:valid_W_inv}).

Note that it is not easy to specify precisely when the snapshot (of
objects the GC will retain) is taken due to the raggedness of the
initialisation.

Read the following as ``when mutator <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m›</span></span></span></span> is past the
specified handshake, and has yet to reach the next one, ... holds.''

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">marked_insertion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">marked_insertion</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">of</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="main">(</span>Some <span class="bound">r'</span><span class="main">)</span> <span class="main">⇒</span> marked <span class="bound">r'</span> <span class="bound">s</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">marked_deletion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">marked_deletion</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">of</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">opt_r'</span> <span class="main">⇒</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> marked <span class="bound">r'</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">r</span> <span class="bound">f</span> <span class="bound">s</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True"</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">marked_insertions</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">marked_insertions</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">w</span><span class="main">.</span> tso_pending_store <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="bound">w</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked_insertion <span class="bound">w</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">marked_deletions</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">marked_deletions</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">w</span><span class="main">.</span> tso_pending_store <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="bound">w</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked_deletion <span class="bound">w</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">mutator_phase_inv_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_phase <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv_aux</span> hp_Idle          <span class="main">=</span> <span class="main">⟨</span>True<span class="main">⟩</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv_aux</span> hp_IdleInit      <span class="main">=</span> no_black_refs"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv_aux</span> hp_InitMark      <span class="main">=</span> marked_insertions"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv_aux</span> hp_Mark          <span class="main">=</span> <span class="main">(</span>marked_insertions <span class="main"><span class="hidden">❙</span><b>∧</b></span> marked_deletions<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv_aux</span> hp_IdleMarkSweep <span class="main">=</span> <span class="main">(</span>marked_insertions <span class="main"><span class="hidden">❙</span><b>∧</b></span> marked_deletions <span class="main"><span class="hidden">❙</span><b>∧</b></span> reachable_snapshot_inv<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mutator_phase_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mutator_phase_inv</span> <span class="main">≡</span> mutator_phase_inv_aux <span class="main"><span class="hidden">❙</span><b>$</b></span> mut_ghost_hs_phase"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mutators_phase_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mutators_phase_inv</span> <span class="main">≡</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> mut_m.mutator_phase_inv <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This is what the GC guarantees. Read this as ``when the GC is at or
past the specified handshake, ... holds.''

›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">sys_phase_inv_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_phase <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv_aux</span> hp_Idle          <span class="main">=</span> <span class="main">(</span> <span class="main">(</span><span class="keyword1">If</span> sys_fA <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_fM <span class="keyword1">Then</span> black_heap <span class="keyword1">Else</span> white_heap<span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> no_grey_refs <span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv_aux</span> hp_IdleInit      <span class="main">=</span> no_black_refs"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv_aux</span> hp_InitMark      <span class="main">=</span> <span class="main">(</span>sys_fA <span class="main"><span class="hidden">❙</span><b>≠</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⟶</b></span> no_black_refs<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv_aux</span> hp_Mark          <span class="main">=</span> <span class="main">⟨</span>True<span class="main">⟩</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv_aux</span> hp_IdleMarkSweep <span class="main">=</span> <span class="main">(</span> <span class="main">(</span>sys_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> tso_pending_store gc <span class="main">(</span>mw_Phase ph_Idle<span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> no_grey_refs <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sys_phase_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_phase_inv</span> <span class="main">≡</span> sys_phase_inv_aux <span class="main"><span class="hidden">❙</span><b>$</b></span> sys_ghost_hs_phase"</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Writes to shared GC variables›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Relate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and writes to the phase in the GC's TSO buffer.

The first relation treats the case when the GC's TSO buffer does not
contain any writes to the phase.

The second relation exhibits the data race on the phase variable: we
need to precisely track the possible states of the GC's TSO buffer.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">handshake_phase_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hs_phase <span class="main">⇒</span> bool <span class="main">⇒</span> gc_phase <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">handshake_phase_rel</span> <span class="free"><span class="bound"><span class="entity">hp</span></span></span> <span class="free"><span class="bound"><span class="entity">in_sync</span></span></span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">hp</span></span></span> <span class="keyword1">of</span>
       hp_Idle          <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Idle
     <span class="main">|</span> hp_IdleInit      <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Idle <span class="main">∨</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">in_sync</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Init<span class="main">)</span>
     <span class="main">|</span> hp_InitMark      <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Init <span class="main">∨</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">in_sync</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Mark<span class="main">)</span>
     <span class="main">|</span> hp_Mark          <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Mark
     <span class="main">|</span> hp_IdleMarkSweep <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">=</span> ph_Mark <span class="main">∨</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">in_sync</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">ph</span></span></span> <span class="main">∈</span> <span class="main">{</span> ph_Idle<span class="main">,</span> ph_Sweep <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">phase_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">×</span> hs_phase <span class="main">×</span> gc_phase <span class="main">×</span> gc_phase <span class="main">×</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">phase_rel</span> <span class="main">=</span>
     <span class="main">(</span><span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> <span class="bound">hp</span><span class="main">,</span> <span class="bound">ph</span><span class="main">,</span> <span class="bound">ph</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">in_sync</span> <span class="bound">hp</span> <span class="bound">ph</span><span class="main">.</span> handshake_phase_rel <span class="bound">hp</span> <span class="bound">in_sync</span> <span class="bound">ph</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">(</span><span class="main">{</span>True<span class="main">}</span> <span class="main">×</span> <span class="main">{</span> <span class="main">(</span>hp_IdleInit<span class="main">,</span> ph_Init<span class="main">,</span> ph_Idle<span class="main">,</span> <span class="main">[</span>mw_Phase ph_Init<span class="main">]</span><span class="main">)</span><span class="main">,</span>
                  <span class="main">(</span>hp_InitMark<span class="main">,</span> ph_Mark<span class="main">,</span> ph_Init<span class="main">,</span> <span class="main">[</span>mw_Phase ph_Mark<span class="main">]</span><span class="main">)</span><span class="main">,</span>
                  <span class="main">(</span>hp_IdleMarkSweep<span class="main">,</span> ph_Sweep<span class="main">,</span> ph_Mark<span class="main">,</span> <span class="main">[</span>mw_Phase ph_Sweep<span class="main">]</span><span class="main">)</span><span class="main">,</span>
                  <span class="main">(</span>hp_IdleMarkSweep<span class="main">,</span> ph_Idle<span class="main">,</span> ph_Mark<span class="main">,</span> <span class="main">[</span>mw_Phase ph_Sweep<span class="main">,</span> mw_Phase ph_Idle<span class="main">]</span><span class="main">)</span><span class="main">,</span>
                  <span class="main">(</span>hp_IdleMarkSweep<span class="main">,</span> ph_Idle<span class="main">,</span> ph_Sweep<span class="main">,</span> <span class="main">[</span>mw_Phase ph_Idle<span class="main">]</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">phase_rel_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">phase_rel_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> gc_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_phase gc <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span>phase_rel<span class="main">⟩</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Similarly we track the validity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (respectively,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fA"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) wrt <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fA"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) and the
handshake phase. We also include the TSO lock to rule out the GC
having any pending marks during the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "hp_Idle"<span class="antiquote"><span class="antiquote">}</span></span></span></span> handshake
phase.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fM_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">×</span> hs_phase <span class="main">×</span> gc_mark <span class="main">×</span> gc_mark <span class="main">×</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action list <span class="main">×</span> bool<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fM_rel</span> <span class="main">=</span>
      <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> <span class="bound">hp</span><span class="main">,</span> <span class="bound">fM</span><span class="main">,</span> <span class="bound">fM</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span> <span class="main">|</span><span class="bound">fM</span> <span class="bound">hp</span> <span class="bound">in_sync</span> <span class="bound">l</span><span class="main">.</span> <span class="bound">hp</span> <span class="main">=</span> hp_Idle <span class="main">⟶</span> <span class="main">¬</span><span class="bound">in_sync</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_Idle<span class="main">,</span> <span class="bound">fM</span><span class="main">,</span> <span class="bound">fM'</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span> <span class="main">|</span><span class="bound">fM</span> <span class="bound">fM'</span> <span class="bound">in_sync</span> <span class="bound">l</span><span class="main">.</span> <span class="bound">in_sync</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_Idle<span class="main">,</span> <span class="main">¬</span><span class="bound">fM</span><span class="main">,</span> <span class="bound">fM</span><span class="main">,</span> <span class="main">[</span>mw_fM <span class="main">(</span><span class="main">¬</span><span class="bound">fM</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> False<span class="main">)</span> <span class="main">|</span><span class="bound">fM</span> <span class="bound">in_sync</span><span class="main">.</span> <span class="bound">in_sync</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fM_rel_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fM_rel_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> gc_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_fM gc <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span>sys_mem_lock <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>Some gc<span class="main">⟩</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span>fM_rel<span class="main">⟩</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fA_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">×</span> hs_phase <span class="main">×</span> gc_mark <span class="main">×</span> gc_mark <span class="main">×</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fA_rel</span> <span class="main">=</span>
      <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_Idle<span class="main">,</span>          <span class="bound">fA</span><span class="main">,</span>  <span class="bound">fM</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">fM</span> <span class="bound">in_sync</span><span class="main">.</span> <span class="main">¬</span><span class="bound">in_sync</span> <span class="main">⟶</span> <span class="bound">fA</span> <span class="main">=</span> <span class="bound">fM</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_IdleInit<span class="main">,</span>      <span class="bound">fA</span><span class="main">,</span> <span class="main">¬</span><span class="bound">fA</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">in_sync</span><span class="main">.</span> True <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_InitMark<span class="main">,</span>      <span class="bound">fA</span><span class="main">,</span> <span class="main">¬</span><span class="bound">fA</span><span class="main">,</span> <span class="main">[</span>mw_fA <span class="main">(</span><span class="main">¬</span><span class="bound">fA</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">in_sync</span><span class="main">.</span> <span class="bound">in_sync</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_InitMark<span class="main">,</span>      <span class="bound">fA</span><span class="main">,</span>  <span class="bound">fM</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">fM</span> <span class="bound">in_sync</span><span class="main">.</span> <span class="main">¬</span><span class="bound">in_sync</span> <span class="main">⟶</span> <span class="bound">fA</span> <span class="main">≠</span> <span class="bound">fM</span> <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_Mark<span class="main">,</span>          <span class="bound">fA</span><span class="main">,</span>  <span class="bound">fA</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">in_sync</span><span class="main">.</span> True <span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span><span class="bound">in_sync</span><span class="main">,</span> hp_IdleMarkSweep<span class="main">,</span> <span class="bound">fA</span><span class="main">,</span>  <span class="bound">fA</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">|</span><span class="bound">fA</span> <span class="bound">in_sync</span><span class="main">.</span> True <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fA_rel_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fA_rel_inv</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fA <span class="main"><span class="hidden">❙</span><b>⊗</b></span> gc_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_fA gc <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span>fA_rel<span class="main">⟩</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Worklist invariants \label{def:valid_W_inv}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The worklists track the grey objects. The following invariant asserts
that grey objects are marked on the heap except for a few steps near
the end of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the processes' worklists and
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ghost_honorary_grey"<span class="antiquote"><span class="antiquote">}</span></span></span></span>s are disjoint, and that pending marks
are sensible.

The safety of the collector does not to depend on disjointness; we
include it as proof that the single-threading of grey objects in the
implementation is sound.

Note that the phase invariants of \S\ref{sec:phase-invariants} limit
the scope of this invariant.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_W_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_W_inv</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">p</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="keyword1">in_W</span> <span class="bound">p</span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>sys_mem_lock <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>Some <span class="bound">p</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">r</span> <span class="keyword1">in_ghost_honorary_grey</span> <span class="bound">p</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="bound">r</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">p</span> <span class="bound">q</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">p</span> <span class="main">≠</span> <span class="bound">q</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> WL <span class="bound">p</span> <span class="main"><span class="hidden">❙</span><b>∩</b></span> WL <span class="bound">q</span> <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span><span class="main">{}</span><span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">p</span> <span class="bound">q</span> <span class="bound">r</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span><span class="bound">r</span> <span class="keyword1">in_ghost_honorary_grey</span> <span class="bound">p</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">r</span> <span class="keyword1">in_W</span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="keyword1">EMPTY</span> sys_ghost_honorary_grey<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">p</span> <span class="bound">r</span> <span class="bound">fl</span><span class="main">.</span> tso_pending_store <span class="bound">p</span> <span class="main">(</span>mw_Mark <span class="bound">r</span> <span class="bound">fl</span><span class="main">)</span>
       <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">⟨</span><span class="bound">fl</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_fM
         <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">r</span> <span class="keyword1">in_ghost_honorary_grey</span> <span class="bound">p</span>
         <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_locked_by <span class="bound">p</span>
         <span class="main"><span class="hidden">❙</span><b>∧</b></span> white <span class="bound">r</span>
         <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_pending_mark <span class="bound">p</span> <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span><span class="main">[</span>mw_Mark <span class="bound">r</span> <span class="bound">fl</span><span class="main">]</span><span class="main">⟩</span> <span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Coarse invariants about the stores a process can issue›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">gc_writes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_writes</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">of</span> mw_Mark <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> mw_Phase <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> mw_fM <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> mw_fA <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mut_writes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> mem_store_action <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_writes</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">of</span> mw_Mutate <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> mw_Mark <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tso_store_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tso_store_inv</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">w</span><span class="main">.</span>   tso_pending_store gc          <span class="bound">w</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">⟨</span>gc_writes <span class="bound">w</span><span class="main">⟩</span><span class="main">)</span>
   <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span> <span class="bound">w</span><span class="main">.</span> tso_pending_store <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span> <span class="bound">w</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">⟨</span>mut_writes <span class="bound">w</span><span class="main">⟩</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The global invariants collected›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invs</span> <span class="main">=</span>
   <span class="main">(</span>handshake_phase_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> strong_tricolour_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Initial conditions \label{sec:initial-conditions}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We ask that the GC and system initially agree on some things:
\begin{itemize}

\item All objects on the heap are marked (have their flags equal to
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and there are no grey references, i.e. the heap
  is uniformly black.

\item The GC and system have the same values for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"fA"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="quoted">"fM"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, etc. and the phase is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Idle</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

\item No process holds the TSO lock and all write buffers are empty.

\item All root-reachable references are backed by objects.

\end{itemize}
Note that these are merely sufficient initial conditions and can be
weakened.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> gc_system <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">initial_mark</span> <span class="main">::</span> <span class="quoted">gc_mark</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gc_initial_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lst_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_initial_state</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span>
    <span class="main">(</span>fM <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">initial_mark</span>
   <span class="main">∧</span> phase <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> ph_Idle
   <span class="main">∧</span> ghost_honorary_grey <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> W <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mut_initial_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lst_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_initial_state</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span>
    <span class="main">(</span>ghost_hs_phase <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> hp_IdleMarkSweep
   <span class="main">∧</span> ghost_honorary_grey <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> ghost_honorary_root <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> W <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sys_initial_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lst_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_initial_state</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="main">¬</span>hs_pending <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">m</span> <span class="main">∧</span> ghost_hs_in_sync <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">m</span><span class="main">)</span>
   <span class="main">∧</span> ghost_hs_phase <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> hp_IdleMarkSweep <span class="main">∧</span> hs_type <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> ht_GetRoots
   <span class="main">∧</span> obj_mark <span class="main">`</span> ran <span class="main">(</span>heap <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">initial_mark</span><span class="main">}</span>
   <span class="main">∧</span> fA <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">initial_mark</span>
   <span class="main">∧</span> fM <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free">initial_mark</span>
   <span class="main">∧</span> phase <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> ph_Idle
   <span class="main">∧</span> ghost_honorary_grey <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> W <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> mem_store_buffers <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">p</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span>
   <span class="main">∧</span> mem_lock <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">root_reachable</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">m</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">x</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_m.mut_roots <span class="bound">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_refs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_refs</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">y</span><span class="main">.</span> root_reachable <span class="bound">y</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> valid_ref <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gc_system_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_system_init</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> gc_initial_state <span class="main">(</span><span class="bound">s</span> gc<span class="main">)</span><span class="main">)</span>
     <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> mut_initial_state <span class="main">(</span><span class="bound">s</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sys_initial_state <span class="main">(</span><span class="bound">s</span> sys<span class="main">)</span><span class="main">)</span>
     <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The system consists of the programs and these constraints on the initial state.

›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">gc_system</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_system"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_system</span> <span class="main">≡</span> <span class="main">⦇</span>PGMs <span class="main">=</span> gc_coms<span class="main">,</span> INIT <span class="main">=</span> gc_system_init<span class="main">,</span> FAIR <span class="main">=</span> <span class="main">⟨</span>True<span class="main">⟩</span><span class="main">⦈</span>"</span></span> <span class="comment1">(* FIXME add fairness hypotheses *)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Local_Invariants">
<div class="head">
<h1>Theory Local_Invariants</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Local_Invariants
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Proofs_Basis.html">Proofs_Basis</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Local invariants \label{sec:local-invariants}›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹TSO invariants›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The GC holds the TSO lock only during the \texttt{CAS} in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mark_object›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="entity">tso_lock_locs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tso_lock_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span><span class="main">∈</span><span class="main">{</span> <span class="inner_quoted">''mo_co_cmark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_ctest''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_mark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_unlock''</span> <span class="main">}</span><span class="main">.</span> suffixed <span class="bound">l</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tso_lock_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tso_lock_invL</span> <span class="main">=</span>
    <span class="main">(</span>atS_gc tso_lock_locs      <span class="main">(</span>tso_locked_by gc<span class="main">)</span>
   <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc <span class="main">(</span><span class="main">-</span> tso_lock_locs<span class="main">)</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span> tso_locked_by gc<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

A mutator holds the TSO lock only during the \texttt{CAS}s in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mark_object›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tso_lock_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span><span class="main">∈</span><span class="main">{</span> <span class="inner_quoted">''mo_co_cmark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_ctest''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_mark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_unlock''</span> <span class="main">}</span><span class="main">.</span> suffixed <span class="bound">l</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tso_lock_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tso_lock_invL</span> <span class="main">=</span>
    <span class="main">(</span>atS_mut tso_lock_locs     <span class="main">(</span>tso_locked_by <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>
   <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut <span class="main">(</span><span class="main">-</span>tso_lock_locs<span class="main">)</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span>tso_locked_by <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Handshake phases \label{sec:local-handshake-phases}›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Connect <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span> with locations in the GC.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">idle_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''idle''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''init''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">mark_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''mark''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sweep_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''sweep''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">mark_loop_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''mark_loop''</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hp_Idle_locs</span> <span class="main">=</span>
    <span class="main">(</span>prefixed <span class="inner_quoted">''idle_noop''</span> <span class="main">-</span> <span class="main">{</span> idle_noop_mfence<span class="main">,</span> idle_noop_init_type <span class="main">}</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">{</span> idle_load_fM<span class="main">,</span> idle_invert_fM<span class="main">,</span> idle_store_fM<span class="main">,</span> idle_flip_noop_mfence<span class="main">,</span> idle_flip_noop_init_type <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hp_IdleInit_locs</span> <span class="main">=</span>
    <span class="main">(</span>prefixed <span class="inner_quoted">''idle_flip_noop''</span> <span class="main">-</span> <span class="main">{</span> idle_flip_noop_mfence<span class="main">,</span> idle_flip_noop_init_type <span class="main">}</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">{</span> idle_phase_init<span class="main">,</span> init_noop_mfence<span class="main">,</span> init_noop_init_type <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hp_InitMark_locs</span> <span class="main">=</span>
    <span class="main">(</span>prefixed <span class="inner_quoted">''init_noop''</span> <span class="main">-</span> <span class="main">{</span> init_noop_mfence<span class="main">,</span> init_noop_init_type <span class="main">}</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">{</span> init_phase_mark<span class="main">,</span> mark_load_fM<span class="main">,</span> mark_store_fA<span class="main">,</span> mark_noop_mfence<span class="main">,</span> mark_noop_init_type <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hp_IdleMarkSweep_locs</span> <span class="main">=</span>
    <span class="main">{</span> idle_noop_mfence<span class="main">,</span> idle_noop_init_type<span class="main">,</span> mark_end <span class="main">}</span>
  <span class="main">∪</span> sweep_locs
  <span class="main">∪</span> <span class="main">(</span>mark_loop_locs <span class="main">-</span> <span class="main">{</span> mark_loop_get_roots_init_type <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hp_Mark_locs</span> <span class="main">=</span>
    <span class="main">(</span>prefixed <span class="inner_quoted">''mark_noop''</span> <span class="main">-</span> <span class="main">{</span> mark_noop_mfence<span class="main">,</span> mark_noop_init_type <span class="main">}</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">{</span> mark_loop_get_roots_init_type <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hs_noop_prefixes</span> <span class="main">≡</span> <span class="main">{</span><span class="inner_quoted">''idle_noop''</span><span class="main">,</span> <span class="inner_quoted">''idle_flip_noop''</span><span class="main">,</span> <span class="inner_quoted">''init_noop''</span><span class="main">,</span> <span class="inner_quoted">''mark_noop''</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_noop_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_noop_prefixes<span class="main">.</span> prefixed <span class="bound">l</span> <span class="main">-</span> <span class="main">(</span>suffixed <span class="inner_quoted">''_noop_mfence''</span> <span class="main">∪</span> suffixed <span class="inner_quoted">''_noop_init_type''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_roots_locs</span> <span class="main">=</span>
  prefixed <span class="inner_quoted">''mark_loop_get_roots''</span> <span class="main">-</span> <span class="main">{</span>mark_loop_get_roots_init_type<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_work_locs</span> <span class="main">=</span>
  prefixed <span class="inner_quoted">''mark_loop_get_work''</span> <span class="main">-</span> <span class="main">{</span>mark_loop_get_work_init_type<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_prefixes</span> <span class="main">≡</span>
  hs_noop_prefixes <span class="main">∪</span> <span class="main">{</span> <span class="inner_quoted">''mark_loop_get_roots''</span><span class="main">,</span> <span class="inner_quoted">''mark_loop_get_work''</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_init_loop_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> prefixed <span class="main">(</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_loop''</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_done_loop_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> prefixed <span class="main">(</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_done_loop''</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_done_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> prefixed <span class="main">(</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_done''</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_none_pending_locs</span> <span class="main">=</span> <span class="main">-</span> <span class="main">(</span>hs_init_loop_locs <span class="main">∪</span> hs_done_locs<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_in_sync_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">-</span> <span class="main">(</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> prefixed <span class="main">(</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init''</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> hs_done_locs <span class="main">)</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_type''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_out_of_sync_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_muts''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_mut_in_muts_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_set_pending''</span><span class="main">,</span> <span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_done''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_init_loop_done_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_done''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_init_loop_not_done_locs</span> <span class="main">=</span>
  <span class="main">(</span>hs_init_loop_locs <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">l</span> <span class="main">∈</span> hs_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">l</span> <span class="main">@</span> <span class="inner_quoted">''_init_loop_done''</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">handshake_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">handshake_invL</span> <span class="main">=</span>
     <span class="main">(</span>atS_gc hs_noop_locs         <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_NOOP<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_get_roots_locs    <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetRoots<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_get_work_locs     <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetWork<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_mut_in_muts_locs      <span class="main">(</span>gc_mut <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_muts<span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_init_loop_locs        <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_muts <span class="main"><span class="hidden">❙</span><b>⟶</b></span> sys_hs_pending <span class="bound">m</span>
                                                                  <span class="main"><span class="hidden">❙</span><b>∨</b></span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_init_loop_not_done_locs <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span>   <span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_muts <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_hs_pending <span class="bound">m</span>
                                                                 <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_init_loop_done_locs     <span class="main">(</span> <span class="main">(</span>sys_hs_pending <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_mut
                                        <span class="main"><span class="hidden">❙</span><b>∨</b></span> sys_ghost_hs_in_sync <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_mut<span class="main">)</span>
                                      <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_muts <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>≠</b></span> gc_mut
                                                                 <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_hs_pending <span class="bound">m</span>
                                                                   <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span> <span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_done_locs       <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> sys_hs_pending <span class="bound">m</span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_done_loop_locs  <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">⟨</span><span class="bound">m</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_muts <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_hs_pending <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_none_pending_locs <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_hs_pending <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_in_sync_locs      <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hs_out_of_sync_locs  <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_hs_pending <span class="bound">m</span>
                                         <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_ghost_hs_in_sync <span class="bound">m</span><span class="main">)</span>

    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hp_Idle_locs          <span class="main">(</span>sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_Idle<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hp_IdleInit_locs      <span class="main">(</span>sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleInit<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hp_InitMark_locs      <span class="main">(</span>sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_InitMark<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hp_IdleMarkSweep_locs <span class="main">(</span>sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span><span class="main">)</span>
    <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc hp_Mark_locs          <span class="main">(</span>sys_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_Mark<span class="main">⟩</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Tie the garbage collector's control location to the value of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"gc_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="entity">no_pending_phase_locs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">no_pending_phase_locs</span> <span class="main">=</span>
       <span class="main">(</span>idle_locs <span class="main">-</span> <span class="main">{</span> idle_noop_mfence <span class="main">}</span><span class="main">)</span>
     <span class="main">∪</span> <span class="main">(</span>init_locs <span class="main">-</span> <span class="main">{</span> init_noop_mfence <span class="main">}</span><span class="main">)</span>
     <span class="main">∪</span> <span class="main">(</span>mark_locs <span class="main">-</span> <span class="main">{</span> mark_load_fM<span class="main">,</span> mark_store_fA<span class="main">,</span> mark_noop_mfence <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">phase_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">phase_invL</span> <span class="main">=</span>
   <span class="main">(</span>atS_gc idle_locs             <span class="main">(</span>gc_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc init_locs             <span class="main">(</span>gc_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Init<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc mark_locs             <span class="main">(</span>gc_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Mark<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc sweep_locs            <span class="main">(</span>gc_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Sweep<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc no_pending_phase_locs <span class="main">(</span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_phase gc<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Local handshake phase invariant for the mutators.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_noop_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''hs_noop_''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_roots_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''hs_get_roots_''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_work_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''hs_get_work_''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_pending_mutations_locs</span> <span class="main">=</span>
     <span class="main">{</span> hs_load_ht <span class="main">}</span>
  <span class="main">∪</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_noop''</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_get_roots''</span><span class="main">)</span>
  <span class="main">∪</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_get_work''</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_pending_loaded_locs</span> <span class="main">=</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_''</span> <span class="main">-</span> <span class="main">{</span> hs_load_pending <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_pending_locs</span> <span class="main">=</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_''</span> <span class="main">-</span> <span class="main">{</span> hs_load_pending<span class="main">,</span> hs_pending <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ht_loaded_locs</span> <span class="main">=</span> <span class="main">(</span>prefixed <span class="inner_quoted">''hs_''</span> <span class="main">-</span> <span class="main">{</span> hs_load_pending<span class="main">,</span> hs_pending<span class="main">,</span> hs_mfence<span class="main">,</span> hs_load_ht <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">handshake_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">handshake_invL</span> <span class="main">=</span>
  <span class="main">(</span>atS_mut hs_noop_locs                <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_NOOP<span class="main">⟩</span><span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_get_roots_locs          <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetRoots<span class="main">⟩</span><span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_get_work_locs           <span class="main">(</span>sys_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ht_GetWork<span class="main">⟩</span><span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut ht_loaded_locs             <span class="main">(</span>mut_hs_pending <span class="main"><span class="hidden">❙</span><b>⟶</b></span> mut_hs_type <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_hs_type<span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_pending_loaded_locs     <span class="main">(</span>mut_hs_pending <span class="main"><span class="hidden">❙</span><b>⟶</b></span> sys_hs_pending <span class="free">m</span><span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_pending_locs            <span class="main">(</span>mut_hs_pending<span class="main">)</span>
 <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut no_pending_mutations_locs  <span class="main">(</span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Validity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> wrt <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the handshake
phase. Effectively we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> as ghost state. We also
include the TSO lock to rule out the GC having any pending marks
during the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "hp_Idle"<span class="antiquote"><span class="antiquote">}</span></span></span></span> handshake phase.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fM_eq_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span> idle_store_fM<span class="main">,</span> idle_flip_noop_mfence <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fM_tso_empty_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span> idle_flip_noop_mfence <span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fA_tso_empty_locs</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span> mark_noop_mfence <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fA_eq_locs</span> <span class="main">=</span> <span class="main">{</span> idle_load_fM<span class="main">,</span> idle_invert_fM <span class="main">}</span>
              <span class="main">∪</span> prefixed <span class="inner_quoted">''idle_noop''</span>
              <span class="main">∪</span> <span class="main">(</span>mark_locs <span class="main">-</span> <span class="main">{</span> mark_load_fM<span class="main">,</span> mark_store_fA<span class="main">,</span> mark_noop_mfence <span class="main">}</span><span class="main">)</span>
              <span class="main">∪</span> sweep_locs"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fA_neq_locs</span> <span class="main">=</span> <span class="main">{</span> idle_phase_init<span class="main">,</span> idle_store_fM<span class="main">,</span> mark_load_fM<span class="main">,</span> mark_store_fA <span class="main">}</span>
               <span class="main">∪</span> prefixed <span class="inner_quoted">''idle_flip_noop''</span>
               <span class="main">∪</span> init_locs"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fM_fA_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fM_fA_invL</span> <span class="main">=</span>
   <span class="main">(</span>atS_gc fM_eq_locs                <span class="main">(</span>gc_fM <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_fM<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc idle_store_fM              <span class="main">(</span>gc_fM <span class="main"><span class="hidden">❙</span><b>≠</b></span> sys_fM<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc idle_flip_noop_mfence      <span class="main">(</span>sys_fM <span class="main"><span class="hidden">❙</span><b>≠</b></span> gc_fM <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_fM gc<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc fM_tso_empty_locs         <span class="main">(</span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_fM gc<span class="main">)</span><span class="main">)</span>

  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc fA_eq_locs                <span class="main">(</span>gc_fM <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_fA<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc fA_neq_locs               <span class="main">(</span>gc_fM <span class="main"><span class="hidden">❙</span><b>≠</b></span> sys_fA<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_noop_mfence           <span class="main">(</span>gc_fM <span class="main"><span class="hidden">❙</span><b>≠</b></span> sys_fA <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_fA gc<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc fA_tso_empty_locs         <span class="main">(</span><span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_fA gc<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Mark Object›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Local invariants for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Invoking this code in
phases where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is constant marks the reference in
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ref"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. When <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> could vary this code is not
called. The two cases are distinguished by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">p_ph_enabled</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Each use needs to provide extra facts to justify validity of
references, etc.  We do not include a post-condition for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span> here as it is different at each call site.

›</span></span>

<span class="keyword1"><span class="command">locale</span></span> mark_object <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'mut</span> process_name"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p_ph_enabled</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p_ph_enabled_eq_imp<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="free">p</span><span class="main">)</span> <span class="free">p_ph_enabled</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_cas_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> cas_mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_mark</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> mark <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_fM</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fM <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_ghost_hs_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_hs_phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_ghost_honorary_grey</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_honorary_grey <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_ghost_hs_in_sync</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ghost_hs_in_sync <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_phase</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> phase <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_ref</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ref <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_the_ref</span> <span class="main">≡</span> the <span class="main">∘</span> p_ref"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_W</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> W <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free">p</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">at_p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">at_p</span> <span class="free"><span class="bound"><span class="entity">l'</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> at <span class="free">p</span> <span class="main">(</span><span class="free">l</span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">l'</span></span></span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> LSTP <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_en_cond</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="free">p_ph_enabled</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_valid_ref</span> <span class="main">≡</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> p_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_ref <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_tso_no_pending_mark</span> <span class="main">≡</span> <span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_mark <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_tso_no_pending_mutate</span> <span class="main">≡</span> <span class="keyword1">LIST_NULL</span> <span class="main">(</span>tso_pending_mutate <span class="free">p</span><span class="main">)</span>"</span></span>

<span class="comment1">(* FIXME rename: these are assertions? *)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">p_valid_W_inv</span> <span class="main">≡</span> <span class="main">(</span><span class="main">(</span>p_cas_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>∨</b></span> p_tso_no_pending_mark<span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref<span class="main">)</span>
                <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span>tso_pending_mark <span class="free">p</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">{</span><span class="main">[]</span><span class="main">,</span> <span class="main">[</span>mw_Mark <span class="main">(</span>p_the_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>p_fM <span class="bound">s</span><span class="main">)</span><span class="main">]</span><span class="main">}</span><span class="main">)</span> <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">p_mark_inv</span> <span class="main">≡</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> p_mark
            <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> Some <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span> <span class="main">=</span> p_mark <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>p_the_ref <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>
              <span class="main"><span class="hidden">❙</span><b>∨</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">p_cas_mark_inv</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> Some <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span> <span class="main">=</span> p_cas_mark <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>p_the_ref <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p_valid_fM</span> <span class="main">≡</span> p_fM <span class="main"><span class="hidden">❙</span><b>=</b></span> sys_fM"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">p_ghg_eq_ref</span> <span class="main">≡</span> p_ghost_honorary_grey <span class="main"><span class="hidden">❙</span><b>=</b></span> pred_singleton <span class="main">(</span>the <span class="main">∘</span> p_ref<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">p_ghg_inv</span> <span class="main">≡</span> <span class="keyword1">If</span> p_cas_mark <span class="main"><span class="hidden">❙</span><b>=</b></span> p_mark <span class="keyword1">Then</span> p_ghg_eq_ref <span class="keyword1">Else</span> <span class="keyword1">EMPTY</span> p_ghost_honorary_grey"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mark_object_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mark_object_invL</span> <span class="main">=</span>
   <span class="main">(</span>at_p <span class="inner_quoted">''_mo_null''</span>        <span class="main">⟨</span>True<span class="main">⟩</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_mark''</span>        <span class="main">(</span>p_valid_ref<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_fM''</span>          <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_en_cond <span class="main">(</span>p_mark_inv<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_mtest''</span>       <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_en_cond <span class="main">(</span>p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_phase''</span>       <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> p_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_en_cond <span class="main">(</span>p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_ptest''</span>       <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> p_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_en_cond <span class="main">(</span>p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM<span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_lock''</span>     <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> p_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mark<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_cmark''</span>    <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> p_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mark<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_ctest''</span>    <span class="main">(</span>p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> Some <span class="main">∘</span> p_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_cas_mark_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mark<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_mark''</span>     <span class="main">(</span>p_cas_mark <span class="main"><span class="hidden">❙</span><b>=</b></span> p_mark <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> white <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mark<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_unlock''</span>   <span class="main">(</span>p_ghg_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_W_inv<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_won''</span>      <span class="main">(</span>p_ghg_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mutate<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_p <span class="inner_quoted">''_mo_co_W''</span>        <span class="main">(</span>p_ghg_eq_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_valid_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> p_the_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> p_tso_no_pending_mutate<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The uses of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in the GC and during the root
marking are straightforward.

›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> gc_mark<span class="main">:</span> mark_object <span class="quoted"><span class="quoted">"gc"</span></span> <span class="quoted"><span class="quoted">"gc.mark_loop"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>True<span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> gc_mark_mark_object_invL_def2<span class="main">[</span><span class="operator">inv</span><span class="main">]</span> <span class="main">=</span> gc_mark.mark_object_invL_def<span class="main">[</span><span class="operator">unfolded</span> loc_defs<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> loc_defs<span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> mut_get_roots<span class="main">:</span> mark_object <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"mut_m.hs_get_roots_loop"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>True<span class="main">⟩</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> mut_get_roots_mark_object_invL_def2<span class="main">[</span><span class="operator">inv</span><span class="main">]</span> <span class="main">=</span> mut_get_roots.mark_object_invL_def<span class="main">[</span><span class="operator">unfolded</span> loc_defs<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> loc_defs<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The most interesting cases are the two asynchronous uses of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in the mutators: we need something that holds even
before we read the phase. In particular we need to avoid interference
by an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> flip.

›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> mut_store_del<span class="main">:</span> mark_object <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted">''store_del''</span>"</span></span> <span class="quoted"><span class="quoted">"mut_m.mut_ghost_hs_phase <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>hp_Idle<span class="main">⟩</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span> <span class="comment1">(* FIXME store del, why the string? *)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> mut_store_del_mark_object_invL_def2<span class="main">[</span><span class="operator">inv</span><span class="main">]</span> <span class="main">=</span> mut_store_del.mark_object_invL_def<span class="main">[</span><span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> loc_defs<span class="main">]</span>

<span class="keyword1"><span class="command">interpretation</span></span> mut_store_ins<span class="main">:</span> mark_object <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"mut_m.store_ins"</span></span>  <span class="quoted"><span class="quoted">"mut_m.mut_ghost_hs_phase <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>hp_Idle<span class="main">⟩</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> mut_store_ins_mark_object_invL_def2<span class="main">[</span><span class="operator">inv</span><span class="main">]</span> <span class="main">=</span> mut_store_ins.mark_object_invL_def<span class="main">[</span><span class="operator">unfolded</span> loc_defs<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> loc_defs<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Local invariant for the mutator's uses of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>mark_object›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_roots_loop_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''hs_get_roots_loop''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_get_roots_loop_mo_locs</span> <span class="main">=</span>
  prefixed <span class="inner_quoted">''hs_get_roots_loop_mo''</span> <span class="main">∪</span> <span class="main">{</span>hs_get_roots_loop_done<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">mut_async_mark_object_prefixes</span> <span class="main">≡</span> <span class="main">{</span> <span class="inner_quoted">''store_del''</span><span class="main">,</span> <span class="inner_quoted">''store_ins''</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_not_hp_Idle_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">pref</span><span class="main">∈</span>mut_async_mark_object_prefixes<span class="main">.</span>
     <span class="main">⋃</span><span class="bound">l</span><span class="main">∈</span><span class="main">{</span><span class="inner_quoted">''mo_co_lock''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_cmark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_ctest''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_mark''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_unlock''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_won''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_W''</span><span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">pref</span> <span class="main">@</span> <span class="inner_quoted">''_''</span> <span class="main">@</span> <span class="bound">l</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">async_mo_ptest_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">pref</span><span class="main">∈</span>mut_async_mark_object_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">pref</span> <span class="main">@</span> <span class="inner_quoted">''_mo_ptest''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">mo_ptest_locs</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">⋃</span><span class="bound">pref</span><span class="main">∈</span>mut_async_mark_object_prefixes<span class="main">.</span> <span class="main">{</span><span class="bound">pref</span> <span class="main">@</span> <span class="inner_quoted">''_mo_ptest''</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">mo_valid_ref_locs</span> <span class="main">=</span>
  <span class="main">(</span>prefixed <span class="inner_quoted">''store_del''</span> <span class="main">∪</span> prefixed <span class="inner_quoted">''store_ins''</span> <span class="main">∪</span> <span class="main">{</span>deref_del<span class="main">,</span> lop_store_ins<span class="main">}</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This local invariant for the mutators illustrates the handshake
structure: we can rely on the insertion barrier earlier than on the
deletion barrier. Both need to be installed before <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_roots›</span></span></span></span>
to ensure we preserve the strong tricolour invariant. All black
objects at that point are allocated: we need to know that the
insertion barrier is installed to preserve it. This limits when <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fA›</span></span></span></span> can be set.

It is interesting to contrast the two barriers. Intuitively a mutator
can locally guarantee that it, in the relevant phases, will insert
only marked references. Less often can it be sure that the reference
it is overwriting is marked. We also need to consider stores pending
in TSO buffers: it is key that after the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>''init_noop''›</span></span></span></span>
handshake there are no pending white insertions
(mutations that insert unmarked references). This ensures the deletion barrier
does its job.

›</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ghost_honorary_grey_empty_locs</span> <span class="main">=</span>
     <span class="main">(</span><span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">pref</span><span class="main">∈</span><span class="main">{</span> <span class="inner_quoted">''hs_get_roots_loop''</span><span class="main">,</span> <span class="inner_quoted">''store_del''</span><span class="main">,</span> <span class="inner_quoted">''store_ins''</span> <span class="main">}</span><span class="main">.</span>
        <span class="main">⋃</span><span class="bound">l</span><span class="main">∈</span><span class="main">{</span> <span class="inner_quoted">''mo_co_unlock''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_won''</span><span class="main">,</span> <span class="inner_quoted">''mo_co_W''</span> <span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">pref</span> <span class="main">@</span> <span class="inner_quoted">''_''</span> <span class="main">@</span> <span class="bound">l</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ghost_honorary_root_empty_locs</span> <span class="main">=</span>
     <span class="main">(</span><span class="main">-</span> <span class="main">(</span>prefixed <span class="inner_quoted">''store_del''</span> <span class="main">∪</span> <span class="main">{</span>lop_store_ins<span class="main">}</span> <span class="main">∪</span> prefixed <span class="inner_quoted">''store_ins''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ghost_honorary_root_nonempty_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''store_del''</span> <span class="main">-</span> <span class="main">{</span>store_del_mo_null<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">not_idle_locs</span> <span class="main">=</span> suffixed <span class="inner_quoted">''_mo_ptest''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ins_barrier_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''store_ins''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">del_barrier1_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''store_del_mo''</span> <span class="main">∪</span> <span class="main">{</span>lop_store_ins<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mark_object_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mark_object_invL</span> <span class="main">=</span>
   <span class="main">(</span>atS_mut hs_get_roots_loop_locs        <span class="main">(</span>mut_refs <span class="main"><span class="hidden">❙</span><b>⊆</b></span> mut_roots <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">r</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots <span class="main"><span class="hidden">❙</span><b>-</b></span> mut_refs <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_get_roots_loop_mo_locs     <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mut_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_the_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut hs_get_roots_loop_done         <span class="main">(</span>marked <span class="main"><span class="hidden">❙</span><b>$</b></span> mut_the_ref<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut hs_get_roots_loop_mo_ptest     <span class="main">(</span>mut_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut hs_get_roots_done              <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">r</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="bound">r</span><span class="main">)</span>

  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut mo_valid_ref_locs             <span class="main">(</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mut_new_ref <span class="main"><span class="hidden">❙</span><b>⟶</b></span> mut_the_new_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots<span class="main">)</span>
                                          <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span>mut_tmp_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots<span class="main">)</span> <span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut store_del_mo_null              <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mut_ref <span class="main"><span class="hidden">❙</span><b>⟶</b></span> mut_the_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_ghost_honorary_root<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut ghost_honorary_root_nonempty_locs   <span class="main">(</span>mut_the_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_ghost_honorary_root<span class="main">)</span>

  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut not_idle_locs                 <span class="main">(</span>mut_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>hp_Idle<span class="main">⟩</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut hs_not_hp_Idle_locs           <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>hp_Idle<span class="main">⟩</span><span class="main">)</span>

  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut mo_ptest_locs                 <span class="main">(</span>mut_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span><span class="main">{</span>hp_Idle<span class="main">,</span> hp_IdleInit<span class="main">}</span><span class="main">⟩</span>
                                                                          <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span>
                                                                                <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut ghost_honorary_grey_empty_locs <span class="main">(</span><span class="keyword1">EMPTY</span> mut_ghost_honorary_grey<span class="main">)</span>
<span class="comment1">― ‹insertion barrier›</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut store_ins                      <span class="main">(</span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">⟨</span><span class="main">{</span>hp_InitMark<span class="main">,</span> hp_Mark<span class="main">}</span><span class="main">⟩</span>
                                            <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span><span class="main">)</span>
                                           <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mut_new_ref
                                           <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> mut_the_new_ref <span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut ins_barrier_locs              <span class="main">(</span> <span class="main">(</span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_Mark<span class="main">⟩</span>
                                              <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span><span class="main">)</span>
                                            <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">opt_r'</span><span class="main">.</span> <span class="main">¬</span>tso_pending_store <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mw_Mutate <span class="main">(</span>mut_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_field <span class="bound">s</span><span class="main">)</span> <span class="bound">opt_r'</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>
                                            <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> marked <span class="bound">r'</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_field <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span> <span class="main">)</span>
                                          <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span>mut_ref <span class="main"><span class="hidden">❙</span><b>=</b></span> mut_new_ref<span class="main">)</span> <span class="main">)</span>
<span class="comment1">― ‹deletion barrier›</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut del_barrier1_locs             <span class="main">(</span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_Mark<span class="main">⟩</span>
                                            <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span><span class="main">)</span>
                                           <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">opt_r'</span><span class="main">.</span> <span class="main">¬</span>tso_pending_store <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mw_Mutate <span class="main">(</span>mut_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_field <span class="bound">s</span><span class="main">)</span> <span class="bound">opt_r'</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>
                                          <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> mut_ref <span class="bound">s</span> <span class="main">=</span> Some <span class="bound">r</span> <span class="main">∨</span> marked <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>mut_field <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut lop_store_ins                  <span class="main">(</span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_Mark<span class="main">⟩</span>
                                             <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="main">(</span>mut_ghost_hs_phase <span class="main"><span class="hidden">❙</span><b>=</b></span> <span class="main">⟨</span>hp_IdleMarkSweep<span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase <span class="main"><span class="hidden">❙</span><b>≠</b></span> <span class="main">⟨</span>ph_Idle<span class="main">⟩</span><span class="main">)</span><span class="main">)</span>
                                           <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> mut_ref
                                          <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> mut_the_ref <span class="main">)</span>
<span class="comment1">―‹after <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>init_noop›</span></span>. key: no pending white insertions <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>at_mut hs_noop_done›</span></span> which we get from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹handshake_invL›<span class="antiquote">}</span></span>.›</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_mut mut_load                         <span class="main">(</span>mut_tmp_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> mut_roots<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_mut ghost_honorary_root_empty_locs  <span class="main">(</span><span class="keyword1">EMPTY</span> mut_ghost_honorary_root<span class="main">)</span> <span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The infamous termination argument›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We need to know that if the GC does not receive any further work to do
at <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_roots›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_work›</span></span></span></span>, then there are no grey
objects left. Essentially this encodes the stability property that
grey objects must exist for mutators to create grey objects.

Note that this is not invariant across the scan: it is possible for
the GC to hold all the grey references. The two handshakes transform
the GC's local knowledge that it has no more work to do into a global
property, or gives it more work.

›</span></span>

<span class="comment1">(* FIXME this is an assertion? *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">gc_W_empty_mut_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_W_empty_mut_inv</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="keyword1">EMPTY</span> sys_W <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_ghost_hs_in_sync <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> <span class="main">(</span>WL <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
   <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∃</b></span><span class="bound">m'</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span>sys_ghost_hs_in_sync <span class="bound">m'</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">EMPTY</span> <span class="main">(</span>WL <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="entity">gc_W_empty_locs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"location set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_W_empty_locs</span> <span class="main">=</span>
       idle_locs <span class="main">∪</span> init_locs <span class="main">∪</span> sweep_locs <span class="main">∪</span> <span class="main">{</span>mark_load_fM<span class="main">,</span> mark_store_fA<span class="main">,</span> mark_end<span class="main">}</span>
     <span class="main">∪</span> prefixed <span class="inner_quoted">''mark_noop''</span>
     <span class="main">∪</span> prefixed <span class="inner_quoted">''mark_loop_get_roots''</span>
     <span class="main">∪</span> prefixed <span class="inner_quoted">''mark_loop_get_work''</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_roots_UN_get_work_locs</span> <span class="main">=</span> hs_get_roots_locs <span class="main">∪</span> hs_get_work_locs"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">black_heap_locs</span> <span class="main">=</span> <span class="main">{</span>sweep_idle<span class="main">,</span> idle_noop_mfence<span class="main">,</span> idle_noop_init_type<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">no_grey_refs_locs</span> <span class="main">=</span> black_heap_locs <span class="main">∪</span> sweep_locs <span class="main">∪</span> <span class="main">{</span>mark_end<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gc_W_empty_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">gc_W_empty_invL</span> <span class="main">=</span>
   <span class="main">(</span>atS_gc get_roots_UN_get_work_locs   <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> mut_m.gc_W_empty_mut_inv <span class="bound">m</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop_get_roots_load_W    <span class="main">(</span><span class="keyword1">EMPTY</span> sys_W <span class="main"><span class="hidden">❙</span><b>⟶</b></span> no_grey_refs<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop_get_work_load_W     <span class="main">(</span><span class="keyword1">EMPTY</span> sys_W <span class="main"><span class="hidden">❙</span><b>⟶</b></span> no_grey_refs<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop                     <span class="main">(</span><span class="keyword1">EMPTY</span> gc_W <span class="main"><span class="hidden">❙</span><b>⟶</b></span> no_grey_refs<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc no_grey_refs_locs            no_grey_refs
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc gc_W_empty_locs              <span class="main">(</span><span class="keyword1">EMPTY</span> gc_W<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Sweep loop invariants›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sweep_loop_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''sweep_loop''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sweep_loop_not_choose_ref_locs</span> <span class="main">=</span> <span class="main">(</span>prefixed <span class="inner_quoted">''sweep_loop_''</span> <span class="main">-</span> <span class="main">{</span>sweep_loop_choose_ref<span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sweep_loop_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sweep_loop_invL</span> <span class="main">=</span>
   <span class="main">(</span>at_gc sweep_loop_check            <span class="main">(</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> gc_mark <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> Some <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span> <span class="main">=</span> gc_mark <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>gc_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
                                      <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span> <span class="keyword1">NULL</span> gc_mark <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_ref <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_tmp_ref <span class="main">)</span> <span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc sweep_loop_free             <span class="main">(</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> gc_mark <span class="main"><span class="hidden">❙</span><b>∧</b></span> the <span class="main">∘</span> gc_mark <span class="main"><span class="hidden">❙</span><b>≠</b></span> gc_fM <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> Some <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span> <span class="main">=</span> gc_mark <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>gc_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span> <span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc sweep_loop_ref_done         <span class="main">(</span>valid_ref <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_tmp_ref<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc sweep_loop_locs            <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">⟨</span><span class="bound">r</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_refs <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_ref <span class="bound">r</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="bound">r</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc black_heap_locs            <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">r</span><span class="main">.</span> valid_ref <span class="bound">r</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="bound">r</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc sweep_loop_not_choose_ref_locs <span class="main">(</span>gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_refs<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

For showing that the GC's use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mark_object_fn"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is correct.

When we take grey <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "tmp_ref"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to black, all of the objects it
points to are marked, ergo the new black does not point to white, and
so we preserve the strong tricolour invariant.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">obj_fields_marked</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">obj_fields_marked</span> <span class="main">=</span>
     <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">f</span><span class="main">.</span> <span class="main">⟨</span><span class="bound">f</span><span class="main">⟩</span> <span class="main"><span class="hidden">❙</span><b>∈</b></span> <span class="main">(</span><span class="main">-</span> gc_field_set<span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> marked <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>gc_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="bound">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">mark_loop_mo_locs</span> <span class="main">=</span> prefixed <span class="inner_quoted">''mark_loop_mo''</span>"</span></span>
<span class="keyword1"><span class="command">locset_definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">obj_fields_marked_good_ref_locs</span> <span class="main">=</span> mark_loop_mo_locs <span class="main">∪</span> <span class="main">{</span>mark_loop_mark_field_done<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ghost_honorary_grey_empty_locs</span> <span class="main">=</span>
     <span class="main">(</span><span class="main">-</span> <span class="main">{</span> mark_loop_mo_co_unlock<span class="main">,</span> mark_loop_mo_co_won<span class="main">,</span> mark_loop_mo_co_W <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locset_definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">obj_fields_marked_locs</span> <span class="main">=</span>
     <span class="main">{</span>mark_loop_mark_object_loop<span class="main">,</span> mark_loop_mark_choose_field<span class="main">,</span> mark_loop_mark_deref<span class="main">,</span> mark_loop_mark_field_done<span class="main">,</span> mark_loop_blacken<span class="main">}</span>
   <span class="main">∪</span> mark_loop_mo_locs"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">obj_fields_marked_invL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">inv</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">obj_fields_marked_invL</span> <span class="main">=</span>
    <span class="main">(</span>atS_gc obj_fields_marked_locs       <span class="main">(</span>obj_fields_marked <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_W<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc obj_fields_marked_good_ref_locs <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> gc_ref <span class="bound">s</span> <span class="main">=</span> Some <span class="bound">r</span> <span class="main">∨</span> marked <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>gc_tmp_ref <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>gc_field <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc mark_loop_mo_locs            <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">y</span><span class="main">.</span> <span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> gc_ref <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>gc_the_ref <span class="bound">s</span><span class="main">)</span> <span class="keyword1">reaches</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⟶</b></span> valid_ref <span class="bound">y</span><span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop_fields              <span class="main">(</span>gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>∈</b></span> gc_W<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop_mark_field_done     <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="keyword1">NULL</span> gc_ref <span class="main"><span class="hidden">❙</span><b>⟶</b></span> marked <span class="main"><span class="hidden">❙</span><b>$</b></span> gc_the_ref<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> at_gc mark_loop_blacken             <span class="main">(</span><span class="keyword1">EMPTY</span> gc_field_set<span class="main">)</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> atS_gc ghost_honorary_grey_empty_locs <span class="main">(</span><span class="keyword1">EMPTY</span> gc_ghost_honorary_grey<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ The local innvariants collected ›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> <span class="entity">invsL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invsL</span> <span class="main">=</span>
   <span class="main">(</span>fM_fA_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> <span class="entity">invsL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invsL</span> <span class="main">=</span>
   <span class="main">(</span>mark_object_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL
  <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invsL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invsL</span> <span class="main">=</span> <span class="main">(</span>gc.invsL <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>∀</b></span><span class="bound">m</span><span class="main">.</span> mut_m.invsL <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Tactics">
<div class="head">
<h1>Theory Tactics</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Tactics
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Proofs_Basis.html">Proofs_Basis</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ CIMP specialisation \label{sec:cimp-specialisation} ›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Hoare triples ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Specialise CIMP's pre/post validity to our system.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">valid_proc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred <span class="main">⇒</span> <span class="tfree">'mut</span> process_name <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> _ <span class="keyword1">⦃</span>_<span class="keyword1">⦄</span>"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">afts</span><span class="main">)</span> <span class="main">∈</span> vcg_fragments <span class="main">(</span>gc_coms <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">.</span> gc_coms<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="bound">afts</span> <span class="main">⊢</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">⦄</span> <span class="bound">c</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">⦄</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">valid_proc_inv_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred <span class="main">⇒</span> <span class="tfree">'mut</span> process_name <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⦃</span>_<span class="keyword1">⦄</span> _"</span> <span class="main">[</span>100<span class="main">,</span>0<span class="main">]</span> 100<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⦃</span></span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main"><span class="free">⦄</span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">⦄</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">⦄</span>"</span></span>

<span class="keyword1" id="Tactics-valid_pre"><span class="command">lemma</span></span> valid_pre<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">R</span><span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_proc_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> bspec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> vcg_pre<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Tactics-valid_conj_lift"><span class="command">lemma</span></span> valid_conj_lift<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">Q'</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>      <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">P</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free">P'</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">Q</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free">Q'</span><span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_proc_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_conj<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_pre<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> x<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> Ball_def valid_proc_def split_paired_All<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">simplified</span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">rule_format</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> vcg_pre<span class="main"><span class="main">[</span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> spec<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> y<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> Ball_def valid_proc_def split_paired_All<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">simplified</span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">rule_format</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Tactics-valid_all_lift"><span class="command">lemma</span></span> valid_all_lift<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⦃</span><span class="free">P</span> <span class="bound">x</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="free">Q</span> <span class="bound">x</span><span class="main">⦄</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">⦄</span> <span class="free">p</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_proc_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> vcg_all_lift<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Tactics ›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹ Model-specific ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following is unfortunately overspecialised to the GC. One might
hope for general tactics that work on all CIMP programs.

The system responds to all requests. The schematic variable is
instantiated with the semantics of the responses. Thanks to Thomas
Sewell for the hackery.

›</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> system_responds_actionE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="main">⦃</span><span class="free">l</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="free">action</span><span class="main">,</span> <span class="free">afts</span><span class="main">)</span> <span class="main">∈</span> fragments <span class="main">(</span>gc_coms <span class="free">p</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">action</span> <span class="free">x</span> <span class="free">s</span><span class="main">;</span>
     <span class="main">⟦</span> <span class="free">p</span> <span class="main">=</span> sys<span class="main">;</span> <span class="var">?P</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_com_interned_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">atomize</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∨</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> Q<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">action</span> <span class="skolem">p</span> <span class="skolem">k</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">p</span> <span class="skolem">k</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">action</span> <span class="skolem">p</span> <span class="skolem">k</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="skolem">p</span> <span class="skolem">k</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> conj_disj_distribR conj_assoc mem_Collect_eq <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> sys"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> system_responds_action_caseE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="main">⦃</span><span class="free">l</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="free">action</span><span class="main">,</span> <span class="free">afts</span><span class="main">)</span> <span class="main">∈</span> fragments <span class="main">(</span>gc_coms <span class="free">p</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">action</span> <span class="main">(</span><span class="free">pname</span><span class="main">,</span> <span class="free">req</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span>
     <span class="main">⟦</span> <span class="free">p</span> <span class="main">=</span> sys<span class="main">;</span> case_request_op <span class="var">?P1</span> <span class="var">?P2</span> <span class="var">?P3</span> <span class="var">?P4</span> <span class="var">?P5</span> <span class="var">?P6</span> <span class="var">?P7</span> <span class="var">?P8</span> <span class="var">?P9</span> <span class="var">?P10</span> <span class="var">?P11</span> <span class="var">?P12</span> <span class="var">?P13</span> <span class="var">?P14</span> <span class="free">req</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> system_responds_actionE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">req</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> request_op.simps prod.inject simp_thms fst_conv snd_conv if_cancel empty_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> empty_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> meta_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ TrueI<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> meta_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule_tac</span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">A</span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">∧</span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">B</span></span></span></span></span></span></span></span></span></span></span></span></span></span>"</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">A</span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem"><span class="skolem">B</span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> triv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> system_responds_action_specE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="main">⦃</span><span class="free">l</span><span class="main">⦄</span> <span class="keyword1">Response</span> <span class="free">action</span><span class="main">,</span> <span class="free">afts</span><span class="main">)</span> <span class="main">∈</span> fragments <span class="main">(</span>gc_coms <span class="free">p</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> <span class="free">action</span> <span class="free">x</span> <span class="free">s</span><span class="main">;</span>
     <span class="main">⟦</span> <span class="free">p</span> <span class="main">=</span> sys<span class="main">;</span> case_request_op <span class="var">?P1</span> <span class="var">?P2</span> <span class="var">?P3</span> <span class="var">?P4</span> <span class="var">?P5</span> <span class="var">?P6</span> <span class="var">?P7</span> <span class="var">?P8</span> <span class="var">?P9</span> <span class="var">?P10</span> <span class="var">?P11</span> <span class="var">?P12</span> <span class="var">?P13</span> <span class="var">?P14</span> <span class="main">(</span>snd <span class="free">x</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> system_responds_action_caseE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pname<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"fst <span class="free"><span class="free">x</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> req<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"snd <span class="free"><span class="free">x</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹ Locations›</span></span>

<span class="comment1">(* FIXME not automation friendly but used in some non-interference proofs *)</span>
<span class="keyword1" id="Tactics-atS_dests"><span class="command">lemma</span></span> atS_dests<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span><span class="main">;</span> atS <span class="free">p</span> <span class="free">ls'</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> atS <span class="free">p</span> <span class="main">(</span><span class="free">ls</span> <span class="main">∪</span> <span class="free">ls'</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span>atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span><span class="main">;</span> <span class="main">¬</span>atS <span class="free">p</span> <span class="free">ls'</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span>atS <span class="free">p</span> <span class="main">(</span><span class="free">ls</span> <span class="main">∪</span> <span class="free">ls'</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span>atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span><span class="main">;</span> atS <span class="free">p</span> <span class="free">ls'</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> atS <span class="free">p</span> <span class="main">(</span><span class="free">ls'</span> <span class="main">-</span> <span class="free">ls</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span>atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span><span class="main">;</span> at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> atS <span class="free">p</span> <span class="main">(</span><span class="main">{</span><span class="free">l</span><span class="main">}</span> <span class="main">-</span> <span class="free">ls</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_def<span class="main">)</span>

<span class="keyword1" id="Tactics-schematic_prem"><span class="command">lemma</span></span> schematic_prem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">Q</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* One way of instantiating a schematic prem. *)</span>
<span class="keyword1" id="Tactics-TrueE"><span class="command">lemma</span></span> TrueE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>True<span class="main">;</span> <span class="free">P</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Tactics-thin_locs_pre_discardE"><span class="command">lemma</span></span> thin_locs_pre_discardE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">p</span> <span class="free">l'</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span><span class="main">;</span> <span class="free">l'</span> <span class="main">≠</span> <span class="free">l</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span><span class="main">;</span> <span class="free">l</span> <span class="main">∉</span> <span class="free">ls</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> atS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Tactics-thin_locs_pre_keep_atE"><span class="command">lemma</span></span> thin_locs_pre_keep_atE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Tactics-thin_locs_pre_keep_atSE"><span class="command">lemma</span></span> thin_locs_pre_keep_atSE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> at <span class="free">p</span> <span class="free">l</span> <span class="free">s</span><span class="main">;</span> <span class="free">l</span> <span class="main">∈</span> <span class="free">ls</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> atS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* FIXME complete with symmetric rules on process names -- but probably not needed here *)</span>
<span class="keyword1" id="Tactics-thin_locs_post_discardE"><span class="command">lemma</span></span> thin_locs_post_discardE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∉</span> <span class="free">lfn</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> <span class="free">q</span><span class="main">⟧</span> <span class="main">⟹</span> at <span class="free">p</span> <span class="free">l'</span> <span class="free">s'</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∉</span> <span class="free">lfn</span><span class="main">⟧</span> <span class="main">⟹</span> at <span class="free">p</span> <span class="free">l'</span> <span class="free">s'</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">∈</span> <span class="free">lfn</span> <span class="main">⟹</span> <span class="bound">l</span> <span class="main">∉</span> <span class="free">ls</span><span class="main">;</span>  <span class="free">p</span> <span class="main">≠</span> <span class="free">q</span><span class="main">⟧</span> <span class="main">⟹</span> atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s'</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">∈</span> <span class="free">lfn</span> <span class="main">⟹</span> <span class="bound">l</span> <span class="main">∉</span> <span class="free">ls</span><span class="main">⟧</span> <span class="main">⟹</span> atS <span class="free">p</span> <span class="free">ls</span> <span class="free">s'</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> atS_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> thin_locs_post_discard_conjE <span class="main">=</span>
  conjI<span class="main">[</span><span class="operator">OF</span> thin_locs_post_discardE<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  conjI<span class="main">[</span><span class="operator">OF</span> thin_locs_post_discardE<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
  conjI<span class="main">[</span><span class="operator">OF</span> thin_locs_post_discardE<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span>
  conjI<span class="main">[</span><span class="operator">OF</span> thin_locs_post_discardE<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span>

<span class="keyword1" id="Tactics-thin_locs_post_keep_locsE"><span class="command">lemma</span></span> thin_locs_post_keep_locsE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="free">R</span><span class="main">;</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Tactics-thin_locs_post_keepE"><span class="command">lemma</span></span> thin_locs_post_keepE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span> <span class="main">∧</span> <span class="free">R</span><span class="main">;</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="free">L</span> <span class="main">⟶</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="comment1">(* FIXME checking the fun_upds are irrelevant is not necessary, but ensures the keep rule applies. *)</span>
<span class="comment1">(* FIXME consider atS (mutator m) mut_hs_get_roots_loop_locs s' -- same again but replace at proc l s' with atS proc ls s' *)</span>
<span class="comment1">(* FIXME in general we'd need to consider intersections *)</span>
<span class="keyword1" id="Tactics-ni_thin_locs_discardE"><span class="command">lemma</span></span> ni_thin_locs_discardE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l</span> <span class="main">≠</span> <span class="free">l'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l</span> <span class="main">≠</span> <span class="free">l'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∉</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∉</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> atS <span class="free">proc</span> <span class="free">ls'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l</span> <span class="main">∉</span> <span class="free">ls'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> atS <span class="free">proc</span> <span class="free">ls'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l</span> <span class="main">∉</span> <span class="free">ls'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="comment1">(*
  "⟦atS proc ls s ⟶ P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc l s'; l ∉ ls; proc ≠ p; proc ≠ q; Q⟧ ⟹ Q"
  "⟦atS proc ls s ⟶ P; AT s' = (AT s)(p := lfn); atS proc ls' s'; l ∉ ls; proc ≠ p; Q⟧ ⟹ Q"
*)</span>
<span class="keyword1"><span class="command">unfolding</span></span> atS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Tactics-ni_thin_locs_keep_atE"><span class="command">lemma</span></span> ni_thin_locs_keep_atE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l</span> <span class="free">s'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>at <span class="free">proc</span> <span class="free">l</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l</span> <span class="free">s'</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Tactics-ni_thin_locs_keep_atSE"><span class="command">lemma</span></span> ni_thin_locs_keep_atSE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∈</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> at <span class="free">proc</span> <span class="free">l'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">l'</span> <span class="main">∈</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">,</span> <span class="free">q</span> <span class="main">:=</span> <span class="free">lfn'</span><span class="main">)</span><span class="main">;</span> atS <span class="free">proc</span> <span class="free">ls'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">ls'</span> <span class="main">⊆</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">q</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>atS <span class="free">proc</span> <span class="free">ls</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">P</span><span class="main">;</span> AT <span class="free">s'</span> <span class="main">=</span> <span class="main">(</span>AT <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">lfn</span><span class="main">)</span><span class="main">;</span> atS <span class="free">proc</span> <span class="free">ls'</span> <span class="free">s'</span><span class="main">;</span> <span class="free">ls'</span> <span class="main">⊆</span> <span class="free">ls</span><span class="main">;</span> <span class="free">proc</span> <span class="main">≠</span> <span class="free">p</span><span class="main">;</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> atS_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Tactics-loc_mem_tac_intros"><span class="command">lemma</span></span> loc_mem_tac_intros<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">c</span> <span class="main">∉</span> <span class="free">A</span><span class="main">;</span> <span class="free">c</span> <span class="main">∉</span> <span class="free">B</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="free">d</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∉</span> <span class="main">{</span><span class="free">d</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> <span class="main">-</span> <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∉</span> <span class="main">-</span> <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="comment1">(* FIXME these rules are dangerous if any other sets are lying around. Specialise the types? *)</span>
<span class="keyword1"><span class="command">lemmas</span></span> loc_mem_tac_elims <span class="main">=</span>
  singletonE
  UnE

<span class="keyword1"><span class="command">lemmas</span></span> loc_mem_tac_simps <span class="main">=</span>
  append.simps list.simps rev.simps <span class="comment1">― ‹evaluate string equality›</span>
  char.inject cong_exp_iff_simps <span class="comment1">― ‹evaluate character equality›</span>
  prefix_code suffix_to_prefix
  simp_thms
  Eq_FalseI
  not_Cons_self

<span class="keyword1"><span class="command">lemmas</span></span> vcg_fragments'_simps <span class="main">=</span>
  valid_proc_def gc_coms.simps vcg_fragments'.simps atC.simps
  ball_Un bool_simps if_False if_True

<span class="keyword1"><span class="command">lemmas</span></span> vcg_sem_simps <span class="main">=</span>
  lconst.simps
  simp_thms
  True_implies_equals
  prod.simps fst_conv snd_conv
  gc_phase.simps process_name.simps hs_type.simps hs_phase.simps
  mem_store_action.simps mem_load_action.simps request_op.simps response.simps

<span class="keyword1"><span class="command">lemmas</span></span> vcg_inv_simps <span class="main">=</span>
  simp_thms

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">GC_VCG</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Internals *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> nuke_schematic_prems <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> loc_mem_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> vcg_fragments_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> vcg_sem_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> thin_pre_inv_tac <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> thin_post_inv_tac <span class="main">:</span> bool <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> vcg_inv_tac <span class="main">:</span> bool <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="comment1">(* End-user tactics *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> vcg_jackhammer_tac <span class="main">:</span> bool <span class="main">-&gt;</span> bool <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> vcg_chainsaw_tac <span class="main">:</span> bool <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> vcg_name_cases_tac <span class="main">:</span> term list <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> <span class="entity">context_tactic</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">GC_VCG</span> <span class="main">:</span> <span class="entity">GC_VCG</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Identify and remove schematic premises. FIXME reverses the prems *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nuke_schematic_prems</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_schematic_prem</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="inner_quoted">"HOL.Trueprop"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">is_schematic_prem</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">t</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">is_schematic_prem</span> <span class="entity">t</span>
      <span class="main">|</span> Var <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
  <span class="keyword2"><span class="keyword">in</span></span>
    DETERM o filter_prems_tac <span class="entity">ctxt</span> <span class="main">(</span>not o <span class="entity">is_schematic_prem</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* FIXME Want to unify only with a non-schematic prem. might get there with first order matching or some existing variant of assume. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assume_non_schematic_prem_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="main">(</span>TRY o <span class="entity">nuke_schematic_prems</span> <span class="entity">ctxt</span><span class="main">)</span> THEN' assume_tac <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_fragments_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">safe_simp_tac</span> <span class="main">(</span><span class="entity">ss_only</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> vcg_fragments'_simps<span class="antiquote">}</span></span></span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> all_com_interned_defs<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
                  THEN' SELECT_GOAL <span class="main">(</span><span class="entity">safe_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="comment1">(* FIXME split the goal, simplify the sets away. FIXME try to nuke safe_tac *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_sem_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> CIMP_vcg.vcg.intros<span class="antiquote">}</span></span></span>
                  THEN' <span class="main">(</span>TRY o <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> system_responds_action_specE<span class="antiquote">}</span></span></span> THEN' assume_tac <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
                  THEN' <span class="entity">Rule_Insts.thin_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"HST s = h"</span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> s<span class="antiquote">}</span></span></span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> h<span class="antiquote">}</span></span></span><span class="main">,</span> NONE<span class="main">,</span> NoSyn<span class="main">)</span><span class="main">]</span> <span class="comment1">(* discard history: we don't use it here *)</span>
                  THEN' <span class="entity">clarsimp_tac</span> <span class="main">(</span><span class="entity">ss_only</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> vcg_sem_simps<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span><span class="main">)</span>
           THEN_ALL_NEW <span class="entity">asm_simp_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="comment1">(* remove unused meta-bound vars FIXME subgoaler in HOL's usual simplifier setup, somehow lost by ss_only *)</span>

<span class="comment1">(* FIXME gingerly settle location set membership and (dis-)equalities *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">loc_defs</span> <span class="main">=</span> Proof_Context.get_fact <span class="entity">ctxt</span> <span class="main">(</span>Facts.named <span class="inner_quoted">"loc_defs"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span> <span class="main">(</span>TRY o REPEAT_ALL_NEW <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> loc_mem_tac_elims<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
               THEN_ALL_NEW <span class="main">(</span>TRY o <span class="entity">hyp_subst_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
               THEN_ALL_NEW <span class="main">(</span>TRY o REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> loc_mem_tac_intros<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
               THEN_ALL_NEW <span class="main">(</span> SOLVED' <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">named_theorems</span><span class="hidden">&gt;</span></span>‹locset_cache›</span><span class="main">)</span>
                               ORELSE' <span class="entity">safe_simp_tac</span> <span class="main">(</span><span class="entity">HOL_ss_only</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> loc_mem_tac_simps<span class="antiquote">}</span></span></span> @ <span class="entity">loc_defs</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">)</span> <span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thin_pre_inv_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span> <span class="comment1">(* FIXME trying to scope the REPEAT_DETERM ala [1] *)</span>
            <span class="main">(</span>REPEAT_DETERM o ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">)</span>
      THEN' <span class="main">(</span>REPEAT_DETERM o <span class="main">(</span> <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_pre_discardE<span class="antiquote">}</span></span></span>  THEN' assume_tac <span class="entity">ctxt</span> THEN' <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
                       ORELSE' <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_pre_keep_atE<span class="antiquote">}</span></span></span>  THEN' assume_tac <span class="entity">ctxt</span><span class="main">)</span>
                       ORELSE' <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_pre_keep_atSE<span class="antiquote">}</span></span></span> THEN' assume_tac <span class="entity">ctxt</span> THEN' <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(* FIXME redo keep_postE: if at loc is provable, discard the at antecedent, otherwise keep it *)</span>
<span class="comment1">(* if the post inv is an LSTP then the present fix is to say (no_thin_post_inv) -- would be good to automate that *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thin_post_inv_tac</span> <span class="entity">keep_locs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">keep_postE_thms</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">keep_locs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_post_keep_locsE<span class="antiquote">}</span></span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_post_keepE<span class="antiquote">}</span></span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nail_discard_prems_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">assume_non_schematic_prem_tac</span> <span class="entity">ctxt</span> THEN' <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span> THEN' <span class="main">(</span>TRY o match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span> <span class="comment1">(* FIXME trying to scope the REPEAT_DETERM ala [1] *)</span>
            resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> schematic_prem<span class="antiquote">}</span></span></span>
      THEN' REPEAT_DETERM o CHANGED o <span class="comment1">(* FIXME CHANGED? also check what happens for non-invL post invs -- aim to fail the ^^^ resolve_tac too *)</span>
              <span class="main">(</span> <span class="main">(</span>                                      match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_post_discard_conjE<span class="antiquote">}</span></span></span> THEN' <span class="entity">nail_discard_prems_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
        ORELSE' <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> TrueE<span class="antiquote">}</span></span></span> THEN' match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> thin_locs_post_discardE<span class="antiquote">}</span></span></span>      THEN' <span class="entity">nail_discard_prems_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
        ORELSE' eresolve_tac <span class="entity">ctxt</span> <span class="entity">keep_postE_thms</span> <span class="main">)</span>
  <span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_inv_tac</span> <span class="entity">keep_locs</span> <span class="entity">no_thin_post_inv</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">invs</span> <span class="main">=</span> <span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">named_theorems</span><span class="hidden">&gt;</span></span>‹inv›</span>
  <span class="keyword2"><span class="keyword">in</span></span>
          SELECT_GOAL <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="entity">invs</span><span class="main">)</span> <span class="comment1">(* FIXME trying to say unfold in [1] only *)</span>
    THEN' <span class="entity">thin_pre_inv_tac</span> <span class="entity">ctxt</span>
    THEN' <span class="main">(</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">no_thin_post_inv</span>
            <span class="keyword2"><span class="keyword">then</span></span> SELECT_GOAL all_tac <span class="comment1">(* full_simp_tac (ss_only @{thms vcg_inv_simps} ctxt) (* FIXME maybe not? *) *)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">full_simp_tac</span> <span class="main">(</span><span class="entity">Splitter.add_split</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> lcond_split_asm<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">ss_only</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> vcg_inv_simps<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
    THEN_ALL_NEW <span class="entity">thin_post_inv_tac</span> <span class="entity">keep_locs</span> <span class="entity">ctxt</span> <span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* For showing local invariants. FIXME tack on (no_thin_post_inv) for universal/LSTP ones *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_jackhammer_tac</span> <span class="entity">keep_locs</span> <span class="entity">no_thin_post_inv</span> <span class="entity">ctxt</span> <span class="main">=</span>
    SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">vcg_fragments_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
    THEN <span class="entity">PARALLEL_ALLGOALS</span> <span class="main">(</span>
                   <span class="entity">vcg_sem_tac</span> <span class="entity">ctxt</span>
      THEN_ALL_NEW <span class="entity">vcg_inv_tac</span> <span class="entity">keep_locs</span> <span class="entity">no_thin_post_inv</span> <span class="entity">ctxt</span>
      THEN_ALL_NEW <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">keep_locs</span> <span class="keyword2"><span class="keyword">then</span></span> SELECT_GOAL all_tac <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Rule_Insts.thin_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"AT _ = _"</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      THEN_ALL_NEW TRY o <span class="entity">clarsimp_tac</span> <span class="entity">ctxt</span> <span class="comment1">(* limply try to solve the remaining goals *)</span>
    <span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(* For showing noninterference *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_chainsaw_tac</span> <span class="entity">no_thin</span> <span class="entity">unfold_foreign_inv_thms</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">specialize_foreign_invs_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
                   <span class="comment1">(* FIXME split goal: makes sense because local procs control locs have changed? *)</span>
                       REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI<span class="antiquote">}</span></span></span><span class="main">)</span>
          THEN_ALL_NEW TRY o <span class="main">(</span> match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> impI<span class="antiquote">}</span></span></span> <span class="comment1">(* FIXME could tweak rules vvvv *)</span>
                          <span class="comment1">(* thin out the invariant we're showing non-interference for *)</span>
<span class="comment1">(* FIXME look for reasons to retain the invariant, then do a big thin_tac at the end.
Intuitively we don't have enough info to settle atS v atS questions and it's too hard/not informative enough to try.
Let the user do it.
Maybe add an info thing that tells what was thinned.

FIXME location-sensitive predicates are not amenable to
simplification: this is the cost of using projections on
pred_state. Instead use elimination rules ‹nie›.

 *)</span>
                         THEN' <span class="main">(</span> REPEAT_DETERM o <span class="main">(</span> <span class="main">(</span> ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ni_thin_locs_discardE<span class="antiquote">}</span></span></span>  THEN' assume_tac <span class="entity">ctxt</span> THEN' assume_tac <span class="entity">ctxt</span> THEN' <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span> THEN' match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> THEN' TRY o match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> <span class="main">)</span>
                                           ORELSE' <span class="main">(</span> ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ni_thin_locs_keep_atE<span class="antiquote">}</span></span></span>  THEN' assume_tac <span class="entity">ctxt</span> THEN' assume_tac <span class="entity">ctxt</span> THEN' match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> THEN' TRY o match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> <span class="main">)</span>
                                           ORELSE' <span class="main">(</span> ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ni_thin_locs_keep_atSE<span class="antiquote">}</span></span></span> THEN' assume_tac <span class="entity">ctxt</span> THEN' assume_tac <span class="entity">ctxt</span> THEN' <span class="entity">loc_mem_tac</span> <span class="entity">ctxt</span> THEN' match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> THEN' TRY o match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> process_name.simps<span class="antiquote">}</span></span></span> <span class="main">)</span> <span class="main">)</span> <span class="main">)</span> <span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    SELECT_GOAL <span class="main">(</span>HEADGOAL <span class="main">(</span><span class="entity">vcg_fragments_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
    THEN <span class="entity">PARALLEL_ALLGOALS</span> <span class="main">(</span>
                   <span class="entity">vcg_sem_tac</span> <span class="entity">ctxt</span>
                   <span class="comment1">(* nail cheaply with an nie fact + ambient clarsimp *)</span>
      THEN_ALL_NEW <span class="main">(</span> SOLVED' <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> nie<span class="antiquote">}</span></span><span class="main">)</span> THEN_ALL_NEW <span class="entity">clarsimp_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
             ORELSE' <span class="main">(</span> <span class="comment1">(* do it the hard way: specialise any process-specific invariants. Similar to vcg_jackhammer but not the same *)</span>
                       <span class="entity">vcg_inv_tac</span> false true <span class="entity">ctxt</span>
                       <span class="comment1">(* unfold the foreign inv *)</span>
                 THEN' SELECT_GOAL <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="entity">unfold_foreign_inv_thms</span><span class="main">)</span> <span class="comment1">(* FIXME trying to say [1] *)</span>
                 THEN' <span class="main">(</span>REPEAT_DETERM o ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span><span class="main">)</span>
                 THEN' <span class="entity">specialize_foreign_invs_tac</span> <span class="entity">ctxt</span>
                       <span class="comment1">(* limply try to solve the remaining goals; FIXME turn s' into s as much as easily possible *)</span>
          THEN_ALL_NEW <span class="main">(</span>TRY o <span class="entity">clarsimp_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
                       <span class="comment1">(* FIXME discard loc info. It is useful, this is a stopgap *)</span>
          THEN_ALL_NEW <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">no_thin</span> <span class="keyword2"><span class="keyword">then</span></span> SELECT_GOAL all_tac
                        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">Rule_Insts.thin_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"AT _ = _"</span> <span class="main">[</span><span class="main">]</span>
                THEN_ALL_NEW <span class="main">(</span>REPEAT_DETERM o <span class="entity">Rule_Insts.thin_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"at _ _ _ ⟶ _"</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
                THEN_ALL_NEW <span class="main">(</span>REPEAT_DETERM o <span class="entity">Rule_Insts.thin_tac</span> <span class="entity">ctxt</span> <span class="inner_quoted">"atS _ _ _ ⟶ _"</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">)</span><span class="main">)</span>
    <span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*

Scrutinise the goal state for an `AT` fact that tells us which label the process is at.

It seems this is not kosher:
 - for reasons unknown (Eisbach?) this tactic gets called with a bogus "TERM _" and then the real goal state.
 - this tactic (sometimes) does not work if used with THEN_ALL_NEW ';' --
   chk_label does not manage to uniquify labels -- so be sure to
   combine with ','.
 - if two goals have the same `at` location then we disambiguate, but
   perhaps not stably. Could imagine creating subcases, but
   `Method.goal_cases_tac` is not yet capable of that.
 - at communication steps we could get unlucky and choose the label from the other process.

The user can supply a list of process names to somewhat address these issues.

See Pure/Tools/rule_insts.ML for structurally similar tactics ("dynamic instantiation").

Limitations:
 - only works with `Const` labels
 - brittle: assumes things are very well-formed

*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">vcg_name_cases_tac</span> <span class="main">(</span><span class="entity">proc_names</span><span class="main">:</span> term list<span class="main">)</span> <span class="main">_</span><span class="comment1">(*facts*)</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Thm.nprems_of <span class="entity">st</span> <span class="main">=</span> <span class="inner_numeral">0</span>
  <span class="keyword2"><span class="keyword">then</span></span> Seq.empty <span class="comment1">(* no_tac *)</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fst_ord</span> <span class="entity">ord</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">x'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">snd_ord</span> <span class="entity">ord</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">y</span><span class="main">,</span> <span class="entity">y'</span><span class="main">)</span>

      <span class="comment1">(* FIXME this search is drecky *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_AT</span> <span class="main">(</span><span class="entity">t</span><span class="main">:</span> term<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>term * string<span class="main">)</span> option <span class="main">=</span>
            <span class="main">(</span> <span class="comment1">(* tracing ("scruting: " ^ Syntax.string_of_term ctxt t) ; *)</span>
              <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="inner_quoted">"HOL.Trueprop"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "Set.member"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Const <span class="main">(</span><span class="entity">l</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "CIMP_lang.AT"<span class="antiquote">}</span></span><span class="main">,</span>  <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="entity">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="comment1">(* tracing "HIT"; *)</span> SOME <span class="main">(</span><span class="entity">p</span><span class="main">,</span> Long_Name.base_name <span class="entity">l</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> Const <span class="main">(</span><span class="inner_quoted">"HOL.Trueprop"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "CIMP_lang.atS"<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">p</span> $ Const <span class="main">(</span><span class="entity">ls</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="comment1">(* tracing "HIT"; *)</span> SOME <span class="main">(</span><span class="entity">p</span><span class="main">,</span> Long_Name.base_name <span class="entity">ls</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE <span class="main">)</span>

      <span class="comment1">(* FIXME Isabelle makes it awkward to use polymorphic process names; paper over that crack here *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="keyword1"><span class="keyword">rec</span></span> <span class="entity">terms_eq_ignoring_types</span> <span class="main">=</span>
          <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">c0</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">c1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> fast_string_ord <span class="main">(</span><span class="entity">c0</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span> <span class="main">=</span> EQUAL
           <span class="main">|</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">f0</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span>  Free <span class="main">(</span><span class="entity">f1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span>  <span class="main">=&gt;</span> fast_string_ord <span class="main">(</span><span class="entity">f0</span><span class="main">,</span> <span class="entity">f1</span><span class="main">)</span> <span class="main">=</span> EQUAL
           <span class="main">|</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">v0</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">,</span> Var <span class="main">(</span><span class="entity">v1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> prod_ord fast_string_ord int_ord <span class="main">(</span><span class="entity">v0</span><span class="main">,</span> <span class="entity">v1</span><span class="main">)</span> <span class="main">=</span> EQUAL
           <span class="main">|</span> <span class="main">(</span>Bound <span class="entity">i0</span><span class="main">,</span> Bound <span class="entity">i1</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">i0</span> <span class="main">=</span> <span class="entity">i1</span>
           <span class="main">|</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">b0</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t0</span><span class="main">)</span><span class="main">,</span> Abs <span class="main">(</span><span class="entity">b1</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> fast_string_ord <span class="main">(</span><span class="entity">b0</span><span class="main">,</span> <span class="entity">b1</span><span class="main">)</span> <span class="main">=</span> EQUAL <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">terms_eq_ignoring_types</span> <span class="main">(</span><span class="entity">t0</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span>
           <span class="main">|</span> <span class="main">(</span><span class="entity">t0</span> $ <span class="entity">u0</span><span class="main">,</span> <span class="entity">t1</span> $ <span class="entity">u1</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">terms_eq_ignoring_types</span> <span class="main">(</span><span class="entity">t0</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">terms_eq_ignoring_types</span> <span class="main">(</span><span class="entity">u0</span><span class="main">,</span> <span class="entity">u1</span><span class="main">)</span>
           <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_label</span> <span class="main">(</span><span class="entity">default</span><span class="main">:</span> string<span class="main">)</span> <span class="main">(</span><span class="entity">ats</span> <span class="main">:</span> <span class="main">(</span>term * string<span class="main">)</span> list<span class="main">)</span> <span class="main">:</span> string <span class="main">=</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">ats</span><span class="main">,</span> <span class="entity">proc_names</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">l</span><span class="main">)</span>::<span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="comment1">(* tracing ("No proc_names, Using label: " ^ l); *)</span> <span class="entity">l</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ls</span> <span class="main">=</span> List.mapPartial <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">p</span> <span class="main">=&gt;</span> List.find <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">p'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">terms_eq_ignoring_types</span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">p'</span><span class="main">)</span><span class="main">)</span> <span class="entity">ats</span><span class="main">)</span> <span class="entity">proc_names</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ls</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span>warning <span class="main">(</span><span class="inner_quoted">"vcg_name_cases: using the default name: "</span> ^ <span class="entity">default</span><span class="main">)</span><span class="main">;</span> <span class="entity">default</span><span class="main">)</span>
                <span class="main">|</span> <span class="main">_</span>  <span class="main">=&gt;</span> <span class="entity">ls</span> |&gt; List.map snd |&gt; String.concatWith <span class="inner_quoted">"_"</span>
              <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">labels_for_cases</span> <span class="main">(</span><span class="entity">i</span><span class="main">:</span> int<span class="main">)</span> <span class="main">(</span><span class="entity">acc</span><span class="main">:</span> <span class="main">(</span>int * string<span class="main">)</span> list<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>int * string<span class="main">)</span> list <span class="main">=</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="inner_numeral">0</span> <span class="main">=&gt;</span> <span class="entity">acc</span>
            <span class="main">|</span> <span class="entity">i</span> <span class="main">=&gt;</span> Thm.cprem_of <span class="entity">st</span> <span class="entity">i</span> |&gt; Thm.term_of |&gt; Logic.strip_assums_hyp
                   |&gt; List.mapPartial <span class="entity">find_AT</span> |&gt; <span class="entity">mk_label</span> <span class="main">(</span>Int.toString <span class="entity">i</span><span class="main">)</span>
                   |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">l</span> <span class="main">=&gt;</span> <span class="entity">labels_for_cases</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">l</span><span class="main">)</span> :: <span class="entity">acc</span><span class="main">)</span><span class="main">)</span>

        <span class="comment1">(* Make the labels unique if need be *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">uniquify</span> <span class="main">(</span><span class="entity">i</span><span class="main">:</span> int<span class="main">)</span> <span class="main">(</span><span class="entity">ls</span><span class="main">:</span> <span class="main">(</span>int * string<span class="main">)</span> list<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>int * string<span class="main">)</span> list <span class="main">=</span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ls</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">[</span><span class="entity">l</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">l</span><span class="main">]</span>
        <span class="main">|</span> <span class="entity">l</span> :: <span class="entity">l'</span> :: <span class="entity">ls</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> fast_string_ord <span class="main">(</span>snd <span class="entity">l</span><span class="main">,</span> snd <span class="entity">l'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
                             EQUAL <span class="main">=&gt;</span> <span class="main">(</span>fst <span class="entity">l</span><span class="main">,</span> snd <span class="entity">l</span> ^ Int.toString <span class="entity">i</span><span class="main">)</span> :: <span class="entity">uniquify</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="entity">l'</span> :: <span class="entity">ls</span><span class="main">)</span>
                           <span class="main">|</span> <span class="main">_</span>     <span class="main">=&gt;</span> <span class="entity">l</span> :: <span class="entity">uniquify</span> <span class="inner_numeral">0</span> <span class="main">(</span><span class="entity">l'</span> :: <span class="entity">ls</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">labels</span> <span class="main">=</span> <span class="entity">labels_for_cases</span> <span class="main">(</span>Thm.nprems_of <span class="entity">st</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">labels</span> <span class="main">=</span> <span class="entity">labels</span>
                |&gt; sort <span class="main">(</span><span class="entity">snd_ord</span> fast_string_ord<span class="main">)</span> |&gt; <span class="entity">uniquify</span> <span class="inner_numeral">0</span> |&gt; sort <span class="main">(</span><span class="entity">fst_ord</span> int_ord<span class="main">)</span>
                |&gt; List.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">l</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="comment1">(* tracing ("label: " ^ l); *)</span> <span class="entity">l</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Method.goal_cases_tac</span> <span class="entity">labels</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> loc_mem<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.loc_mem_tac</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"solve location membership goals"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_fragments<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.vcg_fragments_tac</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"unfold com defs, execute vcg_fragments' and split goals"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_sem<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.vcg_sem_tac</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"reduce VCG goal to semantics and clarsimp"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_inv<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.lift <span class="main">(</span>Args.mode <span class="inner_quoted">"keep_locs"</span> -- Args.mode <span class="inner_quoted">"no_thin_post_inv"</span><span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">keep_locs</span><span class="main">,</span> <span class="entity">no_thin_post_inv</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.vcg_inv_tac</span> <span class="entity">keep_locs</span> <span class="entity">no_thin_post_inv</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"specialise the invariants to the goal. (keep_locs) retains locs in post conds"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_jackhammer<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.lift <span class="main">(</span>Args.mode <span class="inner_quoted">"keep_locs"</span> -- Args.mode <span class="inner_quoted">"no_thin_post_inv"</span><span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">keep_locs</span><span class="main">,</span> <span class="entity">no_thin_post_inv</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.vcg_jackhammer_tac</span> <span class="entity">keep_locs</span> <span class="entity">no_thin_post_inv</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"VCG tactic. (keep_locs) retains locs in post conds. (no_thin_post_inv) does not attempt to specalise the post condition."</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_chainsaw<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.lift <span class="main">(</span>Args.mode <span class="inner_quoted">"no_thin"</span><span class="main">)</span> -- <span class="entity">Attrib.thms</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">no_thin</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> o <span class="entity">GC_VCG.vcg_chainsaw_tac</span> <span class="entity">no_thin</span> <span class="entity">thms</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"VCG non-interference tactic. Tell it how to unfold the foreign local invs."</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  Theory.setup <span class="main">(</span><span class="entity">Method.setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> vcg_name_cases<span class="antiquote">}</span></span></span>
    <span class="main">(</span>Scan.repeat Args.term &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">proc_names</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">CONTEXT_METHOD</span> <span class="main">(</span><span class="entity">GC_VCG.vcg_name_cases_tac</span> <span class="entity">proc_names</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="inner_quoted">"divine canonical case names for outstanding VCG goals"</span><span class="main">)</span>

›</span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Global_Invariants_Lemmas">
<div class="head">
<h1>Theory Global_Invariants_Lemmas</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Global_Invariants_Lemmas
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants.html">Global_Invariants</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> subst_all <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Global invariants lemma bucket›</span></span>

<span class="comment1">(* FIXME this file should be about the invs. This split makes it easier to move things around, maybe. *)</span>

<span class="keyword1"><span class="command">declare</span></span> mut_m.mutator_phase_inv_aux.simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
<span class="keyword1"><span class="command">case_of_simps</span></span> mutator_phase_inv_aux_case<span class="main">:</span> mut_m.mutator_phase_inv_aux.simps
<span class="keyword1"><span class="command">case_of_simps</span></span> sys_phase_inv_aux_case<span class="main">:</span> sys_phase_inv_aux.simps


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹TSO invariants›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_store_inv_eq_imp"><span class="command">lemma</span></span> tso_store_inv_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">p</span> <span class="bound">s</span><span class="main">.</span> mem_store_buffers <span class="main">(</span><span class="bound">s</span> sys<span class="main">)</span> <span class="bound">p</span><span class="main">)</span>
          tso_store_inv"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def tso_store_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> tso_store_inv_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> tso_store_inv_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_store_invD"><span class="command">lemma</span></span> tso_store_invD<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers gc <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers gc <span class="free">s</span> <span class="main">=</span> mw_Mutate_Payload <span class="free">r</span> <span class="free">f</span> <span class="free">pl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_fA <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_fM <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Phase <span class="free">ph</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tso_store_inv_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">m</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-mut_do_store_action"><span class="command">lemma</span></span> mut_do_store_action<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> tso_store_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> fA <span class="main">(</span>do_store_action <span class="free">w</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span> <span class="main">=</span> sys_fA <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> tso_store_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> fM <span class="main">(</span>do_store_action <span class="free">w</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span> <span class="main">=</span> sys_fM <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">w</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> tso_store_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> phase <span class="main">(</span>do_store_action <span class="free">w</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span> <span class="main">=</span> sys_phase <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_store_inv_sys_load_Mut"><span class="command">lemma</span></span> tso_store_inv_sys_load_Mut<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ract</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span> <span class="main">(</span>mr_fM<span class="main">,</span> mv_Mark <span class="main">(</span>Some <span class="main">(</span>sys_fM <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>mr_fA<span class="main">,</span> mv_Mark <span class="main">(</span>Some <span class="main">(</span>sys_fA <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>mr_Phase<span class="main">,</span> mv_Phase <span class="main">(</span>sys_phase <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">ract</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sys_load_def fold_stores_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> do_load_action <span class="free"><span class="free">ract</span></span> <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">v</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"mut_writes"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tso_store_inv_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_load_action_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_store_inv_sys_load_GC"><span class="command">lemma</span></span> tso_store_inv_sys_load_GC<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tso_store_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sys_load gc <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="main">(</span>Option.bind <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_fields <span class="bound">obj</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> mv_Ref <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> sys_load_def fold_stores_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> Option.bind <span class="main"><span class="main">(</span></span>heap <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">obj</span></span><span class="main"><span class="main">.</span></span> obj_fields <span class="bound"><span class="bound">obj</span></span> <span class="free"><span class="free">f</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="var"><span class="var">?rhs</span></span>"</span></span></span>
                             <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">r</span></span> <span class="bound"><span class="bound">f</span></span> <span class="bound"><span class="bound">r'</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">≠</span></span> mw_Mutate <span class="bound"><span class="bound">r</span></span> <span class="bound"><span class="bound">f</span></span> <span class="bound"><span class="bound">r'</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tso_store_inv_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def map_option_case fun_upd_apply
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_no_pending_marksD"><span class="command">lemma</span></span> tso_no_pending_marksD<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tso_pending_mark <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sys_load <span class="free">p</span> <span class="main">(</span>mr_Mark <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Mark <span class="main">(</span>map_option obj_mark <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> sys_load_def fold_stores_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> map_option obj_mark <span class="main"><span class="main">(</span></span>heap <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> map_option obj_mark <span class="main"><span class="main">(</span></span>sys_heap <span class="free"><span class="free">s</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
                             <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">fl</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">≠</span></span> mw_Mark <span class="free"><span class="free">r</span></span> <span class="bound"><span class="bound">fl</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_option_case do_store_action_def filter_empty_conv fun_upd_apply
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_pending_phase_sys_load"><span class="command">lemma</span></span> no_pending_phase_sys_load<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tso_pending_phase <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sys_load <span class="free">p</span> mr_Phase <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Phase <span class="main">(</span>sys_phase <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sys_load_def fold_stores_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> phase <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> sys_phase <span class="free"><span class="free">s</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">ph</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">≠</span></span> mw_Phase <span class="bound"><span class="bound">ph</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-gc_no_pending_fM_write"><span class="command">lemma</span></span> gc_no_pending_fM_write<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tso_pending_fM gc <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sys_load gc mr_fM <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Mark <span class="main">(</span>Some <span class="main">(</span>sys_fM <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sys_load_def fold_stores_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> fM <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> sys_fM <span class="free"><span class="free">s</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">fl</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">≠</span></span> mw_fM <span class="bound"><span class="bound">fl</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_store_refs_simps"><span class="command">lemma</span></span> tso_store_refs_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
                             sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">]</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">then</span> store_refs <span class="main">(</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate_Payload <span class="free">r</span> <span class="free">f</span> <span class="free">pl</span><span class="main">]</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">then</span> store_refs <span class="main">(</span>mw_Mutate_Payload <span class="free">r</span> <span class="free">f</span> <span class="free">pl</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> insert <span class="free">r</span> <span class="main">(</span>roots <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r</span> <span class="main">↦</span> <span class="free">obj</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> Option.set_option <span class="free">opt_r'</span><span class="main">,</span> ref <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                          mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="main">=</span> mutator <span class="free">m</span> <span class="keyword1">then</span> <span class="main">⋃</span><span class="bound">w</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">.</span> store_refs <span class="bound">w</span> <span class="keyword1">else</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_payload <span class="main">:=</span> <span class="main">(</span>obj_payload <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">pl</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                          mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="main">=</span> mutator <span class="free">m</span> <span class="keyword1">then</span> <span class="main">⋃</span><span class="bound">w</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">.</span> store_refs <span class="bound">w</span> <span class="keyword1">else</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>
<span class="main">⟹</span> mut_m.tso_store_refs <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
 <span class="main">=</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.tso_store_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-fold_stores_points_to"><span class="command">lemma</span></span> fold_stores_points_to<span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">simplified</span> conj_explode<span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"heap <span class="main">(</span>fold_stores <span class="free">ws</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> Some <span class="free">obj</span> <span class="main">∧</span> obj_fields <span class="free">obj</span> <span class="free">f</span> <span class="main">=</span> Some <span class="free">r'</span>
     <span class="main">⟶</span> <span class="main">(</span><span class="free">r</span> <span class="keyword1">points_to</span> <span class="free">r'</span><span class="main">)</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">.</span> <span class="free">r'</span> <span class="main">∈</span> store_refs <span class="bound">w</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>fold_stores <span class="free">ws</span><span class="main">)</span> <span class="free">obj</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> fold_stores_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fold_invariant<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">obj</span></span><span class="main"><span class="main">.</span></span> <span class="var"><span class="var">?P</span></span> <span class="bound"><span class="bound">fr</span></span> <span class="bound"><span class="bound">obj</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span> Q<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">∈</span></span> set <span class="free"><span class="free">ws</span></span>"</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> bspec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.split_asm if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-points_to_Mutate"><span class="command">lemma</span></span> points_to_Mutate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span>
         <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                            mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> <span class="main">(</span><span class="free">r</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">∧</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∧</span> valid_ref <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="free">opt_r'</span> <span class="main">=</span> Some <span class="free">y</span> <span class="main">∨</span> <span class="main">(</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span> <span class="main">∧</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="main">∃</span><span class="bound">f'</span><span class="main">.</span> obj_fields <span class="bound">obj</span> <span class="bound">f'</span> <span class="main">=</span> Some <span class="free">y</span> <span class="main">∧</span> <span class="free">f</span> <span class="main">≠</span> <span class="bound">f'</span><span class="main">)</span> <span class="free">r</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ FIXME mutator handshake facts ›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="comment1">― ‹Sanity›</span>
  <span class="quoted"><span class="quoted">"<span class="free">hp'</span> <span class="main">=</span> hs_step <span class="free">hp</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">in'</span> <span class="bound">ht</span><span class="main">.</span> <span class="main">(</span><span class="bound">in'</span><span class="main">,</span> <span class="bound">ht</span><span class="main">,</span> <span class="free">hp'</span><span class="main">,</span> <span class="free">hp</span><span class="main">)</span> <span class="main">∈</span> hp_step_rel"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">hp</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="comment1">― ‹Sanity›</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>False<span class="main">,</span> <span class="free">ht</span><span class="main">,</span> <span class="free">hp'</span><span class="main">,</span> <span class="free">hp</span><span class="main">)</span> <span class="main">∈</span> hp_step_rel <span class="main">⟹</span> <span class="free">hp'</span> <span class="main">=</span> hp_step <span class="free">ht</span> <span class="free">hp</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ht</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> handshake_phase_invD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"handshake_phase_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sys_ghost_hs_in_sync <span class="free">m</span> <span class="free">s</span><span class="main">,</span> sys_hs_type <span class="free">s</span><span class="main">,</span> sys_ghost_hs_phase <span class="free">s</span><span class="main">,</span> mut_ghost_hs_phase <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> hp_step_rel
       <span class="main">∧</span> <span class="main">(</span>sys_hs_pending <span class="free">m</span> <span class="free">s</span> <span class="main">⟶</span> <span class="main">¬</span>sys_ghost_hs_in_sync <span class="free">m</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> handshake_phase_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-handshake_in_syncD"><span class="command">lemma</span></span> handshake_in_syncD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> All <span class="main">(</span>ghost_hs_in_sync <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">;</span> handshake_phase_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">∀</span><span class="bound">m'</span><span class="main">.</span> mut_m.mut_ghost_hs_phase <span class="bound">m'</span> <span class="free">s</span> <span class="main">=</span> sys_ghost_hs_phase <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mut_m.handshake_phase_invD<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> fM_rel_invD <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> fun_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fM_rel_inv_def<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> atomize_eq<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Relate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and writes to the phase in the GC's TSO buffer.

›</span></span>

<span class="keyword1"><span class="command">simps_of_case</span></span> handshake_phase_rel_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> handshake_phase_rel_def <span class="main">(</span>splits<span class="main">:</span> hs_phase.split<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-phase_rel_invD"><span class="command">lemma</span></span> phase_rel_invD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"phase_rel_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span> <span class="free">s</span><span class="main">,</span> sys_ghost_hs_phase <span class="free">s</span><span class="main">,</span> gc_phase <span class="free">s</span><span class="main">,</span> sys_phase <span class="free">s</span><span class="main">,</span> tso_pending_phase gc <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> phase_rel"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> phase_rel_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-mut_m_not_idle_no_fM_write"><span class="command">lemma</span></span> mut_m_not_idle_no_fM_write<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_hs_phase <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> hp_Idle<span class="main">;</span> fM_rel_inv <span class="free">s</span><span class="main">;</span> handshake_phase_inv <span class="free">s</span><span class="main">;</span> tso_store_inv <span class="free">s</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_fM <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fM_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def fM_rel_def filter_empty_conv p_not_sys<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tso_store_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> mut_ghost_handshake_phase_idle<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_ghost_hs_phase <span class="free">s</span> <span class="main">=</span> hp_Idle<span class="main">;</span> handshake_phase_inv <span class="free">s</span><span class="main">;</span> phase_rel_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> sys_phase <span class="free">s</span> <span class="main">=</span> ph_Idle"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def hp_step_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-mut_m_not_idle_no_fM_writeD"><span class="command">lemma</span></span> mut_m_not_idle_no_fM_writeD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_fM <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> ghost_hs_phase <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> hp_Idle<span class="main">;</span> fM_rel_inv <span class="free">s</span><span class="main">;</span> handshake_phase_inv <span class="free">s</span><span class="main">;</span> tso_store_inv <span class="free">s</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟧</span>
     <span class="main">⟹</span> False"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fM_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def fM_rel_def filter_empty_conv p_not_sys<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tso_store_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹points to, reaches, reachable mut›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> reachable_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> mut_roots <span class="main"><span class="hidden">❙</span><b>⊗</b></span> mut_ghost_honorary_root <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>reachable <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def reachable_def tso_store_refs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">∈</span>set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="improper">s</span><span class="main">)</span><span class="main">.</span> <span class="bound">r'</span> <span class="main">∈</span> store_refs <span class="bound">w</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">∈</span>set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="improper">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">r'</span> <span class="main">∈</span> store_refs <span class="bound">w</span><span class="main">)</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free">r</span><span class="main">)</span> <span class="improper">s</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free">r</span><span class="main">)</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reaches_fields<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">set</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s' r' w<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">w</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">w</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s' r' w<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">w</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">w</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> reachable_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> mut_m.reachable_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachableI"><span class="command">lemma</span></span> reachableI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span> <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span> <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_def reaches_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_points_to"><span class="command">lemma</span></span> reachable_points_to<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_def reaches_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> mut_reachableE<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> mut_root tso_store_refs<span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> reachable <span class="free">y</span> <span class="free">s</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> mut_ghost_honorary_root <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∈</span> tso_store_refs <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_induct"><span class="command">lemma</span></span> reachable_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> root ghost_honorary_root tso_root reaches<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ghost_honorary_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> tso_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> reaches<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> mut_m.reachable <span class="free">m</span> <span class="bound">x</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">points_to</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> r <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span> <span class="main">∪</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span> <span class="main">∪</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> base <span class="keyword1"><span class="command">with</span></span> root ghost_honorary_root tso_root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> reaches <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-mutator_reachable_tso"><span class="command">lemma</span></span> mutator_reachable_tso<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>
    <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> <span class="free">opt_r'</span> <span class="main">=</span> Some <span class="bound">r'</span> <span class="main">⟶</span> mut_m.reachable <span class="free">m</span> <span class="bound">r'</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate_Payload <span class="free">r</span> <span class="free">f</span> <span class="free">pl</span> <span class="main">#</span> <span class="free">ws</span>
    <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Colours ›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-greyI"><span class="command">lemma</span></span> greyI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> WL <span class="free">p</span> <span class="free">s</span> <span class="main">⟹</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span></span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Global_Invariants_Lemmas-blackD"><span class="command">lemma</span></span> blackD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> marked <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> WL <span class="free">p</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Global_Invariants_Lemmas-whiteI"><span class="command">lemma</span></span> whiteI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* FIXME simp normal form of def *)</span>
  <span class="quoted"><span class="quoted">"obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> sys_fM <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> white <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> white_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-marked_not_white"><span class="command">lemma</span></span> marked_not_white<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>marked <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-white_valid_ref"><span class="command">lemma</span></span> white_valid_ref<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-not_white_marked"><span class="command">lemma</span></span> not_white_marked<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span> white <span class="free">r</span> <span class="free">s</span><span class="main">;</span> valid_ref <span class="free">r</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> marked <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-black_eq_imp"><span class="command">lemma</span></span> black_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">r</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>black <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def black_def grey_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_eq_imp"><span class="command">lemma</span></span> grey_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">r</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>grey <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def grey_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Global_Invariants_Lemmas-white_eq_imp"><span class="command">lemma</span></span> white_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>white <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> black_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> black_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> grey_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> grey_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> white_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> white_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹coloured heaps›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-black_heap_eq_imp"><span class="command">lemma</span></span> black_heap_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          black_heap"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def black_heap_def black_def grey_def all_conj_distrib fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> marked <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> marked <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> valid_ref <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> valid_ref <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> WL <span class="bound">p</span> <span class="improper">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> WL <span class="bound">p</span> <span class="improper">s'</span><span class="main">)</span>"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> obj_at_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"map_option <span class="main">⟨</span>True<span class="main">⟩</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> obj_at_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"map_option <span class="main">(</span><span class="main">λ</span><span class="bound">fl</span><span class="main">.</span> <span class="bound">fl</span> <span class="main">=</span> sys_fM <span class="improper">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-white_heap_eq_imp"><span class="command">lemma</span></span> white_heap_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          white_heap"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib eq_imp_def white_def white_heap_def obj_at_def fun_eq_iff
               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>hide_lams<span class="main"><span class="main">,</span></span> no_types<span class="main"><span class="main">)</span></span> map_option_eq_Some<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_black_refs_eq_imp"><span class="command">lemma</span></span> no_black_refs_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          no_black_refs"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def no_black_refs_def black_def grey_def all_conj_distrib fun_eq_iff set_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> marked <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> marked <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> black_heap_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> black_heap_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> white_heap_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> white_heap_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> no_black_refs_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> no_black_refs_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-white_heap_imp_no_black_refs"><span class="command">lemma</span></span> white_heap_imp_no_black_refs<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"white_heap <span class="free">s</span> <span class="main">⟹</span> no_black_refs <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> white_def white_heap_def no_black_refs_def black_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-black_heap_no_greys"><span class="command">lemma</span></span> black_heap_no_greys<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> <span class="main">∀</span><span class="bound">r</span><span class="main">.</span> marked <span class="bound">r</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">¬</span>valid_ref <span class="bound">r</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> black_heap <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def black_heap_def no_grey_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Global_Invariants_Lemmas-heap_colours_colours"><span class="command">lemma</span></span> heap_colours_colours<span class="main">:</span>
  <span class="quoted"><span class="quoted">"black_heap <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>white <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"white_heap <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>black <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_heap_def white_def white_heap_def
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">r</span></span><span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The strong-tricolour invariant ›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-strong_tricolour_invD"><span class="command">lemma</span></span> strong_tricolour_invD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> black <span class="free">x</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_ref <span class="free">y</span> <span class="free">s</span><span class="main">;</span> strong_tricolour_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> marked <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strong_tricolour_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_black_refsD"><span class="command">lemma</span></span> no_black_refsD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"no_black_refs <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>black <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_induct"><span class="command">lemma</span></span> has_white_path_to_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> refl step<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">set</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> has_white_path_to<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">x</span> <span class="keyword1">has_white_path_to</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span> <span class="keyword1">points_to</span> <span class="bound">z</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="bound">z</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtranclp.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_toD"><span class="command">lemma</span></span> has_white_path_toD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> white <span class="free">y</span> <span class="free">s</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.cases<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_refl"><span class="command">lemma</span></span> has_white_path_to_refl<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">x</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_step"><span class="command">lemma</span></span> has_white_path_to_step<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">points_to</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="free">z</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">y</span> <span class="keyword1">has_white_path_to</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="free">y</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> converse_rtranclp_into_rtranclp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_toE"><span class="command">lemma</span></span> has_white_path_toE<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="free">y</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_reaches"><span class="command">lemma</span></span> has_white_path_to_reaches<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def reaches_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_blacken"><span class="command">lemma</span></span> has_white_path_to_blacken<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">s</span> gc<span class="main">⦇</span> W <span class="main">:=</span> gc_W <span class="free">s</span> <span class="main">-</span> <span class="free">rs</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_eq_imp'"><span class="command">lemma</span></span> has_white_path_to_eq_imp'<span class="main">:</span> <span class="comment1">― ‹Complicated condition takes care of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>alloc›</span></span>: collapses no object and object with no fields›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="free">s'</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="free">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="free">s'</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">=</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="free">s</span> <span class="bound">r'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sys_fM <span class="free">s'</span> <span class="main">=</span> sys_fM <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="keyword1">points_to</span> <span class="skolem">z</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sys_heap <span class="free">s</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> 10 10 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def obj_at_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> has_white_path_to_step<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> map_option_eq_Some option.sel<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-has_white_path_to_eq_imp"><span class="command">lemma</span></span> has_white_path_to_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span><span class="free">x</span> <span class="keyword1">has_white_path_to</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> has_white_path_to_eq_imp'<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> has_white_path_to_eq_imp'<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> has_white_path_to_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> has_white_path_to_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹grey protects white›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_whiteD"><span class="command">lemma</span></span> grey_protects_whiteD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> grey <span class="free">g</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="free">g</span> <span class="main">=</span> <span class="free">w</span> <span class="main">∨</span> white <span class="free">w</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_whiteI"><span class="command">lemma</span></span> grey_protects_whiteI<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"grey <span class="free">g</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">g</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_whiteE"><span class="command">lemma</span></span> grey_protects_whiteE<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">points_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> grey <span class="free">g</span> <span class="free">s</span><span class="main">;</span> white <span class="free">w</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">points_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="free">w</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_white_reaches"><span class="command">lemma</span></span> grey_protects_white_reaches<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">reaches</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_white_induct"><span class="command">lemma</span></span> grey_protects_white_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> refl step<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">set</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> grey_protects_white<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> grey <span class="bound">x</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">x</span> <span class="keyword1">has_white_path_to</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span> <span class="keyword1">points_to</span> <span class="bound">z</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="bound">z</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">g</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> grey_protects_white_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rotate_tac</span> -1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> has_white_path_to_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"valid_W_inv"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_inv_sys_ghg_empty_iff"><span class="command">lemma</span></span> valid_W_inv_sys_ghg_empty_iff<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_W_inv <span class="free">s</span> <span class="main">⟹</span> sys_ghost_honorary_grey <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-WLI"><span class="command">lemma</span></span> WLI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∈</span> WL <span class="free">p</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∈</span> WL <span class="free">p</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WL_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Global_Invariants_Lemmas-WL_eq_imp"><span class="command">lemma</span></span> WL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>ghost_honorary_grey <span class="main">(</span><span class="bound">s</span> <span class="free">p</span><span class="main">)</span><span class="main">,</span> W <span class="main">(</span><span class="bound">s</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>WL <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> WL_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> WL_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_inv_eq_imp"><span class="command">lemma</span></span> valid_W_inv_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> W <span class="main">(</span><span class="bound">s</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ghost_honorary_grey <span class="main">(</span><span class="bound">s</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_mem_lock <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mark <span class="bound">p</span><span class="main">)</span>
          valid_W_inv"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def valid_W_inv_def fun_eq_iff all_conj_distrib white_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="improper">s</span> <span class="main">=</span> WL <span class="bound">p</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> marked <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> marked <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span>sys_fM <span class="improper">s'</span><span class="main">)</span><span class="main">)</span> <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span>sys_fM <span class="improper">s'</span><span class="main">)</span><span class="main">)</span> <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">xa</span> <span class="bound">xb</span><span class="main">.</span> mw_Mark <span class="bound">xa</span> <span class="bound">xb</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="bound">x</span> <span class="improper">s</span><span class="main">)</span> <span class="main">⟷</span> mw_Mark <span class="bound">xa</span> <span class="bound">xb</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="bound">x</span> <span class="improper">s'</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x xa xb<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">set</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s'</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s'</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> WL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> valid_W_inv_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> valid_W_inv_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_invE"><span class="command">lemma</span></span> valid_W_invE<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> marked <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">≠</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> marked <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">≠</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_invD"><span class="command">lemma</span></span> valid_W_invD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="free">ws</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span>mw_Mark <span class="free">r</span> <span class="free">fl</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">p</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_inv_colours"><span class="command">lemma</span></span> valid_W_inv_colours<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>white <span class="free">x</span> <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> marked_not_white valid_W_invE<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_inv_no_mark_stores_invD"><span class="command">lemma</span></span> valid_W_inv_no_mark_stores_invD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_lock <span class="free">s</span> <span class="main">≠</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> tso_pending <span class="free">p</span> is_mw_Mark <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> filter_False<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_W_inv_sys_load"><span class="command">lemma</span></span> valid_W_inv_sys_load<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_lock <span class="free">s</span> <span class="main">≠</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> sys_load <span class="free">p</span> <span class="main">(</span>mr_Mark <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Mark <span class="main">(</span>map_option obj_mark <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sys_load_def fold_stores_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">fr</span></span><span class="main"><span class="main">.</span></span> map_option obj_mark <span class="main"><span class="main">(</span></span>heap <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">fr</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> sys<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> map_option obj_mark <span class="main"><span class="main">(</span></span>sys_heap <span class="free"><span class="free">s</span></span> <span class="free"><span class="free">r</span></span><span class="main"><span class="main">)</span></span>"</span></span></span>
                             <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">w</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">r</span></span> <span class="bound"><span class="bound">fl</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">w</span></span> <span class="main"><span class="main">≠</span></span> mw_Mark <span class="bound"><span class="bound">r</span></span> <span class="bound"><span class="bound">fl</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_option_case do_store_action_def filter_empty_conv fun_upd_apply
              <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>grey_reachable›</span></span></span></span> ›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_reachable_eq_imp"><span class="command">lemma</span></span> grey_reachable_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> Set.bind <span class="main">(</span>Option.set_option <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ran <span class="main">∘</span> obj_fields<span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>grey_reachable <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def grey_reachable_def grey_def set_eq_iff reaches_fields<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> grey_reachable_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> grey_reachable_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_reachableI"><span class="command">lemma</span></span> grey_reachableI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"grey <span class="free">g</span> <span class="free">s</span> <span class="main">⟹</span> grey_reachable <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_reachableE"><span class="command">lemma</span></span> grey_reachableE<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">points_to</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> grey_reachable <span class="free">g</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> grey_reachable <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹valid refs inv›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_refs_invI"><span class="command">lemma</span></span> valid_refs_invI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">m</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> mut_m.root <span class="bound">m</span> <span class="bound">x</span> <span class="free">s</span> <span class="main">∨</span> grey <span class="bound">x</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="bound">y</span> <span class="free">s</span>
   <span class="main">⟧</span> <span class="main">⟹</span> valid_refs_inv <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_inv_def mut_m.reachable_def grey_reachable_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_refs_inv_eq_imp"><span class="command">lemma</span></span> valid_refs_inv_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">r'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> roots <span class="main">(</span><span class="bound">s</span> <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ghost_honorary_root <span class="main">(</span><span class="bound">s</span> <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_fields <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mutate <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
          valid_refs_inv"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def valid_refs_inv_def grey_reachable_def all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> valid_ref <span class="bound">r'</span> <span class="improper">s</span> <span class="main">⟷</span> valid_ref <span class="bound">r'</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="improper">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="improper">s'</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mut_m.reachable_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> grey_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reaches_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.set_map<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> valid_refs_inv_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> valid_refs_inv_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_refs_invD"><span class="command">lemma</span></span> valid_refs_invD<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">y</span> <span class="main">=</span> Some <span class="bound">obj</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">y</span> <span class="main">=</span> Some <span class="bound">obj</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">w</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> store_refs <span class="free">w</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">w</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> store_refs <span class="free">w</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">y</span> <span class="main">=</span> Some <span class="bound">obj</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> grey <span class="free">x</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> Some <span class="bound">obj</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">obj</span><span class="main">.</span> sys_heap <span class="free">s</span> <span class="free">y</span> <span class="main">=</span> Some <span class="bound">obj</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_refs_inv_def grey_reachable_def mut_m.reachable_def mut_m.tso_store_refs_def
              <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹reachable snapshot inv›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_invI"><span class="command">lemma</span></span> reachable_snapshot_invI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> reachable <span class="bound">y</span> <span class="free">s</span> <span class="main">⟹</span> in_snapshot <span class="bound">y</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟹</span> reachable_snapshot_inv <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_snapshot_inv_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_eq_imp"><span class="command">lemma</span></span> reachable_snapshot_inv_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> mut_roots <span class="main"><span class="hidden">❙</span><b>⊗</b></span> mut_ghost_honorary_root <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">r'</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM
            <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>ran <span class="main">`</span> obj_fields <span class="main">`</span> set_option <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span>
            <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>
          reachable_snapshot_inv"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def mut_m.reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def black_def grey_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> has_white_path_to_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reachable_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> sys_fM <span class="improper">s'</span><span class="main">)</span> <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> sys_fM <span class="improper">s'</span><span class="main">)</span> <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_heap <span class="improper">s'</span> <span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> reachable_snapshot_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> mut_m.reachable_snapshot_inv_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-in_snapshotI"><span class="command">lemma</span></span> in_snapshotI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> in_snapshot <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> in_snapshot <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> white <span class="free">w</span> <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> in_snapshot <span class="free">w</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="comment1">― ‹Sanity›</span>
  <span class="quoted"><span class="quoted">"in_snapshot <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> grey <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> white <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-in_snapshot_valid_ref"><span class="command">lemma</span></span> in_snapshot_valid_ref<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> in_snapshot <span class="free">r</span> <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> blackD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> grey_protects_whiteD grey_protects_white_reaches in_snapshot_def obj_at_cong obj_at_def option.case<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachableI2"><span class="command">lemma</span></span> reachableI2<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span> <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">x</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Global_Invariants_Lemmas-tso_pending_mw_mutate_cong"><span class="command">lemma</span></span> tso_pending_mw_mutate_cong<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> filter is_mw_Mutate <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> filter is_mw_Mutate <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s'</span><span class="main">)</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span> <span class="main">⟷</span> <span class="free">Q</span> <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">.</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span>  <span class="main">⟶</span> <span class="free">P</span> <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">)</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">.</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span> <span class="main">∈</span> set <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s'</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span> <span class="bound">r</span> <span class="bound">f</span> <span class="bound">r'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> iff_allI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">set</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> marked_insertions_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mw_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>
          marked_insertions"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def marked_insertions_def obj_at_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> tso_pending_mw_mutate_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s' opt x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> marked_insertions_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> mut_m.marked_insertions_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-marked_insertionD"><span class="command">lemma</span></span> marked_insertionD<span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="main">(</span>Some <span class="free">r'</span><span class="main">)</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> marked <span class="free">r'</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_insertions_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-marked_insertions_store_buffer_empty"><span class="command">lemma</span></span> marked_insertions_store_buffer_empty<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_insertions_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_empty_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>

<span class="comment1">(* marked_deletions *)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> marked_deletions_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_fields <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mw_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>
          marked_deletions"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def marked_deletions_def obj_at_field_on_heap_def ran_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">set</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> marked <span class="bound">x</span> <span class="improper">s</span> <span class="main">⟷</span> marked <span class="bound">x</span> <span class="improper">s'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits mem_store_action.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s' x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> marked_deletions_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> mut_m.marked_deletions_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-marked_deletions_store_buffer_empty"><span class="command">lemma</span></span> marked_deletions_store_buffer_empty<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> mut_m.marked_deletions <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_deletions_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_empty_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Location-specific simplification rules›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-obj_at_ref_sweep_loop_free"><span class="command">lemma</span></span> obj_at_ref_sweep_loop_free<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_at <span class="free">P</span> <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">≠</span> <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-obj_at_alloc"><span class="command">lemma</span></span> obj_at_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sys_heap <span class="free">s</span> <span class="free">r'</span> <span class="main">=</span> None
  <span class="main">⟹</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">m</span> <span class="main">:=</span> <span class="free">mut_m_s'</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="free">obj</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> <span class="main">(</span>obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r</span> <span class="main">=</span> <span class="free">r'</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">obj</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_ref_valid_null_ref_simps"><span class="command">lemma</span></span> valid_ref_valid_null_ref_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_ref <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> do_store_action <span class="free">w</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> valid_ref <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"valid_null_ref <span class="free">r'</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> do_store_action <span class="free">w</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> valid_null_ref <span class="free">r'</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"valid_null_ref <span class="free">r'</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">mut_s'</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r''</span> <span class="main">↦</span> <span class="free">obj</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> valid_null_ref <span class="free">r'</span> <span class="free">s</span> <span class="main">∨</span> <span class="free">r'</span> <span class="main">=</span> Some <span class="free">r''</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> do_store_action_def valid_null_ref_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_load"><span class="command">lemma</span></span> reachable_load<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">r'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m'</span> <span class="free">y</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> roots <span class="main">:=</span> mut_roots <span class="free">s</span> <span class="main">∪</span> Option.set_option <span class="free">r'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> mut_m.reachable <span class="free">m'</span> <span class="free">y</span> <span class="free">s</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">=</span> <span class="free">m</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> assms True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sys_load_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_def reaches_def tso_store_refs_def sys_load_def fold_stores_def fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> fold_stores_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fold_stores_points_to<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> converse_rtranclp_into_rtranclp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ranI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">meson</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹WL›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-WL_blacken"><span class="command">lemma</span></span> WL_blacken<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gc_ghost_honorary_grey <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>
    <span class="main">⟹</span> WL <span class="free">p</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">s</span> gc<span class="main">⦇</span> W <span class="main">:=</span> gc_W <span class="free">s</span> <span class="main">-</span> <span class="free">rs</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> WL <span class="free">p</span> <span class="free">s</span> <span class="main">-</span> <span class="main">{</span> <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> gc <span class="main">∧</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">rs</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-WL_hs_done"><span class="command">lemma</span></span> WL_hs_done<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>
     <span class="main">⟹</span> WL <span class="free">p</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hp'</span> <span class="main">⦈</span><span class="main">,</span>
                 sys   <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hsp'</span><span class="main">,</span> W <span class="main">:=</span> sys_W <span class="free">s</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                 ghost_hs_in_sync <span class="main">:=</span> <span class="free">in'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
      <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">p</span> <span class="keyword1">of</span> gc <span class="main">⇒</span> WL gc <span class="free">s</span> <span class="main">|</span> mutator <span class="bound">m'</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> WL <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">|</span> sys <span class="main">⇒</span> WL sys <span class="free">s</span> <span class="main">∪</span> WL <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>
     <span class="main">⟹</span> WL <span class="free">p</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">,</span>
                 sys   <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hsp'</span><span class="main">,</span> W <span class="main">:=</span> sys_W <span class="free">s</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                 ghost_hs_in_sync <span class="main">:=</span> <span class="free">in'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
      <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">p</span> <span class="keyword1">of</span> gc <span class="main">⇒</span> WL gc <span class="free">s</span> <span class="main">|</span> mutator <span class="bound">m'</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> WL <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">|</span> sys <span class="main">⇒</span> WL sys <span class="free">s</span> <span class="main">∪</span> WL <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_load_W"><span class="command">lemma</span></span> colours_load_W<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gc_W <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> gc<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> black <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"gc_W <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> grey <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> gc<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def WL_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-WL_load_W"><span class="command">lemma</span></span> WL_load_W<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gc_W <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>
    <span class="main">⟹</span> <span class="main">(</span>WL <span class="free">p</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> gc<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> sys_W <span class="free">s</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">p</span> <span class="keyword1">of</span> gc <span class="main">⇒</span> WL gc <span class="free">s</span> <span class="main">∪</span> sys_W <span class="free">s</span> <span class="main">|</span> mutator <span class="bound">m</span> <span class="main">⇒</span> WL <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">|</span> sys <span class="main">⇒</span> sys_ghost_honorary_grey <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹no grey refs›</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_eq_imp"><span class="command">lemma</span></span> no_grey_refs_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">p</span><span class="main">.</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
          no_grey_refs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def grey_def no_grey_refs_def set_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> no_grey_refs_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> no_grey_refs_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_no_pending_marks"><span class="command">lemma</span></span> no_grey_refs_no_pending_marks<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> tso_no_pending_marks <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_grey_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> filter_False <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_not_grey_reachableD"><span class="command">lemma</span></span> no_grey_refs_not_grey_reachableD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span> <span class="main">⟹</span> <span class="main">¬</span>grey_reachable <span class="free">x</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def grey_reachable_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refsD"><span class="command">lemma</span></span> no_grey_refsD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> WL <span class="free">p</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_marked"><span class="command">lemma</span></span> no_grey_refs_marked<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> marked <span class="free">r</span> <span class="free">s</span><span class="main">;</span> no_grey_refs <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def black_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_bwD"><span class="command">lemma</span></span> no_grey_refs_bwD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r</span> <span class="main">=</span> Some <span class="free">obj</span><span class="main">;</span> no_grey_refs <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> white <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def grey_def no_grey_refs_def white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_blackD"><span class="command">lemma</span></span> reachable_blackD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> reachable <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> black <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_def reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_not_reachable"><span class="command">lemma</span></span> no_grey_refs_not_reachable<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span>reachable <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def
             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_grey_refs_not_rootD"><span class="command">lemma</span></span> no_grey_refs_not_rootD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> mut_roots <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∉</span> mut_ghost_honorary_root <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∉</span> tso_store_refs <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> no_grey_refs_not_reachable<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_def reaches_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_white_root"><span class="command">lemma</span></span> reachable_snapshot_inv_white_root<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> white <span class="free">w</span> <span class="free">s</span><span class="main">;</span> <span class="free">w</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">∨</span> <span class="free">w</span> <span class="main">∈</span> mut_ghost_honorary_root <span class="free">s</span><span class="main">;</span> reachable_snapshot_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def in_snapshot_def reachable_def grey_protects_white_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* colours *)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-black_dequeue_Mark"><span class="command">lemma</span></span> black_dequeue_Mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">b</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
<span class="main">⟷</span> <span class="main">(</span>black <span class="free">b</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">≠</span> <span class="free">r</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">b</span> <span class="main">=</span> <span class="free">r</span> <span class="main">∧</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> valid_ref <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">¬</span>grey <span class="free">r</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_sweep_loop_free"><span class="command">lemma</span></span> colours_sweep_loop_free<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>black <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">≠</span> <span class="free">r'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>grey <span class="free">r</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">≠</span> <span class="free">r'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_get_work_done"><span class="command">lemma</span></span> colours_get_work_done<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> black <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> white <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def WL_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> process_name.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_get_roots_done"><span class="command">lemma</span></span> colours_get_roots_done<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hs'</span> <span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> black <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hs'</span> <span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hs'</span> <span class="main">⦈</span><span class="main">,</span>
              sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> W <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                              ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> white <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def WL_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> process_name.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_flip_fM"><span class="command">lemma</span></span> colours_flip_fM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">fl</span> <span class="main">≠</span> sys_fM <span class="free">s</span> <span class="main">⟹</span> black <span class="free">b</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>fM <span class="main">:=</span> <span class="free">fl</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> white <span class="free">b</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">¬</span>grey <span class="free">b</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_alloc"><span class="command">lemma</span></span> colours_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None
     <span class="main">⟹</span> black <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> roots <span class="main">:=</span> <span class="free">roots'</span> <span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> black <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r'</span> <span class="main">=</span> <span class="free">r</span> <span class="main">∧</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="main">¬</span>grey <span class="free">r'</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"grey <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> roots <span class="main">:=</span> <span class="free">roots'</span> <span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> grey <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None
     <span class="main">⟹</span> white <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span> roots <span class="main">:=</span> <span class="free">roots'</span> <span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r'</span> <span class="main">=</span> <span class="free">r</span> <span class="main">∧</span> <span class="free">fl</span> <span class="main">≠</span> sys_fM <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-heap_colours_alloc"><span class="command">lemma</span></span> heap_colours_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None<span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span>
  <span class="main">⟹</span> black_heap <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> black_heap <span class="free">s</span> <span class="main">∧</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None
  <span class="main">⟹</span> white_heap <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> white_heap <span class="free">s</span> <span class="main">∧</span> <span class="free">fl</span> <span class="main">≠</span> sys_fM <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_heap_def white_def white_heap_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r'</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reaches_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> valid_refs_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x obj<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r'</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> valid_refs_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_white_hs_done"><span class="command">lemma</span></span> grey_protects_white_hs_done<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hs'</span> <span class="main">⦈</span><span class="main">,</span>
                              sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span> hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> sys_W <span class="free">s</span> <span class="main">∪</span> W <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                            ghost_hs_in_sync <span class="main">:=</span> <span class="free">his'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_protects_white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_white_alloc"><span class="command">lemma</span></span> grey_protects_white_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span><span class="main">;</span> sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_protects_white_def has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> reachable_snapshot_inv_sweep_loop_free<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nmr<span class="main">:</span> <span class="quoted"><span class="quoted">"white <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ngs<span class="main">:</span> <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rsi<span class="main">:</span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ref</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> rx<span class="main">:</span> <span class="quoted"><span class="quoted">"reachable <span class="skolem">y</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"black <span class="skolem">y</span> <span class="free">s</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ngs nmr rsi <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_blackD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ghost_honorary_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ngs nmr rsi <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_blackD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ngs nmr rsi <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_blackD<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>reaches <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ngs nmr rsi <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reachable_def reaches_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> predicate2D<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rtranclp_mono<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">x</span></span> <span class="keyword1"><span class="keyword1">points_to</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">s</span></span>"</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">OF</span> predicate2I<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reachable_blackD<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_def reaches_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> reachable_blackD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_def reaches_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"in_snapshot <span class="skolem">y</span> <span class="var">?s'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> in_snapshot_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_alloc"><span class="command">lemma</span></span> reachable_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rn<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="free">r'</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> insert <span class="free">r</span> <span class="main">(</span>roots <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> mut_m.reachable <span class="free">m</span> <span class="free">r'</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="main">∧</span> <span class="free">r'</span> <span class="main">=</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">from</span></span> this assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>reaches <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_def reaches_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> disjE<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="free">r'</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>reaches <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> rn <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="main">∧</span> <span class="free">r'</span> <span class="main">=</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> rn <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_alloc"><span class="command">lemma</span></span> reachable_snapshot_inv_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">elim</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rsi<span class="main">:</span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rn<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_heap <span class="free">s</span> <span class="free">r</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> insert <span class="free">r</span> <span class="main">(</span>roots <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def in_snapshot_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> reachable_fun_upd<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_discard_roots"><span class="command">lemma</span></span> reachable_snapshot_inv_discard_roots<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> <span class="free">roots'</span> <span class="main">⊆</span> roots <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span>
     <span class="main">⟹</span> reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def reachable_def in_snapshot_def grey_protects_white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_load"><span class="command">lemma</span></span> reachable_snapshot_inv_load<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> roots <span class="main">:=</span> mut_roots <span class="free">s</span> <span class="main">∪</span> Option.set_option <span class="free">r'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_snapshot_inv_store_ins"><span class="command">lemma</span></span> reachable_snapshot_inv_store_ins<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r'</span><span class="main">.</span> <span class="free">opt_r'</span> <span class="main">=</span> Some <span class="bound">r'</span><span class="main">)</span> <span class="main">⟶</span> the <span class="free">opt_r'</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
                                  sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>  mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">]</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def reachable_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="comment1">(* FIXME what's gone wrong here? *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> tso_store_refs_simps<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-WL_mo_co_mark"><span class="command">lemma</span></span> WL_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>
     <span class="main">⟹</span> WL <span class="free">p'</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span> ghost_honorary_grey <span class="main">:=</span> <span class="free">rs</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> WL <span class="free">p'</span> <span class="free">s</span> <span class="main">∪</span> <span class="main">{</span> <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="free">p'</span> <span class="main">=</span> <span class="free">p</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">rs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-ghost_honorary_grey_mo_co_mark"><span class="command">lemma</span></span> ghost_honorary_grey_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> black <span class="free">b</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> black <span class="free">b</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">≠</span> <span class="free">r</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> grey <span class="free">g</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> grey <span class="free">g</span> <span class="free">s</span> <span class="main">∨</span> <span class="free">g</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> white <span class="free">w</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>  <span class="main">⟷</span> white <span class="free">w</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-ghost_honorary_grey_mo_co_W"><span class="command">lemma</span></span> ghost_honorary_grey_mo_co_W<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>
     <span class="main">⟹</span> <span class="main">(</span>WL <span class="free">p</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p'</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> insert <span class="free">r</span> <span class="main">(</span>W <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>WL <span class="free">p</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>
     <span class="main">⟹</span> grey <span class="free">g</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p'</span> <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> insert <span class="free">r</span> <span class="main">(</span>W <span class="main">(</span><span class="free">s</span> <span class="free">p'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> grey <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits if_splits<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_sweep_loop_free"><span class="command">lemma</span></span> reachable_sweep_loop_free<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="free">r</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
   <span class="main">⟹</span> mut_m.reachable <span class="free">m</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def reaches_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mono_rtranclp<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-reachable_deref_del"><span class="command">lemma</span></span> reachable_deref_del<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">opt_r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span><span class="main">;</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
   <span class="main">⟹</span> mut_m.reachable <span class="free">m'</span> <span class="free">y</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> ghost_honorary_root <span class="main">:=</span> Option.set_option <span class="free">opt_r'</span><span class="main">,</span> ref <span class="main">:=</span> <span class="free">opt_r'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
   <span class="main">⟷</span> mut_m.reachable <span class="free">m'</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_def reaches_def sys_load_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> option_bind_invE<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fold_stores_points_to<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> converse_rtranclp_into_rtranclp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span>
              <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_black_refs_dequeue"><span class="command">lemma</span></span> no_black_refs_dequeue<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> no_black_refs <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
   <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">r'</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> no_black_refs <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                      mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main">)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-colours_blacken"><span class="command">lemma</span></span> colours_blacken<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_W_inv <span class="free">s</span> <span class="main">⟹</span> black <span class="free">b</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">s</span> gc<span class="main">⦇</span>W <span class="main">:=</span> gc_W <span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> black <span class="free">b</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r</span> <span class="main">∈</span> gc_W <span class="free">s</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> gc_W <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> grey <span class="free">g</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">s</span> gc<span class="main">⦇</span>W <span class="main">:=</span> gc_W <span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>grey <span class="free">g</span> <span class="free">s</span> <span class="main">∧</span> <span class="free">g</span> <span class="main">≠</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="comment1">(*  "white w (s(gc := s gc⦇W := gc_W s - {r}⦈)) ⟷ white w s" is redundant *)</span>
<span class="keyword1"><span class="command">unfolding</span></span> black_def grey_def valid_W_inv_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_conj_distrib <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits if_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> WL_def fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(* FIXME
apply (auto simp: black_def grey_def WL_def split: obj_at_splits)
apply metis+
done
*)</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_black_refs_alloc"><span class="command">lemma</span></span> no_black_refs_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None<span class="main">;</span> no_black_refs <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
     <span class="main">⟷</span> <span class="free">fl</span> <span class="main">≠</span> sys_fM <span class="free">s</span> <span class="main">∨</span> grey <span class="free">r'</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Global_Invariants_Lemmas-no_black_refs_mo_co_mark"><span class="command">lemma</span></span> no_black_refs_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> no_black_refs <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Global_Invariants_Lemmas-grey_protects_white_mark"><span class="command">lemma</span></span> grey_protects_white_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ghg<span class="main">:</span> <span class="quoted"><span class="quoted">"ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">g'</span><span class="main">.</span> <span class="main">(</span><span class="bound">g'</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">r</span> <span class="keyword1">has_white_path_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> this ghg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this ghg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induct</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">unfolding</span></span> grey_protects_white_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span> <span class="keyword1">has_white_path_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> ghg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> grey_protects_white_def has_white_path_to_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_refs_inv_dequeue_Mutate"><span class="command">lemma</span></span> valid_refs_inv_dequeue_Mutate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                        mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> valid_refs_invI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?root</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span> <span class="bound">x</span><span class="main">.</span> mut_m.root <span class="bound">m</span> <span class="bound">x</span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> grey <span class="bound">x</span>"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="keyword1">reaches</span> <span class="skolem">y</span><span class="main">)</span> <span class="var">?s'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?root</span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> xy <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">m</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?root</span> <span class="bound">m</span> <span class="bound">x</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">reaches</span> <span class="skolem">y</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> valid_ref <span class="skolem">y</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> reaches_def <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> base <span class="keyword1"><span class="command">with</span></span> x sb vri <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> obj_at_fun_upd<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def reaches_def fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">m</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rtranclp.rtrancl_refl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> <span class="comment1">(* FIXME rules *)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> sb vri <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> obj_at_fun_upd<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> obj_at_fun_upd<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclp.intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def reaches_def fun_upd_apply <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">m'</span></span><span class="main"><span class="main">]</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">m'</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
   <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"valid_ref <span class="skolem">y</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Invariants_Lemmas-valid_refs_inv_dequeue_Mutate_Payload"><span class="command">lemma</span></span> valid_refs_inv_dequeue_Mutate_Payload<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate_Payload <span class="free">r</span> <span class="free">f</span> <span class="free">pl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_payload <span class="main">:=</span> <span class="main">(</span>obj_payload <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">pl</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                        mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_refs_invI<span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_invD fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UN_insert Un_iff list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> mut_m.tso_store_refs_def valid_refs_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> case_optionE obj_at_def valid_refs_invD<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Local_Invariants_Lemmas">
<div class="head">
<h1>Theory Local_Invariants_Lemmas</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Local_Invariants_Lemmas
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Local_Invariants.html">Local_Invariants</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> subst_all <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Local invariants lemma bucket›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Location facts›</span></span>

<span class="comment1">(* FIXME loads more in StrongTricolour. These might be mostly about non-interference, in which case it might make sense to
   split those proofs off into a separate theory? *)</span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_roots_loop_locs_subseteq_hs_get_roots_locs"><span class="command">lemma</span></span> hs_get_roots_loop_locs_subseteq_hs_get_roots_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_roots_loop_locs <span class="main">⊆</span> hs_get_roots_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_roots_loop_locs_def hs_get_roots_locs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_pending_locs_subseteq_hs_pending_loaded_locs"><span class="command">lemma</span></span> hs_pending_locs_subseteq_hs_pending_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_pending_locs <span class="main">⊆</span> hs_pending_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_pending_locs_def hs_pending_loaded_locs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-ht_loaded_locs_subseteq_hs_pending_loaded_locs"><span class="command">lemma</span></span> ht_loaded_locs_subseteq_hs_pending_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ht_loaded_locs <span class="main">⊆</span> hs_pending_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ht_loaded_locs_def hs_pending_loaded_locs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_noop_locs_subseteq_hs_pending_loaded_locs"><span class="command">lemma</span></span> hs_noop_locs_subseteq_hs_pending_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_noop_locs <span class="main">⊆</span> hs_pending_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_noop_locs_def hs_pending_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_noop_locs_subseteq_hs_pending_locs"><span class="command">lemma</span></span> hs_noop_locs_subseteq_hs_pending_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_noop_locs <span class="main">⊆</span> hs_pending_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_noop_locs_def hs_pending_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_noop_locs_subseteq_ht_loaded_locs"><span class="command">lemma</span></span> hs_noop_locs_subseteq_ht_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_noop_locs <span class="main">⊆</span> ht_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_noop_locs_def ht_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_roots_locs_subseteq_hs_pending_loaded_locs"><span class="command">lemma</span></span> hs_get_roots_locs_subseteq_hs_pending_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_roots_locs <span class="main">⊆</span> hs_pending_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_roots_locs_def hs_pending_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_roots_locs_subseteq_hs_pending_locs"><span class="command">lemma</span></span> hs_get_roots_locs_subseteq_hs_pending_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_roots_locs <span class="main">⊆</span> hs_pending_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_roots_locs_def hs_pending_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_roots_locs_subseteq_ht_loaded_locs"><span class="command">lemma</span></span> hs_get_roots_locs_subseteq_ht_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_roots_locs <span class="main">⊆</span> ht_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_roots_locs_def ht_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_work_locs_subseteq_hs_pending_loaded_locs"><span class="command">lemma</span></span> hs_get_work_locs_subseteq_hs_pending_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_work_locs <span class="main">⊆</span> hs_pending_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_work_locs_def hs_pending_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_work_locs_subseteq_hs_pending_locs"><span class="command">lemma</span></span> hs_get_work_locs_subseteq_hs_pending_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_work_locs <span class="main">⊆</span> hs_pending_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_work_locs_def hs_pending_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_work_locs_subseteq_ht_loaded_locs"><span class="command">lemma</span></span> hs_get_work_locs_subseteq_ht_loaded_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_work_locs <span class="main">⊆</span> ht_loaded_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hs_get_work_locs_def ht_loaded_locs_def loc_defs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  mut_m.hs_get_roots_loop_locs_subseteq_hs_get_roots_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_pending_locs_subseteq_hs_pending_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.ht_loaded_locs_subseteq_hs_pending_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_noop_locs_subseteq_hs_pending_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_noop_locs_subseteq_hs_pending_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_noop_locs_subseteq_ht_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_roots_locs_subseteq_hs_pending_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_roots_locs_subseteq_hs_pending_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_roots_locs_subseteq_ht_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_work_locs_subseteq_hs_pending_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_work_locs_subseteq_hs_pending_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  mut_m.hs_get_work_locs_subseteq_ht_loaded_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-get_roots_UN_get_work_locs_subseteq_ghost_honorary_grey_empty_locs"><span class="command">lemma</span></span> get_roots_UN_get_work_locs_subseteq_ghost_honorary_grey_empty_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"get_roots_UN_get_work_locs <span class="main">⊆</span> ghost_honorary_grey_empty_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_roots_UN_get_work_locs_def ghost_honorary_grey_empty_locs_def hs_get_roots_locs_def hs_get_work_locs_def loc_defs
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs"><span class="command">lemma</span></span> hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_roots_locs <span class="main">⊆</span> hp_IdleMarkSweep_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hs_get_roots_locs_def hp_IdleMarkSweep_locs_def mark_loop_locs_def
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs"><span class="command">lemma</span></span> hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_get_work_locs <span class="main">⊆</span> hp_IdleMarkSweep_locs"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs_get_work_locs_def hp_IdleMarkSweep_locs_def mark_loop_locs_def loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  gc.get_roots_UN_get_work_locs_subseteq_ghost_honorary_grey_empty_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obj_fields_marked_inv›</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-obj_fields_marked_eq_imp"><span class="command">lemma</span></span> obj_fields_marked_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> gc_field_set <span class="main"><span class="hidden">❙</span><b>⊗</b></span> gc_tmp_ref <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_fields <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span> <span class="bound">r'</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_fM <span class="main"><span class="hidden">❙</span><b>⊗</b></span> tso_pending_mutate gc<span class="main">)</span>
          obj_fields_marked"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def obj_fields_marked_def obj_at_field_on_heap_def obj_at_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_disc_iff<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_disc_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-obj_fields_marked_UNIV"><span class="command">lemma</span></span> obj_fields_marked_UNIV<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_fields_marked <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> gc<span class="main">)</span><span class="main">⦇</span> field_set <span class="main">:=</span> UNIV <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_fields_marked_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Local_Invariants_Lemmas-obj_fields_marked_invL_eq_imp"><span class="command">lemma</span></span> obj_fields_marked_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> map_option obj_fields <span class="main">(</span>sys_heap <span class="bound">s</span><span class="main">↓</span> <span class="bound">r'</span><span class="main">)</span><span class="main">,</span> map_option obj_mark <span class="main">(</span>sys_heap <span class="bound">s</span><span class="main">↓</span> <span class="bound">r'</span><span class="main">)</span><span class="main">,</span> sys_fM <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_W <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> tso_pending_mutate gc <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          obj_fields_marked_invL"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def <span class="dynamic"><span class="dynamic">inv</span></span> obj_at_def obj_at_field_on_heap_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> obj_fields_marked_eq_imp<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reaches_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> option.disc_eq_case<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> option.map_disc_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.set_map<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> atS_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> atS_un obj_fields_marked_good_ref_locs_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="comment1">(* cut and paste *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> obj_fields_marked_eq_imp<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> option.map_sel option.sel<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reaches_eq_imp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> None_eq_map_option_iff option.case_eq_if<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> option.set_map<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> atS_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> atS_un obj_fields_marked_good_ref_locs_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> map_option_eq_Some option.inject option.simps<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-obj_fields_marked_mark_field_done"><span class="command">lemma</span></span> obj_fields_marked_mark_field_done<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> marked <span class="bound">r</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span>gc_tmp_ref <span class="free">s</span><span class="main">)</span> <span class="main">(</span>gc_field <span class="free">s</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> obj_fields_marked <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> obj_fields_marked <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> gc<span class="main">)</span><span class="main">⦇</span>field_set <span class="main">:=</span> gc_field_set <span class="free">s</span> <span class="main">-</span> <span class="main">{</span>gc_field <span class="free">s</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_fields_marked_def obj_at_field_on_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_obj_fields_marked_inv_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> gc.obj_fields_marked_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> gc_obj_fields_marked_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span> iffD1<span class="main">[</span><span class="operator">OF</span> gc.obj_fields_marked_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ mark object ›</span></span>

<span class="keyword1"><span class="command">context</span></span> mark_object
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-mark_object_invL_eq_imp"><span class="command">lemma</span></span> mark_object_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> <span class="free">p</span><span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> <span class="free">p</span><span class="main">,</span> sys_heap <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_fM <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_mem_store_buffers <span class="free">p</span> <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          mark_object_invL"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">s</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> s'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">s'</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> eq_impD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> p_ph_enabled_eq_imp<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mark_object_invL_def obj_at_def white_def
                <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mark_object_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> mark_object_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Local_Invariants_Lemmas-mut_m_mark_object_invL_eq_imp"><span class="command">lemma</span></span> mut_m_mark_object_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">,</span> sys_heap <span class="bound">s</span><span class="main">↓</span> <span class="bound">r</span><span class="main">,</span> sys_fM <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_phase <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>mut_m.mark_object_invL <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def mut_m.mark_object_invL_def fun_eq_iff<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> obj_at_field_on_heap_def
                <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span><span class="main">.</span> marked <span class="bound">r</span> <span class="improper">s</span><span class="main">↓</span> <span class="main">⟷</span> marked <span class="bound">r</span> <span class="improper">s'</span><span class="main">↓</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span><span class="main">.</span> valid_null_ref <span class="bound">r</span> <span class="improper">s</span><span class="main">↓</span> <span class="main">⟷</span> valid_null_ref <span class="bound">r</span> <span class="improper">s'</span><span class="main">↓</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span> <span class="bound">f</span> <span class="bound">opt_r'</span><span class="main">.</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">opt_r'</span> <span class="main">∉</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="improper">s</span><span class="main">↓</span><span class="main">)</span>
                               <span class="main">⟷</span> mw_Mutate <span class="bound">r</span> <span class="bound">f</span> <span class="bound">opt_r'</span> <span class="main">∉</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="improper">s'</span><span class="main">↓</span><span class="main">)</span>"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> filter_set member_filter<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_def valid_null_ref_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_def valid_null_ref_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mut_m_mark_object_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> mut_m_mark_object_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Initial_Conditions">
<div class="head">
<h1>Theory Initial_Conditions</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Initial_Conditions
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Initial conditions \label{sec:initial-conditions-proofs}›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc_system
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Initial_Conditions-init_strong_tricolour_inv"><span class="command">lemma</span></span> init_strong_tricolour_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> obj_mark <span class="main">`</span> ran <span class="main">(</span>sys_heap <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span>gc_fM <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span><span class="main">}</span><span class="main">;</span> sys_fM <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">=</span> gc_fM <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">⟧</span>
     <span class="main">⟹</span> strong_tricolour_inv <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strong_tricolour_inv_def ran_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Initial_Conditions-init_no_grey_refs"><span class="command">lemma</span></span> init_no_grey_refs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> gc_W <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> W <span class="main">(</span><span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> sys_W <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
     gc_ghost_honorary_grey <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> ghost_honorary_grey <span class="main">(</span><span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> sys_ghost_honorary_grey <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_grey_refs <span class="main">⦇</span>GST <span class="main">=</span> <span class="free">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_grey_refs_def grey_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> equals0D process_name.exhaust sup_bot.left_neutral<span class="main">)</span>

<span class="keyword1" id="Initial_Conditions-valid_refs_imp_valid_refs_inv"><span class="command">lemma</span></span> valid_refs_imp_valid_refs_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs <span class="free">s</span><span class="main">;</span> no_grey_refs <span class="free">s</span><span class="main">;</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> sys_mem_store_buffers <span class="bound">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> ghost_honorary_root <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def valid_refs_def mut_m.reachable_def mut_m.tso_store_refs_def
<span class="keyword1"><span class="command">using</span></span> no_grey_refs_not_grey_reachableD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Initial_Conditions-no_grey_refs_imp_valid_W_inv"><span class="command">lemma</span></span> no_grey_refs_imp_valid_W_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> sys_mem_store_buffers <span class="bound">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_W_inv <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def no_grey_refs_def grey_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Initial_Conditions-valid_refs_imp_reachable_snapshot_inv"><span class="command">lemma</span></span> valid_refs_imp_reachable_snapshot_inv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs <span class="free">s</span><span class="main">;</span> obj_mark <span class="main">`</span> ran <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span>sys_fM <span class="free">s</span><span class="main">}</span><span class="main">;</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> sys_mem_store_buffers <span class="bound">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> ghost_honorary_root <span class="main">(</span><span class="free">s</span> <span class="main">(</span>mutator <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def valid_refs_def black_def mut_m.reachable_def mut_m.tso_store_refs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_subset_iff ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Initial_Conditions-init_inv_sys"><span class="command">lemma</span></span> init_inv_sys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> initial_state gc_system <span class="bound">s</span> <span class="main">⟶</span> invs <span class="main">⦇</span>GST <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span><span class="main">↓</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> initial_stateD
              <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gc_system_init_def invs_def gc_initial_state_def mut_initial_state_def sys_initial_state_def
                    <span class="dynamic"><span class="dynamic">inv</span></span>
                    handshake_phase_rel_def handshake_phase_inv_def hp_step_rel_def phase_rel_inv_def phase_rel_def
                    tso_store_inv_def
                    init_no_grey_refs init_strong_tricolour_inv no_grey_refs_imp_valid_W_inv
                    valid_refs_imp_reachable_snapshot_inv
                    valid_refs_imp_valid_refs_inv
                    mut_m.marked_deletions_def mut_m.marked_insertions_def
                    fA_rel_inv_def fA_rel_def fM_rel_inv_def fM_rel_def
                    all_conj_distrib<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Initial_Conditions-init_inv_mut"><span class="command">lemma</span></span> init_inv_mut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> initial_state gc_system <span class="bound">s</span> <span class="main">⟶</span> mut_m.invsL <span class="free">m</span> <span class="main">⦇</span>GST <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> initial_stateD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fun_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"mutator <span class="free"><span class="free">m</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_com_interned_defs<span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.invsL_def mut_m.mut_get_roots_mark_object_invL_def2 mut_m.mut_store_del_mark_object_invL_def2 mut_m.mut_store_ins_mark_object_invL_def2
          mut_m.mark_object_invL_def mut_m.handshake_invL_def mut_m.tso_lock_invL_def
          gc_system_init_def mut_initial_state_def sys_initial_state_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">locset_cache</span></span> atS_simps<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mut_m.loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Initial_Conditions-init_inv_gc"><span class="command">lemma</span></span> init_inv_gc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> initial_state gc_system <span class="bound">s</span> <span class="main">⟶</span> gc.invsL <span class="main">⦇</span>GST <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> initial_stateD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fun_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">gc</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_com_interned_defs<span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.invsL_def gc.fM_fA_invL_def gc.handshake_invL_def gc.obj_fields_marked_invL_def gc.phase_invL_def gc.sweep_loop_invL_def
          gc.tso_lock_invL_def gc.gc_W_empty_invL_def gc.gc_mark_mark_object_invL_def2
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">locset_cache</span></span> atS_simps init_no_grey_refs<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc.loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc_system_init_def gc_initial_state_def mut_initial_state_def sys_initial_state_def
                     gc_system.init_no_grey_refs<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_subset_iff ranI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* FIXME really deserves to be somewhere very public but there's no shared theory immediately above Local and Global invs by design *)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> gc_pred"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">=</span> <span class="main">(</span>invsL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP invs<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> I_defs <span class="main">=</span> gc.invsL_def mut_m.invsL_def invsL_def invs_def I_def

<span class="keyword1"><span class="command">context</span></span> gc_system
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> init_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> initial_state gc_system <span class="bound">s</span> <span class="main">⟶</span> I <span class="main">⦇</span>GST <span class="main">=</span> <span class="bound">s</span><span class="main">,</span> HST <span class="main">=</span> <span class="main">[]</span><span class="main">⦈</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> I_def invsL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_inv_sys init_inv_gc init_inv_mut<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Noninterference">
<div class="head">
<h1>Theory Noninterference</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Noninterference
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Noninterference ›</span></span>

<span class="keyword1" id="Noninterference-mut_del_barrier1_subseteq_mut_mo_valid_ref_locs"><span class="command">lemma</span></span> mut_del_barrier1_subseteq_mut_mo_valid_ref_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* FIXME rename *)</span>
  <span class="quoted"><span class="quoted">"mut_m.del_barrier1_locs <span class="main">⊆</span> mut_m.mo_valid_ref_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.del_barrier1_locs_def mut_m.mo_valid_ref_locs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="Noninterference-mut_del_barrier2_subseteq_mut_mo_valid_ref"><span class="command">lemma</span></span> mut_del_barrier2_subseteq_mut_mo_valid_ref<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* FIXME rename *)</span>
  <span class="quoted"><span class="quoted">"mut_m.ins_barrier_locs <span class="main">⊆</span> mut_m.mo_valid_ref_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.ins_barrier_locs_def mut_m.mo_valid_ref_locs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Noninterference-obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs"><span class="command">lemma</span></span> obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_fields_marked_locs <span class="main">⊆</span> hp_IdleMarkSweep_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.obj_fields_marked_locs_def gc.hp_IdleMarkSweep_locs_def gc.mark_loop_locs_def gc.mark_loop_mo_locs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">locset_cache</span></span> loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-obj_fields_marked_locs_subseteq_hs_in_sync_locs"><span class="command">lemma</span></span> obj_fields_marked_locs_subseteq_hs_in_sync_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_fields_marked_locs <span class="main">⊆</span> hs_in_sync_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_fields_marked_locs_def hs_in_sync_locs_def hs_done_locs_def mark_loop_mo_locs_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> loc_defs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_same_cases<span class="main">)</span>

<span class="keyword1" id="Noninterference-obj_fields_marked_good_ref_subseteq_hp_IdleMarkSweep_locs"><span class="command">lemma</span></span> obj_fields_marked_good_ref_subseteq_hp_IdleMarkSweep_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_fields_marked_good_ref_locs <span class="main">⊆</span> hp_IdleMarkSweep_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_fields_marked_good_ref_locs_def mark_loop_locs_def hp_IdleMarkSweep_locs_def mark_loop_mo_locs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs"><span class="command">lemma</span></span> mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"obj_fields_marked_good_ref_locs <span class="main">⊆</span> hs_in_sync_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> obj_fields_marked_good_ref_locs_def hs_in_sync_locs_def mark_loop_mo_locs_def hs_done_locs_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> loc_defs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_same_cases<span class="main">)</span>

<span class="keyword1" id="Noninterference-no_grey_refs_locs_subseteq_hs_in_sync_locs"><span class="command">lemma</span></span> no_grey_refs_locs_subseteq_hs_in_sync_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"no_grey_refs_locs <span class="main">⊆</span> hs_in_sync_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_locs_def black_heap_locs_def hs_in_sync_locs_def hs_done_locs_def sweep_locs_def loc_defs
         <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_same_cases<span class="main">)</span>

<span class="keyword1" id="Noninterference-get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs"><span class="command">lemma</span></span> get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"get_roots_UN_get_work_locs <span class="main">⊆</span> gc_W_empty_locs"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_roots_UN_get_work_locs_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hs_get_roots_locs_def hs_get_work_locs_def gc_W_empty_locs_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  gc.obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.obj_fields_marked_locs_subseteq_hs_in_sync_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.obj_fields_marked_good_ref_subseteq_hp_IdleMarkSweep_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.no_grey_refs_locs_subseteq_hs_in_sync_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>
  gc.get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs<span class="main">[</span><span class="operator">locset_cache</span><span class="main">]</span>

<span class="keyword1" id="Noninterference-handshake_obj_fields_markedD"><span class="command">lemma</span></span> handshake_obj_fields_markedD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc gc.obj_fields_marked_locs <span class="free">s</span><span class="main">;</span> gc.handshake_invL <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> sys_ghost_hs_phase <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> hp_IdleMarkSweep <span class="main">∧</span> All <span class="main">(</span>ghost_hs_in_sync <span class="main">(</span><span class="free">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.handshake_invL_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> atS_mono gc.obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs gc.obj_fields_marked_locs_subseteq_hs_in_sync_locs<span class="main">)</span>

<span class="keyword1" id="Noninterference-obj_fields_marked_good_ref_locs_hp_phaseD"><span class="command">lemma</span></span> obj_fields_marked_good_ref_locs_hp_phaseD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc gc.obj_fields_marked_good_ref_locs <span class="free">s</span><span class="main">;</span> gc.handshake_invL <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> sys_ghost_hs_phase <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> hp_IdleMarkSweep <span class="main">∧</span> All <span class="main">(</span>ghost_hs_in_sync <span class="main">(</span><span class="free">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.handshake_invL_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> atS_mono gc.mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs gc.obj_fields_marked_good_ref_subseteq_hp_IdleMarkSweep_locs<span class="main">)</span>

<span class="keyword1" id="Noninterference-gc_marking_reaches_Mutate"><span class="command">lemma</span></span> gc_marking_reaches_Mutate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="bound">y</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟶</span> valid_ref <span class="bound">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                             mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> xy xys
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">∈</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> mut_m.tso_store_refs <span class="free">m</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">z</span> <span class="keyword1">reaches</span> <span class="free">y</span><span class="main">)</span> <span class="free">s</span> <span class="main">∧</span> valid_ref <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>refl <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> sb vri <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> obj_at_cong reaches_def rtranclp.rtrancl_into_rtrancl<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> obj_at_def option.case<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reaches_def rtranclp.rtrancl_into_rtrancl valid_refs_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_refs_invD<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> obj_at_cong reaches_def rtranclp.rtrancl_into_rtrancl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_refs_invD<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> obj_at_def option.case<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reaches_def rtranclp.rtrancl_into_rtrancl valid_refs_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> gc_obj_fields_marked_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> filter_empty_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.obj_fields_marked_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> gc.obj_fields_marked_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_locs</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mark <span class="skolem">ref</span> <span class="skolem">mark</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys gc.obj_fields_marked_invL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> handshake_obj_fields_markedD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gc.obj_fields_marked_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> obj_at_field_on_heapE<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> obj_at_field_on_heapE<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys gc.obj_fields_marked_invL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> m<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_imp_valid_ref gc_marking_reaches_Mutate <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> m
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> handshake_obj_fields_markedD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gc.obj_fields_marked_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> m r'
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> obj_fields_marked_good_ref_locs_hp_phaseD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertionD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate_Payload <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">pl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> gc_obj_fields_marked_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fA <span class="skolem">mark</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> gc_obj_fields_marked_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">mark</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys fM_rel_inv_def fM_rel_def gc.obj_fields_marked_invL_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> handshake_obj_fields_markedD hs_phase.distinct<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> hs_phase.distinct<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> obj_fields_marked_good_ref_locs_hp_phaseD<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UnCI elem_set hs_phase.distinct<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> gc.obj_fields_marked_good_ref_locs_def obj_fields_marked_good_ref_locs_hp_phaseD option.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> thin_locs_pre_keep_atSE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Phase <span class="skolem">ph</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> gc_obj_fields_marked_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The infamous termination argument›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_W_empty_mut_inv_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="bound">m'</span><span class="main">.</span> sys_W <span class="main"><span class="hidden">❙</span><b>⊗</b></span> WL <span class="main">(</span>mutator <span class="bound">m'</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>⊗</b></span> sys_ghost_hs_in_sync <span class="bound">m'</span><span class="main">)</span>
          gc_W_empty_mut_inv"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def gc_W_empty_mut_inv_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_W_empty_mut_inv_fun_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> eq_imp_fun_upd<span class="main">[</span><span class="operator">OF</span> mut_m.gc_W_empty_mut_inv_eq_imp<span class="main">,</span> <span class="operator">simplified</span> eq_imp_simps<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> gc_W_empty_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> sys_W <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> WL <span class="bound">p</span> <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_ghost_hs_in_sync <span class="bound">m'</span> <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          gc_W_empty_invL"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_imp_def gc_W_empty_invL_def mut_m.gc_W_empty_mut_inv_def no_grey_refs_def grey_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_W_empty_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> gc.gc_W_empty_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1" id="Noninterference-gc_W_empty_mut_inv_load_W"><span class="command">lemma</span></span> gc_W_empty_mut_inv_load_W<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> mut_m.gc_W_empty_mut_inv <span class="bound">m</span> <span class="free">s</span><span class="main">;</span> <span class="main">∀</span><span class="bound">m</span><span class="main">.</span> sys_ghost_hs_in_sync <span class="bound">m</span> <span class="free">s</span><span class="main">;</span> WL gc <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> WL sys <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_grey_refs <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def no_grey_refs_def grey_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x xa<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> WL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Noninterference-gc_W_empty_mut_inv_hs_init"><span class="command">lemma</span></span> gc_W_empty_mut_inv_hs_init<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mut_m.gc_W_empty_mut_inv <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>hs_type <span class="main">:=</span> <span class="free">ht</span><span class="main">,</span> ghost_hs_in_sync <span class="main">:=</span> <span class="main">⟨</span>False<span class="main">⟩</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mut_m.gc_W_empty_mut_inv <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>hs_type <span class="main">:=</span> <span class="free">ht</span><span class="main">,</span> ghost_hs_in_sync <span class="main">:=</span> <span class="main">⟨</span>False<span class="main">⟩</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">hp'</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def<span class="main">)</span>

<span class="keyword1" id="Noninterference-gc_W_empty_invL"><span class="command">lemma</span></span> gc_W_empty_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP valid_W_inv <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> gc_W_empty_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> gc_W_empty_mut_inv_load_W <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WL_def<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">vcg_name_cases</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_work_done_loop <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> WL_def gc_W_empty_mut_inv_load_W valid_W_inv_sys_ghg_empty_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_roots_done_loop <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> WL_def gc_W_empty_mut_inv_load_W valid_W_inv_sys_ghg_empty_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> gc_gc_W_empty_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.gc_W_empty_invL <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_chainsaw</span>

<span class="keyword1" id="Noninterference-empty_WL_GC"><span class="command">lemma</span></span> empty_WL_GC<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc gc.get_roots_UN_get_work_locs <span class="free">s</span><span class="main">;</span> gc.obj_fields_marked_invL <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> gc_ghost_honorary_grey <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.obj_fields_marked_invL_def
<span class="keyword1"><span class="command">using</span></span> atS_mono<span class="main">[</span><span class="operator">OF</span> _ gc.get_roots_UN_get_work_locs_subseteq_ghost_honorary_grey_empty_locs<span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-gc_hs_get_roots_get_workD"><span class="command">lemma</span></span> gc_hs_get_roots_get_workD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc gc.get_roots_UN_get_work_locs <span class="free">s</span><span class="main">;</span> gc.handshake_invL <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> sys_ghost_hs_phase <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> hp_IdleMarkSweep <span class="main">∧</span> sys_hs_type <span class="free">s</span><span class="main">↓</span> <span class="main">∈</span> <span class="main">{</span>ht_GetWork<span class="main">,</span> ht_GetRoots<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gc.handshake_invL_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> atS_mono atS_un gc.get_roots_UN_get_work_locs_def gc.hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs gc.hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Noninterference-handshake_sweep_mark_endD"><span class="command">lemma</span></span> handshake_sweep_mark_endD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc no_grey_refs_locs <span class="free">s</span><span class="main">;</span> handshake_invL <span class="free">s</span><span class="main">;</span> handshake_phase_inv <span class="free">s</span><span class="main">↓</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.mut_ghost_hs_phase <span class="free">m</span> <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> hp_IdleMarkSweep <span class="main">∧</span> All <span class="main">(</span>ghost_hs_in_sync <span class="main">(</span><span class="free">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc.handshake_invL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ gc.no_grey_refs_locs_subseteq_hs_in_sync_locs<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gc.no_grey_refs_locs_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> atS_state_weak_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_un<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_mono<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ls'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"gc.hp_IdleMarkSweep_locs"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gc.black_heap_locs_def <span class="dynamic"><span class="dynamic">locset_cache</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_mono<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ls'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"gc.hp_IdleMarkSweep_locs"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_IdleMarkSweep_locs_def hp_step_rel_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_simps <span class="dynamic"><span class="dynamic">locset_cache</span></span> hp_step_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-gc_W_empty_mut_mo_co_mark"><span class="command">lemma</span></span> gc_W_empty_mut_mo_co_mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> mut_m.gc_W_empty_mut_inv <span class="bound">x</span> <span class="free">s</span><span class="main">↓</span><span class="main">;</span> mutators_phase_inv <span class="free">s</span><span class="main">↓</span><span class="main">;</span>
     mut_m.mut_ghost_honorary_grey <span class="free">m</span> <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
     <span class="free">r</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span><span class="main">↓</span> <span class="main">∪</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span><span class="main">↓</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span><span class="main">↓</span><span class="main">;</span>
     atS gc get_roots_UN_get_work_locs <span class="free">s</span><span class="main">;</span> gc.handshake_invL <span class="free">s</span><span class="main">;</span> gc.obj_fields_marked_invL <span class="free">s</span><span class="main">;</span>
     atS gc gc_W_empty_locs <span class="free">s</span> <span class="main">⟶</span> gc_W <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
     handshake_phase_inv <span class="free">s</span><span class="main">↓</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">↓</span> <span class="main">⟧</span>
    <span class="main">⟹</span> mut_m.gc_W_empty_mut_inv <span class="free">m'</span> <span class="main">(</span><span class="free">s</span><span class="main">↓</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> gc_hs_get_roots_get_workD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Un_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span> before_get_work past_get_work before_get_roots after_get_roots<span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> before_get_work <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> past_get_work <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mut_m.reachable_snapshot_inv_white_root<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> grey_protects_whiteD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> g p<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="comment1">(* mutator *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
       <span class="comment1">(* Can't be the GC *)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> empty_WL_GC<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs<span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WL_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="comment1">(* Can't be sys *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WL_def valid_W_inv_sys_ghg_empty_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> before_get_roots <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> after_get_roots <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mut_m.reachable_snapshot_inv_white_root<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> grey_protects_whiteD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> g p<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="comment1">(* mutator *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
       <span class="comment1">(* Can't be the GC *)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> empty_WL_GC<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs<span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WL_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="comment1">(* Can't be sys *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WL_def valid_W_inv_sys_ghg_empty_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Noninterference-no_grey_refs_mo_co_mark"><span class="command">lemma</span></span> no_grey_refs_mo_co_mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mutators_phase_inv <span class="free">s</span><span class="main">↓</span><span class="main">;</span>
     no_grey_refs <span class="free">s</span><span class="main">↓</span><span class="main">;</span>
     gc.handshake_invL <span class="free">s</span><span class="main">;</span>
     at gc mark_loop <span class="free">s</span> <span class="main">∨</span> at gc mark_loop_get_roots_load_W <span class="free">s</span> <span class="main">∨</span> at gc mark_loop_get_work_load_W <span class="free">s</span> <span class="main">∨</span> atS gc no_grey_refs_locs <span class="free">s</span><span class="main">;</span>
     <span class="free">r</span> <span class="main">∈</span> mut_m.mut_roots <span class="free">m</span> <span class="free">s</span><span class="main">↓</span> <span class="main">∪</span> mut_m.mut_ghost_honorary_root <span class="free">m</span> <span class="free">s</span><span class="main">↓</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span><span class="main">↓</span><span class="main">;</span>
     handshake_phase_inv <span class="free">s</span><span class="main">↓</span> <span class="main">⟧</span>
    <span class="main">⟹</span> no_grey_refs <span class="main">(</span><span class="free">s</span><span class="main">↓</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_simps gc.handshake_invL_def <span class="dynamic"><span class="dynamic">locset_cache</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> mut_m.handshake_phase_invD<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> conj_disj_distribR<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> handshake_in_syncD mut_m.no_grey_refs_not_rootD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_simps gc.handshake_invL_def <span class="dynamic"><span class="dynamic">locset_cache</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> mut_m.handshake_phase_invD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> handshake_in_syncD mut_m.no_grey_refs_not_rootD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_simps gc.handshake_invL_def <span class="dynamic"><span class="dynamic">locset_cache</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> mut_m.handshake_phase_invD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> handshake_in_syncD mut_m.no_grey_refs_not_rootD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> handshake_sweep_mark_endD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> handshake_in_syncD mut_m.no_grey_refs_not_rootD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Noninterference-gc_W_empty_invL"><span class="command">lemma</span></span> gc_W_empty_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> gc.gc_W_empty_mut_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> gc.no_grey_refs_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
           <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.obj_fields_marked_invL
           <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.gc_W_empty_invL
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> gc.gc_W_empty_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.gc_W_empty_invL_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_noop_done <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">x</span><span class="main">)</span>       <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gc.handshake_invL_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atS_un gc.get_roots_UN_get_work_locs_def hs_type.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> hs_type.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done0 <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def WL_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done0 <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">x</span><span class="main">)</span>  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.gc_W_empty_mut_inv_def WL_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Noninterference-mut_store_old_mark_object_invL"><span class="command">lemma</span></span> mut_store_old_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mutator_phase_inv <span class="free">m</span><span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> mut_store_del.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.mark_object_invL_def mut_m.mut_store_del_mark_object_invL_def2<span class="main">)</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>at gc sweep_loop_free s›</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> handshake_in_syncD mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> mut_m.no_grey_refs_not_rootD obj_at_cong white_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-mut_store_ins_mark_object_invL"><span class="command">lemma</span></span> mut_store_ins_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mutator_phase_inv <span class="free">m</span><span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> mut_store_ins.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.mark_object_invL_def mut_m.mut_store_ins_mark_object_invL_def2<span class="main">)</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>at gc sweep_loop_free s›</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> handshake_in_syncD mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> mut_m.no_grey_refs_not_rootD obj_at_cong white_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Noninterference-mut_mark_object_invL"><span class="command">lemma</span></span> mut_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.handshake_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> mut_m.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.handshake_invL_def mut_m.mark_object_invL_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span><span class="main">)</span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>at gc sweep_loop_free s›</span></span>›</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ins_barrier_locs <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_in_syncD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mut_m.no_grey_refs_not_rootD obj_at_cong white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> marked_not_white mut_m.no_grey_refs_not_rootD whiteI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>del_barrier1_locs <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_in_syncD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mut_m.no_grey_refs_not_rootD obj_at_cong white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> marked_not_white mut_m.no_grey_refs_not_rootD obj_at_cong white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Noninterference-mut_m_get_roots_no_fM_write"><span class="command">lemma</span></span> mut_m_get_roots_no_fM_write<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_m.handshake_invL <span class="free">m</span> <span class="free">s</span><span class="main">;</span> handshake_phase_inv <span class="free">s</span><span class="main">↓</span><span class="main">;</span> fM_rel_inv <span class="free">s</span><span class="main">↓</span><span class="main">;</span> tso_store_inv <span class="free">s</span><span class="main">↓</span> <span class="main">⟧</span>
     <span class="main">⟹</span> atS <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> mut_m.hs_get_roots_locs <span class="free">s</span> <span class="main">∧</span> <span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟶</span> <span class="main">¬</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> mw_fM <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.handshake_invL_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> conjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> fM_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def fM_rel_def filter_empty_conv p_not_sys<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> hs_phase.distinct<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> tso_store_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* FIXME loads of cut-and-paste here *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> mut_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> filter_empty_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.handshake_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span>
     <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> mut_m.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.mark_object_invL_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atS_mono mut_m.hs_get_roots_loop_locs_subseteq_hs_get_roots_locs mut_m_get_roots_no_fM_write<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_done <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> fl obj<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> fl<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">fl</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ws<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">ws</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m_get_roots_no_fM_write<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">loc_mem</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> fl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> fl<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">fl</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> ws<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">ws</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m_get_roots_no_fM_write<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> atS_simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">loc_mem</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mo_ptest_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">ws</span> <span class="skolem">ph'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def handshake_in_syncD <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> hs_phase.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span> 5<span class="main"><span class="main">)</span></span> mut_m.mut_ghost_handshake_phase_idle mut_m_not_idle_no_fM_writeD store_ins<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">using</span></span> valid_refs_invD<span class="main">(</span>9<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def handshake_in_syncD <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>del_barrier1_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> del_barrier1_locs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_imp_valid_ref <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>z3<span class="main"><span class="main">)</span></span> reachableI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> marked_insertionD mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> obj_at_cong reachableI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="comment1">(* brutal *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ma x2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ma</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ma</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertionD mut_m.mut_ghost_handshake_phase_idle<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> del_barrier1_locs mut_m_not_idle_no_fM_writeD <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Phase <span class="skolem">ph</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> del_barrier1_locs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def handshake_in_syncD <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ins_barrier_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ins_barrier_locs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_imp_valid_ref <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>z3<span class="main"><span class="main">)</span></span> reachableI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> marked_insertionD mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> mut_m.mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> obj_at_cong reachableI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="comment1">(* brutal *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ma x2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ma</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ma</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertionD mut_m.mut_ghost_handshake_phase_idle<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ins_barrier_locs mut_m_not_idle_no_fM_writeD <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Phase <span class="skolem">ph</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ins_barrier_locs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def handshake_in_syncD <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lop_store_ins <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> hs_phase.distinct<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">,</span></span>7<span class="main"><span class="main">)</span></span> mut_m_not_idle_no_fM_write<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def handshake_in_syncD <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Global_Noninterference">
<div class="head">
<h1>Theory Global_Noninterference</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Global_Noninterference
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Global non-interference ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹ proofs that depend only on global invariants + lemmas ›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> strong_tricolour_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> strong_tricolour_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> LSTP strong_tricolour_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strong_tricolour_inv_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">x</span> <span class="skolem">xa</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mark <span class="skolem">ref</span> <span class="skolem">field</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">ref</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_def white_def WL_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">ref</span> <span class="skolem">field</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def p_not_sys<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def heap_colours_colours no_black_refsD<span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span> hp_InitMark hp_Mark hp_IdleMarkSweep<span class="main">)</span>
             <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hp_InitMark <span class="skolem">m</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_insertions_def no_black_refsD marked_not_white<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hp_Mark <span class="skolem">m</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_insertions_def no_black_refsD<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hp_IdleMarkSweep <span class="skolem">m</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_not_white mut_m.marked_insertions_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">fM</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def p_not_sys<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_def black_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> colours_distinct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> white_valid_ref<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> white_heap_def<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">xa</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> white_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def p_not_sys<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Noninterference-black_heap_reachable"><span class="command">lemma</span></span> black_heap_reachable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bh<span class="main">:</span> <span class="quoted"><span class="quoted">"black_heap <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"black <span class="free">y</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> black_heap_def valid_refs_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> reachable_points_to valid_refs_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Noninterference-black_heap_valid_ref_marked_insertions"><span class="command">lemma</span></span> black_heap_valid_ref_marked_insertions<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> black_heap <span class="free">s</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_insertions_def black_heap_def black_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits
         <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_refs_invD<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Global_Noninterference-reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate"><span class="command">lemma</span></span> reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bh<span class="main">:</span> <span class="quoted"><span class="quoted">"black_heap <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ngr<span class="main">:</span> <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                                        mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mut_m.reachable_snapshot_invI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> in_snapshotI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> black_heap_reachable<span class="main">)</span>
 <span class="keyword1"><span class="command">using</span></span> bh vri
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> black_heap_def fun_upd_apply<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> bh ngr sb vri
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_refs_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_def grey_reachable_def fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> black_heap_reachable<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> black_heap_def fun_upd_apply<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_inv_dequeue_Mutate<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def in_snapshot_valid_ref fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Noninterference-marked_deletions_dequeue_Mark"><span class="command">lemma</span></span> marked_deletions_dequeue_Mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.marked_deletions <span class="free">m</span> <span class="free">s</span><span class="main">;</span> tso_store_inv <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_deletions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_deletions_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply obj_at_field_on_heap_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits option.splits mem_store_action.splits
         <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD<span class="main">)</span>

<span class="keyword1" id="Global_Noninterference-marked_deletions_dequeue_Mutate"><span class="command">lemma</span></span> marked_deletions_dequeue_Mutate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.marked_deletions <span class="free">m</span> <span class="free">s</span><span class="main">;</span> mut_m.marked_insertions <span class="free">m'</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_deletions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                                 mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_insertions_def mut_m.marked_deletions_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> obj_at_field_on_heap_imp_valid_ref<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Noninterference-grey_protects_white_dequeue_Mark"><span class="command">lemma</span></span> grey_protects_white_dequeue_Mark<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span><span class="main">)</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> this assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="free">r</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> black_dequeue_Mark colours_distinct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> do_store_action_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> greyI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> grey_protects_whiteE<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> grey_protects_whiteI marked_imp_black_or_grey<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_ref_valid_null_ref_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> white_valid_ref<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> black_dequeue_Mark colours_distinct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> do_store_action_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> grey_protects_whiteE<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> grey_protects_whiteI marked_imp_black_or_grey<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_ref_valid_null_ref_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> white_valid_ref<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g'</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>refl <span class="skolem">g</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">g</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> grey_protects_whiteI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grey_fun_upd<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> <span class="comment1">(* FIXME something eta-ish going wrong here: fun_upd_apply triggers too early, why? Maybe the WL rules are borked too *)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> g<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="free">r</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grey_fun_upd<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">g</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> has_white_path_to_step<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Noninterference-reachable_snapshot_inv_dequeue_Mark"><span class="command">lemma</span></span> reachable_snapshot_inv_dequeue_Mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">Not</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> grey_protects_white_dequeue_Mark<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> colours_distinct<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Noninterference-marked_insertions_dequeue_Mark"><span class="command">lemma</span></span> marked_insertions_dequeue_Mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span><span class="main">;</span> <span class="free">tso_writes_inv</span> <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_insertions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_insertions_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span> <span class="main">=</span> <span class="free">p</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Global_Noninterference-marked_insertions_dequeue_Mutate"><span class="command">lemma</span></span> marked_insertions_dequeue_Mutate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">r'</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_insertions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                                    mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_insertions_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span> <span class="main">=</span> <span class="free">p</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* shows the snapshot is preserved by the two marks. *)</span>
<span class="keyword1" id="Global_Noninterference-grey_protects_white_dequeue_Mutate"><span class="command">lemma</span></span> grey_protects_white_dequeue_Mutate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mi<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> md<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.marked_deletions <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                                        mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span><span class="main">)</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> this mi sb <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> grey_protects_white_induct<span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>refl <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> white_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate grey_protects_white_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> marked_insertionD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_not_white whiteI fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="bound">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="var">?s'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="keyword1">grey_protects_white</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> grey_protects_white_induct<span class="main">)</span>
         <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>refl <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grey_fun_upd<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span> <span class="comment1">(* FIXME *)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> md sb <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_protects_white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> g<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="free">r</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate fun_upd_apply <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> has_white_path_to_step<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_split_asm<span class="main">)</span> <span class="comment1">(* FIXME rule: witness field for r points_to c *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> g obj aa<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">aa</span> <span class="main">=</span> <span class="free">f</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">g</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> has_white_path_to_def fun_upd_apply<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rtranclp.intros<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> has_white_path_to_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_deletions_def<span class="main">)</span> <span class="comment1">(* FIXME rule *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"mw_Mutate <span class="free"><span class="free">r</span></span> <span class="free"><span class="free">f</span></span> <span class="free"><span class="free">opt_r'</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* write barrier installed but not all mutators are necessarily past get_roots *)</span>
<span class="keyword1" id="Global_Noninterference-reachable_snapshot_inv_dequeue_Mutate"><span class="command">lemma</span></span> reachable_snapshot_inv_dequeue_Mutate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> grey_protects_white_dequeue_Mutate<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'field</span><span class="main">,</span> <span class="tfree">'mut</span><span class="main">,</span> <span class="tfree">'payload</span><span class="main">,</span> <span class="tfree">'ref</span><span class="main">)</span> lsts"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mi<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.marked_insertions <span class="free">m'</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> md<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.marked_deletions <span class="free">m'</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rsi<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sti<span class="main">:</span> <span class="quoted"><span class="quoted">"strong_tricolour_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">obj</span><span class="main">⦇</span>obj_fields <span class="main">:=</span> <span class="main">(</span>obj_fields <span class="bound">obj</span><span class="main">)</span><span class="main">(</span><span class="free">f</span> <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                                        mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> mut_m.reachable_snapshot_invI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="skolem">y</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>mut_m.reachable <span class="free">m</span> <span class="skolem">y</span> <span class="free">s</span> <span class="main">∨</span> mut_m.reachable <span class="free">m'</span> <span class="skolem">y</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> in_snapshot <span class="skolem">y</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> mi md rsi sb <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ghost_honorary_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> mi md rsi sb <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> mi md rsi sb <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> w<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="comment1">(* FIXME cut and paste here *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ref field option<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_deletions_def mut_m.marked_insertions_def fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate <span class="improper">ref</span> <span class="improper">field</span> <span class="improper">option</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate <span class="improper">ref</span> <span class="improper">field</span> <span class="improper">option</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="skolem">x</span> <span class="free">s</span>"</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reachableI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ref field pl<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.marked_deletions_def mut_m.marked_insertions_def fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate_Payload <span class="skolem">x</span> <span class="improper">field</span> <span class="improper">pl</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate_Payload <span class="skolem">x</span> <span class="improper">field</span> <span class="improper">pl</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="skolem">x</span> <span class="free">s</span>"</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reachableI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.tso_store_refs_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>reaches <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> reaches sb <span class="keyword1"><span class="command">have</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_m.reachable <span class="free">m</span> <span class="skolem">y</span> <span class="free">s</span> <span class="main">∨</span> mut_m.reachable <span class="free">m'</span> <span class="skolem">y</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate mut_m.reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> reachable_points_to mutator_reachable_tso<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> y vri <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_ref <span class="skolem">y</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> reaches mi md rsi sb sti y <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>black <span class="skolem">y</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span> <span class="keyword1">grey_protects_white</span> <span class="skolem">y</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> points_to_Mutate mut_m.marked_insertions_def mut_m.marked_deletions_def<span class="main">)</span> <span class="comment1">(* FIXME lemmas *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"mw_Mutate <span class="free"><span class="free">r</span></span> <span class="free"><span class="free">f</span></span> <span class="free"><span class="free">opt_r'</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_points_to<span class="main">)</span> <span class="comment1">(* FIXME probably want points_to_Mutate as an elim rule to make this robust, reduce duplication *)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> strong_tricolour_invD<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> grey_protects_whiteI marked_imp_black_or_grey<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> grey_protects_whiteE<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> grey_protects_whiteI marked_imp_black_or_grey<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_points_to<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def<span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_points_to<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def<span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_points_to<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def<span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> strong_tricolour_invD<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def<span class="main">)</span>

       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_def fun_upd_apply<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> grey_protects_whiteE<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> grey_protects_whiteI marked_imp_black_or_grey<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> mi md rsi sb
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"in_snapshot <span class="skolem">y</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Global_Noninterference-mutator_phase_inv"><span class="command">lemma</span></span> mutator_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> strong_tricolour_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> LSTP <span class="main">(</span>mut_m.mutator_phase_inv <span class="free">m</span><span class="main">)</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mark <span class="skolem">ref</span> <span class="skolem">field</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case
                           marked_deletions_dequeue_Mark marked_insertions_dequeue_Mark reachable_snapshot_inv_dequeue_Mark
                    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">ref</span> <span class="skolem">field</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
       <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ghost_hs_phase <span class="main">(</span><span class="skolem">s</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> hp_IdleInit
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹sys_mem_store_buffers <span class="skolem">p</span> <span class="skolem">s</span><span class="main">↓</span> <span class="main">=</span> <span class="skolem">w</span> <span class="main">#</span> <span class="skolem">ws</span>›</span></span> spec<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹mutators_phase_inv <span class="skolem">s</span><span class="main">↓</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">]</span> mw_Mutate
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
       <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hp_InitMark
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹sys_mem_store_buffers <span class="skolem">p</span> <span class="skolem">s</span><span class="main">↓</span> <span class="main">=</span> <span class="skolem">w</span> <span class="main">#</span> <span class="skolem">ws</span>›</span></span> spec<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹mutators_phase_inv <span class="skolem">s</span><span class="main">↓</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">]</span> mw_Mutate
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> marked_insertions_dequeue_Mutate<span class="main">)</span>
       <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hp_Mark <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer mw_Mutate <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case p_not_sys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertions_dequeue_Mutate<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> m'<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> marked_deletions_dequeue_Mutate<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command">using</span></span> hs_phase.distinct<span class="main">(</span>11<span class="main">)</span> hs_phase.distinct<span class="main">(</span>15<span class="main">)</span> hs_type.distinct<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
       <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hp_IdleMarkSweep <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer mw_Mutate <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case p_not_sys
                             <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sys.marked_insertions_dequeue_Mutate<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> m'<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> marked_deletions_dequeue_Mutate<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def fA_rel_def fM_rel_def <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> black_heap_valid_ref_marked_insertions<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> m'<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span>  <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">m'</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> mut_m.handshake_phase_invD<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate reachable_snapshot_inv_dequeue_Mutate<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def fA_rel_def fM_rel_def<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate_Payload <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">pl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> reachable_snapshot_fun_upd<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> mem_store_action.simps<span class="main"><span class="main">(</span></span>39<span class="main"><span class="main">)</span></span> tso_store_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fA <span class="skolem">mark</span><span class="main">)</span>     <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">mark</span><span class="main">)</span>     <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> mut_m_not_idle_no_fM_writeD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Phase <span class="skolem">phase</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="MarkObject">
<div class="head">
<h1>Theory MarkObject</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> MarkObject
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Mark Object ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

These are the most intricate proofs in this development.

›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MarkObject-mark_object_invL"><span class="command">lemma</span></span> mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> mark_object_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">obj</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>deref_del <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> obj_at_field_on_heapE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> obj_at_field_on_heap_no_pending_stores<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def hp_step_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="MarkObject-mut_store_ins_mark_object_invL"><span class="command">lemma</span></span> mut_store_ins_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_store_ins.mark_object_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> mut_store_ins.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> store_ins_mo_null <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> reachableI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_ins_mo_mark <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">obj</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_W_inv_no_mark_stores_invD filter_empty_conv<span class="main">)</span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_ins_mo_co_won <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_ins_mo_mtest <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_ins_mo_co_ctest0 <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> whiteI<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_ctest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">obj</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MarkObject-mut_store_del_mark_object_invL"><span class="command">lemma</span></span> mut_store_del_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_store_del.mark_object_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> mut_store_del.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> store_del_mo_co_ctest0 <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_del_mo_co_ctest  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_del_mo_ptest     <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_inv_no_mark_stores_invD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_del_mo_mark      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> store_del_mo_null      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_refs_invD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MarkObject-mut_get_roots_mark_object_invL"><span class="command">lemma</span></span> mut_get_roots_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> hs_get_roots_loop_mo_co_ctest0 <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hs_get_roots_loop_mo_co_ctest  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hs_get_roots_loop_mo_ptest     <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_inv_no_mark_stores_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hs_get_roots_loop_mo_mark      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> hs_get_roots_loop_mo_null      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_inv_no_mark_stores_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> mut_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> obj_at_field_on_heap_splits<span class="main">[</span><span class="operator">split</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mark_object_invL <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mark_object_invL_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">obj_fields_marked_inv</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MarkObject-gc_mark_mark_object_invL"><span class="command">lemma</span></span> gc_mark_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
        <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP valid_W_inv <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> gc_mark.mark_object_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_inv_no_mark_stores_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="MarkObject-obj_fields_marked_invL"><span class="command">lemma</span></span> obj_fields_marked_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> obj_fields_marked_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mark_field_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> obj_fields_marked_mark_field_done<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mark_deref <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"grey <span class="main">(</span>gc_tmp_ref <span class="skolem">s</span><span class="main">↓</span><span class="main">)</span> <span class="skolem">s</span><span class="main">↓</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> mark_loop_mark_deref <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> case_optionE obj_at_def valid_W_invE<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> valid_refs_invD<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_def ranI reaches_step<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MarkObject-mut_store_ins_mark_object_invL"><span class="command">lemma</span></span> mut_store_ins_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mut_m_not_idle_no_fM_writeD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">,</span> <span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> not_blocked_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.tso_lock_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> mut_store_ins.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.mark_object_invL_def mut_m.tso_lock_invL_def mut_m.mut_store_ins_mark_object_invL_def2<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_fM <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">ref</span> <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_mtest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI notI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_cmark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_ctest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_won <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI notI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MarkObject-mut_store_del_mark_object_invL"><span class="command">lemma</span></span> mut_store_del_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mut_m_not_idle_no_fM_writeD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">,</span> <span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> not_blocked_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.tso_lock_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> mut_store_del.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.mark_object_invL_def mut_m.tso_lock_invL_def mut_m.mut_store_del_mark_object_invL_def2<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_fM <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_mtest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI notI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_cmark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_ctest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> filter_empty_conv valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_won <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def filter_empty_conv mut_m_not_idle_no_fM_write valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MarkObject-mut_get_roots_mark_object_invL"><span class="command">lemma</span></span> mut_get_roots_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> not_blocked_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> p_not_sys<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mut_m.handshake_phase_invD<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span><span class="main">,</span> <span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.tso_lock_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.handshake_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.tso_lock_invL_def mut_m.handshake_invL_def mut_m.mut_get_roots_mark_object_invL_def2<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"mutator <span class="free">m</span>"</span></span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_fM <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits if_splits<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_mtest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_cmark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_ctest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_won <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def valid_W_invD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def hp_step_rel_def filter_empty_conv valid_W_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MarkObject-gc_mark_mark_object_invL"><span class="command">lemma</span></span> gc_mark_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.tso_lock_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> gc_mark.mark_object_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.gc_mark_mark_object_invL_def2 gc.tso_lock_invL_def gc.phase_invL_def gc.fM_fA_invL_def gc.handshake_invL_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted"><span class="quoted">"gc"</span></span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_fM <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_mtest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_phase <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_ptest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_cmark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_ctest <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_won <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def not_blocked_def fM_rel_def filter_empty_conv p_not_sys valid_W_invD
                     <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> mut_get_roots_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_chainsaw</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> mut_store_ins_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_store_ins.mark_object_invL <span class="free">m</span> <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_chainsaw</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> mut_store_del_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_store_del.mark_object_invL <span class="free">m</span> <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_chainsaw</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> mut_get_roots_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.handshake_invL <span class="free">m</span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main">⦄</span> gc <span class="main">⦃</span> mut_get_roots.mark_object_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.handshake_invL_def mut_m.mut_get_roots_mark_object_invL_def2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_obj_fields_marked_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.obj_fields_marked_invL
     <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> gc.obj_fields_marked_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.obj_fields_marked_invL_def gc.handshake_invL_def<span class="main">)</span>
<span class="comment1">(* FIXME rules *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gc.obj_fields_marked_def fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s' ra x<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> obj_at_field_on_heapE<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"grey <span class="main">(</span>gc_tmp_ref <span class="improper">s</span><span class="main">↓</span><span class="main">)</span> <span class="improper">s</span><span class="main">↓</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"gc_tmp_ref <span class="improper">s</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> greyI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_mark_mark_object_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc_mark.mark_object_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.gc_mark_mark_object_invL_def2<span class="main">)</span>


<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Phases">
<div class="head">
<h1>Theory Phases</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Phases
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Handshake phases›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Reasoning about phases, handshakes.

Tie the garbage collector's control location to the value of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
"gc_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> phase_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> tso_pending_phase gc <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          phase_invL"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def <span class="dynamic"><span class="dynamic">inv</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_phase_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> gc.phase_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> phase_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP phase_rel_inv <span class="main">⦄</span> gc <span class="main">⦃</span> phase_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> gc_phase_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_splits<span class="main">[</span><span class="operator">split</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.phase_invL <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.phase_invL_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_phase_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.phase_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.phase_invL_def<span class="main"><span class="main">[</span></span><span class="operator">inv</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> phase_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP phase_rel_inv <span class="main">⦄</span> gc <span class="main">⦃</span> LSTP phase_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> phase_rel_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> phase_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> gc.phase_invL_def<span class="main">[</span><span class="operator">inv</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> phase_rel_inv_def<span class="main">[</span><span class="operator">inv</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span> sys <span class="main">⦃</span> LSTP phase_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> phase_rel_def p_not_sys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> phase_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP phase_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> phase_rel_inv_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_noop_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD
             <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> handshake_phase_rel_def phase_rel_def hp_step_rel_def
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD
             <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> handshake_phase_rel_def phase_rel_def hp_step_rel_def
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD
             <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> handshake_phase_rel_def phase_rel_def hp_step_rel_def
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Connect <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_ghost_hs_phase"<span class="antiquote"><span class="antiquote">}</span></span></span></span> with locations in the GC.

›</span></span>

<span class="keyword1" id="Phases-gc_handshake_invL_eq_imp"><span class="command">lemma</span></span> gc_handshake_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> sys_ghost_hs_phase <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> hs_pending <span class="main">(</span><span class="bound">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">,</span> ghost_hs_in_sync <span class="main">(</span><span class="bound">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">,</span> sys_hs_type <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          gc.handshake_invL"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc.handshake_invL_def eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_handshake_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> gc_handshake_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> gc_handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.handshake_invL <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.handshake_invL_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> handshake_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP handshake_phase_inv <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> handshake_phase_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> handshake_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP handshake_phase_inv <span class="main">⦄</span> gc <span class="main">⦃</span> LSTP handshake_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> handshake_phase_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> handshake_phase_inv_def hp_step_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Local handshake phase invariant for the mutators.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> handshake_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">,</span> sys_hs_type <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_hs_pending <span class="free">m</span> <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> mem_store_buffers <span class="main">(</span><span class="bound">s</span><span class="main">↓</span> sys<span class="main">)</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          handshake_invL"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> eq_imp_def handshake_invL_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> mut_m_handshake_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> mut_m.handshake_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_chainsaw</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> mut_handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.handshake_invL <span class="free">m</span> <span class="main">⦄</span> gc <span class="main">⦃</span> mut_m.handshake_invL <span class="free">m</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.handshake_invL_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> mut_handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_splits<span class="main">[</span><span class="operator">split</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.handshake_invL <span class="free">m</span> <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.handshake_invL_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_handshake_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main">⦄</span> mutator <span class="free">m</span> <span class="main">⦃</span> gc.handshake_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.handshake_invL_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> handshake_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP handshake_phase_inv <span class="main">⦄</span> mutator <span class="free">m</span> <span class="main">⦃</span> LSTP handshake_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> handshake_phase_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Validity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sys_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> wrt <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the handshake
phase. Effectively we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "gc_fM"<span class="antiquote"><span class="antiquote">}</span></span></span></span> as ghost state. We also
include the TSO lock to rule out the GC having any pending marks
during the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "hp_Idle"<span class="antiquote"><span class="antiquote">}</span></span></span></span> handshake phase.

›</span></span>

<span class="keyword1" id="Phases-gc_fM_fA_invL_eq_imp"><span class="command">lemma</span></span> gc_fM_fA_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> sys_fA <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_fM <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> sys_mem_store_buffers gc <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          gc.fM_fA_invL"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc.fM_fA_invL_def eq_imp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_fM_fA_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> gc_fM_fA_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-fM_fA_invL"><span class="command">lemma</span></span> fM_fA_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword1" id="Phases-fM_rel_inv"><span class="command">lemma</span></span> fM_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP fM_rel_inv <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP fM_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def<span class="main">)</span>

<span class="keyword1" id="Phases-fA_rel_inv"><span class="command">lemma</span></span> fA_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP fA_rel_inv <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP fA_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-gc_fM_fA_invL"><span class="command">lemma</span></span> gc_fM_fA_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.fM_fA_invL_def<span class="main">)</span>

<span class="keyword1" id="Phases-fM_rel_inv"><span class="command">lemma</span></span> fM_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP fM_rel_inv <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fM_rel_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fM_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1" id="Phases-fA_rel_inv"><span class="command">lemma</span></span> fA_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP fA_rel_inv <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fA_rel_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fA_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-fA_neq_locs_diff_fA_tso_empty_locs"><span class="command">lemma</span></span> fA_neq_locs_diff_fA_tso_empty_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fA_neq_locs <span class="main">-</span> fA_tso_empty_locs <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fA_neq_locs_def fA_tso_empty_locs_def <span class="dynamic"><span class="dynamic">locset_cache</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> loc_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-gc_fM_fA_invL"><span class="command">lemma</span></span> gc_fM_fA_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> gc.fM_fA_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span> <span class="operator">vcg_chainsaw</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin</span><span class="main"><span class="main">)</span></span> gc.fM_fA_invL_def
     <span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_not_sys<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_name_cases</span> <span class="quoted">sys</span> <span class="quoted">gc</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer_mark_noop_mfence <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fA_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer_fA_neq_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fA_rel_def fM_rel_inv_def fM_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> atS_dests<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_simps gc.fA_neq_locs_diff_fA_tso_empty_locs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer_fA_eq_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fA_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer_idle_flip_noop_mfence <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer_fM_eq_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Phases-fM_rel_inv"><span class="command">lemma</span></span> fM_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span> sys <span class="main">⦃</span> LSTP fM_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def fM_rel_inv_def fM_rel_def p_not_sys
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Phases-fA_rel_inv"><span class="command">lemma</span></span> fA_rel_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span> sys <span class="main">⦃</span> LSTP fA_rel_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def fA_rel_inv_def fA_rel_def p_not_sys
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹sys phase inv›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-sys_phase_inv"><span class="command">lemma</span></span> sys_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
             <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
        <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP sys_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span> <span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span>
       <span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def sys_phase_inv_aux_case heap_colours_colours
                 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits if_splits <span class="main">)</span>
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>alloc <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">rb</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def no_black_refs_def
                  <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD
                  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_mark0 <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def hp_step_rel_def
                   <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def conj_disj_distribR<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
                      <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD filter_empty_conv<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_mark0 <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mut_m.no_grey_refs_not_rootD mutator_phase_inv_aux.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def conj_disj_distribR<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> no_grey_refs_not_rootD
                      <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD filter_empty_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def filter_empty_conv
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def conj_disj_distribR<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
                      <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_grey_refs_not_rootD filter_empty_conv<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def phase_rel_def filter_empty_conv
                     <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD phase_rel_invD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> sys_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP sys_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_work_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def no_grey_refsD filter_empty_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_blacken <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> no_grey_refsD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> no_grey_refsD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> no_grey_refsD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_roots_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def no_grey_refsD filter_empty_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_roots_init_type <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> phase_rel_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def no_grey_refsD filter_empty_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>idle_noop_init_type <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> black_heap_no_greys <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Phases-no_grey_refs_no_marks"><span class="command">lemma</span></span> no_grey_refs_no_marks<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_grey_refs <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_grey_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> greyI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_W_invE<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="comment1">(* FIXME suggests redundancy in valid_W_inv rules:  by (meson greyI(1) valid_W_invD(1)) *)</span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Phases-black_heap_dequeue_mark"><span class="command">lemma</span></span> black_heap_dequeue_mark<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> black_heap <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
   <span class="main">⟹</span> black_heap <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> map_option <span class="main">(</span>obj_mark_update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fl</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sys_heap <span class="free">s</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> colours_distinct<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> white_valid_ref<span class="main">)</span>

<span class="keyword1" id="Phases-white_heap_dequeue_fM"><span class="command">lemma</span></span> white_heap_dequeue_fM<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"black_heap <span class="free">s</span><span class="main">↓</span>
     <span class="main">⟹</span> white_heap <span class="main">(</span><span class="free">s</span><span class="main">↓</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span><span class="main">↓</span> sys<span class="main">⦇</span>fM <span class="main">:=</span> <span class="main">¬</span> sys_fM <span class="free">s</span><span class="main">↓</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_heap_def white_heap_def black_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="comment1">(* FIXME rules? *)</span>

<span class="keyword1" id="Phases-black_heap_dequeue_fM"><span class="command">lemma</span></span> black_heap_dequeue_fM<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> white_heap <span class="free">s</span><span class="main">↓</span><span class="main">;</span> no_grey_refs <span class="free">s</span><span class="main">↓</span> <span class="main">⟧</span>
     <span class="main">⟹</span> black_heap <span class="main">(</span><span class="free">s</span><span class="main">↓</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span><span class="main">↓</span> sys<span class="main">⦇</span>fM <span class="main">:=</span> <span class="main">¬</span> sys_fM <span class="free">s</span><span class="main">↓</span><span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span><span class="main">↓</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">ws</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> black_heap_def white_heap_def no_grey_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Phases-sys_phase_inv"><span class="command">lemma</span></span> sys_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> LSTP sys_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span>
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def p_not_sys
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> do_store_action_def sys_phase_inv_aux_case
                   <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits hs_phase.splits if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> filter.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.discI tso_store_invD<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="StrongTricolour">
<div class="head">
<h1>Theory StrongTricolour</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> StrongTricolour
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="comment1">(* local lemma bucket *)</span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* marked insertions *)</span>

<span class="keyword1" id="StrongTricolour-marked_insertions_store_ins"><span class="command">lemma</span></span> marked_insertions_store_ins<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> marked_insertions <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r'</span><span class="main">.</span> <span class="free">opt_r'</span> <span class="main">=</span> Some <span class="bound">r'</span><span class="main">)</span> <span class="main">⟶</span> marked <span class="main">(</span>the <span class="free">opt_r'</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> marked_insertions
               <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
                   sys <span class="main">:=</span> <span class="free">s</span> sys
                     <span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">]</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertions_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-marked_insertions_alloc"><span class="command">lemma</span></span> marked_insertions_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None<span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span>
  <span class="main">⟹</span> marked_insertions <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="free">obj'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟷</span> marked_insertions <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_insertions_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ref field x<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">ref</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">field</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> valid_refs_invD<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r'</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r'</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(* marked_deletions *)</span>

<span class="keyword1" id="StrongTricolour-marked_deletions_store_ins"><span class="command">lemma</span></span> marked_deletions_store_ins<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> marked_deletions <span class="free">s</span><span class="main">;</span> obj_at_field_on_heap <span class="main">(</span><span class="main">λ</span><span class="bound">r'</span><span class="main">.</span> marked <span class="bound">r'</span> <span class="free">s</span><span class="main">)</span> <span class="free">r</span> <span class="free">f</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> marked_deletions
               <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
                   sys <span class="main">:=</span> <span class="free">s</span> sys
                     <span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">]</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_deletions_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits option.splits<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-marked_deletions_alloc"><span class="command">lemma</span></span> marked_deletions_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> marked_deletions <span class="free">s</span><span class="main">;</span> heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="free">r'</span> <span class="main">=</span> None<span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span>
  <span class="main">⟹</span> marked_deletions <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m'</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m'</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="free">obj'</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_deletions_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ref field option<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate <span class="improper">ref</span> <span class="improper">field</span> <span class="improper">option</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">ref</span> <span class="main">=</span> <span class="free">r'</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Sweep loop invariants›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> sweep_loop_invL_eq_imp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eq_imp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span>AT <span class="bound">s</span> gc<span class="main">,</span> <span class="bound">s</span><span class="main">↓</span> gc<span class="main">,</span> sys_fM <span class="bound">s</span><span class="main">↓</span><span class="main">,</span> map_option obj_mark <span class="main">∘</span> sys_heap <span class="bound">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>
          sweep_loop_invL"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_imp_def <span class="dynamic"><span class="dynamic">inv</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> s s'<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span><span class="main">.</span> valid_ref <span class="bound">r</span> <span class="improper">s</span><span class="main">↓</span> <span class="main">⟷</span> valid_ref <span class="bound">r</span> <span class="improper">s'</span><span class="main">↓</span>"</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">P</span> <span class="bound">r</span><span class="main">.</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span> <span class="improper">s</span><span class="main">↓</span> <span class="main">⟷</span> obj_at <span class="main">(</span><span class="main">λ</span><span class="bound">obj</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>obj_mark <span class="bound">obj</span><span class="main">)</span><span class="main">)</span> <span class="bound">r</span> <span class="improper">s'</span><span class="main">↓</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">mark</span><span class="main">.</span> Some <span class="bound">mark</span> <span class="main">=</span> gc_mark <span class="improper">s'</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">mark</span><span class="main">.</span> <span class="bound">mark</span> <span class="main">=</span> sys_fM <span class="improper">s'</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> r<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">r</span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> r<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">r</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> map_option_eq_Some<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> gc_sweep_loop_invL_niE<span class="main">[</span><span class="operator">nie</span><span class="main">]</span> <span class="main">=</span>
  iffD1<span class="main">[</span><span class="operator">OF</span> gc.sweep_loop_invL_eq_imp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eq_imp_simps<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> conj_explode<span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rotated</span> -1<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> sweep_loop_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
         <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> sweep_loop_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> sweep_loop_ref_done  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> sweep_loop_check     <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> option.collapse option.inject<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> sweep_loop_load_mark <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="StrongTricolour-sweep_loop_locs_subseteq_sweep_locs"><span class="command">lemma</span></span> sweep_loop_locs_subseteq_sweep_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sweep_loop_locs <span class="main">⊆</span> sweep_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sweep_loop_locs_def sweep_locs_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-sweep_locs_subseteq_fM_tso_empty_locs"><span class="command">lemma</span></span> sweep_locs_subseteq_fM_tso_empty_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sweep_locs <span class="main">⊆</span> fM_tso_empty_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sweep_locs_def fM_tso_empty_locs_def loc_defs<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-sweep_loop_locs_fM_eq_locs"><span class="command">lemma</span></span> sweep_loop_locs_fM_eq_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sweep_loop_locs <span class="main">⊆</span> fM_eq_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sweep_loop_locs_def fM_eq_locs_def sweep_locs_def loc_defs<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-sweep_loop_locs_fA_eq_locs"><span class="command">lemma</span></span> sweep_loop_locs_fA_eq_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sweep_loop_locs <span class="main">⊆</span> fA_eq_locs"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sweep_loop_locs_def fA_eq_locs_def sweep_locs_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> subset_insertI2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="StrongTricolour-black_heap_locs_subseteq_fM_tso_empty_locs"><span class="command">lemma</span></span> black_heap_locs_subseteq_fM_tso_empty_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"black_heap_locs <span class="main">⊆</span> fM_tso_empty_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> black_heap_locs_def fM_tso_empty_locs_def loc_defs<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-black_heap_locs_fM_eq_locs"><span class="command">lemma</span></span> black_heap_locs_fM_eq_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"black_heap_locs <span class="main">⊆</span> fM_eq_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> black_heap_locs_def fM_eq_locs_def loc_defs<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-black_heap_locs_fA_eq_locs"><span class="command">lemma</span></span> black_heap_locs_fA_eq_locs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"black_heap_locs <span class="main">⊆</span> fA_eq_locs"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> black_heap_locs_def fA_eq_locs_def sweep_locs_def loc_defs<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-fM_fA_invL_tso_emptyD"><span class="command">lemma</span></span> fM_fA_invL_tso_emptyD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> atS gc <span class="free">ls</span> <span class="free">s</span><span class="main">;</span> fM_fA_invL <span class="free">s</span><span class="main">;</span> <span class="free">ls</span> <span class="main">⊆</span> fM_tso_empty_locs <span class="main">⟧</span> <span class="main">⟹</span> tso_pending_fM gc <span class="free">s</span><span class="main">↓</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_fA_invL_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> atS_mono<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-gc_sweep_loop_invL_locsE"><span class="command">lemma</span></span> gc_sweep_loop_invL_locsE<span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>atS gc <span class="main">(</span>sweep_locs <span class="main">∪</span> black_heap_locs<span class="main">)</span> <span class="free">s</span> <span class="main">⟶</span> False<span class="main">)</span> <span class="main">⟹</span> gc.sweep_loop_invL <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gc.sweep_loop_invL_def atS_un<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">locset_cache</span></span> atS_simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> atS_mono<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atS_mono gc.sweep_loop_locs_subseteq_sweep_locs<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bspec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sweep_locs_def sweep_loop_not_choose_ref_locs_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> gc_sweep_loop_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> gc.sweep_loop_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_locs</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mark <span class="skolem">r</span> <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gc.gc_sweep_loop_invL_locsE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> gc.gc_W_empty_invL_def gc.no_grey_refs_locs_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> atS_state_weak_cong<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atS_un<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted">"AT <span class="main">_</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span> <span class="comment1">(* FIXME speed the metis call up a bit *)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">thin_tac</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"at <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main">⟶</span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span>"</span></span></span></span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> filter.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> loc_mem_tac_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> no_grey_refs_no_pending_marks<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">opt_r'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">erule</span> gc_sweep_loop_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mutate_Payload <span class="skolem">r</span> <span class="skolem">f</span> <span class="skolem">pl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">erule</span> gc_sweep_loop_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff fun_upd_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fA <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> gc_sweep_loop_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gc.gc_sweep_loop_invL_locsE<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">p</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> gc.fM_fA_invL_tso_emptyD<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command">using</span></span> gc.black_heap_locs_subseteq_fM_tso_empty_locs gc.sweep_locs_subseteq_fM_tso_empty_locs <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Phase <span class="skolem">ph</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> gc_sweep_loop_invL_niE<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> gc_sweep_loop_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc.sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> gc.sweep_loop_invL <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span> <span class="operator">vcg_chainsaw</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin</span><span class="main"><span class="main">)</span></span> gc.fM_fA_invL_def gc.sweep_loop_invL_def gc.handshake_invL_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="quoted">gc</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sweep_loop_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">rb</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> atS_mono gc.sweep_loop_locs_fA_eq_locs gc.sweep_loop_locs_fM_eq_locs<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>black_heap_locs <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">rb</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> atS_mono gc.black_heap_locs_fA_eq_locs gc.black_heap_locs_fM_eq_locs<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Mutator proofs ›</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* reachable snapshot inv *)</span>

<span class="keyword1" id="StrongTricolour-reachable_snapshot_inv_mo_co_mark"><span class="command">lemma</span></span> reachable_snapshot_inv_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> reachable_snapshot_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> in_snapshot_def reachable_snapshot_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-reachable_snapshot_inv_hs_get_roots_done"><span class="command">lemma</span></span> reachable_snapshot_inv_hs_get_roots_done<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sti<span class="main">:</span> <span class="quoted"><span class="quoted">"strong_tricolour_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span><span class="main">.</span> marked <span class="bound">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ghr<span class="main">:</span> <span class="quoted"><span class="quoted">"mut_ghost_honorary_root <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"tso_pending_mutate <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> vri<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv
               <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_hs_phase <span class="main">:=</span> <span class="free">ghp'</span><span class="main">⦈</span><span class="main">,</span>
                  sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>hs_pending <span class="main">:=</span> <span class="free">hp'</span><span class="main">,</span> W <span class="main">:=</span> sys_W <span class="free">s</span> <span class="main">∪</span> mut_W <span class="free">s</span><span class="main">,</span> ghost_hs_in_sync <span class="main">:=</span> <span class="free">in'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="var">?s'</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"reachable <span class="skolem">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"in_snapshot <span class="skolem">r</span> <span class="var">?s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> reachable_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> m <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span> <span class="comment1">(* FIXME intro rules *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> marked_imp_black_or_grey<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ghost_honorary_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ghr <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_root <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> t <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_empty_conv tso_store_refs_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> w<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">w</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>reaches <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> reaches vri <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_ref <span class="skolem">x</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"valid_ref <span class="skolem">y</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> reachable_points_to <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> reaches sti vri <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> strong_tricolour_inv_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> marked_imp_black_or_grey<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"white <span class="skolem">y</span> <span class="free">s</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> grey_protects_whiteE
                 <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> marked_imp_black_or_grey<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StrongTricolour-reachable_snapshot_inv_hs_get_work_done"><span class="command">lemma</span></span> reachable_snapshot_inv_hs_get_work_done<span class="main">:</span>
  <span class="quoted"><span class="quoted">"reachable_snapshot_inv <span class="free">s</span>
    <span class="main">⟹</span> reachable_snapshot_inv
               <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">,</span>
                   sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>hs_pending <span class="main">:=</span> <span class="free">pending'</span><span class="main">,</span> W <span class="main">:=</span> sys_W <span class="free">s</span> <span class="main">∪</span> mut_W <span class="free">s</span><span class="main">,</span>
                                ghost_hs_in_sync <span class="main">:=</span> <span class="main">(</span>ghost_hs_in_sync <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">m</span> <span class="main">:=</span> True<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-reachable_snapshot_inv_deref_del"><span class="command">lemma</span></span> reachable_snapshot_inv_deref_del<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> reachable_snapshot_inv <span class="free">s</span><span class="main">;</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">opt_r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span><span class="main">;</span> mut_ghost_honorary_root <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> reachable_snapshot_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> Option.set_option <span class="free">opt_r'</span><span class="main">,</span> ref <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-mutator_phase_inv"><span class="command">lemma</span></span> mutator_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> reachable_snapshot_inv_deref_del<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> strong_tricolour_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP mutator_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span> <span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span>
    <span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits
    <span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> alloc <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def fM_rel_def hp_step_rel_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reachable_snapshot_inv_alloc<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> marked_deletions_store_ins<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span> <span class="comment1">(* FIXME shuffle the following into this lemma *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">opt_r'</span><span class="main">.</span> mw_Mutate <span class="main">(</span>mut_tmp_ref <span class="skolem">s</span><span class="main">↓</span><span class="main">)</span> <span class="main">(</span>mut_field <span class="skolem">s</span><span class="main">↓</span><span class="main">)</span> <span class="bound">opt_r'</span> <span class="main">∉</span> set <span class="main">(</span>sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="skolem">s</span><span class="main">↓</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_deletions_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> marked_insertions_store_ins<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def hp_step_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reachable_blackD <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> blackD<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> marked_deletions_store_ins<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="comment1">(* FIXME as above *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> phase_rel_invD<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> phase_rel_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="comment1">(* FIXME invert handshake_phase_rel *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x2a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> blackD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> reachable_blackD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mut_tmp_ref <span class="skolem">s</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> reachable_points_to<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x2a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> blackD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> reachable_blackD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mut_tmp_ref <span class="skolem">s</span><span class="main">↓</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> reachable_points_to<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> marked_deletions_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_noop_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def hp_step_rel_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"mut_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main">)</span> <span class="comment1">(* FIXME invert handshake_step *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def reachable_snapshot_inv_hs_get_roots_done<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hp_step_rel_def reachable_snapshot_inv_hs_get_work_done<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m'<span class="main">)</span> mutator_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mut_m.mark_object_invL_def<span class="main">[</span><span class="operator">inv</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mut_m.handshake_invL_def<span class="main">[</span><span class="operator">inv</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.handshake_invL <span class="free">m'</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_m.mark_object_invL <span class="free">m'</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m'</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m'</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m'</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m'</span>
   <span class="main">⦃</span> LSTP mutator_phase_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span> <span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span>
    <span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits
    <span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>alloc <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">rb</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reachable_snapshot_inv_alloc<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> handshake_phase_invD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sys_ghost_hs_phase <span class="skolem">s</span><span class="main">↓</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_black_refs_def reachable_snapshot_inv_def in_snapshot_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_black_refs_def reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* FIXME Some of ‹mutator_phase_inv›, the rest in Global Noninterference *)</span>

<span class="keyword1" id="StrongTricolour-no_black_refs_sweep_loop_free"><span class="command">lemma</span></span> no_black_refs_sweep_loop_free<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"no_black_refs <span class="free">s</span> <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span>gc_tmp_ref <span class="free">s</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="StrongTricolour-no_black_refs_load_W"><span class="command">lemma</span></span> no_black_refs_load_W<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> no_black_refs <span class="free">s</span><span class="main">;</span> gc_W <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> no_black_refs <span class="main">(</span><span class="free">s</span><span class="main">(</span>gc <span class="main">:=</span> <span class="free">s</span> gc<span class="main">⦇</span>W <span class="main">:=</span> sys_W <span class="free">s</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>W <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> no_black_refs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="StrongTricolour-marked_insertions_sweep_loop_free"><span class="command">lemma</span></span> marked_insertions_sweep_loop_free<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_m.marked_insertions <span class="free">m</span> <span class="free">s</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_insertions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>heap <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_insertions_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits obj_at_splits option.splits<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-marked_deletions_sweep_loop_free"><span class="command">lemma</span></span> marked_deletions_sweep_loop_free<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mut_m.marked_deletions <span class="free">m</span> <span class="free">s</span><span class="main">;</span> mut_m.reachable_snapshot_inv <span class="free">m</span> <span class="free">s</span><span class="main">;</span> no_grey_refs <span class="free">s</span><span class="main">;</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> mut_m.marked_deletions <span class="free">m</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mut_m.marked_deletions_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ref field option<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"mw_Mutate <span class="improper">ref</span> <span class="improper">field</span> <span class="improper">option</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> obj_at_field_on_heap_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_def mut_m.tso_store_refs_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span> <span class="comment1">(* FIXME rule *)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> grey_protects_whiteD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_snapshot_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_def mut_m.tso_store_refs_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span> <span class="comment1">(* FIXME rule *)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> grey_protects_whiteD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> no_grey_refs_def<span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> white_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="StrongTricolour-obj_fields_marked_inv_blacken"><span class="command">lemma</span></span> obj_fields_marked_inv_blacken<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> gc_field_set <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> obj_fields_marked <span class="free">s</span><span class="main">;</span> <span class="main">(</span>gc_tmp_ref <span class="free">s</span> <span class="keyword1">points_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> white <span class="free">w</span> <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> obj_fields_marked_def obj_at_field_on_heap_def ran_def white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits obj_at_splits<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-obj_fields_marked_inv_has_white_path_to_blacken"><span class="command">lemma</span></span> obj_fields_marked_inv_has_white_path_to_blacken<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> gc_field_set <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> gc_tmp_ref <span class="free">s</span> <span class="main">∈</span> gc_W <span class="free">s</span><span class="main">;</span> <span class="main">(</span>gc_tmp_ref <span class="free">s</span> <span class="keyword1">has_white_path_to</span> <span class="free">w</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> obj_fields_marked <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">w</span> <span class="main">=</span> gc_tmp_ref <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> converse_rtranclpE gc.obj_fields_marked_inv_blacken has_white_path_to_def<span class="main">)</span>

<span class="keyword1" id="StrongTricolour-mutator_phase_inv"><span class="command">lemma</span></span> mutator_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP <span class="main">(</span>mut_m.mutator_phase_inv <span class="free">m</span><span class="main">)</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span> <span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span>
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mutator_phase_inv_aux_case white_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span> <span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sweep_loop_free <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mut_m.reachable_snapshot_inv_sweep_loop_free<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> white_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_work_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span> <span class="comment1">(* FIXME rule *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_blacken <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.handshake_phase_invD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> obj_fields_marked_inv_has_white_path_to_blacken<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> handshake_in_syncD mut_m.reachable_snapshot_inv_mo_co_mark<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_roots_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mut_m.reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def<span class="main">)</span> <span class="comment1">(* FIXME rule *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> strong_tricolour_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>strong_tricolour_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP strong_tricolour_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strong_tricolour_inv_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_blacken <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="skolem">xa</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> obj_fields_marked_inv_blacken<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> strong_tricolour<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mark_object_invL
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fA_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> strong_tricolour_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP strong_tricolour_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strong_tricolour_inv_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>alloc <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">x</span> <span class="skolem">xa</span> <span class="skolem">rb</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_inv_def fM_rel_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> handshake_phase_invD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">m</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sys_phase_inv_aux_case
               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> hs_phase.splits if_splits<span class="main">)</span>

 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> heap_colours_colours<span class="main">)</span>

 <span class="comment1">(* FIXME rule? *)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> black_def no_black_refsD obj_at_cong option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> black_def no_black_refsD obj_at_cong option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hp_step_rel_def<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fA_rel_def fM_rel_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="TSO">
<div class="head">
<h1>Theory TSO</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> TSO
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Coarse TSO invariants ›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TSO-tso_lock_invL"><span class="command">lemma</span></span> tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> tso_lock_invL <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword1" id="TSO-tso_store_inv"><span class="command">lemma</span></span> tso_store_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP tso_store_inv <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tso_store_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword1" id="TSO-mut_tso_lock_invL"><span class="command">lemma</span></span> mut_tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.tso_lock_invL <span class="free">m</span> <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.tso_lock_invL_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TSO-tso_store_inv"><span class="command">lemma</span></span> tso_store_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP tso_store_inv <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tso_store_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword1" id="TSO-gc_tso_lock_invL"><span class="command">lemma</span></span> gc_tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.tso_lock_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.tso_lock_invL_def<span class="main">)</span>

<span class="keyword1" id="TSO-tso_lock_invL"><span class="command">lemma</span></span> tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> tso_lock_invL <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg_jackhammer</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> mut_m'
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TSO-tso_lock_invL"><span class="command">lemma</span></span> tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> tso_lock_invL <span class="main">⦄</span> mutator <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> tso_lock_invL<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> sys
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="TSO-tso_gc_store_inv"><span class="command">lemma</span></span> tso_gc_store_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP tso_store_inv <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> tso_store_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> list.set_intros<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="TSO-gc_tso_lock_invL"><span class="command">lemma</span></span> gc_tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc.tso_lock_invL <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> gc.tso_lock_invL_def<span class="main">)</span>

<span class="keyword1" id="TSO-mut_tso_lock_invL"><span class="command">lemma</span></span> mut_tso_lock_invL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mut_m.tso_lock_invL <span class="free">m</span> <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">vcg_chainsaw</span> mut_m.tso_lock_invL_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Valid_Refs">
<div class="head">
<h1>Theory Valid_Refs</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Valid_Refs
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Valid refs inv proofs ›</span></span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_sweep_loop_free"><span class="command">lemma</span></span> valid_refs_inv_sweep_loop_free<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ngr<span class="main">:</span> <span class="quoted"><span class="quoted">"no_grey_refs <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rsi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">m'</span><span class="main">.</span> mut_m.reachable_snapshot_inv <span class="bound">m'</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"white <span class="free">r'</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> <span class="main">(</span>sys_heap <span class="free">s</span><span class="main">)</span><span class="main">(</span><span class="free">r'</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def grey_reachable_def no_grey_refs_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> reachable_sweep_loop_free<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> mut_m.reachable_blackD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ngr spec<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rsi<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> valid_refs_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> fM_fA_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_mark.mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> phase_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>handshake_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> mutators_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP valid_refs_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sweep_loop_free <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> handshake_in_syncD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_refs_inv_sweep_loop_free<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> white_def<span class="main">)</span> <span class="comment1">(* FIXME rule? *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_inv_def grey_reachable_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> mut_m
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_discard_roots"><span class="command">lemma</span></span> valid_refs_inv_discard_roots<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs_inv <span class="free">s</span><span class="main">;</span> <span class="free">roots'</span> <span class="main">⊆</span> mut_roots <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> <span class="free">roots'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def mut_m.reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_load"><span class="command">lemma</span></span> valid_refs_inv_load<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs_inv <span class="free">s</span><span class="main">;</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> mut_roots <span class="free">s</span> <span class="main">∪</span> Option.set_option <span class="free">r'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_alloc"><span class="command">lemma</span></span> valid_refs_inv_alloc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs_inv <span class="free">s</span><span class="main">;</span> sys_heap <span class="free">s</span> <span class="free">r'</span> <span class="main">=</span> None <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>roots <span class="main">:=</span> insert <span class="free">r'</span> <span class="main">(</span>mut_roots <span class="free">s</span><span class="main">)</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>heap <span class="main">:=</span> sys_heap <span class="free">s</span><span class="main">(</span><span class="free">r'</span> <span class="main">↦</span> <span class="main">⦇</span>obj_mark <span class="main">=</span> <span class="free">fl</span><span class="main">,</span> obj_fields <span class="main">=</span> Map.empty<span class="main">,</span> obj_payload <span class="main">=</span> Map.empty<span class="main">⦈</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def mut_m.reachable_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> converse_reachesE <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_store_ins"><span class="command">lemma</span></span> valid_refs_inv_store_ins<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs_inv <span class="free">s</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span><span class="main">;</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r'</span><span class="main">.</span> <span class="free">opt_r'</span> <span class="main">=</span> Some <span class="bound">r'</span><span class="main">)</span> <span class="main">⟶</span> the <span class="free">opt_r'</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span> ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span><span class="main">,</span>
                          sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span> mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> sys_mem_store_buffers <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mutate <span class="free">r</span> <span class="free">f</span> <span class="free">opt_r'</span><span class="main">]</span><span class="main">)</span> <span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_refs_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_reachable_def mut_m.reachable_def fun_upd_apply<span class="main">)</span>
<span class="comment1">(* FIXME what's gone wrong here? *)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> tso_store_refs_simps<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_deref_del"><span class="command">lemma</span></span> valid_refs_inv_deref_del<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_refs_inv <span class="free">s</span><span class="main">;</span> sys_load <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span> <span class="main">(</span>mr_Ref <span class="free">r</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span> <span class="main">=</span> mv_Ref <span class="free">opt_r'</span><span class="main">;</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span><span class="main">;</span> mut_ghost_honorary_root <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_root <span class="main">:=</span> Option.set_option <span class="free">opt_r'</span><span class="main">,</span> ref <span class="main">:=</span> <span class="free">opt_r'</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv_mo_co_mark"><span class="command">lemma</span></span> valid_refs_inv_mo_co_mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> mut_roots <span class="free">s</span> <span class="main">∪</span> mut_ghost_honorary_root <span class="free">s</span><span class="main">;</span> mut_ghost_honorary_grey <span class="free">s</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> valid_refs_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> valid_refs_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>mutator <span class="free">m</span> <span class="main">:=</span> <span class="free">s</span> <span class="main">(</span>mutator <span class="free">m</span><span class="main">)</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_inv_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> grey_reachable_def fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> grey_reachable_def valid_refs_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>10<span class="main"><span class="main">)</span></span> valid_refs_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Valid_Refs-valid_refs_inv"><span class="command">lemma</span></span> valid_refs_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_discard_roots<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_load<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_alloc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_store_ins<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_deref_del<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> valid_refs_inv_mo_co_mark<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> mark_object_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP valid_refs_inv <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP valid_refs_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_locs</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_inv_def grey_reachable_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_inv_def grey_reachable_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> valid_refs_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv<span class="main">)</span> <span class="main">⦄</span> sys <span class="main">⦃</span> LSTP valid_refs_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> do_store_action_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_not_sys valid_refs_inv_dequeue_Mutate valid_refs_inv_dequeue_Mutate_Payload fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> mem_store_action.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Worklists">
<div class="head">
<h1>Theory Worklists</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Worklists
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Global_Invariants_Lemmas.html">Global_Invariants_Lemmas</a>
  <a href="Local_Invariants_Lemmas.html">Local_Invariants_Lemmas</a>
  <a href="Tactics.html">Tactics</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Worklist invariants \label{sec:worklist-invariants} ›</span></span>

<span class="keyword1" id="Worklists-valid_W_invD0"><span class="command">lemma</span></span> valid_W_invD0<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> <span class="free">q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> WL <span class="free">q</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> W <span class="main">(</span><span class="free">s</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> <span class="free">q</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">∉</span> WL <span class="free">q</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> marked_not_white <span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 5 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>

<span class="keyword1" id="Worklists-valid_W_distinct_simps"><span class="command">lemma</span></span> valid_W_distinct_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">=</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">=</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">r</span> <span class="main">∈</span> WL <span class="free">p</span> <span class="free">s</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">r</span> <span class="main">∈</span> WL <span class="free">q</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">=</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> valid_W_invD0<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
 <span class="keyword1"><span class="command">using</span></span> valid_W_invD0<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> UnE WL_def valid_W_invD0<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_W_invD0<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Worklists-valid_W_inv_sys_mem_store_buffersD"><span class="command">lemma</span></span> valid_W_inv_sys_mem_store_buffersD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Mutate <span class="free">r'</span> <span class="free">f</span> <span class="free">r''</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="free">ws</span> <span class="main">=</span> <span class="main">[</span>mw_Mark <span class="free">r</span> <span class="free">fl</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_fA <span class="free">fl'</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="free">ws</span> <span class="main">=</span> <span class="main">[</span>mw_Mark <span class="free">r</span> <span class="free">fl</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_fM <span class="free">fl'</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="free">ws</span> <span class="main">=</span> <span class="main">[</span>mw_Mark <span class="free">r</span> <span class="free">fl</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> mw_Phase <span class="free">ph</span> <span class="main">#</span> <span class="free">ws</span><span class="main">;</span> mw_Mark <span class="free">r</span> <span class="free">fl</span> <span class="main">∈</span> set <span class="free">ws</span><span class="main">;</span> valid_W_inv <span class="free">s</span> <span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">fl</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∧</span> tso_locked_by <span class="free">p</span> <span class="free">s</span> <span class="main">∧</span> white <span class="free">r</span> <span class="free">s</span> <span class="main">∧</span> filter is_mw_Mark <span class="free">ws</span> <span class="main">=</span> <span class="main">[</span>mw_Mark <span class="free">r</span> <span class="free">fl</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def white_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">p</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Worklists-valid_W_invE2"><span class="command">lemma</span></span> valid_W_invE2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">obj</span><span class="main">⟧</span> <span class="main">⟹</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">≠</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">obj</span><span class="main">.</span> obj_mark <span class="bound">obj</span> <span class="main">=</span> sys_fM <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">obj</span> <span class="main">⟧</span> <span class="main">⟹</span> obj_at <span class="free">P</span> <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> obj_at_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> valid_W_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_store_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     sys
   <span class="main">⦃</span> LSTP valid_W_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>tso_dequeue_store_buffer <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">p</span> <span class="skolem">w</span> <span class="skolem">ws</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
       <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_Mark <span class="skolem">r</span> <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib white_def valid_W_inv_sys_ghg_empty_iff filter_empty_conv obj_at_simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> valid_W_invE2<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Int_emptyI valid_W_distinct_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> valid_W_invD<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command">using</span></span> valid_W_invD<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mw_fM <span class="skolem">fl</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> tso_dequeue_store_buffer <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fM_rel_inv_def fM_rel_def p_not_sys<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> no_grey_refs_no_pending_marks<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Int_emptyI no_grey_refsD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> no_grey_refsD<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_distinct_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_W_inv_sys_ghg_empty_iff valid_W_inv_sys_mem_store_buffersD<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* Lemmas for key mark_object transitions *)</span>

<span class="keyword1" id="Worklists-valid_W_inv_ghg_disjoint"><span class="command">lemma</span></span> valid_W_inv_ghg_disjoint<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> white <span class="free">y</span> <span class="free">s</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">=</span> Some <span class="free">p</span><span class="main">;</span> valid_W_inv <span class="free">s</span><span class="main">;</span> <span class="free">p0</span> <span class="main">≠</span> <span class="free">p1</span> <span class="main">⟧</span>
     <span class="main">⟹</span> WL <span class="free">p0</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> WL <span class="free">p1</span> <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def WL_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 5 5 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span>

<span class="keyword1" id="Worklists-valid_W_inv_mo_co_mark"><span class="command">lemma</span></span> valid_W_inv_mo_co_mark<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_W_inv <span class="free">s</span><span class="main">;</span> white <span class="free">y</span> <span class="free">s</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">=</span> Some <span class="free">p</span><span class="main">;</span> filter is_mw_Mark <span class="main">(</span>sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟧</span>
    <span class="main">⟹</span> valid_W_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>ghost_honorary_grey <span class="main">:=</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span><span class="main">⦈</span><span class="main">,</span> sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>mem_store_buffers <span class="main">:=</span> <span class="main">(</span>mem_store_buffers <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">@</span> <span class="main">[</span>mw_Mark <span class="free">y</span> <span class="main">(</span>sys_fM <span class="free">s</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_distinct_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_inv_sys_ghg_empty_iff valid_W_invD0 valid_W_inv_ghg_disjoint valid_W_inv_colours<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Worklists-valid_W_inv_mo_co_lock"><span class="command">lemma</span></span> valid_W_inv_mo_co_lock<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_W_inv <span class="free">s</span><span class="main">;</span> sys_mem_lock <span class="free">s</span> <span class="main">=</span> None <span class="main">⟧</span>
    <span class="main">⟹</span> valid_W_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> <span class="free">s</span> sys<span class="main">⦇</span>mem_lock <span class="main">:=</span> Some <span class="free">p</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_inv_def fun_upd_apply<span class="main">)</span> <span class="comment1">(* FIXME some eager rule expects valid_W_inv *)</span>

<span class="keyword1" id="Worklists-valid_W_inv_mo_co_W"><span class="command">lemma</span></span> valid_W_inv_mo_co_W<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> valid_W_inv <span class="free">s</span><span class="main">;</span> marked <span class="free">y</span> <span class="free">s</span><span class="main">;</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span><span class="main">;</span> <span class="free">p</span> <span class="main">≠</span> sys <span class="main">⟧</span>
    <span class="main">⟹</span> valid_W_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span><span class="free">p</span> <span class="main">:=</span> <span class="free">s</span> <span class="free">p</span><span class="main">⦇</span>W <span class="main">:=</span> insert <span class="free">y</span> <span class="main">(</span>W <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> fun_upd_apply<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_W_distinct_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command">using</span></span> valid_W_distinct_simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> marked_not_white singletonD valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Worklists-valid_W_inv_mo_co_unlock"><span class="command">lemma</span></span> valid_W_inv_mo_co_unlock<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sys_mem_lock <span class="free">s</span> <span class="main">=</span> Some <span class="free">p</span><span class="main">;</span> sys_mem_store_buffers <span class="free">p</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> ghost_honorary_grey <span class="main">(</span><span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> marked <span class="bound">r</span> <span class="free">s</span><span class="main">;</span>
     valid_W_inv <span class="free">s</span>
   <span class="main">⟧</span> <span class="main">⟹</span> valid_W_inv <span class="main">(</span><span class="free">s</span><span class="main">(</span>sys <span class="main">:=</span> mem_lock_update Map.empty <span class="main">(</span><span class="free">s</span> sys<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_W_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_apply<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> emptyE empty_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> valid_W_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> gc_mark.mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> gc_W_empty_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> obj_fields_marked_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> sweep_loop_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP valid_W_inv <span class="main">⦄</span>
     gc
   <span class="main">⦃</span> LSTP valid_W_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sweep_loop_free <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib white_def valid_W_inv_sys_ghg_empty_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> disjoint_iff_not_equal no_grey_refsD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> no_grey_refsD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> no_grey_refsD<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_invE<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_work_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD0 valid_W_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_distinct_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits process_name.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_blacken <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_W_invD0 valid_W_invD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_distinct_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits process_name.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_W<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_unlock<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_mark<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_lock<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>mark_loop_get_roots_load_W <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
<span class="comment1">(* FIXME ran out of patience. Something makes auto diverge on some subgoals *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib valid_W_inv_sys_ghg_empty_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Int_emptyI Un_iff process_name.distinct<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> valid_W_distinct_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_invD0<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
 <span class="keyword1"><span class="command">using</span></span> valid_W_invD<span class="main">(</span>2<span class="main">)</span> valid_W_inv_sys_ghg_empty_iff <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> valid_W_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> if_split_asm<span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fun_upd_apply<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> handshake_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> mark_object_invL <span class="main"><span class="hidden">❙</span><b>∧</b></span> tso_lock_invL
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_get_roots.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_del.mark_object_invL <span class="free">m</span>
      <span class="main"><span class="hidden">❙</span><b>∧</b></span> mut_store_ins.mark_object_invL <span class="free">m</span>
       <span class="main"><span class="hidden">❙</span><b>∧</b></span> LSTP <span class="main">(</span>fM_rel_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> sys_phase_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_refs_inv <span class="main"><span class="hidden">❙</span><b>∧</b></span> valid_W_inv<span class="main">)</span> <span class="main">⦄</span>
     mutator <span class="free">m</span>
   <span class="main">⦃</span> LSTP valid_W_inv <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">vcg_jackhammer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_thin_post_inv</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">vcg_name_cases</span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>alloc <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">r</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_conj_distrib <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_distinct_simps valid_W_invD0<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_W<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_unlock<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_mark<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_ins_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_lock<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_W<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_unlock<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_mark<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>store_del_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_lock<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_W <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_W<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_unlock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_unlock<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_mark <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_mark<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_loop_mo_co_lock <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">y</span><span class="main">)</span>   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> valid_W_inv_mo_co_lock<span class="main"><span class="keyword3">;</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_roots_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_inv_sys_ghg_empty_iff valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> filter_empty_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> valid_W_invE<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_distinct_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>hs_get_work_done <span class="skolem">s</span> <span class="skolem">s'</span><span class="main">)</span>  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> valid_W_inv_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI impI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_inv_sys_ghg_empty_iff valid_W_invD<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> valid_W_invD0<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> filter_empty_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> valid_W_invE<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_W_distinct_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> process_name.splits if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Proofs">
<div class="head">
<h1>Theory Proofs</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Proofs
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="TSO.html">TSO</a>
  <a href="Phases.html">Phases</a>
  <a href="MarkObject.html">MarkObject</a>
  <a href="StrongTricolour.html">StrongTricolour</a>
  <a href="Valid_Refs.html">Valid_Refs</a>
  <a href="Worklists.html">Worklists</a>
  <a href="Global_Noninterference.html">Global_Noninterference</a>
  <a href="Noninterference.html">Noninterference</a>
  <a href="Initial_Conditions.html">Initial_Conditions</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Top-level safety \label{sec:top-level-correctness}›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> gc<span class="main">)</span> I<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> I <span class="main">⦄</span> gc"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift valid_all_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> sys<span class="main">)</span> I<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> I <span class="main">⦄</span> sys"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift valid_all_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We need to separately treat the two cases of a single mutator and
multiple mutators. In the latter case we have the additional
obligation of showing mutual non-interference amongst mutators.

›</span></span>

<span class="keyword1" id="Proofs-mut_invsL"><span class="command">lemma</span></span> mut_invsL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span>I<span class="main">⦄</span> mutator <span class="free">m</span> <span class="main">⦃</span>mut_m.invsL <span class="free">m'</span><span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">m'</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">interpret</span></span> mut_m <span class="quoted"><span class="free">m'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> mut_m' <span class="quoted"><span class="free">m'</span></span> <span class="quoted"><span class="free">m</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* FIXME split mutators_phase_inv from global invs to local invs. Move to StrongTricolour or similar. note dependence on I *)</span>
<span class="keyword1" id="Proofs-mutators_phase_inv"><span class="command">lemma</span></span> mutators_phase_inv<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> I <span class="main">⦄</span> mutator <span class="free">m</span>  <span class="main">⦃</span> LSTP <span class="main">(</span>mut_m.mutator_phase_inv <span class="free">m'</span><span class="main">)</span> <span class="main">⦄</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">m'</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">interpret</span></span> mut_m <span class="quoted"><span class="free">m'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift valid_all_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> mut_m' <span class="quoted"><span class="free">m'</span></span> <span class="quoted"><span class="free">m</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift valid_all_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> mut_m<span class="main">)</span> I<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⦃</span> I <span class="main">⦄</span> mutator <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_def gc.invsL_def invs_def Local_Invariants.invsL_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> valid_pre<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span> <span class="operator">rule</span> valid_conj_lift valid_all_lift <span class="main"><span class="keyword3">|</span></span> <span class="operator">fastforce</span> <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_defs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> gc_system
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"gc_system ⊨<span class="hidden">⇘</span><sub>pre</sub><span class="hidden">⇙</span> I"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> VCG<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> init_inv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> p<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mut_m.I<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> valid_proc_def<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gc.I<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> valid_proc_def<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sys.I<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> valid_proc_def<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:proofs-headline-safety}

Our headline safety result follows directly.

›</span></span>

<span class="keyword1"><span class="command">corollary</span></span> safety<span class="main">:</span> <span class="quoted"><span class="quoted">"gc_system ⊨<span class="hidden">⇘</span><sub>pre</sub><span class="hidden">⇙</span> LSTP valid_refs"</span></span>
<span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">unfolding</span></span> I_def invs_def valid_refs_def prerun_valid_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">σ</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> alwaysI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> i<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">i</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> alwaysE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_refs_invD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The GC is correct for the remaining fixed-but-arbitrary initial
conditions.

›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> gc_system_interpretation<span class="main">:</span> gc_system <span class="quoted">undefined</span> <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">(* unused_thms Main Sublist CIMP - *)</span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ A concrete system state \label{sec:concrete-system-state} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We demonstrate that our definitions are not vacuous by exhibiting a
concrete initial state that satisfies the initial conditions. The heap
is shown in Figure~\ref{fig:concrete-heap}. We use Isabelle's notation
for types of a given size.

\begin{figure}
  \centering
  \includegraphics{heap.pdf}
  \caption{A concrete system state.}
  \label{fig:concrete-heap}
\end{figure}

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Concrete_heap">
<div class="head">
<h1>Theory Concrete_heap</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">theory</span></span> Concrete_heap
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Saturated.html">HOL-Library.Saturated</a>"</span>
  <span class="quoted">"<a href="Global_Invariants.html">../Global_Invariants</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* From 40e16c534243 by Makarius. Doesn't seem to have a huge impact on run time now (2021-01-07) *)</span>
<span class="keyword1"><span class="command">declare</span></span> subst_all <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> field <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="numeral">3</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> mut <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> payload <span class="main">=</span> <span class="quoted"><span class="quoted">"unit"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> ref <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="numeral">5</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> concrete_local_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>field<span class="main">,</span> mut<span class="main">,</span> payload<span class="main">,</span> ref<span class="main">)</span> local_state"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> clsts <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>field<span class="main">,</span> mut<span class="main">,</span> payload<span class="main">,</span> ref<span class="main">)</span> lsts"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mut_common_init_state</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_common_init_state</span> <span class="main">≡</span> undefined<span class="main">⦇</span> ghost_hs_phase <span class="main">:=</span> hp_IdleMarkSweep<span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> ghost_honorary_root <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> roots <span class="main">:=</span> <span class="main">{}</span><span class="main">,</span> W <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> gc_system
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sys_init_heap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ref <span class="main">⇒</span> <span class="main">(</span>field<span class="main">,</span> payload<span class="main">,</span> ref<span class="main">)</span> object option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_init_heap</span> <span class="main">≡</span>
  <span class="main">[</span>   <span class="main">0</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> <span class="main">[</span> <span class="main">0</span> <span class="main">↦</span> <span class="numeral">5</span> <span class="main">]</span><span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">,</span>
      <span class="main">1</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> Map.empty<span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">,</span>
      <span class="numeral">2</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> Map.empty<span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">,</span>
      <span class="numeral">3</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> <span class="main">[</span> <span class="main">0</span> <span class="main">↦</span> <span class="main">1</span> <span class="main">,</span> <span class="main">1</span> <span class="main">↦</span> <span class="numeral">2</span> <span class="main">]</span><span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">,</span>
      <span class="numeral">4</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> <span class="main">[</span> <span class="main">1</span> <span class="main">↦</span> <span class="main">0</span> <span class="main">]</span><span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span><span class="main">,</span>
      <span class="numeral">5</span> <span class="main">↦</span> <span class="main">⦇</span> obj_mark <span class="main">=</span> <span class="free">initial_mark</span><span class="main">,</span>
             obj_fields <span class="main">=</span> Map.empty<span class="main">,</span>
             obj_payload <span class="main">=</span> Map.empty <span class="main">⦈</span>
  <span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mut_init_state0</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_init_state0</span> <span class="main">≡</span> mut_common_init_state <span class="main">⦇</span> roots <span class="main">:=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mut_init_state1</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_init_state1</span> <span class="main">≡</span> mut_common_init_state <span class="main">⦇</span> roots <span class="main">:=</span> <span class="main">{</span><span class="numeral">3</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mut_init_state2</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mut_init_state2</span> <span class="main">≡</span> mut_common_init_state <span class="main">⦇</span> roots <span class="main">:=</span> <span class="main">{</span><span class="numeral">2</span><span class="main">,</span> <span class="numeral">5</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Concrete">
<div class="head">
<h1>Theory Concrete</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Concrete
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Concrete_heap.html">Concrete_heap</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword1"><span class="command">context</span></span> gc_system
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sys_init_state</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sys_init_state</span> <span class="main">≡</span>
     undefined<span class="main">⦇</span> fA <span class="main">:=</span> <span class="free">initial_mark</span>
              <span class="main">,</span> fM <span class="main">:=</span> <span class="free">initial_mark</span>
              <span class="main">,</span> heap <span class="main">:=</span> sys_init_heap
              <span class="main">,</span> hs_pending <span class="main">:=</span> <span class="main">⟨</span>False<span class="main">⟩</span>
              <span class="main">,</span> hs_type <span class="main">:=</span> ht_GetRoots
              <span class="main">,</span> mem_lock <span class="main">:=</span> None
              <span class="main">,</span> mem_store_buffers <span class="main">:=</span> <span class="main">⟨</span><span class="main">[]</span><span class="main">⟩</span>
              <span class="main">,</span> phase <span class="main">:=</span> ph_Idle
              <span class="main">,</span> W <span class="main">:=</span> <span class="main">{}</span>
              <span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span>
              <span class="main">,</span> ghost_hs_in_sync <span class="main">:=</span> <span class="main">⟨</span>True<span class="main">⟩</span>
              <span class="main">,</span> ghost_hs_phase <span class="main">:=</span> hp_IdleMarkSweep <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">gc_init_state</span> <span class="main">::</span> <span class="quoted">concrete_local_state</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gc_init_state</span> <span class="main">≡</span>
     undefined<span class="main">⦇</span> fM <span class="main">:=</span> <span class="free">initial_mark</span>
              <span class="main">,</span> fA <span class="main">:=</span> <span class="free">initial_mark</span>
              <span class="main">,</span> phase <span class="main">:=</span> ph_Idle
              <span class="main">,</span> W <span class="main">:=</span> <span class="main">{}</span>
              <span class="main">,</span> ghost_honorary_grey <span class="main">:=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kvs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> fst <span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">then</span> snd <span class="free"><span class="bound"><span class="entity">kv</span></span></span> <span class="keyword1">else</span> <span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">kvs</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">muts_init_states</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>mut <span class="main">×</span> concrete_local_state<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">muts_init_states</span> <span class="main">≡</span> <span class="main">[</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> mut_init_state0<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> mut_init_state1<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> mut_init_state2<span class="main">)</span> <span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">init_state</span> <span class="main">::</span> <span class="quoted">clsts</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">init_state</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span>
              gc <span class="main">⇒</span> gc_init_state
            <span class="main">|</span> sys <span class="main">⇒</span> sys_init_state
            <span class="main">|</span> mutator <span class="bound">m</span> <span class="main">⇒</span> lookup muts_init_states mut_common_init_state <span class="bound">m</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"gc_system_init init_state"</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">unfolding</span></span> gc_system_init_def gc_initial_state_def mut_initial_state_def sys_initial_state_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
<span class="keyword1"><span class="command">unfolding</span></span> valid_refs_def reaches_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rtranclp.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits obj_at_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>